//----------------------------------------------------------------------------------------
//arrays.h
//Объявление классов АНТЕННЫХ РЕШЕТОК (ANTENNA ARRAYs)
//Initial date: May,10,2005. Final date:
//Copyright (c) JohnSoft 2005. All rights reserved. C++ Builder 6
//----------------------------------------------------------------------------------------
#ifndef arraysH
#define arraysH

#include "const.h"
#pragma hdrstop

#include "matrix.h"
#include "parsing.h"
#include "CoDec.h"
#include "RandGen.h"


//****************************************************************************************
//Предварительное объявление имен классов
//****************************************************************************************
class TEmissionSource_2D;//Модель источника излучения на плоскости (с одной угловой коорд.)
class TJammers_2D;//Модель аддитивной помехи с одной угловой координатой
class TUnEqLAA_ODA;//Модель Uniform Equispaced Linear Array with Omnidirectional antennas

class TGrayScaleImgSrc_2D;//Модель источника изображения в градациях серого на плоскости

typedef deque<TEmissionSource_2D>::const_iterator CIter_Jams2D;

//****************************************************************************************
// ОБЪЯВЛЕНИЕ КЛАССА - TUnEqLAA_ODA - ЛИНЕЙНАЯ ОДНОРОДНАЯ ЭКВИДИСТАНТНАЯ АНТЕННАЯ РЕШЕТКА
// С ВСЕНАПРАВЛЕННЫМИ АНТЕННАМИ (Uniform Equispaced LAA with Omnidirectional antenna
// Класс представляет математическую модель линейной однородной эквидистантной антенной АР
// с всенаправленными элементами (антеннами). Диаграмма направленности каждого антенного
// элемента в направлении на источник излучения равна 1. Свойства такой LAA представляются:
// 1) N - количество антенных элементов (N > 0, by default N = 1);
// 2) d - относительное расстояние в длинах волн между соседними элементами LAA (d > 0,
//    by default d = 0.5);
// 3) Zero - номер антенного элемента, относительно которого осуществляется отсчет
//    (0 <= Origin < N, by default N = 0).
// 4) Pn - уровень внутреннего шума в каждом канале LAA (Pn > 0)
// Класс может быть использован для исследования LAA с такой конфигурацией, для проведения
// аналитического (численного) и статистического моделирования. На выходе такой решетки
// в зависимости от мощностей и пространственных положений относительно нормали к раскрыву
// LAA можно формировать корреляционные матрицы, комплексные векторы амлитуд напряжений как
// для одного либо конкретного источника излучения, так и для аддитивного сигнала.
//****************************************************************************************
class TUnEqLAA_ODA {
 //---------------------------------------------------------------------------------------
 // ОБЪЯВЛЕНИЕ ЗАКРЫТЫХ ЧЛЕНОВ-ДАННЫХ КЛАССА TUnEqLAA_ODA
 //---------------------------------------------------------------------------------------
 private:
  ulong _N;    //Размерность LAA - кол-во антенн в решетке (N > 0)
  ulong _Zero; //Номер антенны, относительно которого осуществляется отсчет (0<=Origin<N)
  double _d;   //Относительное расстояние в длинах волн между соседними элементами (d > 0)
  double _Pn;  //Уровень (дисперсия) внутреннего шума в каждом канале LAA (Pn > 0)
 //----------------------------------------------------------------------------------------
 // ОБЪЯВЛЕНИЕ КОНСТРУКТОРА и ДЕСТРУКТОРА КЛАССА TUnEqLAA_ODA
 //----------------------------------------------------------------------------------------
 public:
 //Конструктор по умолчанию
 TUnEqLAA_ODA() {Init();};
 //Конструктор с аргументами
 TUnEqLAA_ODA(ulong DimLAA, double RelDist, double Pn = 1.0, ulong Origin = 0L)
 {Set(DimLAA,RelDist,Pn,Origin);};
 //Объявление конструктора копирования
 TUnEqLAA_ODA(const TUnEqLAA_ODA& LAA) {*this = LAA;};
 //Объявление деструктора класса
 ~TUnEqLAA_ODA() {Init();};

 //---------------------------------------------------------------------------------------
 // Объявление общедоступных членов-функций класса TUnEqLAA_ODA
 //---------------------------------------------------------------------------------------
 //Формирование корреляционных матриц входного воздействия на выходе LAA
 bool GetRss(cmatrix& R, const TEmissionSource_2D& EmiSrc, bool lNoise = true) const;
 //Формирование корреляционной матрицы аддитивного сигнала (помехи) на выходе LAA
 bool GetRjj(cmatrix& R, const TJammers_2D& Jams, bool lNoise = true) const;
 //Формирование корреляционной матрицы аддитивного сигнала (помехи) на выходе LAA без
 //канала с порядковым номером Origin (без основного (отсчетного) канала)
 bool GetAuxRjj(cmatrix& R, const TJammers_2D& Jams, bool lNoise = true) const;
 //Расчет вектора взаимных ковариаций между отсчетным (основным) и остальными приемными
 //каналами LAA в условиях действия аддитивного сигнала (помехи)
 bool CalcCovVector(cvector& U, const TJammers_2D& Jams) const;
 //Расчет вектора взаимных ковариаций между отсчетным (основным) и остальными приемными
 //каналами LAA в условиях действия одного источника сигнала
 bool CalcCovVector(cvector& U, const TEmissionSource_2D& EmiSrc) const;


 //Расчет фазосдвигающих коэффициентов лучеобразующей схемы для заданного угла сканирования
 bool CalcBeamFactors(cvector& B, double Angle, bool unit = DEG, bool conj = false) const;

 //Расчет вектора напряжений на выходах LAA при действии одного источника излучения
 bool CalcUs(cvector& U, const TEmissionSource_2D& EmiSrc) const;

 //Формирование вектора напряжений на выходах LAA при действии одного источника излучения
 //ЕДИНИЧНОЙ МОЩНОСТИ с направления Angle относительно раскрыва LAA
 bool TFunc(cvector& U, double Angle, bool unit = DEG) const;

 //Расчет матрицы напряжений на выходах LAA при действии источников излучений ЕДИНИЧНОЙ
 //МОЩНОСТИ с направлений Angles относительно раскрыва LAA (кол-во строк матрицы соответст-
 //вует кол-ву каналов LAA, кол-во столбцов матрицы - размерности вектора Angles).
 //По умолчанию принято: углы заданы в градусах, основной канал не учитывается.
 bool TFunc(cmatrix& U, rvector& Angles, bool unit = DEG, bool lBaseCh = false) const;
 bool TFunc(cmatrix& U, const TDoubleSet& Angles, bool lBaseCh = false) const;

 //Передаточная функция (Transfer function) антенной решетки
 bool TFunc(rmatrix& P, const TEvenCloseInterval& Sector, double ScanAngle = 0,
            bool Norm = ON, bool Db = ON, double MinDb = -60.0) const;

 //---------------------------------------------------------------------------------------
 //Установка свойств класса TUnEqLAA_ODA
 //---------------------------------------------------------------------------------------
 ulong SetDimLAA(ulong N);//Установка размерности LAA
 double SetRelDist(double d);//Установка относительного расстояния между соседними антеннами
 ulong SetOrigin(ulong Origin);//Установка отсчетного элемента LAA
 double SetPn(double Pnoise);//Установка уровня внутреннего шума для каналов LAA
 //Установка всех свойств LAA
 void Set(ulong DimLAA, double RelDist, double Pn = 1.0, ulong Origin = 0L);

 //---------------------------------------------------------------------------------------
 //Получение свойства класса TUnEqLAA_ODA
 //---------------------------------------------------------------------------------------
 ulong GetDimLAA() const {return _N;};//Размерность LAA - кол-во антенн в решетке
 double GetRelDist() const {return _d;};//Относительное расстояние между антенными элементами
 ulong GetOrigin() const {return _Zero;};//Номер отсчетного элемента LAA
 double GetPn() const {return _Pn;};//Уровень внутреннего шума в приемных каналах LAA

 //Получение свойств класса в виде строкового объекта string
 string& Properties(string &s) const;
 string& Brief(string &s) const;

 //Объявление перегруженного оператора присваивания operator =
 void operator =(const TUnEqLAA_ODA& LAA);
 //Объявление перегруженного оператора сравнения operator ==
 bool operator ==(const TUnEqLAA_ODA& LAA) const;
 //Объявление перегруженного оператора сравнения operator <
 bool operator <(const TUnEqLAA_ODA& LAA) const;

 //---------------------------------------------------------------------------------------
 // ДРУЖЕСТВЕННЫЕ ФУНКЦИИ КЛАССА TUnEqLAA_ODA
 //---------------------------------------------------------------------------------------

 //Перегрузка оператора вывода (<<) для вывода параметров класса
 friend ostream& operator <<(ostream& out, const TUnEqLAA_ODA& LAA);
 //Ввод параметров объекта из стандартного потока ввода cin
 friend bool Edit(TUnEqLAA_ODA& LAA);
 //Расчет ковариационной матрицы на выходе LAA с возможностью размещения столбца и строки
 //матрицы, связанных с отсчетным каналом, в последнем строке и столбце.
 friend bool CalcRss(cmatrix& R, const TUnEqLAA_ODA& LAA, double P, double Phi,
                     bool lNoise, bool lBaseToEnd = true);
 friend bool CalcRss(cmatrix& R, const TUnEqLAA_ODA& LAA, const TEmissionSource_2D& EmiSrc,
                     bool lNoise, bool lBaseToEnd = true);
 friend bool CalcRjj(cmatrix& R, const TUnEqLAA_ODA& LAA, const TJammers_2D& Jams,
                     bool lNoise, bool lBaseToEnd = true);
 //---------------------------------------------------------------------------------------
 // Статистическое моделирование
 //---------------------------------------------------------------------------------------
 //Расчет комплексных амплитуд в приемных каналах LAA при действии источника сигнала
 //мощностью P с направления Phi [deg] (детерминированный сигнал)
 friend bool CalcSignal(cvector& Us, const TUnEqLAA_ODA& LAA, double P, double Phi,
             bool lBaseToEnd = true);
 //Расчет комплексных амплитуд в приемных каналах LAA при действии источника сигнала
 //мощностью P с направления Phi [deg] со случайными составляющими амплитуды и фазы
 //(гауссовский закон распределения)
 friend bool CalcSignal(cvector& Us, const TUnEqLAA_ODA& LAA, double P, double Phi,
             TRandGen_64& RandGen, bool lBaseToEnd = true);
 //Расчет комплексных амплитуд в приемных каналах LAA при действии аддитивной помехи Jams
 //со случайными составляющими амплитуды и фазы (гауссовский закон распределения)
 friend bool CalcJams(cvector& Ujam, const TUnEqLAA_ODA& LAA, const TJammers_2D& Jams,
             TRandGen_64& RandGen, bool lBaseToEnd = true);
 //Расчет комплексных амплитуд внутреннего шума в приемных каналах LAA со случайными
 //составляющими амплитуды и фазы (гауссовский закон распределения)
 friend bool CalcNoise(cvector& Unoise, const TUnEqLAA_ODA& LAA, TRandGen_64& RandGen,
             bool lBaseToEnd = true);


 //---------------------------------------------------------------------------------------
 // ОБЪЯВЛЕНИЕ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TUnEqLAA_ODA
 //---------------------------------------------------------------------------------------
 private:
  void Init(); //Начальная установка характеристик TUnEqLAA_ODA
};//Завершение объявления класса TUnEqLAA_ODA


//****************************************************************************************
//     Объявление класса - TEmissionSource_2D - источник излучения на плоскости
//Класс описывает математическую модель источника излучения с одной угловой координатой
//(аналог угла места или азимутального угла), которая характеризуется двумя параметрами:
//1) Power - мощностью излучения (Power >= 0);
//2) Angle - угловое положение источника, относительно нормали к раскрыву антенны или
//   антенной системы (например, антенной решетки), -Pi <= Angle <= Pi (в радианах).
//Angle принимает отрицательное значение, если угол отсчитывается против стрелки часов
//относительно нормали к раскрыву приемной системы, и положительное значение - при отсчете
//угла по часовой стрелке.
//Класс используется для моделирования сигнала (сигналов) на входе приемных систем (напр.,
//LAA), которые пространственно могут различать источники с одной угловой координатой
//(например, только по углу места или только по углу азимута).
//****************************************************************************************
class TEmissionSource_2D {
 //---------------------------------------------------------------------------------------
 // ОБЪЯВЛЕНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ДАННЫХ КЛАССА TEmissionSource_2D
 //---------------------------------------------------------------------------------------
 protected:
  double _Power;//Мощность источника Power >= 0
  double _Angle;//Угловое положение в радианах относительно нормали к раскрыву приемной системы
 //---------------------------------------------------------------------------------------
 // I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TEmissionSource_2D
 //---------------------------------------------------------------------------------------
 public:
 //***************************************************************************************
 // ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TEmissionSource_2D
 //***************************************************************************************
 TEmissionSource_2D();//Объявление конструктора по умолчанию
 //Объявление конструктора с аргументами
 TEmissionSource_2D(double Power, double Angle, bool unit = DEG);
 //Объявление конструктора копирования
 TEmissionSource_2D(const TEmissionSource_2D& EmiSrc) {*this = EmiSrc;};
 //Объявление деструктора класса
 ~TEmissionSource_2D();
 //***************************************************************************************
 // ОБЩЕДОСТУПНЫЕ ФУНКЦИИ ДЛЯ РАБОТЫ С КЛАССОМ TEmissionSource_2D
 //***************************************************************************************
 //Установка свойств модели источника излучения
 void Set(double Power, double Angle, bool unit = DEG);
 void SetPower(double Power);
 void SetAngle(double Angle, bool unit = DEG);
 bool Set(const char* s);
 bool Set(const string& s) {return Set(s.c_str());};
 //Получение свойств модели источника излучения
 double GetPower() const {return _Power;};
 double GetAngle(bool unit = DEG) const;
 void Get(double& Power, double& Angle, bool unit = DEG) const;
 //Получение свойств класса в виде строкового объекта string
 string& Properties(string &s) const;
 string& Brief(string &s) const;

 //Объявление перегруженного оператора присваивания operator =
 void operator =(const TEmissionSource_2D& EmiSrc);
 //Объявление перегруженного оператора сравнения operator ==
 bool operator ==(const TEmissionSource_2D& EmiSrc) const;
 //Объявление перегруженного оператора сравнения operator <
 bool operator <(const TEmissionSource_2D& EmiSrc) const;

 //***************************************************************************************
 // ДРУЖЕСТВЕННЫЕ ФУНКЦИИ КЛАССА TEmissionSource_2D
 // 1. ФУНКЦИИ ВВОДА - ВЫВОДА ПАРАМЕТРОВ
 //***************************************************************************************
 //Перегрузка оператора вывода (<<) для вывода параметров класса
 friend ostream& operator <<(ostream& out, const TEmissionSource_2D& EmiSrc);

 //Ввод параметров объекта из стандартного потока ввода cin
 friend bool Edit(TEmissionSource_2D& EmiSrc, const char* sName = NULL);

 //Перегрузка оператора ввода (>>) для ввода параметров класса
 friend bool operator >>(istream& in, TEmissionSource_2D& EmiSrc);

 //---------------------------------------------------------------------------------------
 // II. ОБЪЯВЛЕНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TEmissionSource_2D
 //---------------------------------------------------------------------------------------
 protected:
  void Reset(); //Начальная установка всех характеристик TEmissionSource_2D
};
//Конец объявления класса TEmissionSource_2D
//The end of class TEmissionSource_2D declaration

//****************************************************************************************
//     Объявление класса - TJammers_2D - аддитивная помеха на плоскости
//Класс описывает математическую модель множества источников излучения с одной угловой
//координатой (аналог угла места или азимутального угла), каждая из которых характеризуется
//двумя параметрами:
//1) Power - мощностью излучения (Power >= 0);
//2) Angle - угловое положение источника, относительно нормали к раскрыву антенны или
//   антенной системы (например, антенной решетки), -Pi <= Angle <= Pi (в радианах).
//Angle принимает отрицательное значение, если угол отсчитывается против стрелки часов
//относительно нормали к раскрыву приемной системы, и положительное значение - при отсчете
//угла по часовой стрелке.
//Каждый источник представляется объектом класса TEmissionSource_2D. Все источники хранятся
//в контейнерном классе библиотеки STL - <deque>. Класс не позволяет хранить два и более
//источника с равными угловыми координатами.
//Класс используется для моделирования аддитивной пространственной помехи на входе приемных
//систем (напр., LAA), которые пространственно могут различать источники с одной угловой
//координатой (например, только по углу места или только по углу азимута).
//****************************************************************************************
class TJammers_2D {
 //---------------------------------------------------------------------------------------
 // ОБЪЯВЛЕНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ДАННЫХ КЛАССА TJammers_2D
 //---------------------------------------------------------------------------------------
 protected:
  //Контейнер для пространственно различающихся источников излучения
  deque<TEmissionSource_2D> _Jams;

 //---------------------------------------------------------------------------------------
 // I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TJammers_2D
 //---------------------------------------------------------------------------------------
 public:
 //***************************************************************************************
 // ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TJammers_2D
 //***************************************************************************************
 TJammers_2D() {RemoveAll();};//Объявление конструктора по умолчанию
 //Объявление конструктора с аргументами
 TJammers_2D(const TEmissionSource_2D& Jam) {Add(Jam);};
 TJammers_2D(double Power, double Angle, bool unit = DEG) {Add(Power,Angle,unit);};
 TJammers_2D(const char* s) {Import(s,true);};
 //Объявление конструктора копирования
 TJammers_2D(const TJammers_2D& JamList) {*this = JamList;};
 //Объявление деструктора класса
 ~TJammers_2D() {RemoveAll();};
 //***************************************************************************************
 // ОБЩЕДОСТУПНЫЕ ФУНКЦИИ ДЛЯ РАБОТЫ С КЛАССОМ TJammers_2D
 //***************************************************************************************
 //Добавление источника излучения в список
 bool Add(const TEmissionSource_2D& EmiSrc);
 bool Add(double Power, double Angle, bool unit = DEG);
 //Присваивание новых источников излучения (с удалением старых) с угловыми координатами
 //из вектора Angle и одинаковой мощностью Power
 long Assign(const rvector& Angle, double Power = 1.0);
 //Присваивание новых источников излучения (с удалением старых) с угловыми координатами
 //из множества Angle и одинаковой мощностью Power
 long Assign(const TDoubleSet& Angle, double Power = 1.0);

 //Извлечение списка источников излучения из строки и добавление их в список
 //Источники излучения в строке представляются в виде - (P1,A1) (P2,A2) ... (Pn,An)
 long Import(const char* s, bool lClear = true);
 long Import(const string& s, bool lClear = true) {return Import(s.c_str(),lClear);};

 //Удаление всех источников излучения из списка
 void RemoveAll() {_Jams.clear();};

 //Сортировка источников излучения в списке
 void SortByPower();
 void SortByAngle();

 //Установка одинаковых значений мощности Power для всех источников излучения
 bool SetPower(double Power);
 //Установка суммарной мощности для всех источников излучения с равномерным ее
 //распределением для всех источников: Pi = Psum/N, N - число источников излучения
 bool SetTotalPower(double Psum);

 //---------------------------------------------------------------------------------------
 //Получение свойств объекта
 //---------------------------------------------------------------------------------------
 const deque<TEmissionSource_2D>* GetList() const {return &_Jams;};
 //Получение константных итераторов на начало и конец списка _Jams
 long GetIterators(CIter_Jams2D& begin, CIter_Jams2D& end) const;

 ulong Count() const {return _Jams.size();};//Кол-во источников в списке
 //Суммарная мощность всех источников излучения, размещенных в контейнере
 double TotalPower() const;
 //Экспорт в объект AngleCoord всех угловых координат источников излучения в градусах,
 //размещенных в контейнере
 ulong GetAngleCoords(TDoubleSet& Angle) const;
 //Определяет наличие в списке объекта с угловой координатой равной EmiSrc
 bool FindByAngle(const TEmissionSource_2D& EmiSrc) const;
 //Определяет наличие в списке объекта со свойствами аналогичными свойствам EmiSrc
 bool Find(const TEmissionSource_2D& EmiSrc) const;

 //Получение свойств класса в виде строкового объекта string
 string& Properties(string &s, char delim = ' ') const;
 string& Brief(string &s, char delim = ' ') const;

 //Объявление перегруженного оператора присваивания operator =
 void operator =(const TJammers_2D& Jams);
 //Объявление перегруженного оператора сравнения operator ==
 bool operator ==(const TJammers_2D& Jams) const;

 //***************************************************************************************
 // ДРУЖЕСТВЕННЫЕ ФУНКЦИИ КЛАССА TJammers_2D
 // 1. ФУНКЦИИ ВВОДА - ВЫВОДА ПАРАМЕТРОВ
 //***************************************************************************************
 //Перегрузка оператора вывода (<<) для вывода параметров класса
 friend ostream& operator <<(ostream& out, const TJammers_2D& Jams);

 //Ввод параметров объекта из стандартного потока ввода cin
 friend long Edit_VarPower(TJammers_2D& Jams);
 //Консольный ввод источников излучения равных по мощности, суммарной мощностью Psum
 //Формат ввода: <Angle1 Angle2 ... AngleN> Psum
 friend long Edit_TheSamePower(TJammers_2D& Jams);

 //Консольное редактирование свойств источников излучения (возвращается число источников
 //излучения в контейнере)
 friend long Edit(TJammers_2D& Jams);

 //Перегрузка оператора ввода (>>) для ввода параметров класса
 friend bool operator >>(istream& in, TJammers_2D& Jams);

 //Форматированный многострочный вывод источников излучения в строку
 friend ulong MultiLineFormat(string& s, const TJammers_2D& Jams, ulong MaxWidth = 80,
        const char* sfx = NULL);

 //---------------------------------------------------------------------------------------
 // II. ОБЪЯВЛЕНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TJammers_2D
 //---------------------------------------------------------------------------------------
 protected:
  //Начальная установка характеристик TJammers_2D - очистка списка
  void Init() {_Jams.clear();};
};
//Конец объявления класса TJammers_2D
//The end of class TJammers_2D declaration

//****************************************************************************************
// Объявление класса - TGrayScaleImgSrc_2D - 2D источник изображения в градациях серого
//Класс описывает математическую модель источника изображения в градациях серого с одной
//угловой координатой (аналог угла места или азимутального угла), которая характеризуется
//следующими параметрами:
//1) Power - мощностью излучения (Power >= 0);
//2) Angle - угловое положение источника, относительно нормали к раскрыву антенны или
//   антенной системы (например, антенной решетки), -Pi <= Angle <= Pi (в радианах);
//3) Raster - растр изображения в градациях серого, представляет собой прямоугольную матрицу,
//   значения которой изменяются в пределах от 0 до 255.
//Angle принимает отрицательное значение, если угол отсчитывается против стрелки часов
//относительно нормали к раскрыву приемной системы, и положительное значение - при отсчете
//угла по часовой стрелке.
//Класс используется для моделирования многомерных сигналов на входе приемных систем (напр.,
//LAA), которые пространственно могут различать источники с одной угловой координатой
//(например, только по углу места или только по углу азимута).
//****************************************************************************************
class TGrayScaleImgSrc_2D {
 //---------------------------------------------------------------------------------------
 // ОБЪЯВЛЕНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ДАННЫХ КЛАССА TGrayScaleImgSrc_2D
 //---------------------------------------------------------------------------------------
 protected:
  TEmissionSource_2D _EmiSrc;//Источник излучения (задает мощность и угловое положение)
  imatrix _Raster;           //Растр изображения в градациях серого
  string _Name;              //Наименование изображения

 //---------------------------------------------------------------------------------------
 // I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TGrayScaleImgSrc_2D
 //---------------------------------------------------------------------------------------
 public:
  static string _MsgErr;     //Строковое сообщение об ошибке

 //***************************************************************************************
 // ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TGrayScaleImgSrc_2D
 //***************************************************************************************
 TGrayScaleImgSrc_2D();//Объявление конструктора по умолчанию
 //Объявление конструктора с аргументами
 TGrayScaleImgSrc_2D(const string& fname, double Power, double Angle, bool unit = DEG);
 TGrayScaleImgSrc_2D(const char* s) {this->Reset(); this->Import(s);};
 TGrayScaleImgSrc_2D(string& s) {this->Reset(); this->Import(s);};
 //Объявление деструктора класса
 ~TGrayScaleImgSrc_2D();
 //***************************************************************************************
 // ОБЩЕДОСТУПНЫЕ ФУНКЦИИ ДЛЯ РАБОТЫ С КЛАССОМ TGrayScaleImgSrc_2D
 //***************************************************************************************
 //Проверка "работоспособности" источника изображения
 bool IsReady() const;
 //Считывание растра изображения из файла
 bool LoadRasterFromFile(const string& fname);

 //Установка свойств источника излучения
 void SetSignal(double Power, double Angle, bool unit = DEG) {_EmiSrc.Set(Power,Angle,unit);};
 void SetPower(double Power) {_EmiSrc.SetPower(Power);};
 void SetAngle(double Angle, bool unit = DEG) {_EmiSrc.SetAngle(Angle,unit);};

 //Получение свойств источника излучения
 bool IsSignal() const {return (_EmiSrc.GetPower() != 0.0) ? true : false;};
 double GetPower() const {return _EmiSrc.GetPower();};
 double GetAngle(bool unit = DEG) const {return _EmiSrc.GetAngle(unit);};
 void GetEmiSrc(double& Power, double& Angle, bool unit = DEG) const
 {_EmiSrc.Get(Power,Angle,unit);};
 const TEmissionSource_2D& GetEmiSrc() const {return _EmiSrc;};

 //Получение свойств растра изображения
 bool IsRaster() const {return (_Raster.IsZeroSize()) ? false : true;};
 ulong GetHeight() const {return _Raster.Rows();};
 ulong GetWidth() const {return _Raster.Cols();};

 //Получение свойств класса в виде строкового объекта string
 string& AboutSignal(string& s, bool lBriefly = true) const;
 string& AboutRaster(string& s, bool lBriefly = true) const;
 string& About(string& s, bool lBriefly = true) const;

 //Извлечение из строки свойств источника сигнала - мощности и углового положения в виде:
 // SIGNAL: (Power, Angle[in deg])
 bool ImportSignal(const char* s, bool lClear = true);
 bool ImportSignal(const string& s, bool lClear = true)
 {return this->ImportSignal(s.c_str(),lClear);};

 //Извлечение из строки имени файла с растром изображения сигнала в виде: RASTER: <filename>
 //с последующим копированием изображения из файла в матрицу _Raster.
 bool ImportRaster(const char* s, bool lClear = true);
 bool ImportRaster(const string& s, bool lClear = true)
 {return this->ImportRaster(s.c_str(),lClear);};

 //Извлечение из строки свойств объекта, представленных в виде:
 //SIGNAL: (Power, Angle[in deg]) RASTER: <filename>
 bool Import(const char* s, bool lClear = true);
 bool Import(const string& s, bool lClear = true)
 {return this->Import(s.c_str(),lClear);};

 //Сохранение растра в файле
 bool SaveRasterAsBMP(const char* fname) const;
 bool SaveRasterAsJPG(const char* fname, BYTE quality = 100) const;

 //Расчет растра сигнала при воздействии на него аддитивной помехи при распространении
 //сигнала на выходе адаптивного фильтра и сохранение полученного растра в файле
 bool CalcAndSaveAsBMP(double Psjn, const char* sfx) const;
 bool CalcAndSaveAsJPG(double Psjn, const char* sfx, BYTE quality = 100) const;
 bool CalcAndSaveAsJPG(double Ps, double Pjn, const char* sfx, BYTE quality = 100) const;

 //Расчет модуляционной матрицы мощностей по значениям амплитуд растра по формуле:
 //P(i,j) = Ps + sqrt(_Raster(i,j)), Ps - мощность источника излучения
 bool Modulate(rmatrix& P) const;
 //Демодуляция матрицы мощности, соответствующая растру сигнала, и ее сохранение в виде
 //графического файла JPEG. Демодуляционная формула: _Raster(i,j) = [P(i,j)-Ps]^2
 bool DemodulateAndSaveAsJPG(const rmatrix& P, const char* sfx, BYTE quality = 100) const;

 //Расчет модуляционной матрицы мощности растра по закону линейной амплитудной модуляции:
 //P(i,j) = k*U(i,j) + Ps, k = (Pmax-Ps)/(Umax-Umin) = dP/255,
 //Ps - мощность источника сигнала, соответствующая U = Umin = 0; Umax = 255;
 //dP - максимальное превышение мощности сигнала над Ps для U == Umax (255), dP > 0
 bool LAM_Modulate(rmatrix& P, double dP = 100.0) const;
 //Демодуляция матрицы мощности, рассчитанной по закону линейной амплитудной модуляции:
 //U(i,j) = |P(i,j)-Ps|/k = |P(i,j)-Ps|*255/dP, (Umax-Umin) == 255;
 //Ps - мощность источника сигнала, соответствующая U = Umin = 0; Umax = 255;
 //dP - максимальное превышение мощности сигнала над Ps для U == Umax (255), dP > 0
 bool LAM_DemodAndSaveAsJPG(const rmatrix& P, const char* sfx, BYTE quality = 100,
      double dP = 100.0) const;

 //Расчет среднего уровня мощности изображения в зависимости от растра изображения и
 //типа кодирования - декодирования при его передаче и приеме
 double CalcAvPower(const TFuncGen_DSClipper* pCoDec) const;

 //Расчет модуляционной матрицы мощностей по растру сигнала в соответствии с алгоритмом
 //кодирования кодера-декодера pCoDec
 bool Modulate(rmatrix& P, const TFuncGen_DSClipper* pCoDec) const;

 //Демодуляция матрицы мощности в растр сигнала в соответствии с алгоритмом декодирования
 //кодера-декодера pCoDec и сохранение демодулированного растра в JPEG-формате
 bool DemodulateAndSaveAsJPG(const rmatrix& P, const TFuncGen_DSClipper* pCoDec,
      const char* sfx, BYTE quality = 100) const;

 //Создание имени файла с расширением JPG на основе имени растра изображения _Name и
 //строки sfx, присоединяемую к концу _Name. Структура имени файла выглядит следующим
 //образом: <_Name>_<sfx>.jpg
 bool MakeFileNameAsJPG(string& FName, const char* sfx) const;

 //***************************************************************************************
 // ДРУЖЕСТВЕННЫЕ ФУНКЦИИ КЛАССА TGrayScaleImgSrc_2D
 // 1. ФУНКЦИИ ВВОДА - ВЫВОДА ПАРАМЕТРОВ
 //***************************************************************************************
 //Перегрузка оператора вывода (<<) для вывода параметров класса
 friend ostream& operator <<(ostream& out, const TGrayScaleImgSrc_2D& Signal_2D);

 //Ввод параметров объекта из стандартного потока ввода cin
 friend bool Edit(TGrayScaleImgSrc_2D& Signal_2D);

 //Перегрузка оператора ввода (>>) для ввода параметров класса
 friend bool operator >>(istream& in, TGrayScaleImgSrc_2D& Signal_2D);

 //---------------------------------------------------------------------------------------
 // II. ОБЪЯВЛЕНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TGrayScaleImgSrc_2D
 //---------------------------------------------------------------------------------------
 protected:
  void Reset();//Начальная установка всех характеристик TGrayScaleImgSrc_2D
  void RasterClear();//Начальная установка характеристик растра
  //Считывание растра изображения из BMP-файла
  bool LoadRasterFromBMP(const string& fname);
  //Считывание растра изображения из JPEG-файла
  bool LoadRasterFromJPG(const string& fname);
  //Считывание растра изображения из TXT-файла
  bool LoadRasterFromTXT(const string& fname);

};
//Конец объявления класса TGrayScaleImgSrc_2D
//The end of class TGrayScaleImgSrc_2D declaration


//------------------------------ The end of file "arrays.h" ------------------------------
#endif //ЗАВЕРШЕНИЕ ОБЪЯВЛЕНИЯ ЗАГОЛОВОЧНОГО ФАЙЛА "ARRAYS.H"
