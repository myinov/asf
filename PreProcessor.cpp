//----------------------------------------------------------------------------------------
//PreProcessor.cpp
//Initial date: December,12,2006. Final date:
//Copyright (c) JohnSoft 2006. All rights reserved. C++ Builder 6.0
//----------------------------------------------------------------------------------------

#include "PreProcessor.h"

//#pragma package(smart_init)

//****************************************************************************************
//               РЕАЛИЗАЦИЯ КЛАССА TPreProcessor_MISO_SF
//Численная и статистическая модели предпроцессора обработки входного сигнала пространст-
//венного N-канального адаптивного фильтра с ОСНОВНЫМ каналом на основе LAA.
//****************************************************************************************
//========================================================================================
//        РЕАЛИЗАЦИЯ КОНСТРУКТОРОВ И ДЕСТРУКТОРОВ КЛАССА TPreProcessor_MISO_SF
//========================================================================================

//========================================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TPreProcessor_MISO_SF
//   PUBLIC MEMBER-FUNCTION OF TPreProcessor_MISO_SF CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsReady() const
//НАЗНАЧЕНИЕ: Проверка работоспособности предпроцессора. Функция возвращает true при одно-
//временном выполнении следующих условий:
//1) работоспособности LAA; 2) работоспособности BFC; 3) наличии AuxCh. В противном случае,
//функция возвращает false, что означает неработоспособность предпроцессора.
//P.S. Работоспособность SRF не влияет на работоспособность предпроцессора. SRF используют
//для исключения приема сигналов в дополнительных каналах фильтра с заданных направлений,
//например, с целью предотвращения подавления полезного сигнала адаптивным пространственным
//фильтром, подключаемым к выходу предпроцессора.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lReady - работоспособность предпроцессора
//****************************************************************************************
bool TPreProcessor_MISO_SF::IsReady() const
{return (this->LAA_IsReady()) ? ON : OFF;
}
//****************************************************************************************
//СТАТУС: I.2, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Info(string& s, uint width = 80) const
//НАЗНАЧЕНИЕ: Формирование характеристик объекта предпроцессора пространственного фильтра
//с многими входами и одним выходом в строке s, передаваемой по ссылке. Свойства объекта
//представляются в виде:
//----------------------------------------------------------------------------------------
//MISO SF Preprocessor: <ON> || <OFF>
// 1. LAA: N: <_N>, Origin: <_Zero>, d: <_d>, Pn: <_Pn>, Antenna: <ODA>;
// 2. BFC: <N> {LAA indexes}, ScanAngle = <Angle>;
// 3. AuxCh: <N> {LAA indexes};
// 4. SRF: <Off> || ElimDirs: <N> {N1 N2 ... Nn}, WorkCh: [BaseCh] & <M> {LAA indexes},
//    Unit: <SRF Unit Type>;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект, в котором формируются свойства предпроцессора;
//2. uint width (80) - максимальная ширина строки при многострочном выводе свойств.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами объекта.
//****************************************************************************************
string& TPreProcessor_MISO_SF::Info(string& s, uint width) const
{string t;
 t.assign("Multi-In Single-Out Space Filter Preprocessor: ");
 if (this->IsReady()) t.append("< ON >;\n");
 else t.append("< OFF >;\n");
 //Получаем свойства LAA
 this->LAA_Info(s); t.append(" 1. "); t.append(s); t.append(1,'\n');
 //Получаем свойства BFC
 this->BFC_Info(s); t.append(" 2. "); t.append(s); t.append(1,'\n');
 //Получаем информацию о вспомогательных каналах
 this->AUX_Info(s); t.append(" 3. "); t.append(s); t.append(1,'\n');
 //Получаем сведения об SRF
 this->SRF_Info(s); t.append(" 4. "); t.append(s); t.append(1,'\n');
 //Разбиваем строку t на подстроки с максимальной шириной не более width
 MultiLineFormat(s,t,width,NULL);
 return s;
}
//****************************************************************************************
//СТАТУС: I.3, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CalcInSignal(cvector& Us, double Power, double Angle, bool lBaseCh = ON) const
//НАЗНАЧЕНИЕ: Расчет комплексных амплитуд на входе предпроцессора при действии источника
//сигнала мощностью Power с направления Angle [в градусах]. Вектор входного сигнала будет
//формироваться в Us, передаваемом по ссылке. Размерность вектора Us будет равна размерности
//предпроцессора по входу при включении в расчет ОСНОВНОГО канала (lBaseCh = ON) или на 1
//меньше при lBaseCh = OFF. Для неработоспособного предпроцессора функция возвращает false,
//вектор Us - нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& Us - ссылка на результирующий вектор комплексных амплитуд на входе объекта;
//2. double Power - мощность источника сигнала;
//3. double Angle - угловое положение источника сигнала в градусах;
//4. bool lBaseCh [ON] - опция включения в расчет напряжения на выходе BFC.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета вектора входного сигнала
//****************************************************************************************
bool TPreProcessor_MISO_SF::CalcInSignal(cvector& Us, double Power, double Angle,
     bool lBaseCh) const
{if (!this->IsReady()) {Us.Set(0,COL,false); return false;}
 //Устанавливаем размерность вектора Us
 ulong szUs = (lBaseCh) ? this->In() : this->In()-1;
 if (Us.Set(szUs,COL,C_ZERO) == false) return false;

 //Объявление рабочих переменных
 ulong OffSet = 0;
 LongSet::const_iterator p, end;
 long index;
 long Origin = this->LAA.GetOrigin();//Отсчетный канал LAA
 double d = this->LAA.GetRelDist();//Относительное расстояние между соседними каналами LAA
 double Ampl = sqrt(Power);
 double c = TwoPI*d*sin(Angle*DegRad);
 double Phase;

 //Рассчитываем напряжения на выходе BFC
 if (lBaseCh == ON || this->SRF_UseBaseCh())
 {complex BFC_Uout = this->BFC_CalcUs(Power,Angle);
  if (lBaseCh) Us.Put(szUs-1,BFC_Uout);
  if (this->SRF_UseBaseCh()) {Us.Put(0,BFC_Uout); OffSet = 1;}
 }
 //Рассчитываем входное напряжение рабочих каналов SRF (WorkCh)
 if (this->_WorkCh.GetIters(p,end))
 {while (p != end)
  {index = *p;
   Phase = c*(index-Origin);
   Us.Put(OffSet++,polar(Ampl,Phase));
   ++p;
  }
 }
 //Рассчитываем входное напряжение вспомогательных каналов (AuxCh)
 if (this->AUX_UseAllCh()) //Все каналы LAA используются как ВСПОМОГАТЕЛЬНЫЕ каналы SF
 {long szLAA = this->LAA.GetDimLAA();
  for (long i = 0L; i < szLAA; i++)
  {Phase = c*(index-Origin);
   Us.Put(OffSet++,polar(Ampl,Phase));
  }
 }
 else
 {if (this->_AuxCh.GetIters(p,end))
  {while (p != end)
   {index = *p;
    Phase = c*(index-Origin);
    Us.Put(OffSet++,polar(Ampl,Phase));
    ++p;
   }
  }
 }
 return true;
}
//****************************************************************************************
//СТАТУС: I.4, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CalcInSignal(cmatrix& Us, const TJammers_2D& Jams, bool lBaseCh = ON) const
//НАЗНАЧЕНИЕ: Расчет комплексных амплитуд на входе предпроцессора при действии аддитивного
//сигнала (нескольких источников излучения) с параметрами, описываемыми контейнером Jams.
//При работоспособном предпроцессоре функция сформирует комплексную матрицу Us. Количество
//строк матрицы Us равно числу входов предпроцессора с учетом опции lBaseCh. Количество
//столбцов матрицы Us равно числу источников излучения. Функция возвращает true в случае
//возможности расчета комплексных амплитуд на входе предпроцессора для каждой составляющей
//аддитивного сигнала и false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& Us - ссылка на матрицу комплексных амплитуд на входе предпроцессора, рассчи-
//   танные индивидуально для каждого источника излучения, размещенного в контейнере Jams;
//2. const TJammers_2D& Jams - константная ссылка на контейнер со свойствами источников
//   излучения, представляющих аддитивное воздействие;
//3. bool lBaseCh [ON] - опция включения в расчет напряжения на выходе BFC.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета матрицы комплексных амплитуд для
//каждой составляющей аддитивного сигнала (помехи)
//****************************************************************************************
bool TPreProcessor_MISO_SF::CalcInSignal(cmatrix& Us, const TJammers_2D& Jams, bool lBaseCh) const
{//Проверка работоспособености предпроцессора
 if (!this->IsReady()) {Us.Set(0,false); return false;}
 //Устанавливаем размерность матрицы Us
 ulong rows = (lBaseCh) ? this->In() : this->In()-1;//Число входов предпроцессора
 ulong cols = Jams.Count();//Число источников излучения
 if (Us.Set(rows,cols,false) == false) return false;

 cvector Uj;
 ulong j = 0;
 CIter_Jams2D J, EIter;
 Jams.GetIterators(J,EIter);

 while (J != EIter)
 {//Расчет комплексных амплитуд на входе предпроцессора для J-го источника излучения
  if (this->CalcInSignal(Uj,J->GetPower(),J->GetAngle(DEG),lBaseCh))
  {//Заполняем j-ый столбец матрицы Us значениями комплексных амплитуд на входе
   //предпроцессора, рассчитанными для j-го источника излучения
   for (ulong i = 0; i < rows; i++) Us.Put(i,j,Uj.Get(i));
   ++J;
   ++j;
  }
  else {Us.Set(0,false); return false;}
 }
 return true;
}
//****************************************************************************************
//СТАТУС: I.5, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool TFunc(rmatrix& P, const TEvenCloseInterval& Sector, bool lSector = ON,
//            bool lNorm = ON, bool lGroup = ON, bool dB = ON, double MindB = -60.0) const
//НАЗНАЧЕНИЕ: Передаточная функция предпроцессора адаптивного пространственного фильтра.
//Функция формирует матрицу мощностей P, передаваемую по ссылке, на всех выходах (AuxCh +
//BaseCh). В каждую строку матрицы P заносятся мощности на выходах предпроцессора при опре-
//деленном угловом положении источника сигнала ЕДИНИЧНОЙ мощности. Сектор перемещения
//источника тест-сигнала передается в объекте Sector. Количество строк матрицы P определяет-
//ся размерностью объекта Sector (Sector.Size()), количество столбцов матрицы P определяется
//количеством выходов предпроцессора Out(). В последнем столбце хранятся выходный мощности
//для ОСНОВНОГО канала, в предшествующих столбцах - выходные  мощности ДОПОЛНИТЕЛЬНЫХ кана-
//лов. Опция lSector (ON) позволяет включить в первый столбец матрицы P значения углов в
//градусах, для которых вычисляется передаточная функция. Опция lNorm (ON) задает нормировку
//выходных мощностей. Опция lGroup (ON) устанавливает общую или индивидуальную для каждого
//канала нормировку. Опция dB (ON) устанавливает нормировку в децибелах.
//Функция возвращает false, если препроцессор НЕРАБОТОСПОСОБЕН, в остальных случаях функция
//возвращает true.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& P - ссылка на матрицу со значениями мощности на выходах препроцессора
//   при перемещении источника сигнала ЕДИНИЧНОЙ мощности в секторе Sector;
//2. const TEvenCloseInterval& Sector - сектор по углу места (азимуту), в  котором рассчи-
//   тывается передаточная функция предпроцессора (в градусах);
//3. bool lSector (ON) - опция включения значений углов сектора в результирующую матрицу P;
//4. bool lNorm (ON) - опция нормирования выходных мощностей;
//5. bool lGroup (ON) - установка групповой или поканальной (индивидуальной) нормировки;
//6. bool dB (ON) - опция нормирования в децибелах (действует при lNorm = ON);
//7. double MindB - минимальный уровень в децибелах (действует при dB = ON).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//****************************************************************************************
bool TPreProcessor_MISO_SF::TFunc(rmatrix& P, const TEvenCloseInterval& Sector, bool lSector,
     bool lNorm, bool lGroup, bool dB, double MindB) const
{//Проверка работоспособности ПРЕДПРОЦЕССОРА:
 if (!this->IsReady()) {P.Set(0L,0L,false); return false;}
 cvector InSignal, OutSignal;
 bool lSuccess;
 //Создание матрицы P необходимых размеров: rows=Sector.Size(); cols=Out().
 P.Set(Sector.Size(),this->Out(),0.0);
 //Определение мощности на выходах предпроцессора в заданном секторе
 for (ulong i = 0L; i < P.Rows(); i++)
 {//----------------------------------------------------------------------------
  //1. ФОРМИРОВАНИЕ ВХОДНОГО ТЕСТ-СИГНАЛА ДЛЯ ПРЕДПРОЦЕССОРА
  //----------------------------------------------------------------------------
  lSuccess = this->CalcInSignal(InSignal,1.0,Sector(i),ON);
  if (!lSuccess) {P.Set(0L,0L,false); return false;}
  //----------------------------------------------------------------------------
  //2. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ режекторного пространственного фильтра для AuxCh при
  //   его подключении к предпроцессору (Q-преобразование)
  //----------------------------------------------------------------------------
  if (this->SRF_IsReady())
  {_SRF->TFunc(InSignal,OutSignal);
   //Переписываем OutSignal в P
   for (ulong j = 0L; j < P.Cols(); j++) P.Put(i,j,norm(OutSignal.Get(j)));
  }
  else //Переписываем InSignal в P
   for (ulong j = 0L; j < P.Cols(); j++) P.Put(i,j,norm(InSignal.Get(j)));
 }
 //-----------------------------------------------------------------------------
 //Нормирование выходных мощностей предпроцессора
 //-----------------------------------------------------------------------------
 if (lNorm == ON)
 {rmatrix NormP;
  if (dB == ON) //Нормирование в децибелах
  {if (lGroup) lSuccess = P.NormalizeToDB(NormP,true,MindB);//Групповое нормирование
   else //Индивидуальное нормирование каждого канала
    lSuccess = P.NormalizeColsToDB(NormP,true,MindB);
  }
  else //Нормирование в интервале [0..1]
  {if (lGroup) lSuccess = P.Normalize(NormP,FIRST_NORM);//Групповое нормирование
   else //Индивидуальное нормирование каждого канала
    lSuccess = P.NormalizeCols(NormP,FIRST_NORM);
  }
  if (lSuccess) P = NormP;
 }
 //----------------------------------------------------------------------------------
 //Включение в матрицу P значений углов сектора, в которых вычисляется передаточная
 //функция предпроцессора
 //----------------------------------------------------------------------------------
 if (lSector == ON)
 {rmatrix Table;
  Table.Set(P.Rows(),P.Cols()+1,false);
  double Angle;
  for (ulong i = 0L; i < Table.Rows(); i++)
   for (ulong j = 0L; j < Table.Cols(); j++)
   {if (j == 0)
    {Angle = Sector(i);
     if (fabs(Angle) < 1.0e-10) Angle = 0.0;//Округление до нуля
     Table.Put(i,j,Angle);
    }
    else Table.Put(i,j,P.Get(i,j-1));
   }
  P = Table;
 }
 return true;
}
//****************************************************************************************
//СТАТУС: I.6, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(rmatrix& P, TSettingsTF& Settings) const
//НАЗНАЧЕНИЕ: Передаточная функция предпроцессора адаптивного пространственного фильтра.
//Функция формирует матрицу мощностей P, передаваемую по ссылке, на всех выходах (AuxCh +
//BaseCh). В каждую строку матрицы P заносятся мощности на выходах предпроцессора при опре-
//деленном угловом положении источника сигнала ЕДИНИЧНОЙ мощности. Сектор перемещения источ-
//ника тест-сигнала и опции по нормированию, вычисленной передаточной функции предпроцессора
//передается в объекте Settings. Количество строк матрицы P определяется размерностью объекта
//Sector (Sector.Size()), количество столбцов матрицы P определяется количеством выходов
//предпроцессора Out(). В последнем столбце хранятся выходный мощности для ОСНОВНОГО канала,
//в предшествующих столбцах - выходные  мощности ДОПОЛНИТЕЛЬНЫХ каналов. Первый столбец P
//содержит значения углов в градусах, для которых вычисляется передаточная функция. Функция
//возвращает false, если предпроцессор НЕРАБОТОСПОСОБЕН, в остальных случаях возвращается
//true.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& P - ссылка на матрицу со значениями мощности на выходах препроцессора
//   при перемещении источника сигнала ЕДИНИЧНОЙ мощности в секторе Sector;
//2. TSettingsTF& Settings - содержит параметры сектора, в котором вычисляется TF, и
//   опции по нормированию значений мощности.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//****************************************************************************************
bool TPreProcessor_MISO_SF::TFunc(rmatrix& P, TSettingsTF& Settings) const
{//Проверка работоспособности ПРЕДПРОЦЕССОРА:
 if (!this->IsReady()) {P.Set(0L,0L,false); return false;}
 cvector InSignal, OutSignal;
 bool lSuccess;
 //Создание матрицы P необходимых размеров: rows=Sector.Size(); cols=Out().
 P.Set(Settings.Count(),this->Out(),0.0);
 //Определение мощности на выходах предпроцессора в заданном секторе
 for (ulong i = 0L; i < P.Rows(); i++)
 {//----------------------------------------------------------------------------
  //1. ФОРМИРОВАНИЕ ВХОДНОГО ТЕСТ-СИГНАЛА ДЛЯ ПРЕДПРОЦЕССОРА
  //----------------------------------------------------------------------------
  lSuccess = this->CalcInSignal(InSignal,1.0,Settings.Number(i),ON);
  if (!lSuccess) {P.Set(0L,0L,false); return false;}
  //----------------------------------------------------------------------------
  //2. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ режекторного пространственного фильтра для AuxCh при
  //   его подключении к предпроцессору (Q-преобразование)
  //----------------------------------------------------------------------------
  if (this->SRF_IsReady())
  {_SRF->TFunc(InSignal,OutSignal);
   //Переписываем OutSignal в P
   for (ulong j = 0L; j < P.Cols(); j++) P.Put(i,j,norm(OutSignal.Get(j)));
  }
  else //Переписываем InSignal в P
   for (ulong j = 0L; j < P.Cols(); j++) P.Put(i,j,norm(InSignal.Get(j)));
 }
 //Формирование выходного отчета
 rmatrix Table;
 //Проверка при нормировании в децибелах по мощности
 if (Settings.IsNormDB() && (Settings.GetNormType() != Norm_10Lg))
  Settings.SetNormType(Norm_10Lg,Settings.GetMindB());
 lSuccess = Settings.MakeReport(Table,P);
 P = Table;
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.7, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool TFunc(cmatrix& U, const rvector& Angle, bool lBaseCh = OFF) const
//НАЗНАЧЕНИЕ: Передаточная функция предпроцессора адаптивного пространственного фильтра.
//Функция формирует матрицу комплексных напряжений U, передаваемую по ссылке, на всех
//выходах (AuxCh+BaseCh при lBaseCh = ON) или только на выходах AuxCh (lBaseCh = ON). В
//каждый столбец матрицы U заносятся комплекные амплитуды на выходах предпроцессора при
//определенном угловом положении источника сигнала ЕДИНИЧНОЙ мощности, задаваемое вектором
//Angle. Количество строк матрицы U определяется количеством выходов предпроцессора при
//lBaseCh = ON или на 1 меньше при lBaseCh = OFF. Количество столбцов матрицы U определяется
//размерностью вектора Angle.
//В последней строке U при lBaseCh = ON хранятся выходные напряжения для ОСНОВНОГО канала,
//в предшествующих строках - выходные напряжения ДОПОЛНИТЕЛЬНЫХ каналов. Угловые положения
//источников излучения, передаваемых вектором Angle, должны быть выражены в градусах отно-
//сительно нормали к раскрыву LAA.
//Функция возвращает false, если предпроцессор НЕРАБОТОСПОСОБЕН, в остальных случаях
//возвращается true.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& U - ссылка на матрицу значений комплексных амплитуд на выходах предпроцессора
//   при различных угловых положениях источника сигнала ЕДИНИЧНОЙ мощности;
//2. const rvector& Angle - значения угловых положений источников излучения в градусах;
//3. bool lBaseCh (OFF) - опция расчета мощности на выходе ОСНОВНОГО канала.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//****************************************************************************************
bool TPreProcessor_MISO_SF::TFunc(cmatrix& U, const rvector& Angle, bool lBaseCh) const
{//Проверка работоспособности ПРЕДПРОЦЕССОРА:
 if (!this->IsReady() || Angle.IsZeroSize()) {U.Set(0L,0L,false); return false;}
 cvector InSignal, OutSignal;
 bool lSuccess;
 //Создание матрицы P необходимых размеров: cols=Angle.Size(),
 //rows= (lBaseCh) ? Out() : Out()-1.
 if (lBaseCh) U.Set(this->Out(),Angle.Size(),C_ZERO);
 else U.Set(this->Out()-1,Angle.Size(),C_ZERO);
 //Определение мощности на выходах предпроцессора для заданных угловых положений
 //источников излучения
 for (ulong j = 0L; j < Angle.Size(); j++)
 {//----------------------------------------------------------------------------
  //1. ФОРМИРОВАНИЕ ВХОДНОГО ТЕСТ-СИГНАЛА ДЛЯ ПРЕДПРОЦЕССОРА
  //----------------------------------------------------------------------------
  lSuccess = this->CalcInSignal(InSignal,1.0,Angle.Get(j),ON);
  if (!lSuccess) {U.Set(0L,0L,false); return false;}
  //----------------------------------------------------------------------------
  //2. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ режекторного пространственного фильтра для AuxCh при
  //   его подключении к предпроцессору (Q-преобразование)
  //----------------------------------------------------------------------------
  if (this->SRF_IsReady())
  {_SRF->TFunc(InSignal,OutSignal);
   //Переписываем OutSignal в P
   for (ulong i = 0L; i < U.Rows(); i++) U.Put(i,j,OutSignal.Get(i));
  }
  else //Переписываем InSignal в P
   for (ulong i = 0L; i < U.Rows(); i++) U.Put(i,j,InSignal.Get(i));
 }
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.8, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CalcInRss(cmatrix& InRss, double Power, double Angle) const
//НАЗНАЧЕНИЕ: Расчет входной ковариационной матрицы предпроцессора для одного источника
//сигнала мощностью Power и направлением Angle [в градусах]. Результирующая матрица будет
//сформирована в комплексной матрице InRss, передаваемой по ссылке. Функция возвращает true
//в случае успешного расчета ковариационной матрицы и false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& InRss - ссылка на результирующую ковариационную матрицу на входе
//   предпроцессора при действии одного источника излучения;
//2. double Power - мощность источника сигнала;
//3. double Angle - угловое положение источника сигнала в градусах;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета входной ковариационной матрицы
//****************************************************************************************
bool TPreProcessor_MISO_SF::CalcInRss(cmatrix& InRss, double Power, double Angle) const
{//Проверка работоспособности ПРЕДПРОЦЕССОРА:
 if (!this->IsReady()) {InRss.Set(0L,false); return false;}
 cvector Us;
 //Расчет комплексных амплитуд на входе предпроцессора при действии одного источника
 if (this->CalcInSignal(Us,Power,Angle,ON))
 {//Построение ковариационной матрицы Rss по вектору Us
  if (CorrelationMatrix(Us,InRss) == false) return false;
 }
 else {InRss.Set(0L,false); return false;}
 return true;
}
//****************************************************************************************
//СТАТУС: I.9, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CalcOutRss(cmatrix& OutRss, double Power, double Angle) const
//НАЗНАЧЕНИЕ: Расчет выходной ковариационной матрицы предпроцессора для одного источника
//сигнала мощностью Power и направлением Angle [в градусах]. Результирующая матрица будет
//сформирована в комплексной матрице OutRss, передаваемой по ссылке. Функция возвращает true
//в случае успешного расчета ковариационной матрицы и false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& OutRss - ссылка на результирующую ковариационную матрицу на выходе
//   предпроцессора при действии одного источника излучения;
//2. double Power - мощность источника сигнала;
//3. double Angle - угловое положение источника сигнала в градусах;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета выходной ковариационной матрицы
//****************************************************************************************
bool TPreProcessor_MISO_SF::CalcOutRss(cmatrix& OutRss, double Power, double Angle) const
{//Проверка работоспособности ПРЕДПРОЦЕССОРА:
 if (!this->IsReady()) {OutRss.Set(0L,false); return false;}
 //Расчет ковариационной матрицы на входе предпроцессора при действии одного источника
 cmatrix InRss;
 if (this->CalcInRss(InRss,Power,Angle))
 {//Проверка на использование SRF
  if (this->SRF_IsReady()) _SRF->TFunc(InRss,OutRss);//Q-преобразование
  else OutRss = InRss;
 }
 else {OutRss.Set(0L,false); return false;}
 return true;
}
//****************************************************************************************
//СТАТУС: I.10, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CalcInRjn(cmatrix& InRjn, const TJammers_2D& Jams) const
//НАЗНАЧЕНИЕ: Расчет входной ковариационной матрицы предпроцессора для аддитивного сигнала
//(помехи) с учетом внутреннего шума приемных каналов LAA и BaseCh. Свойства источников
//излучения (мощность и угловое положение относительно раскрыва LAA) хранятся в контейнере
//Jams, передаваемом по ссылке. Матрица формируется в комплексной матрице InRjn, передавае-
//мой по ссылке. Функция возвращает true в случае успешного расчета ковариационной матрицы
//и false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& InRjn - ссылка на входную ковариационную матрицу предпроцессора при действии
//   аддитивного сигнала (шума) с учетом внутреннего шума каналов;
//2. const TJammers_2D& Jams - константная ссылка на контейнер с источниками излучения,
//   принимаемые предпроцессором (модель аддитивного сигнала).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета входной ковариационной матрицы
//****************************************************************************************
bool TPreProcessor_MISO_SF::CalcInRjn(cmatrix& InRjn, const TJammers_2D& Jams) const
{//Проверка работоспособности ПРЕДПРОЦЕССОРА:
 if (!this->IsReady()) {InRjn.Set(0L,false); return false;}
 cmatrix Us;
 //Расчет комплексных амплитуд на входе предпроцессора для каждого источника излучения,
 //принимаемого предпроцессором
 if (this->CalcInSignal(Us,Jams,ON))
 {//Построение входной ковариационной матрицы InRjn аддитивного сигнала (помехи) по матрице Us
  if (CorrelationMatrix(Us,InRjn) == false) return false;
  //Добавление мощности внутреннего шума приемных каналов в диагональные элементы InRjn,
  //так как внутренний шум в приемных каналах некоррелированный
  ulong BaseIndex = InRjn.Rows()-1;
  double Pn = LAA.GetPn();
  for (ulong i = 0L; i < BaseIndex; i++) InRjn.Put(i,i,InRjn.Get(i,i)+Pn);
  InRjn.Put(BaseIndex,BaseIndex,InRjn.Get(BaseIndex,BaseIndex)+this->BFC_Pnoise());
 }
 else {InRjn.Set(0L,false); return false;}
 return true;
}
//****************************************************************************************
//СТАТУС: I.11, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CalcOutRjn(cmatrix& OutRjn, const TJammers_2D& Jams) const
//НАЗНАЧЕНИЕ: Расчет выходной ковариационной матрицы предпроцессора для аддитивного сигнала
//(помехи) с учетом внутреннего шума приемных каналов LAA и BaseCh. Свойства источников
//излучения (мощность и угловое положение относительно раскрыва LAA) хранятся в контейнере
//Jams, передаваемом по ссылке. Матрица формируется в комплексной матрице OutRjn, передавае-
//мой по ссылке. Функция возвращает true в случае успешного расчета ковариационной матрицы
//и false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& OutRjn - ссылка на выходную ковариационную матрицу предпроцессора при действии
//   аддитивного сигнала (шума) с учетом внутреннего шума каналов;
//2. const TJammers_2D& Jams - константная ссылка на контейнер с источниками излучения,
//   принимаемые предпроцессором (модель аддитивного сигнала).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета выходной ковариационной матрицы
//****************************************************************************************
bool TPreProcessor_MISO_SF::CalcOutRjn(cmatrix& OutRjn, const TJammers_2D& Jams) const
{//Проверка работоспособности ПРЕДПРОЦЕССОРА:
 if (!this->IsReady()) {OutRjn.Set(0L,false); return false;}
 //Расчет ковариационной матрицы аддитивного сигнала (помехи) с учетом внутреннего шума
 //на входе предпроцессора
 cmatrix InRjn;
 if (this->CalcInRjn(InRjn,Jams))
 {//Проверка на использование SRF
  if (this->SRF_IsReady()) _SRF->TFunc(InRjn,OutRjn);//Q-преобразование
  else OutRjn = InRjn;
 }
 else {OutRjn.Set(0L,false); return false;}
 return true;
}
//****************************************************************************************
//СТАТУС: I.12, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CalcInRnn(cmatrix& InRnn) const
//НАЗНАЧЕНИЕ: Расчет входной ковариационной матрицы внутреннего шума приемных каналов LAA
//и BaseCh. Матрица формируется в комплексной матрице InRnn, передаваемой по ссылке, и
//является диагональной, т.к. внутренний шум - некоррелированный. Функция возвращает true
//при успешном расчете ковариационной матрицы и false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//cmatrix& InRnn - ссылка на входную ковариационную матрицу внутреннего шума каналов
//предпроцессора;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета входной ковариационной матрицы
//****************************************************************************************
bool TPreProcessor_MISO_SF::CalcInRnn(cmatrix& InRnn) const
{//Проверка работоспособности ПРЕДПРОЦЕССОРА:
 if (!this->IsReady()) {InRnn.Set(0L,false); return false;}
 if (InRnn.Set(this->In(),C_ZERO) == false) return false;
 //Добавление мощности внутреннего шума приемных каналов в диагональные элементы InRnn,
 //так как внутренний шум в приемных каналах некоррелированный
 ulong BaseIndex = InRnn.Rows()-1;
 double Pn = LAA.GetPn();
 for (ulong i = 0L; i < BaseIndex; i++) InRnn.Put(i,i,Pn);
 InRnn.Put(BaseIndex,BaseIndex,this->BFC_Pnoise());
 return true;
}
//****************************************************************************************
//СТАТУС: I.13, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CalcOutRnn(cmatrix& OutRnn) const
//НАЗНАЧЕНИЕ: Расчет выходной ковариационной матрицы внутреннего шума дополнительных и ОС-
//НОВНОГО канала предпроцессора. Матрица формируется в комплексной матрице OutRnn, переда-
//ваемой по ссылке. Функция возвращает true в случае успешного расчета ковариационной мат-
//рицы и false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//cmatrix& OutRnn - ссылка на выходную ковариационную матрицу внутреннего шума каналов
//предпроцессора.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета выходной ковариационной матрицы
//****************************************************************************************
bool TPreProcessor_MISO_SF::CalcOutRnn(cmatrix& OutRnn) const
{//Проверка работоспособности ПРЕДПРОЦЕССОРА:
 if (!this->IsReady()) {OutRnn.Set(0L,false); return false;}
 //Расчет ковариационной матрицы внутреннего шума на входе предпроцессора
 cmatrix InRnn;
 if (this->CalcInRnn(InRnn))
 {//Проверка на использование SRF
  if (this->SRF_IsReady()) _SRF->TFunc(InRnn,OutRnn);//Q-преобразование
  else OutRnn = InRnn;
 }
 else {OutRnn.Set(0L,false); return false;}
 return true;
}
//****************************************************************************************
//СТАТУС: I.14, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CalcInSignal(cvector& InUs, double P, double Phi, const TRandSignal& RandSignal) const
//НАЗНАЧЕНИЕ: Расчет комплексных амплитуд на входе предпроцессора при действии источника
//сигнала мощностью P с направления Phi [в градусах] со случайными амплитудой и фазой, пере-
//даваемые по ссылке в объекте RandSignal. Вектор входного сигнала формируется в InUs, пере-
//даваемый по ссылке. Размерность вектора InUs равна размерности предпроцессора по входу.
//Для неработоспособного предпроцессора функция возвращает false, InUs - нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& InUs - ссылка на результирующий вектор комплексных амплитуд на входе объекта;
//2. double P - мощность источника сигнала;
//3. double Phi - угловое положение источника сигнала в градусах;
//4. const TRandSignal& RandSignal - ссылка на объект с случайными составляющими сигнала.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета вектора входного сигнала
//****************************************************************************************
bool TPreProcessor_MISO_SF::CalcInSignal(cvector& InUs, double P, double Phi,
     const TRandSignal& RandSignal) const
{if (!this->IsReady()) {InUs.Set(0,COL,false); return false;}
 //Устанавливаем размерность вектора Us
 if (InUs.Set(this->In(),COL,C_ZERO) == false) return false;

 //Объявление рабочих переменных
 ulong OffSet = 0;
 LongSet::const_iterator p, end;
 long index;
 long Origin = this->LAA.GetOrigin();//Отсчетный канал LAA
 double d = this->LAA.GetRelDist();//Относительное расстояние между соседними каналами LAA
 double Ampl = sqrt(P)*RandSignal.Amplitude();
 double c = TwoPI*d*sin(Phi*DegRad);
 double Phase;
 double RandPhase = RandSignal.Phase(RAD);

 //Рассчитываем напряжения на выходе BFC
 complex BFC_Uout = this->BFC_CalcUs(P,Phi,RandSignal);
 InUs.Put(InUs.Size()-1,BFC_Uout);
 if (this->SRF_UseBaseCh()) {InUs.Put(0,BFC_Uout); OffSet = 1;}
 //Рассчитываем входное напряжение рабочих каналов SRF (WorkCh)
 if (this->_WorkCh.GetIters(p,end))
 {while (p != end)
  {index = *p;
   Phase = c*(index-Origin);
   InUs.Put(OffSet++,polar(Ampl,Phase+RandPhase));
   ++p;
  }
 }
 //Рассчитываем входное напряжение вспомогательных каналов (AuxCh)
 if (this->AUX_UseAllCh()) //Все каналы LAA используются как ВСПОМОГАТЕЛЬНЫЕ каналы SF
 {long szLAA = this->LAA.GetDimLAA();
  for (long i = 0L; i < szLAA; i++)
  {Phase = c*(index-Origin);
   InUs.Put(OffSet++,polar(Ampl,Phase+RandPhase));
  }
 }
 else
 {if (this->_AuxCh.GetIters(p,end))
  {while (p != end)
   {index = *p;
    Phase = c*(index-Origin);
    InUs.Put(OffSet++,polar(Ampl,Phase+RandPhase));
    ++p;
   }
  }
 }
 return true;
}
//****************************************************************************************
//СТАТУС: I.15, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CalcOutSignal(cvector& OutUs, double P, double Phi, const TRandSignal& RandSignal) const
//НАЗНАЧЕНИЕ: Расчет комплексных амплитуд на выходе предпроцессора при действии источника
//сигнала мощностью P с направления Phi [в градусах] со случайными амплитудой и фазой, пере-
//даваемые по ссылке в объекте RandSignal. Вектор выходного сигнала формируется в OutUs,
//передаваемый по ссылке. Размерность OutUs равна размерности предпроцессора по выходу.
//Для неработоспособного предпроцессора функция возвращает false, OutUs - нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& OutUs - ссылка на результирующий вектор комплексных амплитуд на выходе объекта;
//2. double P - мощность источника сигнала;
//3. double Phi - угловое положение источника сигнала в градусах;
//4. const TRandSignal& RandSignal - ссылка на объект с случайными составляющими сигнала.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета вектора выходного сигнала
//****************************************************************************************
bool TPreProcessor_MISO_SF::CalcOutSignal(cvector& OutUs, double P, double Phi,
     const TRandSignal& RandSignal) const
{//Проверка работоспособности ПРЕДПРОЦЕССОРА:
 if (!this->IsReady()) {OutUs.Set(0L,COL,false); return false;}
 //Расчет комплексных амплитуд на выходе предпроцессора при действии одного источника сигнала
 //со случайными амплитудой и фазой
 cvector InUs;
 if (this->CalcInSignal(InUs,P,Phi,RandSignal))
 {//Проверка на использование SRF
  if (this->SRF_IsReady()) _SRF->TFunc(InUs,OutUs);//Q-преобразование
  else OutUs = InUs;
 }
 else {OutUs.Set(0L,COL,false); return false;}
 return true;
}
//****************************************************************************************
//СТАТУС: I.16, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CalcOutUs(cvector& OutUs, double Power, double Angle) const
//НАЗНАЧЕНИЕ: Расчет комплексных амплитуд на выходе предпроцессора при действии источника
//сигнала мощностью Power с направления Angle [в градусах]. Вектор выходного сигнала форми-
//руется в OutUs, передаваемый по ссылке. Размерность вектора OutUs равна размерности пред-
//процессора по выходу.
//Для неработоспособного предпроцессора функция возвращает false, OutUs - нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& OutUs - ссылка на результирующий вектор комплексных амплитуд на выходе объекта;
//2. double Power - мощность источника сигнала;
//3. double Angle - угловое положение источника сигнала в градусах;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета вектора выходного сигнала
//****************************************************************************************
bool TPreProcessor_MISO_SF::CalcOutUs(cvector& OutUs, double Power, double Angle) const
{//Проверка работоспособности ПРЕДПРОЦЕССОРА:
 if (!this->IsReady()) {OutUs.Set(0L,COL,false); return false;}
 //Расчет комплексных амплитуд на выходе предпроцессора при действии одного источника сигнала
 cvector InUs;
 if (this->CalcInSignal(InUs,Power,Angle,ON))
 {//Проверка на использование SRF
  if (this->SRF_IsReady()) _SRF->TFunc(InUs,OutUs);//Q-преобразование
  else OutUs = InUs;
 }
 else {OutUs.Set(0L,COL,false); return false;}
 return true;
}
//****************************************************************************************
//СТАТУС: I.17, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CalcInUjam(cvector& InUjam, const TJammers_2D& Jams, TRandGen_64& RandGen) const
//НАЗНАЧЕНИЕ: Расчет комплексных амплитуд на входе предпроцессора при действии аддитивного
//гауссового сигнала (нескольких источников излучения) с параметрами, описываемыми контей-
//нером Jams. Для выработки случайных величин используется объект класса TRandGen_64, пере-
//даваемый по ссылке.
//Работоспособный предпроцессор сформирует суммарный комплексный вектор InUjam. Размерность
//вектора InUjam равна числу входов предпроцессора. Функция возвращает true в случае воз-
//можности расчета комплексных амплитуд на входе предпроцессора и false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& InUjam - ссылка на суммарный вектор комплексных амплитуд на входе
//   предпроцессора для источников излучения, размещенных в контейнере Jams;
//2. const TJammers_2D& Jams - константная ссылка на контейнер со свойствами источников
//   излучения, представляющих аддитивное воздействие;
//3. TRandGen_64& RandGen - ссылка на датчик случайных чисел.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета суммарного вектора комплексных
//амплитуд для составляющих аддитивного сигнала (помехи)
//****************************************************************************************
bool TPreProcessor_MISO_SF::CalcInUjam(cvector& InUjam, const TJammers_2D& Jams,
     TRandGen_64& RandGen) const
{//Проверка работоспособености предпроцессора
 if (!this->IsReady()) {InUjam.Set(0,COL,false); return false;}
 //Устанавливаем размерность вектора InUjam
 if (InUjam.Set(this->In(),COL,complex(0,0)) == false) return false;
 //Генерируем гауссовский сигнал с D = 1 для каждого источника излучения
 RandSignalVect GaussSignal;
 RandGen.GaussSignal(GaussSignal,Jams.Count(),1.0);

 ulong j = 0;
 cvector Uj;
 CIter_Jams2D J, EIter;
 Jams.GetIterators(J,EIter);

 while (J != EIter)
 {//Расчет комплексных амплитуд на входе предпроцессора для J-го источника излучения
  if (this->CalcInSignal(Uj,J->GetPower(),J->GetAngle(DEG),GaussSignal[j]))
  {//Заполняем j-ый столбец матрицы Us значениями комплексных амплитуд на входе
   //предпроцессора, рассчитанными для j-го источника излучения
   for (ulong i = 0; i < InUjam.Size(); i++) InUjam.Put(i,InUjam.Get(i)+Uj.Get(i));
   ++J;
   ++j;
  }
  else {InUjam.Set(0,COL,false); return false;}
 }
 return true;
}
//****************************************************************************************
//СТАТУС: I.18, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CalcOutUjam(cvector& OutUjam, const TJammers_2D& Jams, TRandGen_64& RandGen) const
//НАЗНАЧЕНИЕ: Расчет комплексных амплитуд на выходе предпроцессора при действии аддитивного
//гауссового сигнала (нескольких источников излучения) с параметрами, описываемыми контей-
//нером Jams. Для выработки случайных величин используется объект класса TRandGen_64, пере-
//даваемый по ссылке.
//Работоспособный предпроцессор сформирует суммарный комплексный вектор OutUjam. Размерность
//вектора InUjam равна числу выходов предпроцессора. Функция возвращает true в случае воз-
//можности расчета комплексных амплитуд на выходе предпроцессора и false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& OutUjam - ссылка на суммарный вектор комплексных амплитуд на выходе
//   предпроцессора для источников излучения, размещенных в контейнере Jams;
//2. const TJammers_2D& Jams - константная ссылка на контейнер со свойствами источников
//   излучения, представляющих аддитивное воздействие;
//3. TRandGen_64& RandGen - ссылка на датчик случайных чисел.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета суммарного вектора комплексных
//амплитуд для составляющих аддитивного сигнала (помехи)
//****************************************************************************************
bool TPreProcessor_MISO_SF::CalcOutUjam(cvector& OutUjam, const TJammers_2D& Jams,
     TRandGen_64& RandGen) const
{//Проверка работоспособности ПРЕДПРОЦЕССОРА:
 if (!this->IsReady()) {OutUjam.Set(0L,COL,false); return false;}
 //Расчет комплексных амплитуд на выходе предпроцессора при действии одного источника сигнала
 cvector InUjam;
 if (this->CalcInUjam(InUjam,Jams,RandGen))
 {//Проверка на использование SRF
  if (this->SRF_IsReady()) _SRF->TFunc(InUjam,OutUjam);//Q-преобразование
  else OutUjam = InUjam;
 }
 else {OutUjam.Set(0L,COL,false); return false;}
 return true;
}
//****************************************************************************************
//СТАТУС: I.19, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CalcInUnoise(cvector& InUn, TRandGen_64& RandGen) const
//НАЗНАЧЕНИЕ: Расчет комплексных амплитуд внутреннего шума на входе предпроцессора со слу-
//чайными гауссовыми составляющими в приемных каналах предпроцессора. Вектор входного шума
//формируется в InUn, передаваемый по ссылке. Размерность вектора InUn равна размерности
//предпроцессора по входу. Случайные составляющие приемных каналов предпроцессора формируют-
//ся ГСЧ RandGen, передаваемым по ссылке.
//Для неработоспособного предпроцессора функция возвращает false, InUn - нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& InUn - ссылка на результирующий вектор внутреннего шума на входе объекта;
//2. TRandGen_64& RandGen - ссылка на генератор случайных чисел.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета вектора входного шума
//****************************************************************************************
bool TPreProcessor_MISO_SF::CalcInUnoise(cvector& InUn, TRandGen_64& RandGen) const
{if (!this->IsReady()) {InUn.Set(0,COL,false); return false;}
 //Устанавливаем размерность вектора Us
 if (InUn.Set(this->In(),COL,C_ZERO) == false) return false;
 //Генерируем случайные гауссовские составляющие для всех приемных каналов
 RandSignalVect GaussNoise;
 if (RandGen.GaussSignal(GaussNoise,this->LAA.GetDimLAA(),1.0) == false)
 {InUn.Set(0,COL,false); return false;}
 //Объявление рабочих переменных
 ulong OffSet = 0;
 LongSet::const_iterator p, end;
 long index;
 double Ampl = sqrt(this->LAA.GetPn());
 double RandAmpl;

 //Рассчитываем напряжение внутреннего шума на выходе BFC
 complex BFC_Uout = this->BFC_CalcUnoise(GaussNoise);
 InUn.Put(InUn.Size()-1,BFC_Uout);
 if (this->SRF_UseBaseCh()) {InUn.Put(0,BFC_Uout); OffSet = 1;}
 //Рассчитываем входное напряжение внутреннего шума рабочих каналов SRF (WorkCh)
 if (this->_WorkCh.GetIters(p,end))
 {while (p != end)
  {index = *p;
   RandAmpl = Ampl*GaussNoise[index].Amplitude();
   InUn.Put(OffSet++,polar(RandAmpl,GaussNoise[index].Phase(RAD)));
   ++p;
  }
 }
 //Рассчитываем входное напряжение внутреннего шума вспомогательных каналов (AuxCh)
 if (this->AUX_UseAllCh()) //Все каналы LAA используются как ВСПОМОГАТЕЛЬНЫЕ каналы SF
 {long szLAA = this->LAA.GetDimLAA();
  for (long i = 0L; i < szLAA; i++)
  {RandAmpl = Ampl*GaussNoise[i].Amplitude();
   InUn.Put(OffSet++,polar(RandAmpl,GaussNoise[i].Phase(RAD)));
  }
 }
 else
 {if (this->_AuxCh.GetIters(p,end))
  {while (p != end)
   {index = *p;
    RandAmpl = Ampl*GaussNoise[index].Amplitude();
    InUn.Put(OffSet++,polar(RandAmpl,GaussNoise[index].Phase(RAD)));
    ++p;
   }
  }
 }
 return true;
}
//****************************************************************************************
//СТАТУС: I.20, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CalcOutUnoise(cvector& OutUn, TRandGen_64& RandGen) const
//НАЗНАЧЕНИЕ: Расчет комплексных амплитуд внутреннего шума на выходе предпроцессора со слу-
//чайными гауссовыми составляющими в приемных каналах предпроцессора. Вектор выходного шума
//формируется в OutUn, передаваемый по ссылке. Размерность OutUn равна размерности предпро-
//цессора по выходу. Объект RandGen, передаваемый по ссылке, используется для выработки
//гауссовых случайных составляющих внутреннего шума для всех приемных каналов LAA.
//Для неработоспособного предпроцессора функция возвращает false, OutUn - нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& OutUn - ссылка на вектор внутреннего шума на выходе предпроцессора;
//2. TRandGen_64& RandGen - ссылка на генератор случайных чисел.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета вектора выходного шума
//****************************************************************************************
bool TPreProcessor_MISO_SF::CalcOutUnoise(cvector& OutUn, TRandGen_64& RandGen) const
{//Проверка работоспособности ПРЕДПРОЦЕССОРА:
 if (!this->IsReady()) {OutUn.Set(0L,COL,false); return false;}
 //Расчет комплексных амплитуд внутреннего шума на выходе предпроцессора со случайными
 //амплитудой и фазой приемных каналов LAA
 cvector InUn;
 if (this->CalcInUnoise(InUn,RandGen))
 {//Проверка на использование SRF
  if (this->SRF_IsReady()) _SRF->TFunc(InUn,OutUn);//Q-преобразование
  else OutUn = InUn;
 }
 else {OutUn.Set(0L,COL,false); return false;}
 return true;
}


//****************************************************************************************
//СТАТУС: I.LAA_1, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LAA_IsReady() const
//НАЗНАЧЕНИЕ: Проверка работоспособности LAA. Функция возвращает true, если число каналов
//LAA больше одного, в противном случае возвращается false. Наличие не менее ДВУХ разнесен-
//ных в пространстве каналов LAA является необходимым условием для построения фильтра.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lReady - признак работоспособности LAA.
//****************************************************************************************
bool TPreProcessor_MISO_SF::LAA_IsReady() const
{return (LAA.GetDimLAA() > 1) ? true : false;}
//****************************************************************************************
//СТАТУС: I.LAA_2, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LAA_SetDimension(ulong N, ulong Origin)
//НАЗНАЧЕНИЕ: Установка размера и отсчетного элемента LAA. Функция возвращает признак изме-
//нения устанавливаемых свойств LAA. При изменении N или Origin должны обновляться при
//необходимости остальные блоки предпроцессора - BaseChannel, AuxCh и SRF.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong N - количество приемных каналов LAA;
//2. ulong Origin - номер отсчетного элемента LAA
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lChange - признак изменения устанавливаемых свойств LAA
//****************************************************************************************
bool TPreProcessor_MISO_SF::LAA_SetDimension(ulong N, ulong Origin)
{bool lChange = false;
 ulong PrevDimLAA = LAA.GetDimLAA();
 ulong PrevOrigin = LAA.GetOrigin();
 LAA.SetDimLAA(N);//Установка новой размерности LAA
 LAA.SetOrigin(Origin);//Установка отсчетного элемента LAA
 if ((PrevDimLAA != LAA.GetDimLAA()) || (PrevOrigin != LAA.GetOrigin()))
 {lChange = true;
  this->BFC_Update();
 }
 return lChange;
}
//****************************************************************************************
//СТАТУС: I.LAA_3, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// void LAA_Set(ulong DimLAA, ulong Origin, double RelDist, double Pn = 1.0)
//НАЗНАЧЕНИЕ: Установка всех свойств LAA. При изменении N или Origin при необходимости
//будут обновлены остальные блоки предпроцессора - BaseChannel, AuxCh и SRF.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong DimLAA - количество приемных каналов LAA;
//2. ulong Origin - номер отсчетного элемента LAA;
//3. double RelDist - относительное расстояние между соседними антеннами LAA;
//4. double Pn [1.0] - уровень мощности внутреннего шума приемных каналов LAA.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessor_MISO_SF::LAA_Set(ulong DimLAA, ulong Origin, double RelDist, double Pn)
{//Установка всех свойств LAA
 LAA.Set(DimLAA,RelDist,Pn,Origin);
 //Обновление BFC, AuxCh и SRF
 this->BFC_Update();
}
//****************************************************************************************
//СТАТУС: I.LAA_4, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& LAA_Info(string &s) const
//НАЗНАЧЕНИЕ: Формирование характеристик объекта LAA в строке s, передаваемой по ссылке.
//Свойства LAA представляются в виде:
//----------------------------------------------------------------------------------------
//LAA: N: <_N>, Origin: <_Zero>, d: <_d>, Pn: <_Pn>, Antenna: <ODA>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строковый объект, в котором формируются свойства LAA
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами объекта.
//****************************************************************************************
string& TPreProcessor_MISO_SF::LAA_Info(string &s) const
{s.assign("LAA: ");
 if (this->LAA_IsReady())
 {string t;
  this->LAA.Properties(t);
  s.append(t); s.append(1,';');
 }
 else s.append("Not ready;");
 return s;
}

//****************************************************************************************
//СТАТУС: I.BFC_1, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong BFC_GetLAACh() const
//НАЗНАЧЕНИЕ: Число каналов LAA, подключенных к BFC. Для неработоспособного предпроцессора
//функция возвращает 0.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong ival - число каналов LAA, используемых BaseChannel
//****************************************************************************************
ulong TPreProcessor_MISO_SF::BFC_GetLAACh() const
{ulong ival = 0;
 if (this->IsReady()) ival = (this->BFC_UseAllCh()) ? LAA.GetDimLAA() : _BaseCh.Size();
 return ival;
}
//****************************************************************************************
//СТАТУС: I.BFC_2, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double BFC_SetScanAngle(double Angle)
//НАЗНАЧЕНИЕ: Установка нового угла сканирования в пределах [-90..+90] deg. Функция возвра-
//щает новый угол сканирования. Алгоритм работы функции:
//1) При подключении ОДНОГО канала LAA к BaseChannel угол сканирования всегда равен 0;
//2) При подключении ВСЕХ или НЕСКОЛЬКИХ каналов к LAA угол сканирования должен находиться
//   в диапазоне [-90..+90] deg. При невыполнении этого условия ScanAngle будет равен 0.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: double Angle - новый угол сканирования в градусах
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double _ScanAngle - новое значение угла сканирования в градусах
//****************************************************************************************
double TPreProcessor_MISO_SF::BFC_SetScanAngle(double Angle)
{if (!this->LAA_IsReady() || this->BFC_UseSingleCh()) return _ScanAngle = 0;
 return _ScanAngle = ((Angle < -90) || (Angle > 90)) ? 0 : Angle;
}
//****************************************************************************************
//СТАТУС: I.BFC_3, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong BFC_SetChannels(ulong N)
//НАЗНАЧЕНИЕ: Подключение не более N каналов LAA к BFC. Функция возвращает фактическое число
//каналов LAA, подключенных к BFC. Алгоритм работы функции:
//1) При N = 0 || N >= DimLAA => N = DimLAA;
//2) При N = 1 выбирается номер канала LAA, соответствующий отсчетному элементу (Origin)
//3) При N < DimLAA автоматически выбираются первые N каналов LAA, начиная с индекса 0.
//В случаях 2 и 3 осуществляется корректировка блоков AuxCh и SRF.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong N - максимальное число каналов LAA, подключаемых к BFC
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong ival - фактическое число каналов LAA, подключенных к BFC
//****************************************************************************************
ulong TPreProcessor_MISO_SF::BFC_SetChannels(ulong N)
{if (!this->LAA_IsReady()) return 0;
 //Подключение всех каналов LAA к BaseChannel
 if ((N == 0) || (N >= LAA.GetDimLAA())) _BaseCh.Clear();
 //Подключение одного канала LAA с индексом Origin к BaseChannel
 else if (N == 1) {this->BFC_Reset(); _BaseCh.Assign(LAA.GetOrigin());}
 //Подключение первых N каналов LAA, начиная с первого канала, к BaseChannel (N < DimLAA)
 else
 {_BaseCh.Clear();
  for (ulong i = 0; i < N; i++) _BaseCh.Append(i);
 }
 //Обновление свойств блоков AuxCh и SRF при необходимости
 this->AUX_Update();
 return this->BFC_GetLAACh();
}
//****************************************************************************************
//СТАТУС: I.BFC_4, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong BFC_SetChannels(const string& s)
//НАЗНАЧЕНИЕ: Подключение к BaseChannel индексов каналов LAA, указанных в строке s.
//Функция возвращает количество фактически подключенных каналов.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const string& s - ссылка на строку с номерами каналов LAA
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong ival - фактическое число каналов LAA, подключенных к BFC
//****************************************************************************************
ulong TPreProcessor_MISO_SF::BFC_SetChannels(const string& s)
{if (!this->LAA_IsReady()) return this->BFC_GetLAACh();
 _BaseCh.Assign(s);
 //Исключение каналов LAA с индексами вне пределов [0..LAA.GetDimLAA()-1]
 _BaseCh.RemoveOutSide(0,this->LAA.GetDimLAA()-1);
 //Проверка числа каналов LAA, подключенных к BaseChannel
 ulong N = _BaseCh.Size();
 //Подключаем ВСЕ каналы LAA
 if (N == 0 || N == this->LAA.GetDimLAA()) this->BFC_SetChannels(N);
 //Подключен ОДИН канал LAA
 else if (N == 1) this->BFC_SetScanAngle(0);
 //Обновление свойств блоков AuxCh и SRF при необходимости
 this->AUX_Update();
 return this->BFC_GetLAACh();
}
//****************************************************************************************
//СТАТУС: I.BFC_5, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool BFC_Set(TLongSet& LAACh, double Angle)
//НАЗНАЧЕНИЕ: Подключение к BaseChannel индексов каналов LAA, указанных в контейнере LAACh,
//и установка нового угла сканирования Angle, при условии подключения более одного канала
//LAA к BFC. Функция возвращает true при изменении свойств BFC и false в противном случае.
//Контейнер LAACh изменяется функцией.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TLongSet& LAACh - ссылка на контейнер с номерами каналов LAA, подключаемых к BFC;
//2. double Angle - угловое положение основного лепестка синтезированного ОСНОВНОГО канала
//   в гадусах.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lChanged - признак изменения свойств BFC
//****************************************************************************************
bool TPreProcessor_MISO_SF::BFC_Set(TLongSet& LAACh, double Angle)
{bool lChanged = false;
 double PrevAngle = this->BFC_ScanAngle();
 if (!this->LAA_IsReady()) return lChanged;
 //-------------------------------------------------------------------------------
 //Установка каналов LAA, подключаемых к BFC
 //-------------------------------------------------------------------------------
 //Исключение каналов LAA с индексами вне пределов [0..LAA.GetDimLAA()-1]
 LAACh.RemoveOutSide(0,this->LAA.GetDimLAA()-1);
 //Сравнение контейнеров _BaseCh и LAACh
 if (_BaseCh != LAACh)
 {_BaseCh.AssignData(LAACh);
  //Проверка числа каналов LAA, подключенных к BaseChannel
  ulong N = _BaseCh.Size();
  //Подключаем ВСЕ каналы LAA
  if (N == 0 || N == this->LAA.GetDimLAA()) this->BFC_SetChannels(N);
  //Подключен ОДИН канал LAA
  else if (N == 1) this->BFC_SetScanAngle(0);
  //Обновление свойств блоков AuxCh и SRF при необходимости
  this->AUX_Update();
  lChanged = true;
 }
 //--------------------------------------------------------------------------------
 //Установка угла сканирования
 //--------------------------------------------------------------------------------
 Angle = this->BFC_SetScanAngle(Angle);
 if (!lChanged && (PrevAngle != Angle)) lChanged = true;
 return lChanged;
}
//****************************************************************************************
//СТАТУС: I.BFC_6, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& BFC_Info(string& s) const
//НАЗНАЧЕНИЕ: Формирование в строковом объекте s, передаваемом по ссылке, свойств схемы
//формирования ОСНОВНОГО канала - BeamFormer Circuit (BFC). Функция возвращает ссылку на
//строку s. Информация об BFC представляется в виде:
//<BFC: N {LAA indexes}, ScanAngle = Angle;>,
//N - общее число каналов LAA, используемых как дополнительные каналы SF;
//LAA indexes - номера каналов LAA, подключенные к BFC. Функция распознает последователь-
//ности каналов, образующих арифметическую прогрессию, и представляет их интервалами в
//строковом виде;
//Angle - направление ОСНОВНОГО луча относительно раскрыва LAA (угол сканирования).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const string& s - ссылка на строку-приемник сведений об BFC
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: const string& s - ссылка на строку-приемник сведений об BFC
//****************************************************************************************
string& TPreProcessor_MISO_SF::BFC_Info(string& s) const
{s.assign("BFC: ");
 ulong N = this->BFC_GetLAACh();
 if (N == 0L) s.append("Off;");
 else
 {char buffer[41];
  ostrstream text(buffer, sizeof(buffer));
  text << N << ends; s.append(text.str()); text.seekp(0);
  if (this->BFC_UseAllCh()) //Все каналы LAA подключены к BFC
  {text << " {0 .. " << N-1 << "}" << ends;
   s.append(text.str()); text.seekp(0);
  }
  else //К BFC подключен один или часть каналов LAA
  {//Формирование номеров каналов LAA, подключенных к BFC, с выделением интервалов
   string t;
   this->_BaseCh.DataToStr(t);
   s.append(" {"); s.append(t); s.append("}");
  }
  //Формируем значение угла сканирования в строковом виде
  text << ", ScanAngle = " << this->BFC_ScanAngle() << ";" << ends;
  s.append(text.str()); text.seekp(0);
 }
 return s;
}
//****************************************************************************************
//СТАТУС: I.BFC_7, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool BFC_Edit()
//НАЗНАЧЕНИЕ: Консольное редактирование свойств схемы формирования ОСНОВНОГО канала пред-
//процессора пространственного фильтра с выделенным каналом. Функция возвращает true - в
//случае изменения свойств BFC и false - в противоположном случае. Изменение свойств BFC
//может привести к изменению свойств AuxCh и SRF при ее использовании.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lChanged - признак изменения свойств BFC после редактирования
//****************************************************************************************
bool TPreProcessor_MISO_SF::BFC_Edit()
{//Рабочие переменные
 int y, row_start = wherey();
 string line(79,'-');
 gotoxy(1,row_start); clreol();
 //Проверка на возможность редактирования
 if (!this->LAA_IsReady())
 {cout << line << endl;
  cout << "Editing BFC is impossible ! First of all You should configurate LAA properly!" << endl;
  cout << line << endl;
  cout << "Press any key ..."; getch();
  ClrScr(1,row_start);//Очистка экрана
  return false;
 }
 //Рабочие переменные
 TLongSet LAACh;
 double Angle;
 char buffer[41];
 ulong MaxLAACh = this->LAA.GetDimLAA()-1;
 ostrstream text(buffer, sizeof(buffer));
 char c;
 bool flag;
 string s, t, head, Msg_LAACh, Msg_ScanAngle, res;

 Msg_ScanAngle.assign("Input ScanAngle [-90..+90] deg: ");
 Msg_LAACh.assign("Input LAACh [0 .. ");
 text << MaxLAACh << "] <n1 n2 .. nk;>" << ends;
 Msg_LAACh.append(text.str()); text.seekp(0);

 s.assign("Edit <BFC>, PrevBFC: "); this->BFC_Info(t); s.append(t);
 MultiLineFormat(head,s,80);

 gotoxy(1,row_start); clreol();

 do //Цикл ввода свойств схемы формирования ОСНОВНОГО канала
 {//----------------------------------------------------------------------------------
  cout << line << endl << head << endl << line << endl;
  //----------------------------------------------------------------------------------
  //1. Ввод номеров каналов LAA, подключаемых к BFC
  //----------------------------------------------------------------------------------
  y = wherey();
  cout << Msg_LAACh << endl;
  s.clear();
  cout << "> "; cin.ignore(); getline(cin,s,';');
  ClrScr(1,y);//Очистка экрана
  LAACh.Assign(s);
  //Фильтрация каналов LAA не принадлежащих интервалу [0..MaxLAACh]
  LAACh.RemoveOutSide(0,MaxLAACh);
  //Проверка на отсутствие номеров каналов в контейнере
  if (LAACh.IsEmpty()) LAACh.Assign(this->LAA.GetOrigin());
  //Формирование сообщения по подключенным каналам LAA к BFC
  res.assign("BaseCh: "); LAACh.AboutData(s); res.append(s);
  MultiLineFormat(s,res,80);
  y = wherey();
  cout << s << endl;
  //----------------------------------------------------------------------------------
  //2. Ввод угла сканирования при условии подключения к BFC более одного канала LAA
  //----------------------------------------------------------------------------------
  if (LAACh.Size() == 1) Angle = 0.0;
  else
  {//y = wherey();
   cout << Msg_ScanAngle; cin >> Angle;
   if (fabs(Angle) > 90.0) Angle = 0.0;
   ClrScr(1,y);//Очистка экрана
  }
  text << " ScanAngle = " << Angle << ';' << ends;
  s.assign(text.str()); text.seekp(0);
  res.append(s);
  MultiLineFormat(s,res,80);
  cout << s << endl;
  //-----------------------------------------------------------------------------------
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
 return this->BFC_Set(LAACh,Angle);//Установка свойств BaseChannel
}
//****************************************************************************************
//СТАТУС: I.BFC_8, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double BFC_Pnoise() const
//НАЗНАЧЕНИЕ: Вычисление уровня внутреннего шума ОСНОВНОГО канала. При использовании луче-
//образующей схемы выходная мощность внутреннего шума равна сумме мощностей внутреннего шума
//каналов LAA, подключенных к BFC. Для неработоспособного предпроцессора возвращается 0.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double Pnoise - уровень внутреннего шума на выходе BFC
//****************************************************************************************
double TPreProcessor_MISO_SF::BFC_Pnoise() const
{if (!this->IsReady()) return 0.0;
 return this->LAA.GetPn()*this->BFC_GetLAACh();
}


//****************************************************************************************
//СТАТУС: I.AUX_1, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong AUX_GetLAACh() const
//НАЗНАЧЕНИЕ: Число каналов LAA, используемых как вспомогательные каналы SF. Для неработо-
//способного предпроцессора функция возвращает 0.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong ival - число каналов LAA, используемых как ВСПОМОГАТЕЛЬНЫЕ
//****************************************************************************************
ulong TPreProcessor_MISO_SF::AUX_GetLAACh() const
{ulong ival = 0;
 if (this->IsReady()) ival = (this->AUX_UseAllCh()) ? LAA.GetDimLAA() : _AuxCh.Size();
 return ival;
}
//****************************************************************************************
//СТАТУС: I.AUX_2, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong AUX_SetChannels(ulong N)
//НАЗНАЧЕНИЕ: Назначение не более N каналов LAA в качестве ДОПОЛНИТЕЛЬНЫХ каналов SF. Для
//неработоспособного предпроцессора функция возвращает 0.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong N - число каналов LAA, используемые как ВСПОМОГАТЕЛЬНЫЕ
//каналы адаптивного пространственного фильтра (SF)
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong ival - фактическое число каналов LAA, задействованных как
//вспомогательные каналы адаптивного SF
//****************************************************************************************
ulong TPreProcessor_MISO_SF::AUX_SetChannels(ulong N)
{if (!this->LAA_IsReady()) return 0;//Предпроцессор неработоспособен
 ulong MaxAuxCh = this->AUX_GetMaxLAACh();//Максимальное число ВСПОМОГАТЕЛЬНЫХ каналов
 //Проверка на использование максимально возможного числа каналов LAA как ВСПОМОГАТЕЛЬНЫХ
 if ((N == 0) || (N > MaxAuxCh)) N = MaxAuxCh;
 //Автоматическое назначение вспомогательных каналов SF из интервала [0..DimLAA-1] с огра-
 //ничением на номер ОСНОВНОГО канала (при подключении ОДНОГО канала LAA к BaseChannel).
 //Кроме того, при подключении нескольких, но не всех каналов LAA к BFC, производится выбор
 //по возможности независимых ВСПОМОГАТЕЛЬНЫХ каналов SF, т.е. выбираются такие номера ка-
 //налов LAA, которые не задействованы в формировании ОСНОВНОГО канала.
 if (N == this->LAA.GetDimLAA()) _AuxCh.Clear();//Задействованы ВСЕ каналы LAA
 else
 {TLongSet Empty;
  ulong MaxIndex = LAA.GetDimLAA()-1;
  //Схема BFC использует один канал LAA
  if (this->BFC_UseSingleCh()) _AuxCh.Assign(0L,MaxIndex,_BaseCh,N);
  //Схема BFC использует ВСЕ каналы LAA
  else if (this->BFC_UseAllCh()) _AuxCh.Assign(0L,MaxIndex,Empty,N);
  //Схема BFC использует часть каналов LAA
  else _AuxCh.Assign(0L,MaxIndex,Empty,_BaseCh,N);
 }
 this->SRF_Update();//Обновление свойств SRF

 return this->AUX_GetLAACh();
}
//****************************************************************************************
//СТАТУС: I.AUX_3, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong AUX_SetChannels(const string& s)
//НАЗНАЧЕНИЕ: Назначение каналов LAA, указанных в строке s, в качестве ДОПОЛНИТЕЛЬНЫХ
//каналов адаптивного пространственного фильтра. Функция возвращает количество фактически
//назначенных ДОПОЛНИТЕЛЬНЫХ каналов.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const string& s - ссылка на строку с номерами каналов LAA
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong ival - фактическое число ДОПОЛНИТЕЛЬНЫХ каналов SF
//****************************************************************************************
ulong TPreProcessor_MISO_SF::AUX_SetChannels(const string& s)
{if (!this->LAA_IsReady()) return this->AUX_GetLAACh();
 _AuxCh.Assign(s);
 //Исключение каналов LAA с индексами вне пределов [0..LAA.GetDimLAA()-1]
 _AuxCh.RemoveOutSide(0,this->LAA.GetDimLAA()-1);
 //Исключение номера ОСНОВНОГО канала при использовании BFC ОДНОГО канала LAA
 long BaseIndex;
 if (this->BFC_UseSingleCh(BaseIndex)) _AuxCh.Remove(BaseIndex);
 //Проверка числа каналов LAA, используемых как ДОПОЛНИТЕЛЬНЫЕ каналы SF
 ulong N = _AuxCh.Size();
 //Подключаем ВСЕ каналы LAA
 if (N == 0 || N == this->LAA.GetDimLAA()) this->AUX_SetChannels(N);
 //Обновление свойств SRF
 this->SRF_Update();
 return this->AUX_GetLAACh();
}
//****************************************************************************************
//СТАТУС: I.AUX_4, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool AUX_Set(TLongSet& LAACh)
//НАЗНАЧЕНИЕ: Назначение каналов LAA, передаваемых в контейнере LAACh, в качестве ДОПОЛНИ-
//ТЕЛЬНЫХ каналов адаптивного пространственного фильтра. В процессе работы функция может
//изменять данные контейнера LAACh. Функция возвращает true при обновлении номеров каналов
//антенной решетки, назначенных как ДОПОЛНИТЕЛЬНЫЕ каналы SF.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TLongSet& LAACh - ссылка на контейнер с номерами каналов LAA
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lChanged - признак изменения номеров ДОПОЛНИТЕЛЬНЫХ каналов
//****************************************************************************************
bool TPreProcessor_MISO_SF::AUX_Set(TLongSet& LAACh)
{if (!this->LAA_IsReady()) return false;
 //Исключение каналов LAA с индексами вне пределов [0..LAA.GetDimLAA()-1]
 LAACh.RemoveOutSide(0,this->LAA.GetDimLAA()-1);
 //Исключение номера ОСНОВНОГО канала при использовании BFC ОДНОГО канала LAA
 long BaseIndex;
 if (this->BFC_UseSingleCh(BaseIndex)) LAACh.Remove(BaseIndex);
 bool lChanged = false;
 //Сравнение контейнеров _AuxCh и LAACh
 if (_AuxCh != LAACh)
 {lChanged = true;
  _AuxCh.AssignData(LAACh);
  //Проверка числа каналов LAA, используемых как ДОПОЛНИТЕЛЬНЫЕ каналы SF
  ulong N = _AuxCh.Size();
  //Подключаем ВСЕ каналы LAA
  if (N == 0 || N == this->LAA.GetDimLAA()) this->AUX_SetChannels(N);
  //Обновление свойств SRF
  this->SRF_Update();
 }
 return lChanged;
}
//****************************************************************************************
//СТАТУС: I.AUX_5, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& AUX_Info(string& s) const
//НАЗНАЧЕНИЕ: Формирование в строковом объекте s, передаваемом по ссылке, число и номеров
//каналов LAA, используемых как ДОПОЛНИТЕЛЬНЫЕ каналы пространственного фильтра. Функция
//возвращает ссылку на строку s. Информация об AuxChannel представляется в виде:
//<AuxCh: N {n1 n2 [n3,n4 .. n5] n6 [n7 .. n8] n9};>,
//N - общее число каналов LAA, используемых как дополнительные каналы SF;
//n1 .. n9 - индексы каналов LAA. Функция способна распознавать последовательности каналов,
//образующих арифметическую прогрессия, и представлять их интервалами в строковом виде.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const string& s - ссылка на строку-приемник сведений об AuxCh
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: const string& s - ссылка на строку-приемник сведений об AuxCh
//****************************************************************************************
string& TPreProcessor_MISO_SF::AUX_Info(string& s) const
{s.assign("AuxCh: ");
 ulong N = this->AUX_GetLAACh();
 if (N == 0L) s.append("0;");
 else
 {char buffer[41];
  ostrstream text(buffer, sizeof(buffer));
  text << N << ends; s.append(text.str()); text.seekp(0);
  if (this->AUX_UseAllCh()) //Все каналы LAA используются как дополнительные каналы SF
  {text << " {0 .. " << N-1 << "};" << ends;
   s.append(text.str()); text.seekp(0);
  }
  else //В качестве AuxCh используется часть каналов LAA
  {//Получение номеров каналов LAA, используемых как дополнительные каналы SF, с выделением
   //интервалов
   string t;
   this->_AuxCh.DataToStr(t);
   s.append(" {"); s.append(t); s.append("};");
  }
 }
 return s;
}
//****************************************************************************************
//СТАТУС: I.AUX_6, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool AUX_Edit()
//НАЗНАЧЕНИЕ: Консольное редактирование номеров каналов LAA, используемых как ДОПОЛНИТЕЛЬ-
//НЫЕ каналы SF. Функция возвращает true - при изменения номеров AuxCh и false - в противо-
//положном случае. Изменение свойств AuxCh может привести к изменению свойств SRF при ее
//использовании.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lChanged - признак изменения AuxCh после редактирования
//****************************************************************************************
bool TPreProcessor_MISO_SF::AUX_Edit()
{//Рабочие переменные
 int y, row_start = wherey();
 string line(79,'-');
 gotoxy(1,row_start); clreol();
 //Проверка на возможность редактирования
 if (!this->LAA_IsReady())
 {cout << line << endl;
  cout << "Editing AuxCh is impossible ! First of all You should configurate LAA properly!"
       << endl;
  cout << line << endl;
  cout << "Press any key ..."; getch();
  ClrScr(1,row_start);//Очистка экрана
  return false;
 }
 //Рабочие переменные
 TLongSet LAACh, Derating;
 ulong MaxLAACh = this->LAA.GetDimLAA()-1;
 long BaseChIndex = -1;

 char c;
 bool flag;
 string s, t, head, Msg_LAACh;

 Msg_LAACh.assign("Input LAACh {");
 if (this->BFC_UseSingleCh(BaseChIndex)) Derating.Assign(BaseChIndex);
 else Derating.Clear();
 LAACh.Assign(0,MaxLAACh,Derating);
 LAACh.DataToStr(s);
 Msg_LAACh.append(s);
 Msg_LAACh.append("} <n1 n2 .. nk;>");

 s.assign("Edit <AuxCh>, PrevAuxCh: "); this->AUX_Info(t); s.append(t);
 MultiLineFormat(head,s,80);

 gotoxy(1,row_start); clreol();

 do //Цикл ввода номеров дополнительных каналов пространственного фильтра
 {//----------------------------------------------------------------------------------
  cout << line << endl << head << endl << line << endl;
  //----------------------------------------------------------------------------------
  //Ввод номеров каналов LAA, используемых как ДОПОЛНИТЕЛЬНЫЕ каналы
  //----------------------------------------------------------------------------------
  y = wherey();
  cout << Msg_LAACh << endl;
  s.clear();
  cout << "> "; cin.ignore(); getline(cin,s,';');
  ClrScr(1,y);//Очистка экрана
  LAACh.Assign(s);
  //Фильтрация каналов LAA не принадлежащих интервалу [0..MaxLAACh]
  LAACh.RemoveOutSide(0,MaxLAACh);
  if (this->BFC_UseSingleCh()) LAACh.Remove(BaseChIndex);
  //Проверка на отсутствие номеров каналов в контейнере
  if (LAACh.IsEmpty()) LAACh.Assign(0,MaxLAACh,Derating);
  //Формирование сообщения по дополнительным каналам SF
  t.assign("AuxCh: "); LAACh.AboutData(s); t.append(s);
  MultiLineFormat(s,t,80);
  cout << s << endl;
  //-----------------------------------------------------------------------------------
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
 return this->AUX_Set(LAACh);//Установка AuxCh
}


//****************************************************************************************
//СТАТУС: I.SRF_1, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong SRF_SetElimDirs(const TDoubleSet& ElimDirs)
//НАЗНАЧЕНИЕ: Установка направлений исключения, передаваемых в контейнере ElimDirs. Функция
//возвращает число установленных направлений исключения. Значения режекции должны принадле-
//жать интервалу: [-90 ... +90].
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TDoubleSet& ElimDirs - контейнер с направлениями исключения
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong ival - число установленных направлений исключения
//****************************************************************************************
ulong TPreProcessor_MISO_SF::SRF_SetElimDirs(const TDoubleSet& ElimDirs)
{if (!this->IsReady() || ElimDirs.IsEmpty()) return 0;

 if (&ElimDirs != &this->_ElimDirects)
 {this->_ElimDirects.Clear();
  DblSet::const_iterator p, end;
  ElimDirs.GetIters(p,end);
  double rval;
  //Копирование значений из контейнера ElimDirs в контейнер класса _ElimDirects с фильтра-
  //цией значений в интервале [-90..+90]
  while (p != end)
  {rval = *p;
   if ((rval >= -90.0) && (rval <= 90.0)) this->_ElimDirects.Append(rval);
   ++p;
  }
 }
 //Реакция на изменение направлений исключения
 if (!this->SRF_ElimDirsUpdate()) {this->SRF_Reset(); return 0;}
 if (!this->SRF_UnitUpdate(this->SRF_GetUnit())) {this->SRF_Reset(); return 0;}
 return this->SRF_GetElimDirs();
}
//****************************************************************************************
//СТАТУС: I.SRF_2, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong SRF_SetElimDirs(const string& s)
//НАЗНАЧЕНИЕ: Установка направлений исключения, передаваемых в строке s. Функция возвращает
//число установленных направлений исключения. Значения режекции должны принадлежать интер-
//валу: [-90 ... +90].
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const string& s - ссылка на строку с направлениями исключения
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong ival - число установленных направлений исключения
//****************************************************************************************
ulong TPreProcessor_MISO_SF::SRF_SetElimDirs(const string& s)
{if (!this->IsReady()) return 0;
 TDoubleSet ElimDirs;
 ElimDirs.Assign(s);
 return this->SRF_SetElimDirs(ElimDirs);
}
//****************************************************************************************
//СТАТУС: I.SRF_3, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SRF_SetUnit(uint UnitType)
//НАЗНАЧЕНИЕ: Установка типа пространственного режекторного фильтра. Они бывают двух типов:
//MultiStageUnit  = 1 - многоступенчатая схема реализации;
//SingleStageUnit = 2 - одноступенчатая схема реализации.
//При успешной установке (смене) фильтра функция возвращает true.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint UnitType - тип фильтра
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат смены фильтра
//****************************************************************************************
bool TPreProcessor_MISO_SF::SRF_SetUnit(uint UnitType)
{if (!this->IsReady() || !this->SRF_IsReady()) return false;
 //Отключение SRF
 if (UnitType == 0) {this->SRF_Reset(); return false;}
 //Проверка на допустимый тип фильтра
 if ((UnitType != MultiStageUnit) && (UnitType != SingleStageUnit)) return false;
 return (UnitType != this->SRF_GetUnit()) ? this->SRF_UnitUpdate(UnitType) : false;
}
//****************************************************************************************
//СТАТУС: I.SRF_4, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool SRF_Set(const TDoubleSet& ElimDirs, bool lUseBaseCh, uint UnitType)
//НАЗНАЧЕНИЕ: Установка всех характеристик пространственного режекторного фильтра. Функция
//возвращает состояние готовности фильтра к работе после установки его характеристик.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TDoubleSet& ElimDirs - контейнер с направлениями исключения;
//2. bool lUseBaseCh - опция использования ОСНОВНОГО канала блоком SRF;
//3. uint UnitType - тип фильтра
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lReady - работоспособность SRF
//****************************************************************************************
bool TPreProcessor_MISO_SF::SRF_Set(const TDoubleSet& ElimDirs, bool lUseBaseCh, uint UnitType)
{if (!this->IsReady()) return false;
 if (ElimDirs.IsEmpty() || UnitType == 0) {this->SRF_Reset(); return false;}

 this->_lUseBaseCh = lUseBaseCh;//Установка опции использования ОСНОВНОГО канала

 //Установка направлений исключения
 if (&ElimDirs != &this->_ElimDirects)
 {this->_ElimDirects.Clear();
  DblSet::const_iterator p, end;
  ElimDirs.GetIters(p,end);
  double rval;
  //Копирование значений из контейнера ElimDirs в контейнер класса _ElimDirects с фильтра-
  //цией значений в интервале [-90..+90]
  while (p != end)
  {rval = *p;
   if ((rval >= -90.0) && (rval <= 90.0)) this->_ElimDirects.Append(rval);
   ++p;
  }
 }
 if (!this->SRF_ElimDirsUpdate()) {this->SRF_Reset(); return false;}
 //Установка типа фильтра
 if (!this->SRF_UnitUpdate(UnitType)) this->SRF_Reset();

 return this->SRF_IsReady();
}
//****************************************************************************************
//СТАТУС: I.SRF_5, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SRF_Set(const string& sElimDirs, bool lUseBaseCh, uint UnitType)
//НАЗНАЧЕНИЕ: Установка всех характеристик пространственного режекторного фильтра. Функция
//возвращает состояние готовности фильтра к работе после установки его характеристик.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& sElimDirs - ссылка на строку с направлениями исключения;
//2. bool lUseBaseCh - опция использования ОСНОВНОГО канала блоком SRF;
//3. uint UnitType - тип фильтра
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lReady - работоспособность SRF
//****************************************************************************************
bool TPreProcessor_MISO_SF::SRF_Set(const string& sElimDirs, bool lUseBaseCh, uint UnitType)
{TDoubleSet ElimDirs;
 ElimDirs.Assign(sElimDirs);
 return this->SRF_Set(ElimDirs,lUseBaseCh,UnitType);
}
//****************************************************************************************
//СТАТУС: I.SRF_5, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& SRF_GetUnit(string& s) const
//НАЗНАЧЕНИЕ: Формирование в строковом объекте s, передаваемом по ссылке, типа весового
//сумматора, реализующего пространственный режекторный фильтр SRF. Возвращается ссылка на
//строку s. Информация о типе весового сумматора представляется в виде:
//<Unit: <MultiStage WSum> | <SingleStage WSum> | <Off>>.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const string& s - ссылка на строку-приемник сведений о типе SRF
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: const string& s - ссылка на строку-приемник сведений о типе SRF
//****************************************************************************************
string& TPreProcessor_MISO_SF::SRF_GetUnit(string& s) const
{uint UnitType = this->SRF_GetUnit();
 s.assign("Unit: ");
 if (UnitType == MultiStageUnit) s.append("MultiStage WSum");
 else if (UnitType == SingleStageUnit) s.append("SingleStage WSum");
 else s.append("Off");
 return s;
}
//****************************************************************************************
//СТАТУС: I.SRF_6, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& SRF_GetElimDirs(string& s) const
//НАЗНАЧЕНИЕ: Формирование в строковом объекте s, передаваемом по ссылке, направлений иск-
//лючения, реализуемые пространственным режекторным фильтром (SRF). Возвращается ссылка на
//строку s. Информация о направлениях исключения представляется в виде:
//<ElimDirs [deg]: < 0 > | <A1 A2 .. An>>, где A1, A2, An - значения направлений исключения.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const string& s - ссылка на строку-приемник с ElimDirs
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: const string& s - ссылка на строку-приемник с ElimDirs
//****************************************************************************************
string& TPreProcessor_MISO_SF::SRF_GetElimDirs(string& s) const
{ulong N = this->SRF_GetElimDirs();
 s.assign("ElimDirs [deg]: ");
 if (N == 0) s.append(1,'0');
 else //Формирование значений направлений исключения в символьном виде
 {string t;
  this->_ElimDirects.GetData(t);
  s.append(t);
 }
 return s;
}
//****************************************************************************************
//СТАТУС: I.SRF_7, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& SRF_GetWorkCh(string& s) const
//НАЗНАЧЕНИЕ: Формирование в строковом объекте s, передаваемом по ссылке, числа и номеров
//каналов LAA, используемых как рабочие каналы режекторного фильтра с учетом использования
//ОСНОВНОГО канала. Функция возвращает ссылку на строку s. Информация об WorkCh представ-
//ляется в виде: <WorkCh: [BaseCh] & [N {LAA indexes}]>,
//BaseCh - признак использования ОСНОВНОГО канала режекторным фильтром;
//N - число каналов LAA, используемых как рабочие каналы SRF;
//LAA indexes - индексы каналов LAA. Функция распознает последовательности каналов, обра-
//зующих арифметическую прогрессию, и представляет их интервалами в строковом виде.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const string& s - ссылка на строку-приемник сведений об WorkCh
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: const string& s - ссылка на строку-приемник сведений об WorkCh
//****************************************************************************************
string& TPreProcessor_MISO_SF::SRF_GetWorkCh(string& s) const
{s.assign("WorkCh: ");
 if (!this->SRF_IsReady()) s.append(1,'0');//Режекторный фильтр не используется
 else
 {ulong N = this->_WorkCh.Size();
  if (this->SRF_UseBaseCh()) s.append("BaseCh");
  if (N != 0) //Номера каналов LAA, задействованные в режекторном фильтре
  {char buffer[21];
   ostrstream text(buffer, sizeof(buffer));
   string t;

   if (this->SRF_UseBaseCh()) s.append(" & ");
   text << N << ends; s.append(text.str()); text.seekp(0);
   this->_WorkCh.DataToStr(t);
   s.append(" {"); s.append(t); s.append(1,'}');
  }
 }
 return s;
}
//****************************************************************************************
//СТАТУС: I.SRF_8, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& SRF_Info(string& s) const
//НАЗНАЧЕНИЕ: Формирование в строковом объекте s, передаваемом по ссылке, свойств пространст-
//венного режекторного фильтра - Space Reject Filter (SRF). Функция возвращает ссылку на
//строку s. Информация об SRF представляется в виде:
//<SRF: ElimDirs: N {N1 N2 ... Nn}, WorkCh: [BaseCh] & M {LAA indexes}, Unit: <MultiStage> |
// <SingleStage> WSum | <Off>;>,
//N - число направлений исключения, формируемые SRF;
//N1 N2 ... Nn - направления исключения;
//BaseCh - признак подключения ОСНОВНОГО канала к SRF;
//LAA indexes - номера каналов LAA, подключенные к SRF. Функция распознает последователь-
//ности каналов, образующих арифметическую прогрессию, и представляет их интервалами в
//строковом виде.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const string& s - ссылка на строку-приемник сведений об SRF
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: const string& s - ссылка на строку-приемник сведений об SRF
//****************************************************************************************
string& TPreProcessor_MISO_SF::SRF_Info(string& s) const
{s.assign("SRF: ");
 if (!this->SRF_IsReady()) s.append("Off;");
 else
 {string t;
  //Получаем информацию о направлениях исключения, реализуемых фильтром
  this->SRF_GetElimDirs(t);
  s.append(t); s.append(", ");
  //Получаем информацию о рабочих каналах режекторного фильтра
  this->SRF_GetWorkCh(t);
  s.append(t); s.append(", ");
  //Получаем информацию о типе весового сумматора, реализующего SRF
  this->SRF_GetUnit(t);
  s.append(t); s.append(1,';');
 }
 return s;
}
//****************************************************************************************
//СТАТУС: I.SRF_9, public, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SRF_Edit()
//НАЗНАЧЕНИЕ: Консольное редактирование свойств SRF (формирование нулей в ДН AuxCh SF в
//направлениях задаваемых пользователем). Функция возвращает признак работоспособности
//SRF после редактирования ее свойств. Пользователю доступны для редактирования:
//1. Использование или отключение SRF;
//2. Использование ОСНОВНОГО канала режекторным фильтром (SRF);
//3. Установка направлений исключения в пределах [-90..+90] градусов с контролем
//   максимально возможного числа направлений исключения;
//4. Выбор типа весового сумматора, на котором реализуется SRF.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lReady - работоспособность SRF после редактирования
//****************************************************************************************
bool TPreProcessor_MISO_SF::SRF_Edit()
{//Рабочие переменные
 int y, row_start = wherey();
 string line(79,'-');
 gotoxy(1,row_start); clreol();
 //Проверка на возможность редактирования
 if (!this->LAA_IsReady())
 {cout << line << endl;
  cout << "Editing SRF is impossible ! First of all You should configurate LAA properly!" << endl;
  cout << line << endl;
  cout << "Press any key ..."; getch();
  ClrScr(1,row_start);//Очистка экрана
  return this->SRF_IsReady();
 }
 //Рабочие переменные
 TDoubleSet ElimDirs;
 bool lUseSRF, lUseBaseCh;
 uint WSumType;
 ulong FreeLAACh = this->LAA.GetDimLAA()-this->AUX_GetLAACh();
 ulong MaxElimDirs;

 char buffer[41];
 ostrstream text(buffer, sizeof(buffer));
 char c;
 bool flag;
 string s, t, head, Msg_ElimDirs, res;

 Msg_ElimDirs.assign("Input No-Signal Directions for AuxCh [-90..+90] deg ");
 Msg_ElimDirs.append("<d1 d2 .. dk;> MaxDirs = ");

 s.assign("Edit <SRF>, PrevSRF: "); this->SRF_Info(t); s.append(t);
 MultiLineFormat(head,s,80);

 gotoxy(1,row_start); clreol();

 do //Цикл ввода свойств Space Reject Filter for AuxCh
 {//----------------------------------------------------------------------------------
  cout << line << endl << head << endl << line << endl;
  //----------------------------------------------------------------------------------
  //Запрос на использование SRF предпроцессором
  //----------------------------------------------------------------------------------
  y = wherey();
  cout << "Would you like to use Space Reject Filter for AuxCh ? [y/n]: "; cin >> c;
  lUseSRF = (c == 'Y' || c == 'y') ? true : false;
  ClrScr(1,y);//Очистка экрана
  if (!lUseSRF)
  {cout << "Preprocessor won't use SRF ! Press any key ..."; getch();
   //this->SRF_Reset();
   break;
  }
  //----------------------------------------------------------------------------------
  //1. Запрос на подключение BaseCh к SRF
  //----------------------------------------------------------------------------------
  y = wherey();
  cout << "Would you like to switch < BaseCh > to < SRF > ? [y/n]: "; cin >> c;
  lUseBaseCh = (c == 'Y' || c == 'y') ? true : false;
  ClrScr(1,y);//Очистка экрана
  if (lUseBaseCh) res.assign("BaseCh: ON;");
  else res.assign("BaseCh: OFF;");
  y = wherey();
  cout << res << endl;
  //----------------------------------------------------------------------------------
  //2. Ввод направлений исключения приема сигналов дополнительными каналами фильтра
  //----------------------------------------------------------------------------------
  //MaxElimDirs = (lUseBaseCh) ? FreeLAACh+1 : FreeLAACh;
  if (lUseBaseCh) MaxElimDirs = (BFC_UseSingleCh()) ? FreeLAACh : FreeLAACh+1;
  else MaxElimDirs = (BFC_UseSingleCh()) ? FreeLAACh-1 : FreeLAACh;

  if (MaxElimDirs == 0)
  {ElimDirs.Clear();
   lUseSRF = false;
   t.assign("There aren't free LAA Channels to use theirs as <WorkCh> of SRF! ");
   t.append("All LAA Channels are used as <AuxCh>.\n");
   t.append("TIP: Use <BaseCh> to set up at least ONE no signal direct in ");
   t.append("receive direction of <AuxCh>.");
   MultiLineFormat(s,t,80);
   cout << s << endl;
   cout << "Press any key ..."; getch();
   ClrScr(1,y);//Очистка экрана
  }
  else
  {cout << Msg_ElimDirs << MaxElimDirs << endl;
   cout << "> "; cin.ignore(); getline(cin,s,';');
   ClrScr(1,y);//Очистка экрана
   ElimDirs.Assign(s);
   //Фильтрация направлений исключения [-90..90]
   ElimDirs.RemoveOutSide(-90.0,90.0);
   if (ElimDirs.IsEmpty() || (ElimDirs.Size() > MaxElimDirs))
   {//Автоматический выбор направлений исключения
    double ScanAngle = this->BFC_ScanAngle();
    if (MaxElimDirs == 1) ElimDirs.Assign(ScanAngle);
    else if (MaxElimDirs == 2)
    {ElimDirs.Assign(ScanAngle-0.1);
     ElimDirs.Append(ScanAngle+0.1);
    }
    else
    {ElimDirs.Assign(ScanAngle-0.1);
     ElimDirs.Append(ScanAngle);
     ElimDirs.Append(ScanAngle+0.1);
    }
   }
  }
  res.append(" ElimDirs: "); ElimDirs.AboutData(t); res.append(t); 
  MultiLineFormat(s,res,80);
  y = wherey();
  cout << s << endl;

  //----------------------------------------------------------------------------------
  //3. Выбор типа весового сумматора, на котором будет реализован SRF
  //----------------------------------------------------------------------------------
  if (!lUseSRF) WSumType = 0;
  else
  {STR_UINT ListSRFUnit[2] = {
   {MultiStageUnit,  "MultiStage WSum"  },
   {SingleStageUnit,  "SingleStage WSum" } };
   TB_STR_UINT TbSRFUnit = {2,ListSRFUnit};
   string HeadType =  " Choice WSum Type:";
   WSumType = ConsoleChoice(TbSRFUnit,SingleStageUnit,HeadType.c_str(),2);
   //WSumType = SingleStageUnit;//MultiStageUnit
  }
  res.append(" WSumType: ");
  if (WSumType == SingleStageUnit) res.append("SingleStage;");
  else if (WSumType == MultiStageUnit) res.append("MultiStage;");
  else res.append("OFF;");
  MultiLineFormat(s,res,80);
  ClrScr(1,y);//Очистка экрана
  cout << s << endl;
  //-----------------------------------------------------------------------------------
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
 //Установка свойств SRF
 if (lUseSRF) this->SRF_Set(ElimDirs,lUseBaseCh,WSumType);
 else this->SRF_Reset();
 return this->SRF_IsReady();
}

//========================================================================================
//            РЕАЛИЗАЦИЯ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССА TPreProcessor_MISO_SF
//========================================================================================
//****************************************************************************************
//СТАТУС: 1;  TPreProcessor_MISO_SF class friend overloading operator <<
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend ostream& operator <<(ostream& out, const TPreProcessor_MISO_SF& Obj)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВЫВОДА класса TPreProcessor_MISO_SF.
//Функция предназначена для вывода в поток характеристик предпроцессора пространственного
//фильтра с выделенным каналом. Функция возвращает ссылку на поток, что позволяет записывать
//в программе операторы вывода в поток каскадно. Формат вывода:
//----------------------------------------------------------------------------------------
//MISO SF Preprocessor: <ON> || <OFF>
// 1. LAA: N: <_N>, Origin: <_Zero>, d: <_d>, Pn: <_Pn>, Antenna: <ODA>;
// 2. BFC: <N> {LAA indexes}, ScanAngle = <Angle>;
// 3. AuxCh: <N> {LAA indexes};
// 4. SRF: <Off> || ElimDirs: <N> {N1 N2 ... Nn}, WorkCh: [BaseCh] & <M> {LAA indexes},
//    Unit: <SRF Unit Type>;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на объект потока вывода
//2. сonst TPreProcessor_MISO_SF& Obj - ссылка на объект, выводимый в поток.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ostream& out - ссылка на объект потока вывода.
//***********************-****************************************************************
ostream& operator <<(ostream& out, const TPreProcessor_MISO_SF& Obj)
{string s;
 Obj.Info(s,79);//Получение свойств объекта (в краткой форме)
 out << s;//Вывод характеристик объекта
 return out;
}
//****************************************************************************************
//СТАТУС: 2;  TPreProcessor_MISO_SF class friend function
//INPUT TPreProcessor_MISO_SF PROPERTIES by cin
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend void Edit(TPreProcessor_MISO_SF& Obj)
//НАЗНАЧЕНИЕ: Редактирование свойств объекта класса TPreProcessor_MISO_SF через стандартный
//поток ввода cin. Функция редактирует свойства Obj, передаваемого по ссылке.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TPreProcessor_MISO_SF& Obj - ссылка на редактируемый объект
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void Edit(TPreProcessor_MISO_SF& Obj)
{STR_UINT Option[5] = {
  {1, "Edit < Linear Antenna Array >" },
  {2, "Edit < BeamFormer Circuit >" },
  {3, "Edit < Auxiliary Channels >" },
  {4, "Edit < Space Reject Filter >" },
  {5, "Exit" } };
 TB_STR_UINT Menu = {5, Option};
 string head = " Choice menu option [1-5]: ";
 //Рабочие переменные
 int y_start = wherey();
 string line(78,'-');
 const string msg = "Press any key...";
 const string s = "MISO Space Filter Preprocessor: < Edit >";
 string t;
 bool flag = true;

 gotoxy(1,y_start); clreol();
 //clrscr();
 do
 {cout << line << endl << s << endl;
  cout << line << endl << Obj;
  cout << line << endl;
  uint choice = ConsoleChoice(Menu,1,head.c_str(),2);
  switch (choice)
  {case 1: //Редактирование LAA
    if (Edit(Obj.LAA)) Obj.BFC_Update();
    break;
   case 2: //Редактирование BFC
    Obj.BFC_Edit();
    break;
   case 3: //Редактирование AuxCh
    Obj.AUX_Edit();
    break;
   case 4: //Редактирование SRF
    Obj.SRF_Edit();
    break;
   case 5: //Выход из режима редактирования
    flag = false; break;
  }
  ClrScr(1,y_start);//Очистка экрана
  //clrscr();
 } while (flag);
}

//========================================================================================
//II. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TPreProcessor_MISO_SF
//    PROTECTED MEMBER-FUNCTION OF TPreProcessor_MISO_SF CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: II.BFC_1, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void BFC_Init()
//НАЗНАЧЕНИЕ: Начальная установка свойств ОСНОВНОГО канала при конструировании объекта:
//----------------------------------------------------------------------------------------
//I. СХЕМА ФОРМИРОВАНИЯ ОСНОВНОГО (ВЫДЕЛЕННОГО) КАНАЛА - BaseChannel
// 1. TLongSet _BaseCh: _BaseCh.Size = 0, _BaseCh.Name = "BaseCh";
// 2. double _ScanAngle = 0 [deg];
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessor_MISO_SF::BFC_Init() {_BaseCh.SetName("BaseCh"); this->BFC_Reset();}
//****************************************************************************************
//СТАТУС: II.BFC_2, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void BFC_Reset()
//НАЗНАЧЕНИЕ: Начальная установка свойств ОСНОВНОГО канала:
//----------------------------------------------------------------------------------------
//I. СХЕМА ФОРМИРОВАНИЯ ОСНОВНОГО (ВЫДЕЛЕННОГО) КАНАЛА - BaseChannel
// 1. TLongSet _BaseCh: _BaseCh.Size = 0;
// 2. double _ScanAngle = 0 [deg];
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessor_MISO_SF::BFC_Reset() {_BaseCh.Clear(); _ScanAngle = 0;}
//****************************************************************************************
//СТАТУС: II.BFC_3, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool BFC_UseSingleCh(long& index) const
//НАЗНАЧЕНИЕ: Проверка на подключение к BFC одного канала LAA с присвоением его номера
//переменной index, передаваемой по ссылке. Функция возвращает true при подключении ОДНОГО
//канала LAA к BFC. В противном случае, функция возвращает false и присваивает -1 перемен-
//ной index.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: long& index - ссылка на переменную, которой присваивается номер
//канала LAA, подключенного к BaseChannel.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак подключения ОДНОГО канала LAA к BFC
//****************************************************************************************
bool TPreProcessor_MISO_SF::BFC_UseSingleCh(long& index) const
{if (!this->BFC_UseSingleCh()) {index = -1; return false;}
 _BaseCh.GetFirst(index);
 return true;
}
//****************************************************************************************
//СТАТУС: II.BFC_4, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void BFC_Update()
//НАЗНАЧЕНИЕ: Обновление свойств схемы формирования ОСНОВНОГО канала предпроцессора при
//изменении параметров LAA.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessor_MISO_SF::BFC_Update()
{if (!this->LAA_IsReady()) {this->BFC_Reset(); this->AUX_Update(); return;}
 long ival;
 //Подключены все каналы LAA к BFC
 if (this->BFC_UseAllCh()) {this->AUX_Update(); return;}
 //Подключен ОДИН канал LAA к BFC
 else if (this->BFC_UseSingleCh(ival))
 {//Изменение некорректного номера канала LAA, подключенного к BFC
  if ((ulong) ival > LAA.GetDimLAA()-1) this->BFC_SetChannels(1);
  else this->AUX_Update();
 }
 else //Подключены несколько каналов LAA к BFC, но не ВСЕ
 {ulong N = _BaseCh.Size();//Число каналов подключенных к BFC до изменения свойств LAA
  //Исключение каналов LAA, подключенных к BFC, с номерами вне интервала [0..DimLAA-1]
  _BaseCh.RemoveOutSide(0,LAA.GetDimLAA()-1);
  if (N != _BaseCh.Size()) this->BFC_SetChannels(N);//Подключаем все каналы LAA
  else this->AUX_Update();
 }
}
//****************************************************************************************
//СТАТУС: II.BFC_5, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex BFC_CalcUs(double Power, double Angle) const
//НАЗНАЧЕНИЕ: Расчет комплексного напряжения на выходе BFC при действии источника сигнала
//мощностью Power с направления Angle (в градусах). Функция возвращает рассчитанное значе-
//ние на выходе BFC.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double Power - мощность источника сигнала;
//2. double Angle - угловое положение источника сигнала в градусах.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex Us - напряжение на выходе BFC.
//****************************************************************************************
complex TPreProcessor_MISO_SF::BFC_CalcUs(double Power, double Angle) const
{complex Us = C_ZERO;
 if (!this->IsReady()) return Us;
 long index;
 long Origin = this->LAA.GetOrigin();//Отсчетный канал LAA
 double d = this->LAA.GetRelDist();//Относительное расстояние между соседними каналами LAA
 double Ampl = sqrt(Power);
 double ScanAngle = this->BFC_ScanAngle();
 double c1 = TwoPI*d*sin(Angle*DegRad);
 double c2 = TwoPI*d*sin(ScanAngle*DegRad);
 double Phase;

 //Один канал LAA подключен к BFC
 if (this->BFC_UseSingleCh(index)) Us = polar(Ampl,c1*(index-Origin));
 //Все каналы LAA подключены к BFC
 else if (this->BFC_UseAllCh())
 {index = this->LAA.GetDimLAA();
  for (long i = 0; i < index; i++)
  {//Расчет фазы источника сигнала с учетом фазосдвигающего коэффициента для i-го канала
   //Phase = (c1-c2)*(i-Origin) == c1*(i-Origin)-c2*(i-Origin)
   Phase = (Angle != this->BFC_ScanAngle()) ? (c1-c2)*(i-Origin) : 0;
   Us += polar(Ampl,Phase);
  }
 }
 //К BFC подключена часть каналов LAA
 else
 {LongSet::const_iterator p, end;
  this->_BaseCh.GetIters(p,end);
  while (p != end)
  {index = *p;
   //Расчет фазы источника сигнала с учетом фазосдвигающего коэффициента для канала c но-
   //мером index: Phase = (c1-c2)*(i-Origin) == c1*(i-Origin)-c2*(i-Origin)
   Phase = (Angle != this->BFC_ScanAngle()) ? (c1-c2)*(index-Origin) : 0;
   Us += polar(Ampl,Phase);
   ++p;
  }
 }
 return Us;
}
//****************************************************************************************
//СТАТУС: II.BFC_6, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// complex BFC_CalcUs(double P, double Phi, const TRandSignal& RandSignal) const
//НАЗНАЧЕНИЕ: Расчет комплексного напряжения на выходе BFC при действии источника сигнала
//мощностью P с направления Phi (в градусах) со случайными амплитудой и фазой, передаваемые
//через ссылку на объект RandSignal. Функция возвращает рассчитанное значение на выходе BFC.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double P - мощность источника сигнала;
//2. double Phi - угловое положение источника сигнала в градусах;
//3. const TRandSignal& RandSignal - ссылка на случайные составляющие источника сигнала.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex Us - напряжение на выходе BFC.
//****************************************************************************************
complex TPreProcessor_MISO_SF::BFC_CalcUs(double P, double Phi,
        const TRandSignal& RandSignal) const
{complex Us = C_ZERO;
 if (!this->IsReady()) return Us;
 long index;
 long Origin = this->LAA.GetOrigin();//Отсчетный канал LAA
 double d = this->LAA.GetRelDist();//Относительное расстояние между соседними каналами LAA
 double Ampl = sqrt(P)*RandSignal.Amplitude();
 double ScanAngle = this->BFC_ScanAngle();
 double c1 = TwoPI*d*sin(Phi*DegRad);
 double c2 = TwoPI*d*sin(ScanAngle*DegRad);
 double Phase;
 double RandPhase = RandSignal.Phase(RAD);

 //Один канал LAA подключен к BFC
 if (this->BFC_UseSingleCh(index)) Us = polar(Ampl,c1*(index-Origin)+RandPhase);
 //Все каналы LAA подключены к BFC
 else if (this->BFC_UseAllCh())
 {index = this->LAA.GetDimLAA();
  for (long i = 0; i < index; i++)
  {//Расчет фазы источника сигнала с учетом фазосдвигающего коэффициента для i-го канала
   //Phase = (c1-c2)*(i-Origin) == c1*(i-Origin)-c2*(i-Origin) + RandPhase
   Phase = (Phi != this->BFC_ScanAngle()) ? (c1-c2)*(i-Origin) : 0;
   Us += polar(Ampl,Phase+RandPhase);
  }
 }
 //К BFC подключена часть каналов LAA
 else
 {LongSet::const_iterator p, end;
  this->_BaseCh.GetIters(p,end);
  while (p != end)
  {index = *p;
   //Расчет фазы источника сигнала с учетом фазосдвигающего коэффициента для канала c но-
   //мером index: Phase = (c1-c2)*(i-Origin) == c1*(i-Origin)-c2*(i-Origin) + RandPhase
   Phase = (Phi != this->BFC_ScanAngle()) ? (c1-c2)*(index-Origin) : 0;
   Us += polar(Ampl,Phase+RandPhase);
   ++p;
  }
 }
 return Us;
}
//****************************************************************************************
//СТАТУС: II.BFC_7, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex BFC_CalcUnoise(const RandSignalVect& RandNoise) const
//НАЗНАЧЕНИЕ: Расчет комплексного напряжения внутреннего шума на выходе BFC со случайными
//составляющими амплитуды и фазы в приемных каналах предпроцессора, подключенных к BFC.
//Функция возвращает рассчитанное значение на выходе BFC. В контейнере RandNoise, переда-
//ваемый по ссылке, содержатся случайные составляющие амплитуды и фазы внутреннего шума
//всех приемных каналов предпроцессора.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const RandSignalVect& RandNoise - случайные составляющие внутреннего шума всех приемных
//каналов предпроцессора
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex Us - напряжение на выходе BFC.
//****************************************************************************************
complex TPreProcessor_MISO_SF::BFC_CalcUnoise(const RandSignalVect& RandNoise) const
{complex Un = C_ZERO;
 if (!this->IsReady()) return Un;
 if (RandNoise.size() != this->LAA.GetDimLAA()) return Un;

 long index;
 long Origin = this->LAA.GetOrigin();//Отсчетный канал LAA
 double d = this->LAA.GetRelDist();//Относительное расстояние между соседними каналами LAA
 double Ampl = sqrt(this->LAA.GetPn());
 double ScanAngle = this->BFC_ScanAngle();
 double c = TwoPI*d*sin(ScanAngle*DegRad);
 double Phase;
 double RandAmpl;

 //Один канал LAA подключен к BFC
 if (this->BFC_UseSingleCh(index))
  Un = polar(Ampl*RandNoise[index].Amplitude(),RandNoise[index].Phase(RAD));
 //Все каналы LAA подключены к BFC
 else if (this->BFC_UseAllCh())
 {index = this->LAA.GetDimLAA();
  for (long i = 0; i < index; i++)
  {//Расчет фазы источника сигнала с учетом фазосдвигающего коэффициента для i-го канала
   //Phase = -c*(i-Origin) + RandPhase
   Phase = c*(Origin-i);
   RandAmpl = Ampl*RandNoise[i].Amplitude();
   Un += polar(RandAmpl,Phase+RandNoise[i].Phase(RAD));
  }
 }
 //К BFC подключена часть каналов LAA
 else
 {LongSet::const_iterator p, end;
  this->_BaseCh.GetIters(p,end);
  while (p != end)
  {index = *p;
   //Расчет фазы источника сигнала с учетом фазосдвигающего коэффициента для канала c но-
   //мером index: Phase = -c*(i-Origin) == c*(Origin-i) + RandPhase
   Phase = c*(Origin-index);
   RandAmpl = Ampl*RandNoise[index].Amplitude();
   Un += polar(RandAmpl,Phase+RandNoise[index].Phase(RAD));
   ++p;
  }
 }
 return Un;
}


//****************************************************************************************
//СТАТУС: II.AUX_1, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void AUX_Init()
//НАЗНАЧЕНИЕ: Начальная установка дополнительных канала фильтра при конструировании объекта:
//----------------------------------------------------------------------------------------
//II. ДОПОЛНИТЕЛЬНЫЕ КАНАЛЫ ПРОСТРАНСТВЕННОГО ФИЛЬТРА - AuxChannel
// 1. TLongSet _AuxCh: _AuxCh.Size = 0, _AuxCh.Name = "AuxCh";
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessor_MISO_SF::AUX_Init() {_AuxCh.SetName("AuxCh"); this->AUX_Reset();}
//****************************************************************************************
//СТАТУС: II.AUX_2, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void AUX_Reset()
//НАЗНАЧЕНИЕ: Начальная установка дополнительных каналов фильтра:
//----------------------------------------------------------------------------------------
//II. ДОПОЛНИТЕЛЬНЫЕ КАНАЛЫ ПРОСТРАНСТВЕННОГО ФИЛЬТРА - AuxChannel
// 1. TLongSet _AuxCh: _AuxCh.Size = 0;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessor_MISO_SF::AUX_Reset() {_AuxCh.Clear();}
//****************************************************************************************
//СТАТУС: II.AUX_3, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong AUX_GetMaxLAACh() const
//НАЗНАЧЕНИЕ: Максимально число каналов LAA, которые можно использовать как AuxChannel.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong ival - максимальное число каналов LAA, которые можно исполь-
//зовать как ВСПОМОГАТЕЛЬНЫЕ каналы SF
//****************************************************************************************
ulong TPreProcessor_MISO_SF::AUX_GetMaxLAACh() const
{if (!this->LAA_IsReady()) return 0;
 return (this->BFC_UseSingleCh()) ? LAA.GetDimLAA()-1 : LAA.GetDimLAA();
}
//****************************************************************************************
//СТАТУС: II.AUX_4, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void AUX_Update()
//НАЗНАЧЕНИЕ: Обновление вспомогательных каналов пространственного фильтра при изменении
//параметров LAA или BaseCh.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessor_MISO_SF::AUX_Update()
{if (!this->LAA_IsReady()) {this->AUX_Reset(); this->SRF_Update(); return;}
 ulong szPrevAuxCh = _AuxCh.Size();//Число вспомогательных каналов до обновления
 //Все каналы LAA использовались как ВСПОМОГАТЕЛЬНЫЕ
 if (szPrevAuxCh == 0) this->AUX_SetChannels(szPrevAuxCh);//Use maximum LAA channels as AUX_Ch
 else
 {//Исключение вспомогательных каналов с номерами вне интервала [0..DimLAA-1]
  _AuxCh.RemoveOutSide(0,LAA.GetDimLAA()-1);
  long ival;
  if (this->BFC_UseSingleCh(ival)) _AuxCh.Remove(ival);
  if (_AuxCh.IsEmpty()) this->AUX_SetChannels(szPrevAuxCh);
  this->SRF_Update();//Обновление свойств режекторного пространственного фильтра (SRF)
 }
}


//****************************************************************************************
//СТАТУС: II.SRF_1, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: SRF_Init()
//НАЗНАЧЕНИЕ: Начальная установка свойств SRF при конструировании объекта:
//----------------------------------------------------------------------------------------
//III. ПРОСТРАНСТВЕННЫЙ РЕЖЕКТОРНЫЙ ФИЛЬТР для ДОПОЛНИТЕЛЬНЫХ КАНАЛОВ - SRF
// 1. TDoubleSet _ElimDirects: _ElimDirects.Size = 0,  _ElimDirects.Name = "ElimDirects";
// 2. TLongSet _WorkCh: _WorkCh.Size = 0, _WorkCh.Name = "WorkCh";
// 3. bool _lUseBaseCh = OFF;
// 4. TAuxChSpaceRejectFilter* SRF = NULL;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessor_MISO_SF::SRF_Init()
{_ElimDirects.SetName("ElimDirects");
 _WorkCh.SetName("WorkCh");
 _SRF = NULL;
 this->SRF_Reset();
}
//****************************************************************************************
//СТАТУС: II.SRF_2, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: SRF_Reset()
//НАЗНАЧЕНИЕ: Начальная установка свойств SRF:
//----------------------------------------------------------------------------------------
//III. ПРОСТРАНСТВЕННЫЙ РЕЖЕКТОРНЫЙ ФИЛЬТР для ДОПОЛНИТЕЛЬНЫХ КАНАЛОВ - SRF
// 1. TDoubleSet _ElimDirects: _ElimDirects.Size = 0;
// 2. TLongSet _WorkCh: _WorkCh.Size = 0;
// 3. bool _lUseBaseCh = OFF;
// 4. TAuxChSpaceRejectFilter* SRF = NULL;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessor_MISO_SF::SRF_Reset()
{_ElimDirects.Clear();
 _WorkCh.Clear();
 _lUseBaseCh = OFF;
 if (_SRF != NULL) delete _SRF;
 _SRF = NULL;
}
//****************************************************************************************
//СТАТУС: II.SRF_3, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SRF_IsReady() const
//НАЗНАЧЕНИЕ: Проверка работоспособности пространсвенного режекторного фильтра для исключе-
//ния заданных направлений приема в дополнительных канал фильтра - SRF. SRF считается нера-
//ботоспособной при выполнении одного из условий:
//1) _ElimDirects.Size == 0; 2) _SRF == NULL, в противном случае, функция возвращает true.
//Предпроцессор может работать без использования SRF, поэтому работоспособность SRF не
//влияет на работоспособность предпроцессора.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lReady - признак работоспособности SRF.
//****************************************************************************************
bool TPreProcessor_MISO_SF::SRF_IsReady() const
{return (_ElimDirects.IsEmpty() || _SRF == NULL) ? false : true;}
//****************************************************************************************
//СТАТУС: II.SRF_4, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong SRF_GetMaxWorkCh() const
//НАЗНАЧЕНИЕ: Функция возвращает число каналов LAA, которые можно использовать как РАБОЧИЕ
//каналы, без учета номера ОСНОВНОГО канала (при подключении одного канала LAA к BaseChannel)
//Функция возвращает 0 в случае неработоспособности предпроцессора.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong szMaxWorkCh - число каналов LAA, которые можно использовать
//как РАБОЧИЕ каналы
//****************************************************************************************
ulong TPreProcessor_MISO_SF::SRF_GetMaxWorkCh() const
{if (!this->IsReady()) return 0;
 ulong szMaxWorkCh = this->LAA.GetDimLAA() - this->AUX_GetLAACh();
 if (this->BFC_UseSingleCh()) szMaxWorkCh--;
 return szMaxWorkCh;
}
//****************************************************************************************
//СТАТУС: II.SRF_5, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong SRF_GetMaxElimDirs() const
//НАЗНАЧЕНИЕ: Максимальное количество направлений исключения с учетом использования BaseCh,
//которые может реализовать SRF при данной конфигурации и настройках предпроцессора. Для
//неработоспособного предпроцессора функция возвращает 0.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong szMaxElimDirs - максимальное кол-во направлений исключения,
//которые можно реализовать
//****************************************************************************************
ulong TPreProcessor_MISO_SF::SRF_GetMaxElimDirs() const
{if (!this->IsReady()) return 0;
 ulong szMaxElimDirs = this->SRF_GetMaxWorkCh();
 if (this->SRF_UseBaseCh()) szMaxElimDirs++;
 return szMaxElimDirs;
}
//****************************************************************************************
//СТАТУС: II.SRF_6, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: uint SRF_GetUnit() const
//НАЗНАЧЕНИЕ: Функция возвращает тип режекторного фильтра. Если _SRF == NULL возвращается 0.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint UnitType - тип режекторного фильтра
//****************************************************************************************
uint TPreProcessor_MISO_SF::SRF_GetUnit() const
{return (this->_SRF != NULL) ? this->_SRF->Type() : 0;}
//****************************************************************************************
//СТАТУС: II.SRF_7, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SRF_ElimDirsUpdate()
//НАЗНАЧЕНИЕ: Обновление параметров SRF, связанных с изменением (установкой) направлений
//исключения. Функция проверяет возможность установки числа заданных направлений исключения
//текущей конфигурацией предпроцессора. При невозможности установки хотя бы одного направ-
//ления режекции функция возвращает false. При большем числе заданных направлений максимально
//возможному количеству остается одно направление равное углу сканирования BFC. В случае
//наличия возможности установки хотя бы ОДНОГО направления режекции осуществляется автома-
//тическое назначение номеров каналов LAA и BaseCh (при условии его использования SRF) в
//соответствии с текущей конфигурацией предпроцессора. Обязательным условием при назначении
//рабочих каналов SRF является несовпадение их индексов с индексами ВСПОМОГАТЕЛЬНЫХ каналов
//адаптивного SF, формируемого предпроцессором.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат обновления свойств SRF при изменении или
//установке направлений исключения
//****************************************************************************************
bool TPreProcessor_MISO_SF::SRF_ElimDirsUpdate()
{ulong MaxElimDirs = this->SRF_GetMaxElimDirs();//Максимальное число направлений режекции
 if (this->_ElimDirects.IsEmpty() || MaxElimDirs == 0) return false;

 //Количество заданных направлений исключения больше максимально возможного числа
 if (this->SRF_GetElimDirs() > MaxElimDirs)
 {double ScanAngle = this->BFC_ScanAngle();
  if (MaxElimDirs == 1) this->_ElimDirects.Assign(ScanAngle);
  else if (MaxElimDirs == 2)
  {this->_ElimDirects.Assign(ScanAngle-0.1);
   this->_ElimDirects.Append(ScanAngle+0.1);
  }
  else
  {this->_ElimDirects.Assign(ScanAngle-0.1);
   this->_ElimDirects.Append(ScanAngle);
   this->_ElimDirects.Append(ScanAngle+0.1);
  }
 }
 //Автоматическое назначение рабочих каналов фильтра в соответствии с числом направлений
 //режекции и использованием ОСНОВНОГО канала SRF
 this->_WorkCh.Clear();
 ulong szWorkCh = this->SRF_GetElimDirs();
 if (this->SRF_UseBaseCh()) szWorkCh--;
 if (szWorkCh == 0) return true;//Используем только ОСНОВНОЙ канал для ОДНОГО направления
 //Назначение рабочих каналов SRF, которые не принадлежат _AuxCh и _BaseCh
 for (ulong i = 0; i < this->LAA.GetDimLAA(); i++)
 {if (!this->_AuxCh.Find(i) && !this->_BaseCh.Find(i)) _WorkCh.Append(i);
  if (_WorkCh.Size() == szWorkCh) return true;
 }

 //Доназначение рабочих каналов SRF из числа каналов, подключенных к BaseChannel
 if (this->BFC_UseSingleCh() && !this->SRF_UseBaseCh()) return false;//
 for (ulong i = 0; i < this->LAA.GetDimLAA(); i++)
 {if (!this->_AuxCh.Find(i) && !this->_WorkCh.Find(i)) _WorkCh.Append(i);
  if (_WorkCh.Size() == szWorkCh) break;
 }
 if (_WorkCh.Size() != szWorkCh) return false;

 return true;
}
//****************************************************************************************
//СТАТУС: II.SRF_8, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SRF_UnitUpdate(uint UnitType)
//НАЗНАЧЕНИЕ: Установка или обновление свойств типа устройства компенсации приема сигналов
//с заданных направлений в дополнительных каналах адаптивного пространственного фильтра с
//BaseCh. Функция устанавливает два типа режекторных пространственных фильтра:
//MultiStageUnit или SingleStageUnit. При неверном задании типа фильтра устанавливается
//SingleStageUnit. Функция возвращает true в случае работоспособности SRF и false - в про-
//тивоположном случае. Необходимым условием работы функции является наличие направлений
//исключения в контейнере _ElimDirects.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint UnitType -  тип пространственного режекторного фильтра для
//дополнительных каналов АДАПТИВНОГО ПРОСТРАНСТВЕННОГО ФИЛЬТРА с BaseChannel.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат установки нового или обновления внутрен-
//них параметров установленного режекторного фильтра
//****************************************************************************************
bool TPreProcessor_MISO_SF::SRF_UnitUpdate(uint UnitType)
{if (this->_ElimDirects.IsEmpty()) return false;
 //Определяем количество рабочих каналов с учетом использования ОСНОВНОГО канала в SRF
 ulong szWorkCh = this->_WorkCh.Size();
 if (this->SRF_UseBaseCh()) szWorkCh++;
 //Сравниваем общее число рабочих каналов SRF с количеством направлений исключения
 if (szWorkCh != this->_ElimDirects.Size()) return false;

 //Строим обучающую матрицу L для настройки коэффициентов режекторного фильтра в соответствии
 //с назначенными направлениями режекции в дополнительных каналах AuxCh
 //Число строк матрицы L определяется числом входов предпроцессора без 1 (BaseCh);
 //Число столбцов матрицы L определяется количеством направлений исключения
 cmatrix L;
 L.Set(this->In()-1,this->SRF_GetElimDirs(),C_ZERO);
 if (L.IsZeroSize()) return false;
 //Тестовый вектор для расчета комплексных амплитуд входного сигнала, созданого источником
 //излучения единичной мощности, расположенном в одном из направлений исключения
 cvector Us;
 double Angle;
 DblSet::const_iterator p, end;
 ulong col = 0;

 this->_ElimDirects.GetIters(p,end);
 while (p != end)
 {Angle = *p;//Получаем очередное направление исключения
  this->CalcInSignal(Us,1.0,Angle,OFF);//Формируем тестовый сигнала для направления Angle
  if (Us.IsZeroSize() || Us.Size() != L.Rows()) break;
  //Копируем вектор Us в столбец матрицы L с номером col
  for (ulong i = 0L; i < L.Rows(); i++) L.Put(i,col,Us.Get(i));
  ++p;
  ++col;
 }
 if (col != L.Cols()) return false;

 //Установка нового или обновление параметров ранее установленного режекторного фильтра
 if (this->_SRF != NULL) {delete this->_SRF; this->_SRF = NULL;}
 switch (UnitType)
 {case MultiStageUnit: //Выбор многоступенчатого режекторного фильтра
   _SRF = new TMultiStageAuxChSRF(L);//Конструирование фильтра
   break;
  case SingleStageUnit: //Выбор одноступенчатого режекторного фильтра
   _SRF = new TSingleStageAuxChSRF(L);//Конструирование фильтра
   break;
  default: //По умолчанию создается одноступенчатый режекторный фильтр
   _SRF = new TSingleStageAuxChSRF(L);//Конструирование фильтра
 }
 return _SRF->IsReady();
}
//****************************************************************************************
//СТАТУС: II.SRF_9, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SRF_Update()
//НАЗНАЧЕНИЕ: Обновление свойств SRF при изменении свойств LAA, BaseChannel или AuxCh.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessor_MISO_SF::SRF_Update()
{if (!this->LAA_IsReady()) {this->SRF_Reset(); return;}
 //Обновление установленных направлений исключения и рабочих каналов SRF при изменении
 //конфигурации (свойств) предпроцессора
 if (!this->SRF_ElimDirsUpdate()) {this->SRF_Reset(); return;}
 //Обновление внутренних свойств режекторного фильтра
 if (!this->SRF_UnitUpdate(this->SRF_GetUnit())) this->SRF_Reset();
}

//****************************************************************************************
//СТАТУС: II.1, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: Init()
//НАЗНАЧЕНИЕ: Начальная установка свойств предпроцессора при конструировании объекта:
//----------------------------------------------------------------------------------------
//I. СХЕМА ФОРМИРОВАНИЯ ОСНОВНОГО (ВЫДЕЛЕННОГО) КАНАЛА - BaseChannel
// 1. TLongSet _BaseCh: _BaseCh.Size = 0, _BaseCh.Name = "BaseCh";
// 2. double _ScanAngle = 0 [deg];
//II. ДОПОЛНИТЕЛЬНЫЕ КАНАЛЫ ПРОСТРАНСТВЕННОГО ФИЛЬТРА - AuxChannel
// 1. TLongSet _AuxCh: _AuxCh.Size = 0, _AuxCh.Name = "AuxCh";
//III. ПРОСТРАНСТВЕННЫЙ РЕЖЕКТОРНЫЙ ФИЛЬТР для ДОПОЛНИТЕЛЬНЫХ КАНАЛОВ - SRF
// 1. TDoubleSet _ElimDirects: _ElimDirects.Size = 0,  _ElimDirects.Name = "ElimDirects";
// 2. TLongSet _WorkCh: _WorkCh.Size = 0, _WorkCh.Name = "WorkCh";
// 3. bool _lUseBaseCh = OFF;
// 4. TAuxChSpaceRejectFilter* SRF = NULL;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessor_MISO_SF::Init()
{this->BFC_Init();
 this->AUX_Init();
 this->SRF_Init();
}
//****************************************************************************************
//СТАТУС: II.2, protected, TPreProcessor_MISO_SF class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: Reset()
//НАЗНАЧЕНИЕ: Начальная установка свойств предпроцессора:
//----------------------------------------------------------------------------------------
//I. СХЕМА ФОРМИРОВАНИЯ ОСНОВНОГО (ВЫДЕЛЕННОГО) КАНАЛА - BaseChannel
// 1. TLongSet _BaseCh: _BaseCh.Size = 0;
// 2. double _ScanAngle = 0 [deg];
//II. ДОПОЛНИТЕЛЬНЫЕ КАНАЛЫ ПРОСТРАНСТВЕННОГО ФИЛЬТРА - AuxChannel
// 1. TLongSet _AuxCh: _AuxCh.Size = 0;
//III. ПРОСТРАНСТВЕННЫЙ РЕЖЕКТОРНЫЙ ФИЛЬТР для ДОПОЛНИТЕЛЬНЫХ КАНАЛОВ - SRF
// 1. TDoubleSet _ElimDirects: _ElimDirects.Size = 0;
// 2. TLongSet _WorkCh: _WorkCh.Size = 0;
// 3. bool _lUseBaseCh = OFF;
// 4. TAuxChSpaceRejectFilter* SRF = NULL;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessor_MISO_SF::Reset()
{this->BFC_Reset();
 this->AUX_Reset();
 this->SRF_Reset();
}

//****************************************************************************************
//                РЕАЛИЗАЦИЯ КЛАССА TSingleStageAuxChSRF
// МОДЕЛЬ ОДНОСТУПЕНЧАТОГО ПРОСТРАНСТВЕННОГО РЕЖЕКТОРНОГО ФИЛЬТРА ДОПОЛНИТЕЛЬНЫХ КАНАЛОВ
//                 АДАПТИВНОГО ПРОСТРАНСТВЕННОГО ФИЛЬТРА с ОСНОВНЫМ КАНАЛОМ
//****************************************************************************************
//========================================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TSingleStageAuxChSRF
//   PUBLIC MEMBER-FUNCTION OF TSingleStageAuxChSRF CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1,public,class member-function TSingleStageAuxChSRF
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Tuning(const cmatrix& A);
//НАЗНАЧЕНИЕ: РАСЧЕТ КОЭФФИЦИЕНТОВ ПРОСТРАНСТВЕННОГО РЕЖЕКТОРНОГО ФИЛЬТРА ДЛЯ ЗАДАННЫХ
//НАПРАВЛЕНИЙ ВСПОМОГАТЕЛЬНЫМИ КАНАЛАМИ АДАПТИВНОГО ПРОСТРАНСТВЕННОГО ФИЛЬТРА С ОСНОВНЫМ
//КАНАЛОМ.
//Коэффициенты Space Reject Filter обеспечивают нулевые уровни приема сигналов с
//направлений исключения в AuxCh. Таким образом, обеспечивается  передача сигна-
//лов с направлений исключения только через ОСНОВНОЙ КАНАЛ без его компенсации
//на весовом сумматоре адаптивного фильтра. Методика вычисления коэффициентов
//одноступенчатых режекторных пространственных фильтров следующая:
//1. Формируются сигналы ЕДИНИЧНОЙ МОЩНОСТИ, приходящие с K НАПРАВЛЕНИЙ ИСКЛЮЧЕ-
// НИЯ, и рассчитываются комплексные значения напряжений на каналах LAA,
// подключенных к SingleStageAuxChSRF. К этим каналам относятся RDECh и AuxCh.
// Тестовые сигналы для каналов LAA и ОСНОВНОГО канала (при его подключении),
// которые подключены к AuxChSRF, и заданных направлениях исключения передаются
// в обучающей матрице L. За формирование данной матрицы ответственен класс, ко-
// торый использует объект класса TSingleStageAuxChSRF. Класс TSingleStageAuxChSRF
// выполняет только проверку корректности по размерности матрицы L. Матрица L не
// должна быть нулевой и число строк матрицы должно быть строго больше числа
// столбцов матрицы. В противном случае, объект класса не будет работоспособным.
// Структура обучающей матрицы  для  реализации  пространственного  режекторного
// фильтра  для 4-х  дополнительных  каналов и 3-х направлений  исключения будет
// иметь следующий вид: N = 4; K = 3; M = 7.
//Размерность L: rows = M = 7; cols = K = 3.
//     | U11 U12 U13 |  Uij - комплексное напряжение в i-ом канале при действии
//     | U21 U22 U23 |        одного источника сигнала ЕДИНИЧНОЙ мощности с j-го
//     | U31 U32 U33 |        направления исключения;
// L = | U41 U42 U43 |  U1j..U3j - рабочие каналы AuxChSpaceRejectFilter;
//     | U51 U52 U53 |  U4j..U7j - дополнительные каналы AdaptSpaceFilterBaseCh
//     | U61 U62 U63 |
//     | U71 U72 U73 |
// 2. На основе матрицы L строится система линейных алгебраических уравнений с N
// правыми частями (по числу AuxCh или числу одноступенчатых сумматоров) следую-
// щего вида: A*W = B, где A - подматрица матрицы L с коэффициентами Uij для ра-
// бочих  каналов  фильтра; В - подматрица  матрицы L с  коэффициентами Uij  для
// вспомогательных каналов AuxCh; W - матрица весовых коэффициентов для N одно-
// ступенчатых сумматоров, которая рассчитывается. Для данной матрицы L СЛАУ с
// N правыми частями записывается следующим образом:
// U11*W1 + U21*W2 + U31*W3 = -U41 -U51 -U61 -U71
// U12*W1 + U22*W2 + U32*W3 = -U42 -U52 -U62 -U72
// U13*W1 + U23*W2 + U33*W3 = -U43 -U53 -U63 -U73
// При решении данной системы уравнений получаем коэффициенты матрицы W:
//     | w11 w12 w13 w14 |
// W = | w21 w22 w23 w24 |
//     | w31 w32 w33 w34 |
// Столбцы матрицы W содержат весовые коэффициенты для 4-x одноступенчатых прос-
// ранственных режекторных фильтра, которые обеспечивают по 3 направления исклю-
// чения в 4-х дополнительных  каналах  адаптивного  пространственного фильтра с
// ОСНОВНЫМ каналом.
// Отметим, что для обеспечения правильной работы пространственного режекторного
// фильтра после его настройки, последовательность каналов LAA и BaseCh (при его
// использовании) должна быть аналогичной как и в обучающей матрице L.
// Коэффициенты матрицы W являются частью коэффициентов матрицы Q. Приведем мат-
// рицу Q для схемы AuxChRDEUnit с тремя направлениями исключения для адаптивно-
// го пространственного фильтра с основным каналом и 4 дополнительными каналами.
// Таким образом, RDECh = 3, AuxCh = 4, Dimension Q = (3+4+1)x(4+1) = 8x5
// (с учетом включения ОСНОВНОГО КАНАЛА). Матрица Q будет иметь следующий вид:
//       U0  U1  U2  U3  U4  U5  U6  U7
//     | w11 w21 w31  1   0   0   0   0 | U3
//     | w12 w22 w32  0   1   0   0   0 | U4
// Q = | w13 w23 w33  0   0   1   0   0 | U5
//     | w14 w24 w34  0   0   0   1   0 | U6
//     |  0   0   0   0   0   0   0   1 | U7
// U0..U2 - RDECh, U3..U6 - AuxCh, U7 - BaseChannel.
//С целью минимизации числа неиспользуемых при вычислениях элементов матрицы Q,
//она преобразуется в матрицу Q следующего вида:
//       U0  U1  U2
//     | q00 q01 q02 | U3
//     | q10 q11 q12 | U4
// Q = | q20 q21 q22 | U5
//     | q30 q31 q32 | U6
//Из матрицы первоначальной матрицы Q вырезается  единичная  матрица и последняя
//ее строка, так как отсутствие данных элементов можно легко учесть при реализа-
//ции алгоритма Q-преобразования.
//В качестве  входного  воздействия может быть использованы комплексные корреля-
//ционная матрица R или вектор напряжений U, которые должны содержать компоненту
//ОСНОВНОГО канала адаптивного фильтра. При Q-преобразовании проверяется работо-
//способность фильтра и соответствие размерности входного воздействия размернос-
//ти пространственного режекторного фильтра. При их несоответствии или неработо-
//способности фильтра возвращается вектор или матрица нулевого размера.
//Размерность входного вектора должна быть равна числу входов фильтра. Матрица R
//должна быть квадратной и ее размерность, также, д.б. равна числу входов SRF. В
//качестве выходного значения объект класса возвращает вектор или квадратную мат-
//рицу с размерностями равными числу выходов Space Reject Filter.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const cmatrix& A - ссылка на обучающую матрицу
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак настройки SingleStageAuxChSRF
//****************************************************************************************
bool TSingleStageAuxChSRF::Tuning(const cmatrix& A)
{Reset();//Сброс характеристик режекторного пространственного фильтра
 //Проверка матрицы A на корректность
 if ((A.IsZeroSize()) || (A.Rows() <= A.Cols())) return false;
 //Создание и начальная инициализация элементов матрицы Q
 Input = A.Rows()+1; Output = Input - A.Cols();
 Q.Set(Out()-1,Directs(),C_ZERO);
 trQ.Set(Directs(),Out()-1,C_ZERO);
 //Вспомогательные переменные
 cmatrix L(Directs(),Directs(),C_ZERO);
 cmatrix R(Directs(),Out()-1,C_ZERO);
 cmatrix W;
 //****************************************************************************
 //Расчет коэффициентов матрицы Q решением СЛАУ L*W = R
 //****************************************************************************
 //1. Формирование матрицы коэффициентов L при весовых коэффициентах W
 for (ulong i = 0L; i < L.Rows(); i++)
  for (ulong j = 0L; j < L.Cols(); j++) L.Put(i,j,A.Get(j,i));
 //2. Формирование матрицы правых частей R
 ulong OffSet = Directs();
 for (ulong i = 0L; i < R.Rows(); i++)
  for (ulong j = 0L; j < R.Cols(); j++) R.Put(i,j,-1.0*A.Get(j+OffSet,i));
 //3. Расчет весовых коэффициентов для каналов подключенных к SRF L*W = R
 W = LE_UnSymSolution(L, R);
 //4. Вычисление коэффициентов матрицы Q & trQ
 complex w;
 for (ulong i = 0L; i < W.Rows(); i++)
  for (ulong j = 0L; j < W.Cols(); j++)
  {w = W.Get(i,j); Q.Put(j,i,w); trQ.Put(i,j,conj(w));}
return true;
}
//*****************************************************************************
//СТАТУС: I.2; TSingleStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(const cmatrix& InR, cmatrix& OutR) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ одноступенчатого режекторного фильтра AuxCh.
//Входным воздействием является корреляционная матрица InR, ее размерность долж-
//на  быть  равна числу  входов  фильтра. Выходная матрица формируется в матрице
//OutR, ее  размерность  равна числу выходов фильтра. При работе функции матрица
//OutR изменяется. Функция возвращает признак успешной или неуспешной работы.
//Функция возвращает false в двух случаях. Во-первых, если фильтр неработоспосо-
//бен, во-вторых, размерность  входной  корреляционная матрица InR не соответст-
//вует числу входов SingleStageAuxChSRF.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cmatrix& InR - ссылка на корреляционную матрицу входного сигнала
//cmatrix& OutR - ссылка на выходную корреляционную матрицу
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//*****************************************************************************
bool TSingleStageAuxChSRF::TFunc(const cmatrix& InR, cmatrix& OutR) const
{//Space Reject Filter НЕРАБОТОСПОСОБЕН или размерность InR не соответствует
 //числу входов фильтра
 if ((!IsReady()) || (InR.Rows() != InR.Cols()) || (InR.Rows() != In()))
 {OutR.Set(0L,0L,false); return false;}
 //*****************************************************************************
 //Определение передаточной характеристики SRF при заданном входном воздействии
 //*****************************************************************************
 //Создание промежуточной матрицы R: R = Q*InR
 cmatrix R(Out(),In(),C_ZERO);
 ulong OffSet = Directs();
 //Q-преобразование (оптимальная операция умножения) R = Q*InR
 for (ulong i = 0L; i < R.Rows(); i++)
  for (ulong j = 0L; j < R.Cols(); j++)
   R.Put(i,j,InR.Get(i+OffSet,j));

 for (ulong i = 0L; i < R.Rows()-1; i++)
  for (ulong j = 0L; j < R.Cols(); j++)
   for (ulong k = 0L; k < Directs(); k++)
    R.Put(i,j,R.Get(i,j)+Q.Get(i,k)*InR.Get(k,j));

 //Q-преобразование (оптимальная операция умножения) OutR = R*trQ
 //Формирование выходной матрицы OutR
 OutR.Set(Out(),Out(),C_ZERO);
 for (ulong i = 0L; i < OutR.Rows(); i++)
  for (ulong j = 0L; j < OutR.Cols(); j++)
   OutR.Put(i,j,R.Get(i,j+OffSet));

 for (ulong i = 0L; i < OutR.Rows(); i++)
  for (ulong j = 0L; j < OutR.Cols()-1; j++)
   for (ulong k = 0L; k < Directs(); k++)
    OutR.Put(i,j,OutR.Get(i,j)+R.Get(i,k)*trQ.Get(k,j));
return true;
}
//****************************************************************************************
//СТАТУС: I.3; TSingleStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFuncDM(const cmatrix& InR, cmatrix& OutR) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ одноступенчатого режекторного фильтра AuxCh.
//Входным воздействием является корреляционная диагональная матрица InR, ее размерность
//должна быть равна числу входов фильтра. Выходная матрица формируется в матрице OutR, ее
//размерность равна числу выходов фильтра. При работе функции матрица OutR изменяется.
//Функция возвращает признак успешной или неуспешной работы. Функция возвращает false в
//двух случаях. Во-первых, если фильтр неработоспособен, во-вторых, размерность входной
//корреляционная матрица InR не соответствует числу входов SingleStageAuxChSRF.
//Функция используется для быстрого Q-преобразования над корреляционной матрицей внутреннего
//шума, так как данная матрица является ДИАГОНАЛЬНОЙ. Проверка на диагональность InR не
//производится.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cmatrix& InR - ссылка на корреляционную диагональную матрицу входного сигнала
//cmatrix& OutR - ссылка на выходную корреляционную матрицу
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//****************************************************************************************
bool TSingleStageAuxChSRF::TFuncDM(const cmatrix& InR, cmatrix& OutR) const
{//Space Reject Filter НЕРАБОТОСПОСОБЕН или размерность InR не соответствует
 //числу входов фильтра
 if ((!IsReady()) || (InR.Rows() != InR.Cols()) || (InR.Rows() != In()))
 {OutR.Set(0L,0L,false); return false;}
 //*****************************************************************************
 //Определение передаточной характеристики SRF при заданном входном воздействии
 //*****************************************************************************
 //Создание промежуточной матрицы R: R = Q*InR
 cmatrix R(Out(),In(),C_ZERO);
 ulong OffSet = Directs();
 ulong j;
 //Q-преобразование (оптимальная операция умножения на диагональную матрицу)
 //R = Q*InR
 for (ulong i = 0L; i < R.Rows(); i++) {j = i+OffSet; R.Put(i,j,InR.Get(j,j));}

 for (ulong i = 0L; i < R.Rows()-1; i++)
  for (ulong j = 0L; j < OffSet; j++)
   R.Put(i,j,Q.Get(i,j)*InR.Get(j,j));

 //Q-преобразование (оптимальная операция умножения) OutR = R*trQ
 //Формирование выходной матрицы OutR
 OutR.Set(Out(),Out(),C_ZERO);
 for (ulong i = 0L; i < OutR.Rows(); i++) OutR.Put(i,i,R.Get(i,i+OffSet));

 for (ulong i = 0L; i < OutR.Rows()-1; i++)
  for (ulong j = 0L; j < OutR.Cols()-1; j++)
   for (ulong k = 0L; k < Directs(); k++)
    OutR.Put(i,j,OutR.Get(i,j)+R.Get(i,k)*trQ.Get(k,j));
return true;
}
//*****************************************************************************
//СТАТУС: I.4; TSingleStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(const cvector& InV, cvector& OutV) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ одноступенчатого режекторного фильтра AuxCh.
//Входным  воздействием  является  вектор  входного сигнала InV, его размерность
//должна быть равна числу входов фильтра. Выходной  вектор формируется в векторе
//OutV, его  размерность равна числу выходов фильтра. При работе функции  вектор
//OutV изменяется. Функция возвращает признак успешной или неуспешной работы.
//Функция возвращает false в двух случаях. Во-первых, если фильтр неработоспосо-
//бен, во-вторых, размерность вектора входного сигнала InV не соответствует чис-
//лу входов SingleStageAuxChSRF.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cvector& InV - ссылка на вектор входного сигнала
//cvector& OutV - ссылка на вектор выходного сигнала
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//*****************************************************************************
bool TSingleStageAuxChSRF::TFunc(const cvector& InV, cvector& OutV) const
{//Space Reject Filter НЕРАБОТОСПОСОБЕН или размерность InR не соответствует
 //числу входов фильтра
 if ((!IsReady()) || (InV.Size() != In())) {OutV.Resize(0); return false;}
 //*****************************************************************************
 //Определение передаточной характеристики SRF при заданном входном воздействии
 //*****************************************************************************
 OutV.Resize(Out()); //Формирование выходного вектора OutV
 //Q-преобразование входного сигнала (оптимальная операция умножения)
 //OutV = Q*InV
 ulong OffSet = Directs();
 for (ulong i = 0L; i < Out(); i++) OutV.Put(i,InV.Get(i+OffSet));

 for (ulong i = 0L; i < OutV.Size()-1; i++)
  for (ulong j = 0L; j < OffSet; j++)
   OutV.Put(i,OutV.Get(i)+InV.Get(j)*Q.Get(i,j));
return true;
}
//*****************************************************************************
//СТАТУС: I.5; TSingleStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetW(cmatrix& W, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Получение  значений  весовых коэффициентов одноступенчатого прост-
//ранственного режекторного фильтра дополнительных каналов. Значения коэффициен-
//тов  заносятся  в  матрицу  W. В матрицу W не заносятся комплексно-сопряженные
//коэффициенты матрицы trQ. Функция может формировать матрицу W двумя способами.
//ВАРИАНТ #1 (lExtend = ON): W - прямоугольная матрица с коэффициентами для всех
//каналов, подключенных к режекторному пространственному фильтру;
//ВАРИАНТ #2 (lExtend = OFF): W - прямоугольная  матрица с коэффициентами только
//РАБОЧИХ  каналов режекторного фильтра.
//Пример: BaseCh, AuxCh = 4; DirectElim = 3. Input=3+4+1=8, Output=4+1=5.
//Матрица W (lExtend = ON):
//       U0  U1  U2  U3  U4  U5  U6  U7
//     | q00 q01 q02  1   0   0   0   0 | U3
//     | q10 q11 q12  0   1   0   0   0 | U4
// Q = | q20 q21 q22  0   0   1   0   0 | U5
//     | q30 q31 q32  0   0   0   1   0 | U6
//     |  0   0   0   0   0   0   0   1 | U7
// U0..U2 - RDECh, U3..U6 - AuxCh, U7 - BaseChannel.
//Матрица W (lExtend = OFF):
//       U0  U1  U2
//     | q00 q01 q02 | U3
//     | q10 q11 q12 | U4
// Q = | q20 q21 q22 | U5
//     | q30 q31 q32 | U6
//Если SingleStageAuxChSRF НЕРАБОТОСПОСОБЕН, функция формирует матрицу W нулевого
//размера и возвращает false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1.cmatrix& W - ссылка на матрицу, в которой будут формироваться коэффициенты
//  Space Reject Fulter of AuxCh;
//2.bool lExtend (ON) - режим формирования матрицы W.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//*****************************************************************************
bool TSingleStageAuxChSRF::GetW(cmatrix& W, bool lExtend) const
{//SingleStageAuxChSRF НЕРАБОТОСПОСОБЕН
 if (!IsReady()) {W.Set(0L,0L,false); return false;}
 //Формирование вектора W со значениями весовых коэффициентов SRF
 if (lExtend) //ВАРИАНТ №_1
 {W.Set(Out(),In(),C_ZERO);
  ulong OffSet = Directs();
  for (ulong i = 0L; i < W.Rows(); i++) W.Put(i,i+OffSet,C_ONE);
  //Присвоение коэффициентов матрицы Q матрице W
  for (ulong i = 0L; i < Q.Rows(); i++)
   for (ulong j = 0L; j < Q.Cols(); j++) W.Put(i,j,Q.Get(i,j));
 }
 else W = Q; //ВАРИАНТ №_2
return true;
}
//****************************************************************************************
//СТАТУС: I.6; TSingleStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& Properties(string& s, string& head, uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта TSingleStageAuxChSRF в строке s, передаваемой по
//ссылке (свойства одноступенчатого пространственного режекторного фильтра AuxCh Adaptive
//SpaceFilter with BaseCh). Предыдущее содержимое строки s уничтожается.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& head - ссылка на строку с заголовком объекта;
//3. uint indent - начальное смещение строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//****************************************************************************************
string& TSingleStageAuxChSRF::Properties(string& s, string& head, uint indent) const
{string t; string space(' ',indent);
 //Формирование заголовка объекта
 s = space;
 if (head.empty()) s.append(Clip(t));
 else s.append(head);
 //-------------------------------------------------------------------------------------
 //SingleStageAuxChSRF НЕРАБОТОСПОСОБЕН:
 if (!IsReady()) {s.append(": < Off >;\n"); return s;}
 s.append(" "+GetConfig(t)); //Формирование конфигурации весового сумматора
return s;
}

//****************************************************************************************
//                РЕАЛИЗАЦИЯ КЛАССА TMultiStageAuxChSRF
//МОДЕЛЬ МНОГОСТУПЕНЧАТОГО ПРОСТРАНСТВЕННОГО РЕЖЕКТОРНОГО ФИЛЬТРА ДОПОЛНИТЕЛЬНЫХ
//       КАНАЛОВ АДАПТИВНОГО ПРОСТРАНСТВЕННОГО ФИЛЬТРА с ОСНОВНЫМ КАНАЛОМ
//****************************************************************************************
//========================================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TMultiStageAuxChSRF
//   PUBLIC MEMBER-FUNCTION OF TMultiStageAuxChSRF CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1,public,class member-function TMultiStageAuxChSRF
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Tuning(const cmatrix& A);
//НАЗНАЧЕНИЕ: РАСЧЕТ КОЭФФИЦИЕНТОВ ПРОСТРАНСТВЕННОГО РЕЖЕКТОРНОГО ФИЛЬТРА ДЛЯ
// ЗАДАННЫХ НАПРАВЛЕНИЙ ВСПОМОГАТЕЛЬНЫМИ КАНАЛАМИ АДАПТИВНОГО ПРОСТРАНСТВЕННОГО
// ФИЛЬТРА С ОСНОВНЫМ КАНАЛОМ.
//Коэффициенты хранятся в матрице Q. Матрица Q имеет размерность равную:
//1. RDECh (каналы LAA используемые для исключения приема сигналов с заданных
//   направлений вспомогательными каналами фильтра);
//2. AuxCh (дополнительные каналы фильтра, подключаемые с LAA);
//3. BaseChannel размерности 1 (основной канал фильтра).
//Матрица Q хранит коэффициенты в упакованном виде. Для осуществления исключения
//приема сигналов с N направлений необходимо 2*N элементарных матриц специального
//вида: R' = Qn*Qn-1*...*Q2*Q1*R*trQ1*trQ2*...*trQn-1*trQn, где
//R - входная корреляционная матрица;
//R' - преобразованная корреляционная матрица с N исключенными направлениями;
//Qn,Qn-1,...,Q2,Q1 - комплексные элементарные матрицы специального вида с коэф-
//фициентами исключения для каждого канала для N-направлений. Данные матрицы -
//НИЖНИЕ СТОЛБЦОВЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ;
//trQ1,trQ2,...,trQn-1,trQn - транспонированные к Q1,tQ2,...,Qn-1,Qn матрицы ве-
//совых коэффициентов. Данные матрицы - ПРАВЫЕ СТРОЧНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ.
//Данная особенность позволяет хранить все 2*N матриц в одной матрице Q.  Реали-
//зованные в классах cvector и cmatrix операции умножения на элементарные матри-
//цы специального вида с учетом компактной формы их хранения в одной матрице поз-
//воляют корректно и быстро выполнять необходимые операции для исключения задан-
//ных направлений исключения из входных корреляционных матриц и векторов  сигна-
//лов.
//Для задания N направлений исключения приема  сигналов с  заданных  направлений
//дополнительными каналами фильтра  используются  N каналов LAA, индексы которых
//не должны совпадать с индексами каналов LAA, которые используются как дополни-
//тельные  каналы пространственного фильтра с выделенным каналом. В основном ка-
//нале подавление приема сигналов с заданных направлений не должно происходить,
//поэтому в матрице Q последняя строка и последний столбец содержат нулевые коэф-
//фициенты, за исключением последнего элемента матрицы (на пересечении последних
//столбца и строки) равного 1. Если не задано ни одного направления исключения,
//матрица Q должна быть ЕДИНИЧНОЙ.
//Функция рассчитывает коэффициенты режекторного пространственного фильтра адап-
//тивной LAA. Коэффициенты обеспечивают нулевые уровни приема сигналов с направ-
//лений  исключения в AuxCh. Таким образом, обеспечивается  передача  сигналов с
//направлений  исключения только через ОСНОВНОЙ КАНАЛ без его компенсации на ве-
//совом сумматоре фильтра. Коэффициенты для всех ДОПОЛНИТЕЛЬНЫХ КАНАЛОВ и ОДНОГО
//НАПРАВЛЕНИЯ ИСКЛЮЧЕНИЯ рассчитываются относительно ОДНОГО RDE КАНАЛА,  который
//подключается с АР к MultiStageAuxChSRF и не должен совпадать ни с одним AuxCh.
//Для  расчета  коэффициентов для другого направления исключения должен быть за-
//действован другой рабочий канал SRF и так далее.
//Функция в качестве параметра принимает ссылку на обучающую матрицу A. Структу-
//ра обучающей матрицы A для реализации пространственного режекторного фильтра
//для для 4-х дополнительных каналов и 3-х направлений исключения имеет вид:
//N = 4; K = 3; M = 7. Размерность A: rows = M = 7; cols = K = 3.
//     | U11 U12 U13 |  Uij - комплексное напряжение в i-ом канале при действии
//     | U21 U22 U23 |        одного источника сигнала ЕДИНИЧНОЙ мощности с j-го
//     | U31 U32 U33 |        направления исключения;
// A = | U41 U42 U43 |  U1j..U3j - рабочие каналы AuxChSpaceRejectFilter;
//     | U51 U52 U53 |  U4j..U7j - дополнительные каналы AdaptSpaceFilterBaseCh
//     | U61 U62 U63 |
//     | U71 U72 U73 |
//Каждый столбец матрицы A содержит настроечные сигналы для всех каналов, подклю-
//ченных к MultiStageAuxChSRF, для одного направления исключения в порядке подк-
//лячения данных каналов к фильтру. Матрица должна быть отлична от нуля и число
//строк матрицы  должно превышать число столбцов. Числу столбцов матрицы A соот-
//ветствует кол-во направлений исключения; числу строк - число входов SRF и раз-
//мерность квадратной матрицы Q. Число выходов SRF равно: A.rows()-A.cols().
//Методика вычисления коэффициентов схемы исключения направлений приема сигналов с заданных
//направлений в вспомогательных каналах фильтра следующая:
//1. Формируется сигнал ЕДИНИЧНОЙ МОЩНОСТИ, приходящий с ПЕРВОГО НАПРАВЛЕНИЯ
// ИСКЛЮЧЕНИЯ, и рассчитываются комплексные значения напряжений на каналах LAA,
// подключенных к AuxChRDEUnit. К этим каналам относятся RDEChannel и AuxChannel.
// Комплексные коэффициенты для ПЕРВОГО НАПРАВЛЕНИЯ исключения рассчитываются по
// следующей формуле: Q(i,0) = - Ui/U0, Q(0,i) = conj(Q(i,0)),  0 < i < LAACh
// Q(i,0) - коэффициент AuxChSRF для i-го канала LAA, подключенного к нему,
//          для первого направления исключения;
// Ui - комплексное напряжение i-го канала LAA, подключенного к AuxChSRF,
// при действии источника единичной мощности с первого направления исключения;
// U0 - комплексное напряжение 1-го рабочего канала RDECh, которое обеспечивает
// исключение направления приема сигнала с первого направления в остальных кана-
// лах подключенных к AuxChSRF.
// 2. Алгоритм расчета для j-го направления исключения (0 < j <= N). Формируется
//  сигнал ЕДИНИЧНОЙ МОЩНОСТИ с j-го направления исключения и формируется вектор
//  комплексных напряжений на каналах LAACh, подключенных к RDEUnit. Полученный
//  вектор U умножается на последовательность левых столбцовых элементарных мат-
//  риц Lkc: U' = Lj-1c*...*L1c*L0c*U. В результате этого вектор U изменяется на
//  вектор U', из данного вектора исключаются источники сигнала с 0..j-1 направ-
//  лений исключения. Коэффициенты для j-го направления исключения рассчитываются
//  аналогично п.1 по формуле: Q(i,j)=-U'i/U'j, Q(j,i)=conj(Q(i,j)), j<i<LAACh
// Q(i,j) - коэффициент AuxChSRF для i-го канала LAA, подключенного к нему,
//          для j-го направления исключения;
// U'i - комплексное напряжение i-го канала LAA, подключенного к AuxChSRF,
// при действии источника единичной мощности с j-го направления исключения;
// U'j - комплексное напряжение j-го рабочего канала RDECh, которое обеспечивает
// исключение направления приема сигнала с j-го направления в остальных каналах
// подключенных к AuxChSRF.
// Выполнение п.2 продолжается расчета для всех N направлений исключения.
// Приведем обобщенную структуру матрицы Q для MultiStageAuxChSRF для трех  нап-
// равлений исключения и пространственного фильтра с основным каналом и 5 допол-
// нительными каналами. Таким образом, RDECh = 3, AuxCh = 5, Dimension Q = 9x9
// (с учетом включения ОСНОВНОГО КАНАЛА). Матрица Q будет иметь следующий вид:
//       U0  U1  U2  U3  U4  U5  U6  U7  U8
//     |  1  q01 q02 q03 q04 q05 q06 q07  0| U0
//     | q10  1  q12 q13 q14 q15 q16 q17  0| U1
//     | q20 q21  1  q23 q24 q25 q26 q27  0| U2
//     | q30 q31 q32  1   0   0   0   0   0| U3
// Q = | q40 q41 q42  0   1   0   0   0   0| U4
//     | q50 q51 q52  0   0   1   0   0   0| U5
//     | q60 q61 q62  0   0   0   1   0   0| U6
//     | q70 q71 q72  0   0   0   0   1   0| U7
//     |  0   0   0   0   0   0   0   0   1| U8
// U0..U2 - RDECh, U3..U7 - AuxCh, U8 - BaseChannel
//С целью минимизации числа неиспользуемых при вычислениях элементов матрицы Q,
//она разбивается на две прямоугольные матрицы Q и trQ. Матрицы Q и trQ будут
//иметь следующий вид:
//       U0  U1  U2
//     |  1   0   0  | U0
//     | q10  1   0  | U1
//     | q20 q21  1  | U2          U0  U1  U2  U3  U4  U5  U6  U7
//     | q30 q31 q32 | U3         | 1  q01 q02 q03 q04 q05 q06 q07 | U0
// Q = | q40 q41 q42 | U4   trQ = | 0   1  q12 q13 q14 q15 q16 q17 | U1
//     | q50 q51 q52 | U5         | 0   0   1  q23 q24 q25 q26 q27 | U2
//     | q60 q61 q62 | U6
//     | q70 q71 q72 | U7
// U0..U2 - RDECh, U3..U7 - AuxCh.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const cmatrix& A - ссылка на обучающую матрицу
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак настройки MultiStageAuxChSRF
//*****************************************************************************
bool TMultiStageAuxChSRF::Tuning(const cmatrix& A)
{Reset();//Сброс характеристик режекторного пространственного фильтра
 //Проверка матрицы A на корректность
 if ((A.IsZeroSize()) || (A.Rows() <= A.Cols())) return false;
 //Создание и начальная инициализация элементов матрицы Q
 Input = A.Rows()+1; Output = Input - A.Cols();
 Q.Set(In()-1,Directs(),C_ZERO);
 trQ.Set(Directs(),In()-1,C_ZERO);
 for (ulong i = 0L; i < Q.Cols(); i++) Q.Put(i,i,C_ONE);
 for (ulong i = 0L; i < trQ.Rows(); i++) trQ.Put(i,i,C_ONE);
 //Вспомогательные переменные
 cvector V(A.Rows(),COL);
 complex w;
 //Расчет коэффициентов матрицы Q
 for (ulong j = 0; j < A.Cols(); j++)
 {//1. Формирование тест-сигнала ЕДИНИЧНОЙ МОЩНОСТИ с j-го направления исключения
  for (ulong i = 0; i < A.Rows(); i++) V.Put(i,A.Get(i,j));
  //2. Расчет весовых коэффициентов для каналов подключенных к SRF для j-го
  //направления исключения приема сигналов, j < i < LAACh.Size()
  for (ulong k = 0L; k < j; k++)
   for (ulong i = k+1; i < V.Size(); i++)
    V.Put(i,V.Get(i)+V.Get(k)*Q.Get(i,k));
  //Вычисление коэффициентов матрицы Q & trQ
  for (ulong i = j+1; i < Q.Rows(); i++)
  {w = -1.0*V.Get(i)/V.Get(j); Q.Put(i,j,w); trQ.Put(j,i,conj(w));}
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.2; TMultiStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(const cmatrix& InR, cmatrix& OutR) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ многоступенчатого режекторного фильтра AuxCh.
//Входным воздействием является корреляционная матрица InR, ее размерность долж-
//на  быть  равна числу  входов  фильтра. Выходная матрица формируется в матрице
//OutR, ее  размерность  равна числу выходов фильтра. При работе функции матрица
//OutR изменяется. Функция возвращает признак успешной или неуспешной работы.
//Функция возвращает false в двух случаях. Во-первых, если фильтр неработоспосо-
//бен, во-вторых, размерность  входной  корреляционная матрица InR не соответст-
//вует числу входов MultiStageAuxChSRF.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cmatrix& InR - ссылка на корреляционную матрицу входного сигнала
//cmatrix& OutR - ссылка на выходную корреляционную матрицу
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//*****************************************************************************
bool TMultiStageAuxChSRF::TFunc(const cmatrix& InR, cmatrix& OutR) const
{//Space Reject Filter НЕРАБОТОСПОСОБЕН или размерность InR не соответствует
 //числу входов фильтра
 if ((!IsReady()) || (InR.Rows() != InR.Cols()) || (InR.Rows() != In()))
 {OutR.Set(0L,0L,false); return false;}
 //Определение передаточной характеристики SRF при заданном входном воздействии
 cmatrix R = InR;
 //Q-преобразование (оптимальная операция умножения) R = Q*R
 for (ulong k = 0; k < Directs(); k++) //По всем направлениям исключения
  for (ulong i = k+1; i < R.Rows()-1; i++)
   for (ulong j = 0L; j < R.Cols(); j++)
    R.Put(i,j,R.Get(i,j)+Q.Get(i,k)*R.Get(k,j));

 //Q-преобразование (оптимальная операция умножения) R = R*trQ
 for (ulong k = 0; k < Directs(); k++) //По всем направлениям исключения
  for (ulong j = k+1; j < R.Cols()-1; j++)
   for (ulong i = 0L; i < R.Rows(); i++)
    R.Put(i,j,R.Get(i,j)+R.Get(i,k)*trQ.Get(k,j));

 //Формирование выходной матрицы OutR
 OutR.Set(Out(),Out(),C_ZERO);
 ulong row, col;
 ulong OffSet = Directs();
 for (ulong i = 0L; i < OutR.Rows(); i++)
 {row = i+OffSet;
  for (ulong j = 0L; j < OutR.Cols(); j++)
  {col = j+OffSet; OutR.Put(i,j,R.Get(row,col));}
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.3; TMultiStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFuncDM(const cmatrix& InR, cmatrix& OutR) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ многоступенчатого режекторного фильтра AuxCh.
//Входным воздействием является корреляционная диагональная матрица InR, ее раз-
//мерность должна быть равна числу входов  фильтра. Выходная матрица формируется в матрице
//OutR, ее  размерность  равна числу выходов фильтра. При работе функции матрица
//OutR изменяется. Функция возвращает признак успешной или неуспешной работы.
//Функция возвращает false в двух случаях. Во-первых, если фильтр неработоспосо-
//бен, во-вторых, размерность  входной  корреляционная матрица InR не соответст-
//вует числу входов MultiStageAuxChSRF.
//Функция используется для быстрого Q-преобразования над корреляционной матрицей
//внутреннего  шума, так  как данная  матрица является ДИАГОНАЛЬНОЙ. Проверка на
//диагональность InR не производится.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cmatrix& InR - ссылка на корреляционную диагональную матрицу входного сигнала
//cmatrix& OutR - ссылка на выходную корреляционную матрицу
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//*****************************************************************************
bool TMultiStageAuxChSRF::TFuncDM(const cmatrix& InR, cmatrix& OutR) const
{//Space Reject Filter НЕРАБОТОСПОСОБЕН или размерность InR не соответствует
 //числу входов фильтра
 if ((!IsReady()) || (InR.Rows() != InR.Cols()) || (InR.Rows() != In()))
 {OutR.Set(0L,0L,false); return false;}
 //Определение передаточной характеристики SRF при заданном входном воздействии
 cmatrix R = InR;
 //Q-преобразование диагональной матрицы (оптимальная операция умножения) R=Q*R
 for (ulong k = 0; k < Directs(); k++) //По всем направлениям исключения
  for (ulong i = k+1; i < R.Rows()-1; i++)
   for (ulong j = 0L; j <= k; j++)
    R.Put(i,j,R.Get(i,j)+Q.Get(i,k)*R.Get(k,j));

 //Q-преобразование (оптимальная операция умножения) R = R*trQ
 for (ulong k = 0; k < Directs(); k++) //По всем направлениям исключения
  for (ulong j = k+1; j < R.Cols()-1; j++)
   for (ulong i = 0L; i < R.Rows()-1; i++)
    R.Put(i,j,R.Get(i,j)+R.Get(i,k)*trQ.Get(k,j));

 //Формирование выходной матрицы OutR
 OutR.Set(Out(),Out(),C_ZERO);
 ulong row, col;
 ulong OffSet = Directs();
 for (ulong i = 0L; i < OutR.Rows(); i++)
 {row = i+OffSet;
  for (ulong j = 0L; j < OutR.Cols(); j++)
  {col = j+OffSet; OutR.Put(i,j,R.Get(row,col));}
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.4; TMultiStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(const cvector& InV, cvector& OutV) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ многоступенчатого режекторного фильтра AuxCh.
//Входным  воздействием  является  вектор  входного сигнала InV, его размерность
//должна быть равна числу входов фильтра. Выходной  вектор формируется в векторе
//OutV, его  размерность равна числу выходов фильтра. При работе функции  вектор
//OutV изменяется. Функция возвращает признак успешной или неуспешной работы.
//Функция возвращает false в двух случаях. Во-первых, если фильтр неработоспосо-
//бен, во-вторых, размерность вектора входного сигнала InV не соответствует чис-
//лу входов MultiStageAuxChSRF.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cvector& InV - ссылка на вектор входного сигнала
//cvector& OutV - ссылка на вектор выходного сигнала
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//*****************************************************************************
bool TMultiStageAuxChSRF::TFunc(const cvector& InV, cvector& OutV) const
{//Space Reject Filter НЕРАБОТОСПОСОБЕН или размерность InR не соответствует
 //числу входов фильтра
 if ((!IsReady()) || (InV.Size() != In())) {OutV.Resize(0L); return false;}
 cvector V = InV;
 //Определение передаточной характеристики SRF при заданном входном воздействии
 for (ulong k = 0L; k < Directs(); k++)
  for (ulong i = k+1; i < V.Size()-1; i++)
   V.Put(i,V.Get(i)+V.Get(k)*Q.Get(i,k));
 //Формирование выходного вектора OutV
 OutV.Resize(Out());
 ulong OffSet = Directs();
 for (ulong i = 0L; i < OutV.Size(); i++) OutV.Put(i,V.Get(i+OffSet));
return true;
}
//*****************************************************************************
//СТАТУС: I.5; TMultiStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetW(cmatrix& W, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Получение  значений весовых коэффициентов многоступенчатого прост-
//ранственного режекторного фильтра дополнительных каналов. Значения коэффициен-
//тов  заносятся  в  матрицу  W. В матрицу W не заносятся комплексно-сопряженные
//коэффициенты матрицы Q. Функция может формировать матрицу W двумя способами.
//ВАРИАНТ #1 (lExtend = ON): W - нижняя треугольная матрица с коэффициентами для
//ОСНОВНОГО канала;
//ВАРИАНТ #2 (lExtend = OFF): W - прямоугольная  матрица  без  коэффициентов для
//ОСНОВНОГО канала. Столбцы матрицы Q, внедиагональные элементы которых содержат
//только нулевые коэффициенты, не включаются в матрицу W.
//Пример: AuxCh = 5; DirectElim = 3. Input = 3+5+1 = 9, Output = 5+1 = 6.
//       U0  U1  U2  U3  U4  U5  U6  U7  U8
//     |  1  q01 q02 q03 q04 q05 q06 q07  0| U0
//     | q10  1  q12 q13 q14 q15 q16 q17  0| U1
//     | q20 q21  1  q23 q24 q25 q26 q27  0| U2
//     | q30 q31 q32  1   0   0   0   0   0| U3
// Q = | q40 q41 q42  0   1   0   0   0   0| U4
//     | q50 q51 q52  0   0   1   0   0   0| U5
//     | q60 q61 q62  0   0   0   1   0   0| U6
//     | q70 q71 q72  0   0   0   0   1   0| U7
//     |  0   0   0   0   0   0   0   0   1| U8
// U0..U2 - RDECh, U3..U7 - AuxCh, U8 - BaseChannel.
//Матрица W (lExtend = ON):
//       U0  U1  U2  U3  U4  U5  U6  U7  U8
//     |  1   0   0   0   0   0   0   0   0| U0
//     | q10  1   0   0   0   0   0   0   0| U1
//     | q20 q21  1   0   0   0   0   0   0| U2
//     | q30 q31 q32  1   0   0   0   0   0| U3
// W = | q40 q41 q42  0   1   0   0   0   0| U4
//     | q50 q51 q52  0   0   1   0   0   0| U5
//     | q60 q61 q62  0   0   0   1   0   0| U6
//     | q70 q71 q72  0   0   0   0   1   0| U7
//     |  0   0   0   0   0   0   0   0   1| U8
//Матрица W (lExtend = OFF):
//       U0  U1  U2
//     |  1   0   0  | U0
//     | q10  1   0  | U1
//     | q20 q21  1  | U2
//     | q30 q31 q32 | U3
// W = | q40 q41 q42 | U4
//     | q50 q51 q52 | U5
//     | q60 q61 q62 | U6
//     | q70 q71 q72 | U7
//Если MultiStageAuxChSRF НЕРАБОТОСПОСОБЕН, функция формирует матрицу W нулевого
//размера и возвращает false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1.cmatrix& W - ссылка на матрицу, в которой будут формироваться коэффициенты
//  Space Reject Fulter of AuxCh;
//2.bool lExtend (ON) - режим формирования матрицы W.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//*****************************************************************************
bool TMultiStageAuxChSRF::GetW(cmatrix& W, bool lExtend) const
{//MultiStageAuxChSRF НЕРАБОТОСПОСОБЕН
 if (!IsReady()) {W.Set(0L,0L,false); return false;}
 //Формирование вектора W со значениями весовых коэффициентов SRF
 if (lExtend) //ВАРИАНТ №_1
 {W.Set(In(),In(),C_ZERO);
  for (ulong i = 0L; i < W.Rows(); i++) W.Put(i,i,C_ONE);
  //Присвоение коэффициентов матрицы Q матрице W
  for (ulong j = 0L; j < Q.Cols(); j++)
   for (ulong i = j+1; i < Q.Rows(); i++) W.Put(i,j,Q.Get(i,j));
 }
 else W = Q; //ВАРИАНТ №_2
 return true;
}
//****************************************************************************************
//СТАТУС: I.6; TMultiStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//string& Properties(string& s, string& head, uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта TMultiStageAuxChSRF в строке s, передаваемой по
//ссылке (свойства многоступенчатого пространственного режекторного фильтра AuxCh Adaptive
//SpaceFilter with BaseCh). Предыдущее содержимое строки s уничтожается.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& head - ссылка на строку с заголовком объекта;
//3. uint indent - начальное смещение строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//****************************************************************************************
string& TMultiStageAuxChSRF::Properties(string& s, string& head, uint indent) const
{string t; string space(' ',indent);
 //Формирование заголовка объекта
 s = space;
 if (head.empty()) s.append(Clip(t));
 else s.append(head);
 //---------------------------------------------------------------------------------------
 //MultiStageAuxChSRF НЕРАБОТОСПОСОБЕН:
 if (!IsReady()) {s.append(": < Off >;\n"); return s;}
 s.append(" "+GetConfig(t)); //Формирование конфигурации весового сумматора
 return s;
}



