//Mathlib.h
//Copyright (c) JohnSoft 2000. All rights reserved. Borland C++ 5.01.
//Initial date: March,15,2000. Final date:
//Объявление математических классов общего назначения
#if !defined(__MATHLIB_H)
#define __MATHLIB_H

//Заголовочные файлы
#include "const.h"
#pragma hdrstop

#include "parsing.h"
#include "Predicate.hpp"
//****************************************************************************************
// Определение эктремальных значений функции
//****************************************************************************************
typedef enum {NoneExtr=0, MaxMinExtr, MaxExtr, MinExtr} FuncExtremum;

//****************************************************************************************
// Определение опций установки контрольных точек
// cpEmpty - контрольные точки отсутствуют;
// cpBounds - контрольные точки определены только на границах интервала моделирования;
// cpEvenSample - контрольные точки выбираются равномерно на интервале моделирования с
//                включением граничных значений;
// cpCustom - устанавливаются контрольные точки из предлагаемого списка с учетом их
//            принадлежности существующему интервалу моделирования.
//****************************************************************************************
typedef enum {cpEmpty = 0, cpBounds, cpEvenSample, cpCustom} enCheckPointOpts;

//****************************************************************************************
// Определение вида (типа) нормирования значений:
//
//****************************************************************************************
typedef enum {UnNormalized = 0, Normalized = 1, Norm_10Lg = 2, Norm_20Lg = 3} enNormType;

//****************************************************************************************
//Варианты вычисления передаточной функции фильтра (класс TNumSimulationOpts):
//   a) TF_Disable - передаточная функция не вычисляется;
//   b) TF_ByFinRes - передаточная функция вычисляется в конце моделирования;
//   c) TF_ByCheckPts - передаточная функция вычисляется во всех контрольных точках
//****************************************************************************************
typedef enum {TF_Disable = 0, TF_ByFinRes = 1, TF_ByCheckPts = 2} enCalcTFOpts;

//****************************************************************************************
//Предварительное объявление имен классов и функций
//****************************************************************************************
class TEvenCloseInterval;//РАВНОМЕРНЫЙ ЗАКРЫТЫЙ ИНТЕРВАЛ
class TRandomGenerator;
typedef TRandomGenerator TRandGen;
class TPoint_2D;//Точка на плоскости

class TNumSimulationParams;//Характеристики (параметры) численного моделирования
class TNumSimulationOpts;//Установки, используемые при численном моделировании

class TStatSimulationParams;//Характеристики (параметры) статистического моделирования
class TSettingsTF;//Установки расчета передаточных функций с одной угловой координатой
class TDoubleSet;//Контейнер для хранения вещественных чисел
class TLongSet;//Контейнер для хранения целых чисел типа long

//Поиск экстремумов функции, представленной в табличном виде
long ExtremumSeeking(deque<TPoint_2D>& ExtrPoints, const rmatrix& F, FuncExtremum Extr);
//Форматированный многострочный вывод точек TPoint_2D из контейнера Points в строку s
ulong MultiLineFormat(string& s, const deque<TPoint_2D>& Points, ulong MaxWidth = 80,
      const char* sfx = NULL);
//Построение массивов чисел для отображения числовых значений осей X и Y в 3D-графиках
//пакета MathCad, задаваемых в виде (X,Y,Z)
bool MathCad_AxesXY(rmatrix& X, rmatrix& Y, const rvector& sX, const rvector& sY);
bool MathCad_AxesXY(rmatrix& X, rmatrix& Y, const TDoubleSet& sX, const TDoubleSet& sY);
bool MathCad_AxesXY(imatrix& X, rmatrix& Y, const TLongSet& sX, const TDoubleSet& sY);

//Разбиение строки s на подстроки длиной не более width с возможностью вставки в начало
//каждой подстроки строки pfx. Разбитая на подстроки строка s сохраняется в t и функция
//возвращает число подстрок
ulong MultiLineFormat(string& t, const string& s, uint width = 80, const char* pfx = NULL);

//Разложение положительного целого числа n (n > 1) на простые множители при помощи деления
//n - целое положительное число, разлагаемое на простые множители;
//PrimeNumsColl - результирующий контейнер простых множителей числа n.
//Функция возвращает признак является ли число n простым (true) или составным (false).
bool PrimeFactoringByDivision(ulong n, ULongMap& PrimeNumColl);

//Построение статистического ряда по данным вещественной матрицы A. Ряд формируется в мат-
//рице Res, состоящей из 4 столбцов. Первые два столбца определяют значения левой и правой
//границ отрезков ряда - [Xi..Xi+1), третий столбец содержит счетчик значений Mi данных A,
//которые попадают в отрезок [Xi..Xi+1), четвертый столбец содержит значение частоты Pi в
//процентах для отрезка [Xi..Xi+1): Pi = Mi/N, N - число данных матрицы A. Число строк Res
//будет определятся количеством интервалов Intervals, на которые будет разбит отрезок
//[Left..Right], а также его расположением относительно всего диапазона значений [Min..Max]
//для данных матрицы A, где Min - минимальное, а Max - максимальное значения матрицы A.
bool StatisticalSeries(const rmatrix& A, rmatrix& Res, double Left = 0, double Right = 0,
     ulong Intervals = 10);

//Вычисление относительной погрешности отклонения значений выборки из матрицы X от величин
//из эталонной матрицы S с построением статистического ряда по данным из матрицы RelErr в
//матрице Res (RelErr - матрица значений относительных погрешностей, построенная по данным
//из матриц S и X, с размерностью равной размерности матриц S и X). Относительная погреш-
//ность выражается в процентах и рассчитывается для каждого элемента матрицы X следующим
//образом: RelErr(i,j) = |(S[i,j]-X[i,j])/S[i,j]|*100%.
//Матрица Res описывает статистический ряд матрицы RelErr и состоит из 4-х столбцов.
//Столбцы 1 и 2 определяют левую и правую границы отрезков, на которые разбивается интервал
//всех значений относительной погрешности - [REi..REi+1), столбец 3 содержит счетчик значе-
//ний Mi данных RelErr, принадлежащих [REi..REi+1), столбец 4 содержит значение частоты
//попадания Pi (в %) в [REi..REi+1): Pi = Mi/N, N - число данных матрицы RelErr.
//Число строк Res определяется числом интервалов Intervals, на которые будет разбит отрезок
//[Left..Right], а также его расположением относительно всего диапазона значений относительных
//погрешностей [Min..Max] для данных матрицы RelErr, где Min - минимальное, а Max - макси-
//мальное значения относительных погрешностей.
bool RelativeError(const rmatrix& S, const rmatrix& X, rmatrix& Res, double Left = 0,
     double Right = 0, ulong Intervals = 10);


//----------------------------------------------------------------------------------------
//Объявление класса TRandGenerator
//Copyright (c) JohnSoft 1999. All rights reserved.
//Initial date: May,13,1999; Final date:
//Файл содержит класс, который позволяет получать псевдослучайные последовательности чисел,
//распределенных по основным вероятностным законам. В основе работы генератора случайных
//чисел (ГСЧ) положен простой алгоритм формирования псевдослучайной последовательности чисел,
//который предназначен для использования в технических приложениях. Алгоритм формирует
//случайную выборку, распределенную по равновероятному закону. Принимая за основу случайные
//числа с равновероятным распределением, можно получить случайные числа с другими законами
//распределения. Этот алгоритм имеет следующие свойства:
//1. Алгоритм реализуется на любой ЭВМ, допускающей работу со словами длиной до 32-бит, т.е.
//   с положительными целыми числами от 0 до 2^31-1.
//2. Алгоритм легко запускается, начиная с любой позиции последовательности.
//3. Отсчеты последовательности и ее сегментов достаточно большой длины имеют
//   приблизительно равномерное распределение в интервале от 0 до 1.
//4. Отсчеты являются практически независимыми, а спектр последовательности - РАВНОМЕРНЫМ.
//5. Период последовательности (от 2^20 (1,048,576) до 2^24 (16,777,216)) является
//   достаточным для большинства технических приложений.
//                         А Л Г О Р И Т М
//Данный алгоритм принадлежит множеству алгоритмов последовательностей на основе вычисления
//классов вычетов. Целые положительные псевдослучайные числа формируются по реккурентной
//формуле:
//      I(n+1) = ( J*I(n)+1 )mod M, n = 1,2,...,M-1.  (1)
//I(n+1), I(n) - последующее и предыдущее случайные величины;
//J - множитель последовательности;
//M - период последовательности;
//mod M - операция деления по модулю M.
//Для получения равномерно распределенной СВ в интервале от 0 до 1 последовательность
//целых чисел нормируется. Период последовательности (1) не может быть больше M. Период
//равен M, в частности тогда когда
//      J = 4*K + 1 и M = 2^L,   (2)
//где K и L - такие целые числа, что M > J. Наибольшее значение I(n) в (1) равно M-1,
//поэтому для формирования по (1) чисел, только меньших 2^31, необходимо чтобы
//           J(M-1)+1 < 2^31, или (4*K + 2^31)/(4*K + 1) > 2^L.  (3)
//Таким образом, (3) устанавливает соотношение между J и M в (1). Отметим, что при
//малом начальном значении I(0) (1) начинающейся с него сегмент является последовательностью
//монотонно возрастающих чисел до тех пор, пока J*I(n)+1 не станет больше M.
//Например, в простейшем случае при J = 1 и I(0) = 0 последовательность имеет вид 0,
//1, 2,..., M-1. Таким образом, последовательность становится случайной при больших
//значениях J.
//Пусть минимальный период последовательности равен 10^6, тогда L = 20 и из (3) наибольшее
//возможное значение K = 511. Отсюда для (1) имеем
//       M = 2^20 = 1 048 576, J = 4*(511)+1 = 2045.
//Значение I(0) можно выбирать произвольно, желательно больше 10 000. В объекте класса
//TRandGenerator можно устанавливать I(0) произвольным случайным значением или данное
//значение может быть задано пользователем при конструировании или изменении параметров
//объекта. Доступными параметрами для изменения пользователем являются два параметра:
//период случайной последовательности - M и начальное значение последовательности - I(0).
//Для построения в программе случайных чисел, распределенных по равновероятному закону,
//в интервале от 0 до 1, которые также являются исходными данными для получения случайных
//чисел, распределенных по другим вероятностным законам, можно задать n-й отсчет формулой:
//R(n) = (I(n) + 1)/(M + 1) (4).

#pragma warn -inl      //IGNORE not expanded inline WARNINGS.

//***********************************************************************************
//Объявление структуры соответствия задаваемого пользователем периода последователь-
//ности рабочим установкам генератора - RNG_SET
//***********************************************************************************
typedef struct rng_set
{ uint type;//Идентификатор периода последовательности
  ulong M; //Значение периода псевдослучайной последовательности
  uint J;  //Множитель последовательности
} RNG_SET;

//***********************************************************************************
//Объявление структуры соответствий задаваемого пользователем периода последователь-
//ности рабочим установкам генератора - TB_RNG
//***********************************************************************************
typedef struct tb_rng_set
{uint size; //Количество записей в таблице
 RNG_SET *rec; //Указатель на таблицу, состоящей из записей типа RNG_SET
} TB_RNG;

//***********************************************************************************
//Объявление структуры характеристик генератора случайных чисел - PF_RNG
//***********************************************************************************
typedef struct pf_rng
{ulong M;  //Период последовательности
 uint J;   //Множитель последовательности
 ulong Rn; //Текущее случайное число
 uint Init; //Начальное значение последовательности
 ulong Count; //Кол-во обращений к генератору случайных чисел
} PF_RNG;

// ОБЪЯВЛЕНИЕ КОНСТАНТ, СООТВЕТСТВУЮЩИХ ЗАДАВАЕМОМУ ПЕРИОДУ ПОСЛЕДОВАТЕЛЬНОСТИ
const uint T_1  = 0;//Период 2^20 = 1 048 576
const uint T_2  = 1;//Период 2^21 = 2 097 152
const uint T_4  = 2;//Период 2^22 = 4 194 304
const uint T_8  = 3;//Период 2^23 = 8 388 608
const uint T_16 = 4;//Период 2^24 = 16 777 216

//***********************************************************************************
// ОБЪЯВЛЕНИЕ КЛАССА - TRandomGenerator - генератор псевдослучайной последовательности
// чисел, с возможностью изменения периода последовательности в пределах от 2^20 до
// 2^24. Работа генератора основана на получении случайной последовательности целых
// положительных чисел, распределенных приблизительно по равновероятному закону, в
// интервале от 0 до периода последовательности M. На основе данной последовательности
// класс позволяет генерировать случайные величины, распределенные по равновероятному
// закону, в других интервалах либо случайные величины с другими законами распределе-
// ния - нормальным (гауссовским), релеевским и т.д.
//***********************************************************************************
class TRandomGenerator {
//-----------------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ ЗАКРЫТЫХ ЧЛЕНОВ-ДАННЫХ КЛАССА TRandomGenerator
//-----------------------------------------------------------------------------------
private:
 //Параметры генератора псевдослучайных чисел
 //Индекс в таблице типа TB_RNG с параметрами генератора: M - период последовательности,
 //J - множитель последовательности.
 uint Index;
 uint Init; //Начальное значение последовательности
 //Текущие характеристики работы генератора
 ulong Rn; //Текущее случайное целое число, выработанное генератором
 ulong Count; //Текущее количество обращений к генератору
//-----------------------------------------------------------------------------------
// I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TRandomGenerator
//-----------------------------------------------------------------------------------
public:
 //Установка параметров работы генератора
 void SetPerform(uint Period, uint InitValue = 0);
 //Получение свойств генератора
 PF_RNG& GetPerform(PF_RNG &Info) const;
 //Получение свойств генератора в виде строкового объекта string
 string& GetPerform(string& s) const;
 //----------------------------------------------------------------------------------
 ulong GetPeriod() const; //Получение периода последовательности
 uint GetFactor() const; //Получение множителя последовательности
 //Получение начального значения последовательности
 inline uint GetInit() const {return Init;};
 //Получение текущего случайного числа
 inline ulong GetR() const {return Rn;};
 //Получение количества обращений к генератору случайных чисел
 inline ulong GetCount() const {return Count;};
 //----------------------------------------------------------------------------------
 //Инициализация начального значения последовательности случайной величиной
 void Randomize();
 //----------------------------------------------------------------------------------
 // Объявление функций - членов класса, вырабатывающих случайные величины
 //----------------------------------------------------------------------------------
 //Получение целой положительной равномерно распределенной СВ
 ulong Rand();
 //Получение целой равномерно распределенной СВ от A до B
 long Rand(long A, long B);
 //Получение равномерно распределенной СВ от 0 до 1
 double Random();
 //Получение равномерно распределенной СВ от А до B
 double Random(double A, double B);
 //Получение равномерно распределенной СВ от 0 до 2*PI
 inline double Rand2PI() {return Random(0, 6.283185307179586);};
 //Получение нормально распределенной СВ с мат. ожиданием M и дисперсией D
 inline double Gauss(double M = 0.0, double D = 1.0);
 //Получение СВ распределенной по закону Релея
 inline double Relay() {return sqrt(-2*log(Random()));};
 //Получение СВ распределенной по экспоненциальному закону: F(x)=t*EXP(-t*x), x >= 0.
 inline double Exp(double t = 1.0) {return (-1.0*log(Random()))/t;};
//***********************************************************************************
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TRandomGenerator
//***********************************************************************************
 //Объявление конструктора по умолчанию
 TRandomGenerator() {SetPerform(T_1);};
 //Объявление конструктора с аргументами
 TRandomGenerator(uint Period, uint InitValue = 0)  {SetPerform(Period, InitValue);};
 //Объявление деструктора класса
 ~TRandomGenerator() {Initial();};

//-----------------------------------------------------------------------------------
// II. ОБЪЯВЛЕНИЕ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TRandomGenerator
//-----------------------------------------------------------------------------------
private:
 //Начальная установка всех характеристик TRandomGenerator
 void Initial();
 //Установка заданного периода последовательности генератора
 void SetPeriod(uint Period);
 //Установка начального значения последовательности
 inline void SetInit(uint InitValue) {Init = InitValue;};
};//Завершение объявления класса TRandomGenerator

//****************************************************************************************
// Объявление класса TEvenCloseInterval - РАВНОМЕРНЫЙ ЗАКРЫТЫЙ ИНТЕРВАЛ
//Класс описывает числовую последовательность вещественных чисел, заключенных в интервале
//типа [a,a+delta..b], где a и b - левая и правая границы интервала и delta - шаг интервала
//(delta = I(n+1) - I(n)). Заданы следующие ограничения:
//1)a <= b - левая граница меньше или равна правой границе;
//2)delta > 0 - шаг интервала всегда больше нуля
//3)максимальное число значений, укладывающихся в заданный интервал с определенным шагом
//  интервала не должно превышать величину Nmax = 2^32 - 1.
//Число значений в интервале определяется: N = ceil[(b-a)/delta]+1. В случае превышения N
//величины Nmax последовательным увеличением шага в два раза устанавливается выполнение
//выражения N <= Nmax. Третье ограничение позволяет преобразовать  равномерный  закрытый
//интервал в числовую последовательность, хранимую в вещественном векторе.
//****************************************************************************************
class TEvenCloseInterval {
//----------------------------------------------------------------------------------------
// Объявление защищенных членов-данных класса TEvenCloseInterval
//----------------------------------------------------------------------------------------
protected:
 double Left;//Левая граница интервала
 double Right;//Правая граница интервала
 double Delta;//Шаг интервала
//------------------------------------------------------------------------------
// Объявление закрытых членов-данных класса TEvenCloseInterval
//------------------------------------------------------------------------------
private:
 ulong Count;//Количество чисел, принадлежащих интервалу
//------------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TEvenCloseInterval
//------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TEvenCloseInterval() {Set(0.0,1.0,0.1);};
 //Конструктор с аргументами
 TEvenCloseInterval(double a, double b, double step = 0.1) {Set(a,b,step);};
 //Объявление конструктора копирования
 TEvenCloseInterval(const TEvenCloseInterval &Gap) {*this = Gap;};
 //Объявление деструктора класса
 ~TEvenCloseInterval() {Clear();};
//------------------------------------------------------------------------------
// Объявление общедоступных членов-функций класса TEvenCloseInterval
//------------------------------------------------------------------------------
 inline double LeftBorder() const {return Left;};//Левая граница интервала
 inline double RightBorder() const {return Right;};//Правая граница интервала
 inline double Step() const {return Delta;};//Шаг интервала
 inline ulong Size() const {return Count;};//Количество чисел, принадлежащих интервалу
 //Установка параметров равномерного закрытого интервала
 void Set(double a, double b, double step = 0.1);
 inline void SetLeft(double a) {Set(a,Right,Delta);};//Установка левой границы
 inline void SetRight(double b) {Set(Left,b,Delta);};//Установка правой границы
 inline void SetStep(double step) {Set(Left,Right,step);};//Установка шага интервала
 //Получение n-го числа, принадлежащего интервалу, 0 <= n < N
 double Number(ulong n) const;
 inline double operator() (ulong n) const {return Number(n);};
 //Преобразование интервала в вектор вещественных чисел
 void Copy(rvector& Data) const;
 //Формирование свойств интервала в виде символьной строки
 string& Properties(string& s, const string& head, uint indent = 0) const;
 string& Info(string& s) const;
 //OVERLOAD THE STREAM INSERTION OPERATOR
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator <<(ostream& out, const TEvenCloseInterval& Gap);
 //Ввод параметров интервала с консоли
 void Edit(const string& head);
 //Перегрузка оператора присваивания (=) для класса TEvenCloseInterval
 TEvenCloseInterval& operator =(const TEvenCloseInterval& Gap);
 //Установка пустого интервала
 void Clear() {Left = Right = Delta = Count = 0;};
 //Проверка интервал на пустой
 bool IsEmpty() const {return (Size()) ? false : true;};
};//Завершение объявления класса TEvenCloseInterval
//------------------ Завершение класса TEvenCloseInterval ----------------------

//****************************************************************************************
//Объявление класса TPoint_2D - математическое описание точки на плоскости
//Copyright (c) JohnSoft 2005. All rights reserved.
//Initial date: May,31,2005;
//Класс TPoint_2D представляет описание точки на плоскости, которая представляется двумя
//координатами x и y. Значения координат точки представляются в формате double.
//****************************************************************************************
class TPoint_2D {
 //---------------------------------------------------------------------------------------
 // ОБЪЯВЛЕНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ДАННЫХ КЛАССА TPoint_2D
 //---------------------------------------------------------------------------------------
 protected:
  double _x;//Значение координаты точки по оси Ox
  double _y;//Значение координаты точки по оси Oy
 //---------------------------------------------------------------------------------------
 // I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TPoint_2D
 //---------------------------------------------------------------------------------------
 public:
 //***************************************************************************************
 // ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TPoint_2D
 //***************************************************************************************
 TPoint_2D() {Init();};//Объявление конструктора по умолчанию
 //Объявление конструктора с аргументами
 TPoint_2D(double x, double y) {Set(x,y);};
 //Объявление конструктора копирования
 TPoint_2D(const TPoint_2D& Point) {*this = Point;};
 //Объявление деструктора класса
 ~TPoint_2D() {Init();};
 //***************************************************************************************
 // ОБЩЕДОСТУПНЫЕ ФУНКЦИИ ДЛЯ РАБОТЫ С КЛАССОМ TPoint_2D
 //***************************************************************************************
 //Установка свойств точки на плоскости
 void Set(double x, double y) {_x = x; _y = y;};
 double SetX(double x) {return _x = x;};
 double SetY(double y) {return _y = y;};
 bool Set(const char* s);
 bool Set(const string& s) {return Set(s.c_str());};
 //Получение свойств точки на плоскости
 double GetX() const {return _x;};
 double GetY() const {return _y;};
 void Get(double& x, double& y) const {x = GetX(); y = GetY();};
 void Get(TPoint_2D& Point) const {Point.Set(GetX(),GetY());};
 //Получение свойств класса в виде строкового объекта string
 string& Properties(string &s) const;
 string& Brief(string &s) const;
 //Вычисление нормы (квадрат расстояния от данной точки до начала координат (0,0))
 double norm() const {return _x*_x + _y*_y;};

 //Объявление перегруженного оператора присваивания operator =
 void operator =(const TPoint_2D& Point);
 //Объявление перегруженного оператора сравнения operator ==
 bool operator ==(const TPoint_2D& Point) const;
 //Объявление перегруженного оператора сравнения operator <
 bool operator <(const TPoint_2D& Point) const;

 //***************************************************************************************
 // ДРУЖЕСТВЕННЫЕ ФУНКЦИИ КЛАССА TPoint_2D
 // 1. ФУНКЦИИ ВВОДА - ВЫВОДА ПАРАМЕТРОВ
 //***************************************************************************************
 //Перегрузка оператора вывода (<<) для вывода параметров класса
 friend ostream& operator <<(ostream& out, const TPoint_2D& Point);
 //Перегрузка оператора ввода (>>) для ввода параметров класса
 friend bool operator >>(istream& in, TPoint_2D& Point);
 //Ввод параметров объекта из стандартного потока ввода cin
 friend bool Edit(TPoint_2D& Point);

 //---------------------------------------------------------------------------------------
 // II. ОБЪЯВЛЕНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TPoint_2D
 //---------------------------------------------------------------------------------------
 protected:
  void Init() {_x = _y = 0.0;}; //Начальная установка всех характеристик TPoint_2D
};
//Конец объявления класса TPoint_2D
//The end of class TPoint_2D declaration

//****************************************************************************************
//                      Объявление класса TSettingsTF
//      ПАРАМЕТРЫ РАСЧЕТА ПЕРЕДАТОЧНЫХ ФУНКЦИЙ C ОДНОЙ УГЛОВОЙ КООРДИНАТОЙ
//Класс содержит данные, необходимые для расчета передаточных функций пространственных
//фильтров, антенн, LAA и т.д. в заданном секторе (по одной угловой координате) и типом
//последующей нормировки, вычисленных значений. Класс описывается следующим образом:
//1) TEvenCloseInterval Sector - угловой сектор, в котором рассчитывается передаточная
//   функция: [a,a+delta .. b] в градусах, где  a - начальный угол, b - конечный угол и
//   delta - шаг интервала (дискретность отсчетов);
//2) enNormType NormType - тип нормирования значений:
//   a) UnNormalized - без нормирования;
//   b) Normalized - нормировка в пределах [0..1];
//   c) NormalizedDB - нормирование в децибелах;
//3) double MinDB - минимальный порог в dB при нормировке вычисленных значений в децибелах;
//4) bool _GroupNorm - групповое или индивидуальное нормирование каждого канала при вычис-
//   лении передаточных функций нескольких каналов.
//Класс предоставляет интерфейс по хранению, получению и изменению (редактированию) парамет-
//ров для вычисления передаточной функции, исследуемого объекта или процесса.
//****************************************************************************************
class TSettingsTF {
//----------------------------------------------------------------------------------------
// Объявление защищенных членов-данных класса TSettingsTF
//----------------------------------------------------------------------------------------
protected:
 TEvenCloseInterval _Sector;//Угловой сектор, в котором рассчитывается передаточная ф-ция
 enNormType _NormType;      //Тип нормирования
 double _MinDB;             //Минимальный уровень в децибелах
 bool _GroupNorm;           //Признак групповой или индивидуальной нормировки
//----------------------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TSettingsTF
//----------------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TSettingsTF() {SetDefault();};
 //Конструктор с аргументами
 TSettingsTF(double StartAngle, double EndAngle, double Step, enNormType Type,
             double MindB = -60.0)
             {SetSector(StartAngle,EndAngle,Step); SetNormType(Type,MindB);};
 //Объявление конструктора копирования
 TSettingsTF(const TSettingsTF &Obj) {*this = Obj;};
 //Объявление деструктора класса
 ~TSettingsTF() {Reset();};
//----------------------------------------------------------------------------------------
// Объявление общедоступных членов-функций класса TSettingsTF
//----------------------------------------------------------------------------------------
 void Reset() //Начальная установка свойств класса
 {_Sector.Clear(); _NormType = UnNormalized; _MinDB = 0.0; _GroupNorm = false;};
 //Установка свойств класса по умолчанию
 void SetDefault();
 //Готовность класса к выдаче данных для вычисления передаточной функции
 bool IsReady() const {return (this->Count() > 0) ? true : false;};

 //Получение свойств класса
 double Start() const {return _Sector.LeftBorder();};//Начальный угол в градусах
 double End() const {return _Sector.RightBorder();};//Конечный угол в градусах
 double Step() const {return _Sector.Step();};//Шаг изменения углов в секторе в градусах
 ulong Count() const {return _Sector.Size();};//Кол-во отсчетных значений в секторе
 //Получение n-го числа, принадлежащего интервалу, 0 <= n < N
 double Number(ulong n) const {return _Sector.Number(n);};
 //Преобразование интервала в вектор вещественных чисел
 void Copy(rvector& Data) const {return _Sector.Copy(Data);};

 enNormType GetNormType() const {return _NormType;};//Тип нормирования
 double GetMindB() const {return _MinDB;};//Минимальный уровень при нормировании в dB
 bool GetGroupNorm() const {return _GroupNorm;};//Признак групповой нормировки
 //Проверка установки любого типа нормирования
 bool IsNormalize() const {return (_NormType != UnNormalized) ? true : false;};
 //Проверка на нормирование в децибелах
 bool IsNormDB() const
 {return (_NormType == Norm_10Lg || _NormType == Norm_10Lg) ? true : false;};

 //Установка свойств класса
 ulong SetSector(double StartAngle, double EndAngle, double Step)
 {_Sector.Set(StartAngle,EndAngle,Step); return Count();};
 //Установка типа нормирования и минимального значения при нормировании в dB
 void SetNormType(enNormType Type, double MindB = -60.0)
 {_NormType = Type; SetMinDB(MindB);};
 //Установка минимального значения в dB
 double SetMinDB(double Min) {return _MinDB = (Min >= 0) ? -60.0 : Min;};
 //Установка признака группового нормирования
 bool SetGroupNorm(bool lNorm) {return _GroupNorm = lNorm;};

 //---------------------------------------------------------------------------------------
 //Формирование свойств класса в символьном виде
 //---------------------------------------------------------------------------------------
 string& Sector(string& s) const;
 string& NormType(string& s) const;
 string& GroupNorm(string& s) const;
 string& About(string& s) const;

 //Консольное редактирование свойств класса TSettingsTF
 void EditSector();
 void EditNormType();
 void EditGroupNorm();
 friend void Edit(TSettingsTF& Obj);

 //Нормирование вектора входных данных In в соответствии с установленным типом нормирования
 //с последующим размещением результатов в матрице Out в следующем формате:
 //Out[][0] - значения углов, принадлежащих угловому сектору Sector;
 //Out[][1] - нормированные значения из вектора In
 bool MakeReport(rmatrix& Out, const rvector& In) const;
 //Формирование табличной формы отчета из матрицы входных данных In в соответствии с уста-
 //новками по нормированию. Первый столбец матрицы Out содержит значения углов.
 bool MakeReport(rmatrix& Out, const rmatrix& In) const;

 //---------------------------------------------------------------------------------------
 //Перегрузка операторов для класса TSettingsTF
 //---------------------------------------------------------------------------------------
 //Получение n-го числа, принадлежащего интервалу, 0 <= n < N
 double operator() (ulong n) const {return _Sector.Number(n);};
 //Перегрузка оператора присваивания (=)
 TSettingsTF& operator =(const TSettingsTF& Obj);
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator <<(ostream& out, const TSettingsTF& Obj);

};//Завершение объявления класса TSettingsTF
//-------------------------- Завершение класса TSettingsTF -------------------------------


//****************************************************************************************
//          Объявление класса TDoubleSet - КОНТЕЙНЕР ВЕЩЕСТВЕННЫХ ЧИСЕЛ
//Класс реализует интерфейс по хранению, получению, модификации, редактированию чисел типа
//double. Контейнером для хранения выступает класс std::set, который допускает хранение
//только уникальных значений и их автоматическую сортировку по выбранному пользователем
//критерия (по умолчанию - по возрастанию).
//****************************************************************************************
class TDoubleSet {
//----------------------------------------------------------------------------------------
// Объявление защищенных членов-данных класса TDoubleSet
//----------------------------------------------------------------------------------------
protected:
 string _Name;//Наименование контейнера с данными
 DblSet _Set; //Контейнер вещественных чисел
//----------------------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TDoubleSet
//----------------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TDoubleSet() {Reset(); _Name.assign("DoubleSet");};
 //Конструктор с аргументами
 TDoubleSet(const char* Data, const char* Name,
            const TArgVectorPredicate<double,rvector>* Predicate = NULL)
 {this->Assign(Data,Predicate); this->SetName(Name);};
 
 //Объявление конструктора копирования
 TDoubleSet(const TDoubleSet &Obj) {*this = Obj;};
 //Объявление деструктора класса
 ~TDoubleSet() {Reset();};
//----------------------------------------------------------------------------------------
// Объявление общедоступных членов-функций класса TDoubleSet
//----------------------------------------------------------------------------------------
 //Получение свойств класса
 bool IsEmpty() const {return _Set.empty();};
 ulong Size() const {return _Set.size();};
 //Передача итераторов на начало и конец контейнера
 bool GetIters(DblSet::const_iterator& begin, DblSet::const_iterator& end) const
 {begin = _Set.begin(); end = _Set.end(); return !this->IsEmpty();};
 //Наименование, ассоциированное с элементами контейнера
 const char* Name() const {return _Name.c_str();};
 //Копирование данных из контейнера в вектор
 ulong GetData(rvector& V) const;

 //Установка свойств класса
 void Clear() {return _Set.clear();};
 bool Append(const double& value) {return _Set.insert(value).second;};
 bool Assign(const double& value) {this->Clear(); return this->Append(value);};
 //Извлечение из строки чисел и их добавление в контейнер
 ulong Append(const string& s, const TArgVectorPredicate<double,rvector> *Predicate = NULL);
 ulong Append(const char* str, const TArgVectorPredicate<double,rvector> *Predicate = NULL)
 {string s(str); return this->Append(s,Predicate);};
 //Извлечение из строки чисел и их присваивание контейнеру (с удалением прежних значений)
 ulong Assign(const string& s, const TArgVectorPredicate<double,rvector>* Predicate = NULL)
 {this->Clear(); return this->Append(s,Predicate);};
 ulong Assign(const char* str, const TArgVectorPredicate<double,rvector>* Predicate = NULL)
 {string s(str); return this->Assign(s,Predicate);};
 //Переименование контейнера с данными
 const string& SetName(const string& NewName);
 const string& SetName(const char* NewName) {string s(NewName); return this->SetName(s);};

 //---------------------------------------------------------------------------------------
 //Формирование свойств класса в символьном виде
 //---------------------------------------------------------------------------------------
 //Копирование вещественных чисел из контейнера _Set в строку t
 string& GetData(string& t) const;
 string& GetName(string& t) const {return t = _Name;};
 string& About(string& t, bool lBriefly) const;
 string& About(string& t, uint width, const char* pfx = NULL) const;
 //Формирование в строке t информации о данных, хранящихся в контейнере. Форма представле-
 //ния: <Size> {<_Set>}
 string& AboutData(string& t) const;
 //Формирование в строке t информации о диапазоне (интервале) хранимых в контейнере значе-
 //ний и его размере в формате: (Xmin..Xmax,<Size>)
 string& Range(string& t) const;
 ulong Range(double& Min, double& Max) const;
 //Консольное редактирование свойств класса TDoubleSet
 void EditData(const TArgVectorPredicate<double,rvector>* Predicate = NULL);
 void EditName();//Редактирование наименования контейнера
 void RemoveData();//Удаление из контейнера значений, введенных пользователем
 friend void Edit(TDoubleSet& Obj, const TArgVectorPredicate<double,rvector>* Predicate = NULL);

 //---------------------------------------------------------------------------------------
 //Операции с контейнером TDoubleSet
 //---------------------------------------------------------------------------------------
 //Поиск значения в контейнере
 bool Find(double rvalue) const;
 //Удаление из контейнера значения ivalue
 bool Remove(double rvalue) {return _Set.erase(rvalue);};
 //Удаление всех значений из контейнера, не принадлежащих интервалу [min..max]
 ulong RemoveOutSide(double min, double max);
 //Удаление из контейнера значений, не удовлетворяющих предикату Predicate
 ulong Filtering(const TArgVectorPredicate<double,rvector>* Predicate);

 //---------------------------------------------------------------------------------------
 //Перегрузка операторов для класса TDoubleSet
 //---------------------------------------------------------------------------------------
 //Перегрузка оператора присваивания (=)
 TDoubleSet& operator =(const TDoubleSet& Obj);
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator <<(ostream& out, const TDoubleSet& Obj);

 //---------------------------------------------------------------------------------------
 //Объявление защищенных членов-функций класса TDoubleSet
 //---------------------------------------------------------------------------------------
 protected:
  //Начальная установка свойств класса
  void Reset() {_Name.clear(); _Set.clear();};

};//Завершение объявления класса TDoubleSet
//--------------------------- Завершение класса TDoubleSet -------------------------------

//****************************************************************************************
//          Объявление класса TLongSet - КОНТЕЙНЕР ВЕЩЕСТВЕННЫХ ЧИСЕЛ
//Класс реализует интерфейс по хранению, получению, модификации, редактированию целых чисел
//типа long. Контейнером для хранения выступает класс std::set, который допускает хранение
//только уникальных значений и их автоматическую сортировку по выбранному пользователем
//критерия (по умолчанию - по возрастанию).
//****************************************************************************************
class TLongSet {
//----------------------------------------------------------------------------------------
// Объявление защищенных членов-данных класса TLongSet
//----------------------------------------------------------------------------------------
protected:
 string _Name; //Наименование контейнера с данными
 LongSet _Set; //Контейнер вещественных чисел
//----------------------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TLongSet
//----------------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TLongSet() {Reset(); _Name.assign("LongSet");};
 //Конструктор с аргументами
 TLongSet(const char* Data, const char* Name)
 {this->Assign(Data); this->SetName(Name);};

 //Объявление конструктора копирования
 TLongSet(const TLongSet &Obj) {*this = Obj;};
 //Объявление деструктора класса
 ~TLongSet() {Reset();};
//----------------------------------------------------------------------------------------
// Объявление общедоступных членов-функций класса TLongSet
//----------------------------------------------------------------------------------------
 //Получение свойств класса
 bool IsEmpty() const {return _Set.empty();};
 ulong Size() const {return _Set.size();};
 //Передача итераторов на начало и конец контейнера
 bool GetIters(LongSet::const_iterator& begin, LongSet::const_iterator& end) const
 {begin = _Set.begin(); end = _Set.end(); return !this->IsEmpty();};
 //Наименование, ассоциированное с элементами контейнера
 const char* Name() const {return _Name.c_str();};
 //Копирование данных из контейнера в вектор
 ulong GetData(ivector& V) const;

 //Установка свойств класса
 void Clear() {return _Set.clear();}
 bool Append(const long& value) {return _Set.insert(value).second;};
 bool Assign(const long& value) {this->Clear(); return this->Append(value);};
 ulong AssignData(const TLongSet& LSet);
 //Присваивание контейнеру чисел из интервала [min,min+delta .. max]
 ulong Assign(long min, long max, long delta = 1);

 //Извлечение из строки чисел и их добавление в контейнер
 ulong Append(const string& s, const TArgVectorPredicate<long,ivector> *Predicate = NULL);
 ulong Append(const char* str, const TArgVectorPredicate<long,ivector> *Predicate = NULL)
 {string s(str); return this->Append(s,Predicate);};
 //Извлечение из строки чисел и их присваивание контейнеру (с удалением прежних значений)
 ulong Assign(const string& s, const TArgVectorPredicate<long,ivector> *Predicate = NULL)
 {this->Clear(); return this->Append(s,Predicate);};
 ulong Assign(const char* str, const TArgVectorPredicate<long,ivector> *Predicate = NULL)
 {string s(str); return this->Assign(s,Predicate);};
 //Переименование контейнера с данными
 const string& SetName(const string& NewName);
 const string& SetName(const char* NewName) {string s(NewName); return this->SetName(s);};

 //---------------------------------------------------------------------------------------
 //Формирование свойств класса в символьном виде
 //---------------------------------------------------------------------------------------
 //Копирование целых чисел из контейнера _Set в строку t
 string& GetData(string& t) const;
 string& GetName(string& t) const {return t = _Name;};
 string& About(string& t, bool lBriefly) const;
 string& About(string& t, uint width, const char* pfx = NULL) const;
 //Копирование данных из контейнера _Set в строку t с выделением интервалов
 ulong DataToStr(string& t) const;
 //Формирование в строке t информации о данных, хранящихся в контейнере, с возможностью
 //объединения их в интервалы. Форма предствления: <Size> {<_Set>}
 string& AboutData(string& t) const;
 //Формирование в строке t информации о диапазоне (интервале) хранимых в контейнере значе-
 //ний и его размере в формате: (Xmin..Xmax,<Size>)
 string& Range(string& t) const;
 ulong Range(long& Min, long& Max) const;
 //Консольное редактирование свойств класса TLongSet
 void EditData(const TArgVectorPredicate<long,ivector> *Predicate = NULL);
 void EditName();
 friend void Edit(TLongSet& Obj, const TArgVectorPredicate<long,ivector> *Predicate = NULL);
 friend void EditData(TLongSet& Obj, string& head,
                      const TArgVectorPredicate<long,ivector> *Predicate = NULL);
 //---------------------------------------------------------------------------------------
 //Операции с контейнером TLongSet
 //---------------------------------------------------------------------------------------
 //Поиск значения в контейнере
 bool Find(long ivalue) const;
 //Удаление из контейнера значения ivalue
 bool Remove(long ivalue) {return _Set.erase(ivalue);};
 //Удаление всех значений из контейнера, не принадлежащих интервалу [min..max]
 ulong RemoveOutSide(long min, long max);
 //Получение значения первого элемента контейнера
 bool GetFirst(long& ival) const;
 //Получение значения последнего элемента контейнера
 bool GetLast(long& ival) const;
 //Присваивание контейнеру значений из интервала [min..max] количеством не более max_count
 //с исключением значений, принадлежащих множеству Derating
 ulong Assign(long min, long max, const TLongSet& Derating, ulong max_count = 0);
 //Присваивание контейнеру значений из интервала [min..max] количеством не более max_count
 //Контейнер StrongRestrict задает значения, которые не должны принадлежать исходному
 //контейнеру, контейнер WeakRestrict задает значения, присутствие которых нежелательно в
 //исходном контейнере, с учетом их принадлежности интервалу [min..max]
 ulong Assign(long min, long max, const TLongSet& StrongRestrict,
              const TLongSet& WeakRestrict, ulong max_count = 0);


 //---------------------------------------------------------------------------------------
 //Перегрузка операторов для класса TLongSet
 //---------------------------------------------------------------------------------------
 //Перегрузка оператора присваивания (=)
 TLongSet& operator =(const TLongSet& Obj);
 //Перегрузка оператора сравнения (==)
 friend bool operator ==(const TLongSet& A, const TLongSet& B);
 //Перегрузка оператора неравенства (!=)
 friend bool operator !=(const TLongSet& A, const TLongSet& B)
 {return (A == B) ? false : true;};

 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator <<(ostream& out, const TLongSet& Obj);

 //---------------------------------------------------------------------------------------
 //Объявление защищенных членов-функций класса TLongSet
 //---------------------------------------------------------------------------------------
 protected:
  //Начальная установка свойств класса
  void Reset() {_Name.clear(); _Set.clear();};

};//Завершение объявления класса TLongSet
//--------------------------- Завершение класса TLongSet -------------------------------

//****************************************************************************************
//                    Объявление класса TNumSimulationOpts
//Copyright (c) JohnSoft 2006. All rights reserved. Initial date: July,21,2006.
//Установки, используемые при численном моделировании адаптивных пространственных фильтров
//Класс описывает параметры необходимые для проведения численного моделирования с дискрет-
//ным неотрицательным временем. Данный класс описывается следующим образом:
//1. Time - общее время моделирования (Time > 0), положительное целочисленное значение;
//2. CheckPoint - список значений контрольных точек, в которых необходимо произвести
//   определенные действия (произвести измерения, запомнить результаты, уведомить пользо-
//   вателя и т.д.). Все значения контрольных точек должны принадлежать интервалу [0..Time]
//   и быть целочисленными значениями;
//3. UseSignal - использование полезного сигнала в ковариационной матрице входного
//   воздействия при расчете весовых коэффициентов пространственного фильтра (тип bool);
//4. enCalcTFOpts (перечислымый тип) - варианты вычисления передаточной функции фильтра:
//   a) TF_Disable - передаточная функция не вычисляется;
//   b) TF_ByFinRes - передаточная функция вычисляется в конце моделирования;
//   c) TF_ByCheckPts - передаточная функция вычисляется во всех контрольных точках
//5. TSettingsTF - установки расчета передаточных функций с одной угловой координатой:
//   a) Угловой сектор, в котором вычисляется передаточная функция;
//   b) Тип нормирования, вычисленных значений мощности передаточной функции.
//****************************************************************************************
class TNumSimulationOpts {
 //---------------------------------------------------------------------------------------
 // ОБЪЯВЛЕНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ДАННЫХ КЛАССА TNumSimulationOpts
 //---------------------------------------------------------------------------------------
 protected:
  ulong _Time;//Дискретное положительное общее время моделирования
  TLongSet _CheckPoint;//Отсортированный список контрольных точек
  bool _UseSignal;//Использование полезного сигнала при настройке весов фильтра
  enCalcTFOpts _CalcTFOpts;//Варианты вычисления передаточной функции
  TSettingsTF _TFSets;//Установки расчета передаточных функций с одной угловой координатой

 //---------------------------------------------------------------------------------------
 // I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TNumSimulationOpts
 //---------------------------------------------------------------------------------------
 public:
 //***************************************************************************************
 // ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TNumSimulationOpts
 //***************************************************************************************
 TNumSimulationOpts() {SetDefault();};//Объявление конструктора по умолчанию
 //Объявление деструктора класса
 ~TNumSimulationOpts() {Reset();};

 //---------------------------------------------------------------------------------------
 // Объявление общедоступных членов-функций класса TSettingsTF
 //---------------------------------------------------------------------------------------
 void Reset();//Начальная установка свойств класса
 void SetDefault();//Установка свойств класса по умолчанию
 //Готовность класса к проведению численного моделирования
 bool IsReady() const {return (_Time > 0) ? true : false;};

 ulong SetTime(ulong Tmax);//Установка длительности моделирования
 ulong GetTime() const {return this->_Time;};//Длительность моделирования
 string& GetTime(string& s) const;//Время моделирования в символьном виде: Time: <ivalue>

 //Установка значений контрольных точек
 bool SetCheckPoint(ulong ChPoint, bool lAppend = false);
 ulong SetCheckPoints(const char* str, bool lAppend = false);
 ulong SetCheckPoints(const string& s, bool lAppend = false)
 {return this->SetCheckPoints(s.c_str(),lAppend);};
 //Число установленных контрольных точек
 ulong GetCheckPoints() const {return _CheckPoint.Size();};
 //Получение значений контрольных точек в виде: CheckPoint: <Count> {<CheckPoint List>}
 string& GetCheckPoints(string& s) const;

 //Установка опции включения полезного сигнала при настройке весовых коэффициентов фильтра
 bool SetUseSignal(bool lSignal)
 {return _UseSignal = (this->IsReady()) ? lSignal : false;};
 //Значение опции использования полезного сигнала
 bool GetUseSignal() const {return this->_UseSignal;};
 //Значение опции использования полезного сигнала в виде: Signal: <Enable | Disable>
 string& GetUseSignal(string& s) const;

 //Установка вариантов вычисления передаточной функции
 enCalcTFOpts TF_SetCalcMode(enCalcTFOpts Mode);
 //Получение варианта вычисления передаточной функции
 enCalcTFOpts TF_GetCalcMode() const {return this->_CalcTFOpts;};
 //Значение опции вычисления TF в символьном виде:
 //<TF_CalcMode: Disable | ByFinRes | ByCheckPts>
 string& TF_GetCalcMode(string& s) const;
 //Установка сектора расчета передаточной функции
 ulong TF_SetSector(double StartAngle, double EndAngle, double Step);
 //Установка типа нормирования и минимального значения при нормировании в dB
 enNormType TF_SetNormType(enNormType Type, double MindB = -60.0);
 //Установка минимального значения в dB
 double TF_SetMinDB(double Min);
 //Настройки вычисления передаточной функции в символьном виде
 string& TF_Settings(string& s) const;
 //Проверка возможности использования настроек для вычисления передаточной функции
 bool TF_IsReady() const {return (_CalcTFOpts != TF_Disable) ? true : false;};
 //Кол-во отсчетных значений в секторе
 ulong TF_Count() const {return (this->TF_IsReady()) ? _TFSets.Count() : 0;};
 //Получение n-го числа, принадлежащего интервалу, 0 <= n < N
 double TF_Number(ulong n) const {return _TFSets.Number(n);};
 //Нормирование вектора входных данных In в соответствии с установленным типом нормирования
 //с последующим размещением результатов в матрице Out в следующем формате:
 //Out[][0] - значения углов, принадлежащих угловому сектору Sector;
 //Out[][1] - нормированные значения из вектора In
 bool TF_MakeReport(rmatrix& Out, const rvector& In) const
 {return _TFSets.MakeReport(Out,In);};
 //Формирование табличной формы отчета из матрицы входных данных In в соответствии с уста-
 //новками по нормированию. Первый столбец матрицы Out содержит значения углов.
 bool TF_MakeReport(rmatrix& Out, const rmatrix& In)
 {_TFSets.SetGroupNorm(false); return _TFSets.MakeReport(Out,In);};

 //Свойства TNumSimulationOpts в виде строкового объекта string
 string& Info(string& s, uint width = 80) const;
 //Проверка на принадлежность значения time контрольной точке
 bool IsCheckPoint(ulong time) const;

 //---------------------------------------------------------------------------------------
 // ДРУЖЕСТВЕННЫЕ ФУНКЦИИ КЛАССА TNumSimulationOpts
 //---------------------------------------------------------------------------------------
 //Перегрузка оператора вывода (<<) для вывода параметров класса
 friend ostream& operator <<(ostream& out, const TNumSimulationOpts& Obj);
 //Ввод параметров объекта из стандартного потока ввода cin
 friend void Edit(TNumSimulationOpts& Obj);

 //---------------------------------------------------------------------------------------
 // II. ОБЪЯВЛЕНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TNumSimulationOpts
 //---------------------------------------------------------------------------------------
 protected:
  //*************************************************************************************
  //Консольное редактирование членов-данных класса
  //*************************************************************************************
  void Edit_Time();//Ввод времени моделирования
  void Edit_UseSignal();//Ввод опции использования полезного сигнала при настройке фильтра
  void Edit_CheckPoints();//Ввод значений контрольных точек
  void Edit_TFSettings();//Ввод опций вычисления передаточной функции
  void Edit_TFCalcMode();//Установка вариантов расчета передаточной функции
  void Edit_TFNormType();//Ввод типа нормирования передаточной функции


};
//Конец объявления класса TNumSimulationOpts
//The end of class TNumSimulationOpts declaration


//****************************************************************************************
//    Объявление класса TNumSimulationParams - характеристики численного моделирования
//Copyright (c) JohnSoft 2005. All rights reserved.
//Initial date: August,22,2005;
//Класс описывает параметры необходимые для проведения численного моделирования с дискрет-
//ным неотрицательным временем. Данный класс описывается следующим образом:
//1. Time - общее время моделирования (Time > 0), положительное целочисленное значение;
//2. CheckPoints - список значений контрольных точек, в которых необходимо произвести
//   определенные действия (произвести измерения, запомнить результаты, уведомить пользо-
//   вателя и т.д.). Все значения контрольных точек должны принадлежать интервалу [0..Time]
//   и быть целочисленными значениями.
//****************************************************************************************
class TNumSimulationParams {
 //---------------------------------------------------------------------------------------
 // ОБЪЯВЛЕНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ДАННЫХ КЛАССА TNumSimulationParams
 //---------------------------------------------------------------------------------------
 protected:
  ulong _Time;//Дискретное положительное общее время моделирования
  deque<ulong> _CheckPoint;//Отсортированный список контрольных точек
  enCheckPointOpts _Mode;//Вариант установки контрольных точек
 //---------------------------------------------------------------------------------------
 // I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TNumSimulationParams
 //---------------------------------------------------------------------------------------
 public:
 //***************************************************************************************
 // ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TNumSimulationParams
 //***************************************************************************************
 TNumSimulationParams() {_Init();};//Объявление конструктора по умолчанию
 //Объявление конструктора с аргументами
 TNumSimulationParams(ulong Duration) {_Init(); Set(Duration);};
 TNumSimulationParams(ulong Duration, const char* CheckPoints)
 {_Init(); Set(Duration,CheckPoints);};
 TNumSimulationParams(const char* CheckPoints) {_Init(); Set(CheckPoints,false);};
 TNumSimulationParams(const string& CheckPoints) {_Init(); Set(CheckPoints,false);};
 //Объявление конструктора копирования
 TNumSimulationParams(const TNumSimulationParams& Object) {*this = Object;};
 //Объявление деструктора класса
 ~TNumSimulationParams() {_Init();};
 //***************************************************************************************
 // ОБЩЕДОСТУПНЫЕ ФУНКЦИИ ДЛЯ РАБОТЫ С КЛАССОМ TNumSimulationParams
 //***************************************************************************************
 //Установка свойств параметров численного моделирования с дискретным временем
 //Изменение варианта установки контрольных точек
 bool SetCheckPointMode(enCheckPointOpts NewOption, ulong Param = 0L);
 ulong Set(ulong Duration);//Установка времени моделирования
 //Установка значений контрольных точек
 ulong Set(const string& sCheckPoints, bool lStrict = true);
 ulong Set(const char* sCheckPoints, bool lStrict = true);
 //Установка длительности моделирования и контрольных точек
 ulong Set(ulong Duration, const string& sCheckPoints);
 ulong Set(ulong Duration, const char* sCheckPoints);

 //Проверка на принадлежность значения time контрольной точке
 bool IsCheckPoint(ulong time) const;

 //Получение свойств класса
 ulong GetDuration() const {return _Time;};
 enCheckPointOpts GetCheckPointMode() const {return _Mode;};
 ulong GetCheckPointsNumber() const;
 ulong GetCheckPoints(string& s) const;
 ulong GetCheckPoints(string& s, ulong MaxWidth, const char* sfx = NULL) const;
 void Get(ulong& Duration, string& s) const
 {Duration = this->GetDuration(); GetCheckPoints(s);};
 //Получение свойств класса в виде строкового объекта string
 string& Properties(string &s, ulong MaxWidth = 80L) const;
 string& Brief(string &s, ulong MaxWidth = 80L) const;

 //Объявление перегруженного оператора присваивания operator =
 void operator =(const TNumSimulationParams& Object);
 //Объявление перегруженного оператора сравнения operator ==
 bool operator ==(const TNumSimulationParams& Object) const;
 bool operator ==(const long& time) const;

 //***************************************************************************************
 // ДРУЖЕСТВЕННЫЕ ФУНКЦИИ КЛАССА TNumSimulationParams
 // 1. ФУНКЦИИ ВВОДА - ВЫВОДА ПАРАМЕТРОВ
 //***************************************************************************************
 //Перегрузка оператора вывода (<<) для вывода параметров класса
 friend ostream& operator <<(ostream& out, const TNumSimulationParams& Object);
 //Перегрузка оператора ввода (>>) для ввода параметров класса
 //friend bool operator >>(istream& in, TNumSimulationParams& Object);
 //Ввод параметров объекта из стандартного потока ввода cin
 friend long Edit(TNumSimulationParams& Object);

 //---------------------------------------------------------------------------------------
 // II. ОБЪЯВЛЕНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TNumSimulationParams
 //---------------------------------------------------------------------------------------
 protected:
  void _HndlDurationChange();//Обработчик изменения длительности интервала моделирования
  void _Init(); //Начальная установка характеристик TNumSimulationParams

};
//Конец объявления класса TNumSimulationParams
//The end of class TNumSimulationParams declaration



//--------------------------- The end of file "mathlib.h" --------------------------------
#endif //ЗАВЕРШЕНИЕ ОБЪЯВЛЕНИЯ ЗАГОЛОВОЧНОГО ФАЙЛА "MATHLIB.H"
