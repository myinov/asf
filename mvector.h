//mvector.h
//Объявление классов TComplexVector, TRealVector, TIntVector
//Copyright (c) JohnSoft 1999. All rights reserved.
//Initial date: March,8,1999; Final date:
//Файл содержит классы, который осуществляет хранение векторов, обращение к ее
//компонентам и основные операции, которые могут выполняться над векторами с
//комплексными, действительными и целыми числами. Каждый компонент комплексного
//вектора представлен числом типа complex (16 байт) - реальная часть число типа
//double (8 байт) и мнимая часть число типа double (8 байт). Каждый компонент
//действительной матрицы представлен числом типа double (8 байт). Допустимый
//диапазон, представления элементов векторов классов TComplexVector & TRealVector
//находится в пределах от 1.7x10-308 до 1.7x10+308, максимальное число значащих
//цифр компоненты - 19 цифр.
//Каждый элемент класса TIntVector представлен числом типа long (4 байта). Допус-
//тимый диапазон представления целых чисел данным вектором находится в пределах:
// - 2,147,483,647 до 2,147,483,647. Класс TIntVector не содержит функций, реа-
//лизующих операции линейной алгебры над его элементами. Данный класс служит для
//реализации математических операций над вещественными и комплексными векторами
//и матрицами, в которых осуществляется обработка элементов, имеющих определен-
//ные индексы (групп элементов).
//Классы TComplexVector и TRealVector могут представлять ВЕКТОРЫ-СТОЛБЦЫ и ВЕК-
//ТОРЫ-СТРОКИ.
//Назначение вышеперечисленных классов состоит в представлении векторов в памяти
//компьютера и осуществлении над ними преимущественно МАТЕМАТИЧЕСКИХ ОПЕРАЦИЙ -
//ОПЕРАЦИЙ ЛИНЕЙНОЙ АЛГЕБРЫ. Для представления любых других типов данных в виде
//вектора и осуществления над ними произвольных операций лучше воспользоваться
//стандартным контейнерным классом - vector.
//Максимальная допускаемая размерность векторов 4,294,967,296 строк (столбцов).
//За индекс первого элемента вектора принят 0 (ноль).

#if !defined(__MVECTOR_H)
#define __MVECTOR_H

#include "const.h"
#include "Predicate.hpp"
#pragma hdrstop

/*
class TComplexVector;
typedef TComplexVector cvector;

class TRealVector;
typedef TRealVector rvector;

class TIntVector;
typedef TIntVector ivector;
*/

//Виды сортировки элементов вектора
const bool ASCENDING  = true;//По возрастанию
const bool DESCENDING = false;//По убыванию

//Признак сортировки элементов вектора
const bool SORTED   = true;//Элементы вектора отсортированы
const bool UNSORTED = false;//Элементы вектора не отсортированы

//Максимальный размер (длина) вектора
const ulong MAX_SIZE = 4294967296L;

//Направление поиска элементов вектора
const bool FORWARD  = true;//Поиск в прямом направлении
const bool BACKWARD = false;//Поиск в обратном направлении

//-----------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ ИДЕНТИФИКАТОРОВ МЕР (NORM) ВЕКТОРОВ И МАТРИЦ
//Норма вектора (матрицы) является вещественнозначной функцией, определенная
//для всех векторов (комплексных и действительных) и для всех КВАДРАТНЫХ матриц
//(комплексных и действительных), кроме матриц и векторов нулевого размера. Нор-
//ма матрицы или вектора обозначаются следующим символом - ||A||. Вводятся сле-
//дующие 4 вида норм:
//1. ПЕРВАЯ НОРМА (КУБИЧЕСКАЯ) - FIRST_NORM, CUBIC_NORM:
// Для векторов: ||V|| = MAX|Vi| by i - норма по максимальному АБСОЛЮТНОМУ
// значению по всем элементам вектора. Для комплексных векторов и матриц абсолют-
// ное значение элемента Zi = X + jY вычисляется по формуле:
// |Zi| = sqrt(norm(Zi)) = (X^2 + Y^2)^(1/2). Здесь и далее запись |*| означает
// абсолютное значение (модуль) элемента вектора или матрицы.
// Для матриц: ||A|| = n*MAX|Aij| by i,j - норма по максимальному АБСОЛЮТНОМУ
// значению элемента матрицы помноженная на размерность матрицы A - n.
//2. ВТОРАЯ НОРМА (ОКТАЭДРИЧЕСКАЯ) - SECOND_NORM, OCTAHEDRAL_NORM:
// Для векторов: ||V|| = SUM|Vi| = |V1|+|V2|+...+|Vn| - сумма абсолютных значе-
// ний всех компонент вектора.
// Для матриц: ||A|| = SUM|Aij| = |A11|+|A12|+...+|Akl|+...+|Ann| - сумма абсо-
// лютных значений всех элементов матрицы A размерности n.
//3. ТРЕТЬЯ НОРМА (СФЕРИЧЕСКАЯ) - THIRD_NORM, SPHERICAL_NORM, EUCLIDEAN_NORM:
// Для векторов: ||V|| = sqrt(SUM|Vi^2| by i,j) - Евклидова норма (длина вектора)
// - квадратный корень из суммы квадратов абсолютных величин элементов вектора.
// Для матриц: ||A|| = sqrt(SUM[Aij^2] by i,j) - Евклидова норма или норма Фро-
// бениуса - квадратный корень из суммы квадратов абсолютных величин элементов
// квадратной матрицы. Евклидову норму для матриц можно определить по еще одной
// формуле: ||A|| = sqrt(Sp[A^t*A]), где Sp(*) - СЛЕД МАТРИЦЫ - сумма ее диаго-
// нальных элементов, A^t - транспонированная квадратная матрица A размера n.
//4. P-НОРМЫ, НОРМЫ ГЕЛЬДЕРА - P_NORM, HERLDER_NORM:
// Для векторов: ||V|| = {SUM|Vi|^p by i}^(1/p).
// Для матриц: ||A||p = {SUM[Aij]^p by i,j}^(1/p), p - показатель степени.
// Для p >= 1 - обобщенная матричная норма;  при 1 <= p <= 2 - матричная норма.
// Следует заметить, что все вышеприведенные нормы могут считаться нормами ГЕЛЬ-
// ДЕРА. При p = 1 - вторая норма; при p = 2 - евклидова норма. Первая (кубичес-
// кая) норма получается при p = INF (бесконечности).
// Матричные нормы часто используются при получении границ для спектрального ра-
// диуса Ra = max|EVi| by i, где EVi - собственные значения матрицы A. Для любой
// матричной нормы имеем: ||A|| >= Ra.
//------------------------------------------------------------------------------
//Первая (кубическая) норма
const uint FIRST_NORM = 1;
const uint CUBIC_NORM = 1;
//Вторая (октаэдрическая) норма
const uint SECOND_NORM = 2;
const uint OCTAHEDRAL_NORM = 2;
//Третья (сферическая, Евклидова) норма
const uint THIRD_NORM = 3;
const uint SPHERICAL_NORM = 3;
const uint EUCLIDEAN_NORM = 3;
//Нормы Гельдера или P-нормы
const uint P_NORM = 4;
const uint HERLDER_NORM = 4;

typedef struct norma
{
  double Value; //Величина нормы
  uint Type;    //Вид нормы
  uint Power;   //Степень нормы - для p-норм Гельдера
} NORMA;

//ОПИСАНИЕ СТРУКТУРЫ RM_NORM - НОРМА МАТРИЦЫ
typedef struct norm
{ uint Count; //Общее число норм, определенных для матрицы
  NORMA *Norm;//Массив значений норм и их классификация
} L_NORM;
//Описание указателя на структуру L_NORM
typedef L_NORM *pLNORM;

#if !defined(__MATRIX_H)
#include "matrix.h"
#endif //__MATRIX_H

using namespace std;

//***********************************************************************************
//Объявление структуры характеристик вектора - PF_VECTOR
//***********************************************************************************
typedef struct pf_vector
{ bool type;    //вектор-строка (true) или вектор-столбец (false)
  uint subtype; //расширенный тип вектора
  ulong size;   //размерность вектора
} PF_VECTOR;

typedef PF_VECTOR* pPF_VECTOR; //Указатель на структуру PF_VECTOR

//СПИСОК ОШИБОК, ВОЗНИКАЮЩИХ ПРИ РАБОТЕ С ВЕКТОРАМИ
const int V_SIZE_ERROR     = -1; //Несоответствие размерности вектора
const int V_TYPE_ERROR     = -2; //Несоответствие типа вектора
const int V_ZERO_ERROR     = -3; //Обращение к вектору нулевого размера
const int V_ACCESS_ERROR   = -4; //Обращение к несуществующим элементам вектора
const int V_DIVIDE_BY_ZERO = -5; //Попытка деления на ноль
const int V_SIZE_MISMATCH  = -6; //Несоответствие размерностей 2-х векторов
const int V_TYPE_MISMATCH  = -7; //Несоответствие типов 2-х векторов
const int V_UNKNOWN_TYPE   = -8; //Неизвестный тип вектора

//-----------------------------------------------------------------------------
//КЛАССИФИКАЦИЯ ВЕКТОРОВ rvector, cvector & ivector
//-----------------------------------------------------------------------------
//Типы векторов (type)
const bool ROW = true;  //Вектор-строка
const bool COL = false; //Вектор-столбец
        
//Расширенная классификация векторов (subtype)
const uint V_ZEROSIZE  = 0; //Вектор нулевого размера - 0
const uint V_NUMBER    = 1; //Вектор размером 1
const uint V_ORDINARY  = 2; //Обыкновенный вектор
const uint V_ZERO      = 3; //Вектор с нулевыми элементами
const uint V_UNIT      = 4; //Единичный вектор
const uint V_SCALAR    = 5; //Скалярный вектор (все элементы вектора одинаковы)

//***********************************************************************************
//Объявление класса - ВЕКТОР ДЕЙСТВИТЕЛЬНЫХ ЧИСЕЛ - TRealVector
//TRealVector осуществляет создание действительного вектора, хранение его элементов,
//выполнение основных математических операций над вещественными векторами и его эле-
//ментами, а также обеспечивает ряд других сервисных функций.
//***********************************************************************************
class TRealVector {
//Объявление дружественных классов

//-----------------------------------------------------------------------------------
//Объявление защищенных членов-данных класса
//-----------------------------------------------------------------------------------
protected:
 bool type;  //тип вектора: строка (ROW) или столбец (COL)
 ulong size; //размерность вектора
 //Указатель на одномерный массив хранения компонент действительного вектора
 double *data;
//-----------------------------------------------------------------------------------
//I. Объявление общедоступных членов-функций класса TRealVector
//-----------------------------------------------------------------------------------
public:
//-----------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TRealVector
//-----------------------------------------------------------------------------------
 //Объявление конструктора по умолчанию
 TRealVector();
 //Объявление конструкторов с аргументами
 TRealVector(ulong Size, bool Type, double Init = 0.0);
 TRealVector(ulong Size, bool Type, bool Init);
 //Объявление конструктора копирования
 TRealVector(const TRealVector& V);
 //Объявление деструктора класса
 ~TRealVector();
 //----------------------------------------------------------------------------------
 // Получение характеристик вектора
 //----------------------------------------------------------------------------------
 //Проверка на вектор-строку
 bool IsRow() const {return (type == ROW) ? true : false;};
 //Проверка на вектор-столбец
 bool IsColumn() const {return (type == COL) ? true : false;};
 //Определение размерности вектора
 ulong Size() const {return size;};
 ulong GetSize() const {return size;};
 //Определение типа вектора
 bool Type() const {return type;};
 bool GetType() const {return type;};
 uint SubType() const;//Определение подтипа вектора
 //Получение характеристик (свойств) вектора: тип и его размерность
 void Properties(ulong& Size, bool& Type) const {Size = size; Type = type;};
 void Properties(PF_VECTOR& Info) const
 {Info.type = Type(); Info.subtype = SubType(); Info.size = Size();};
 //----------------------------------------------------------------------------------
 //Получение свойств вектора в символьном виде
 string& Properties(string& s) const;
 //Наименование типа вектора (вектор-строка или вектор-столбец)
 string& GetType(string& s, bool brief = false, uint language = ENG) const;
 //Наименование подтипа вектора
 const char* GetSubType(uint language = ENG) const;
 string& GetSubType(string& s, uint language = ENG) const
 {return s = GetSubType(language);};
 //Полное наименование типа вектора (type + subtype)
 string& GetCompleteType(string& s, uint language = ENG) const;
 //Размещение элементов вектора в символьной строке
 string& GetData(string& s, uint precision = 6, string& delim = string(1,' ')) const;
 //Определение максимальной символьной длины элементов вектора
 uint MaxStrWidthElem(uint precision) const;

 //----------------------------------------------------------------------------------
 // Установка свойств вектора
 //----------------------------------------------------------------------------------
 //Установка нового размера вектора с опцией восстановления значений элементов
 //вектора предыдущего размера.
 bool Resize(const ulong NewSize, bool Restore = false);
 //Установка новых характеристик вектора
 bool Set(ulong Size, bool Type, double Init = 0.0);
 bool Set(ulong Size, bool Type, bool Init);
 bool SetType(bool NewType) {return type = NewType;};

 //Получение значения элемента вектора
 double Get(ulong Index) const {return data[Index];};
 //Установка нового значения элемента вектора
 void Put(ulong Index, double Value) {data[Index] = Value;};

 //----------------------------------------------------------------------------------
 //Инициализация элементов вектора случайными величинами
 //----------------------------------------------------------------------------------
 bool Random(double a = 0.0, double b = 1.0);//По равновероятному закону [a..b]
 bool Rand2PI();//По равновероятному закону [0..2PI]
 bool Gauss(double E = 0.0, double D = 1.0);//По нормальному закону
 bool Relay();//По закону Рэлея
 bool Exp(double t = 1.0);//По экспоненциальному закону

 //Консольное редактирование (ввод) элементов вектора
 void Edit(const string& name, bool confirm = true);
 //Получение значений элементов вектора в виде символьной строки
 string& ConvertToString(string& s, string& sep, string& etc, ulong count = 0) const;
 string& ToString(string& s, ulong MaxLenStr, uint precision) const;
 //Форматированный многострочный вывод элементов вектора в символьную строку
 ulong ToMultiLineString(string& s, ulong MaxLines = 0L, ulong MaxLenLine = 78,
       uint precision = 6, char cStart = '{', char cEnd = '}') const;
 //Получение элементов вектора из символьной строки преобразованием символьного
 //представления вещественных чисел и их интервалов из строчного в двоичный типа double
 ulong GetDataFromString(const string& source, bool unique = false,
                         const TArgVectorPredicate<double,rvector>* Predicate = NULL);
 //Преобразование строкового представления интервала вещественных чисел в вектор
 //вещественных чисел типа double
 ulong StrIntervalToVector(const string& source, double eps = 1e-10);

 //----------------------------------------------------------------------------------
 //Формирование подвектора из данного вектора
 //----------------------------------------------------------------------------------
 //Формирование подвектора из элементов вектора от индекса со значением left до
 //индекса со значением right
 rvector SubVector(ulong left, ulong right) const;
 //Формирование подвектора, состоящего из неповторяющихся значений элементов
 rvector Unique() const;
 bool Unique(rvector& SubVector) const;
 //Формирование подвектора по значениям индексов вектора Index
 rvector SubVector(const ivector& Index) const;
 //Формирование подвектора из элементов исходного вектора, значения которых
 //удовлетворяют объекту-предикату TArgVectorPredicate<double,rvector>
 rvector SubVector(const TArgVectorPredicate<double,rvector>& Predicate) const;
 bool SubVector(rvector& SubVector, const TArgVectorPredicate<double, rvector>& Predicate) const;

 //----------------------------------------------------------------------------------
 //Алгоритмы сортировки элементов вектора
 //----------------------------------------------------------------------------------
 //Пузырьковая модифицированная сортировка по возрастанию и убыванию элементов
 bool BubbleSort(bool direct = ASCENDING, ulong *permutations = NULL,
                 ulong *comparisons = NULL);
 //Пузырьковая модифицированная сортировка по возрастанию и убыванию элементов
 //с одновременной сортировкой столбцов матрицы (размерность вектора должна быть согласована
 //с количеством столбцов матрицы)
 bool BubbleSort(rmatrix& A, bool direct = ASCENDING);

 //Поиск заданного значения среди элементов вектора в заданном интервале
 bool Find(const double& value, ulong* index = NULL, bool sort = UNSORTED,
           ulong left = 0L, ulong right = MAX_SIZE, bool direct = FORWARD) const;

 //Поиск максимального и минимального по модулю чисел
 bool AbsMaxMin(double& Max, double& Min) const;

 //Поиск максимального и минимального чисел
 bool MaxMin(double& Max, double& Min) const;

 //Перестановка элементов вектора в заданном интервале в обратном порядке
 ulong Reverse(ulong left = 0L, ulong right = MAX_SIZE);

 //Присваивание значений элементов одного вектора другому вектору
 rvector Assign(const rvector& V, ulong pos = 0L, ulong* counter = NULL) const;

 //*****************************************************************************
 //             Операции Линейной Алгебры над Действетельными Векторами
 //   Все операции линейной алгебры производятся с копией исходного вектора.
 //*****************************************************************************
 //Операция транспонирования вещественного вектора
 rvector Transpose() const;

 //Перегрузка унарного оператора (!) для получения транспонированного вектора
 rvector operator !() const;

 //Определение норм (мер) вещественного вектора
 double FirstNorm() const;
 double SecondNorm() const;
 double ThirdNorm() const;
 double PNorm(uint p = 2) const;
 double Norm(uint type = EUCLIDEAN_NORM, uint p = 2) const;

 //Нормирование вещественного вектора
 rvector Normalization() const;
 bool Normalization(uint NormType, uint p = 0);
 bool Normalization(rvector& Out, uint NormType = FIRST_NORM, uint p = 0) const;
 bool NormalizeToDB(bool Power = true, double MindB = -60);
 bool NormalizeToDB(rvector& Out, bool Power = true, double MindB = -60) const;

 //Скалярное умножение двух векторов
 //(A,B) = A(a1,...,an)*B(b1,...,bn) = a1*b1+...+an*bn;
 bool ScalarProduct(const rvector& A, double& result) const;
 friend bool ScalarProduct(const rvector& A, const rvector& B, double& result);

 //Увеличение вектора на действительное число value
 //B(b1,...,bn) = const + A(a1,...,an), bi = ai + const
 friend rvector operator +(const double value, const rvector& V);
 //B(b1,...,bn) = A(a1,...,an) + const, bi = ai + const
 friend rvector operator +(const rvector& V, const double value);

 //Уменьшение вектора на действительное число value
 //B(b1,...,bn) = A(a1,...,an) - const, bi = ai - const
 friend rvector operator -(const rvector& V, const double value);

 //Умножение вектора на действительное число value
 //B(b1,...,bn) = const * A(a1,...,an), bi = ai * const
 friend rvector operator *(const double value, const rvector& V);
 //B(b1,...,bn) = A(a1,...,an) * const, bi = ai * const
 friend rvector operator *(const rvector& V, const double value);

 //Деление вектора на действительное число value
 //B(b1,...,bn) = A(a1,...,an) / const, bi = ai / const
 rvector operator /(const double value) const;

 //Сложение двух вещественных векторов
 //С(с1,...,cn) = A(a1,...,an) + B(b1,...,bn), ci = ai + bi;
 rvector operator +(const rvector& V) const;

 //Вычитание двух вещественных векторов
 //С(с1,...,cn) = A(a1,...,an) - B(b1,...,bn), ci = ai - bi;
 rvector operator -(const rvector& V) const;

 //Умножение двух вещественных векторов
 rmatrix operator *(const rvector& V) const;

 //Умножение вещественного вектора на вещественную матрицу слева и справа
 //Умножение на вещественную матрицу слева
 friend rvector operator *(const rvector& V, const rmatrix& A);
 //Умножение на вещественную матрицу справа
 friend rvector operator *(const rmatrix& A, const rvector& V);

 //Поэлементное умножение векторов одинаковых размеров
 rvector MultByItem(const rvector& V) const;
 cvector MultByItem(const cvector& V) const;

 //Сложение элементов вектора
 double SumByItem(ulong* counter = NULL) const;
 double SumByItem(ulong left, ulong right = MAX_SIZE, ulong* counter = NULL) const;
 double SumByItem(const ivector& index, bool check = false, ulong* counter = NULL) const;
 double SumByItem(const TArgVectorPredicate<double,rvector>& Predicate,
                  ulong* counter = NULL) const;

 //----------------------------------------------------------------------------------
 //Умножение вектора на элементарную матрицу и элементарные матрицы специального
 //                              вида (elementary matrix)
 //ПРАВИЛА УМНОЖЕНИЯ:
 //1. Элементарная матрица умножается на вектор-столбец СПРАВА
 //2. Элементарная матрица умножается на вектор-строку СЛЕВА
 //3. Элементарная матрица всегда КВАДРАТНАЯ
 //4. Размерности вектора и элементарной матрицы должны быть РАВНЫ и отличны от 0
 //ЭЛЕМЕНТАРНАЯ МАТРИЦА - матрица E = I + B, где I - единичная матрица, B - мат-
 //рица ранга единица, т.е. матрица с единичной главной диагональю и одним вне-
 //диагональным элементом отличным от нуля.
 //       |1        |
 //       |  1      |
 // Ekl = |    1    |, E(k,l) != 0, k=4,l=2.
 //       |  x   1  |
 //       |        1|
 //----------------------------------------------------------------------------------
 //Элементарные матрицы специального вида. К ним относятся:
 //1. Диагональная элементарная  матрица Dk (DiagonalEM). Диагональная матрица с
 //   элементами Dk(i,i)=1 для всех i != k и Dk(k,k)!=0.
 //      |1        |
 //      |  1      |
 // Dk = |    x    |, k = 3.
 //      |      1  |
 //      |        1|
 //2. Нижняя столбцовая элементарная матрица Lkc (LowerColumnEM).  Внедиагональные
 //   ненулевые элементы расположены только в k-м столбце под диагональю.
 //       |1        |
 //       |  1      |
 // Lkc = |    1    |, k = 3.
 //       |    x 1  |
 //       |    x   1|
 //3. Верхняя столбцовая элементарная матрица Ukc (UpperColumnEM). Внедиагональные
 //   ненулевые элементы расположены только в k-м столбце над диагональю.
 //       |1   x    |
 //       |  1 x    |
 // Ukc = |    1    |, k = 3.
 //       |      1  |
 //       |        1|
 //4. Полная столбцовая элементарная матрица Tkc (CompleteColumnEM). Внедиагональные
 //   ненулевые элементы расположены только в k-м столбце.
 //       |1   x    |
 //       |  1 x    |
 // Tkc = |    1    |, k = 3.
 //       |    x 1  |
 //       |    x   1|
 //5. Левая строчная элементарная матрица Lkr (LeftRowEM). Внедиагональные ненулевые
 //   элементы расположены только в k-й строке левее диагонали.
 //       |1        |
 //       |  1      |
 // Lkr = |x x 1    |, k = 3.
 //       |      1  |
 //       |        1|
 //6. Правая строчная элементарная матрица Ukr (RightRowEM). Внедиагональные ненулевые
 //   элементы расположены только в k-й строке справа от диагонали.
 //       |1        |
 //       |  1      |
 // Ukr = |    1 x x|, k = 3.
 //       |      1  |
 //       |        1|
 //7. Полная строчная элементарная матрица Tkr (CompleteRowEM). Внедиагональные
 //   ненулевые элементы расположены только в k-й строке.
 //       |1        |
 //       |  1      |
 // Tkr = |x x 1 x x|, k = 3.
 //       |      1  |
 //       |        1|
 //При умножении вектора на элементарную, специальную элементарную или группу специаль-
 //ных элементарных матриц используется в качестве элементарной обыкновенная квадратная
 //матрица. Квадратная матрица позволяет размещать группу элементарных специальных мат-
 //риц. Поэтому можно реализовать выполнение операций умножения вектора на несколько
 //элементарных матриц, элементы которых можно хранить в одной квадратной матрице. Нап-
 //ример, квадратная матрица размерности N, позволяет хранить одновременно N DiagonalEM,
 //N LowerColumnEM и N UpperColumnEM.
 //----------------------------------------------------------------------------------
 //Умножение на диагональную элементарную матрицу Dk
 //k < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool DiagonalEM(const rmatrix& Q, ulong k);
 //Умножение на диагональные элементарные матрицы Dk, k=[first..last]
 //first < last < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool DiagonalEM(const rmatrix& Q, ulong first, ulong last);
 //Умножение на все диагональные элементарные матрицы Dk, k=[0..Q.Rows()-1]
 //Q.Rows()==Q.Cols()==V.Size() != 0
 bool DiagonalEM(const rmatrix& Q);

 //Умножение на нижнюю столбцовую элементарную матрицу Lkc
 //k < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool LowerColumnEM(const rmatrix& Q, ulong k);
 //Умножение на нижние столбцовые элементарные матрицы Lkc, k=[first..last]
 //first < last < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool LowerColumnEM(const rmatrix& Q, ulong first, ulong last);
 //Умножение на все нижние столбцовые элементарные матрицы Lkc, k=[0..Q.Rows()-1]
 //Q.Rows()==Q.Cols()==V.Size() != 0
 bool LowerColumnEM(const rmatrix& Q);

 //Умножение на верхнюю столбцовую элементарную матрицу Ukc
 //k < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool UpperColumnEM(const rmatrix& Q, ulong k);
 //Умножение на верхние столбцовые элементарные матрицы Ukc, k=[first..last]
 //first < last < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool UpperColumnEM(const rmatrix& Q, ulong first, ulong last);
 //Умножение на все верхние столбцовые элементарные матрицы Ukc, k=[0..Q.Rows()-1]
 //Q.Rows()==Q.Cols()==V.Size() != 0
 bool UpperColumnEM(const rmatrix& Q);

 //Умножение на полную столбцовую элементарную матрицу Tkc
 //k < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool CompleteColumnEM(const rmatrix& Q, ulong k);
 //Умножение на полные столбцовые элементарные матрицы Tkc, k=[first..last]
 //first < last < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool CompleteColumnEM(const rmatrix& Q, ulong first, ulong last);
 //Умножение на все полные столбцовые элементарные матрицы Tkc, k=[0..Q.Rows()-1]
 //Q.Rows()==Q.Cols()==V.Size() != 0
 bool CompleteColumnEM(const rmatrix& Q);

 //Умножение на левую строчную элементарную матрицу Lkr
 //k < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool LeftRowEM(const rmatrix& Q, ulong k);
 //Умножение на левые строчные элементарные матрицы Lkr, k=[first..last]
 //first < last < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool LeftRowEM(const rmatrix& Q, ulong first, ulong last);
 //Умножение на все левые строчные элементарные матрицы Lkr, k=[0..Q.Rows()-1]
 //Q.Rows()==Q.Cols()==V.Size() != 0
 bool LeftRowEM(const rmatrix& Q);

 //Умножение на правую строчную элементарную матрицу Ukr
 //k < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool RightRowEM(const rmatrix& Q, ulong k);
 //Умножение на правые строчные элементарные матрицы Ukr, k=[first..last]
 //first < last < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool RightRowEM(const rmatrix& Q, ulong first, ulong last);
 //Умножение на все правые строчные элементарные матрицы Ukr, k=[0..Q.Rows()-1]
 //Q.Rows()==Q.Cols()==V.Size() != 0
 bool RightRowEM(const rmatrix& Q);

 //Умножение на полную строчную элементарную матрицу Tkr
 //k < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool CompleteRowEM(const rmatrix& Q, ulong k);
 //Умножение на полные строчные элементарные матрицы Tkr, k=[first..last]
 //first < last < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool CompleteRowEM(const rmatrix& Q, ulong first, ulong last);
 //Умножение на все полные строчные элементарные матрицы Tkr, k=[0..Q.Rows()-1]
 //Q.Rows()==Q.Cols()==V.Size() != 0
 bool CompleteRowEM(const rmatrix& Q);

 //Умножение на обыкновенную элементарную матрицу Bij
 //Q.Rows()==Q.Cols()==V.Size() != 0 && (row < Q.Rows()) && (col < Q.Cols())
 bool OrdinaryEM(const rmatrix& Q, ulong row, ulong col);
//-----------------------------------------------------------------------------------
//              ОБЪЯВЛЕНИЕ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ
//-----------------------------------------------------------------------------------
 //1. OVERLOAD THE CALL FUNCTION OPERATOR ()
 //Объявление перегруженного оператора вызова функции для доступа к элементу вектора
 //(одномерного массива). Используется в программах пользователя.
 double& operator() (ulong i);
 //Объявление перегруженного оператора вызова функции для доступа к элементу вектора
 //(одномерного массива). Эта версия вызывается в операторе присваивания и в конструк-
 //торе копирования.
 //This version is called in ASSIGNMENT OPERATOR and COPY the CONSTRUCTOR
 const double operator() (ulong i) const;
 //2. OVERLOAD THE SUBSCRIPT OPERATOR []
 //Объявление перегруженного оператора доступа к элементу массива для доступа к
 //элементу вектора (одномерного массива). Используется в программах пользователя.
 double& operator[] (ulong i);
 //Объявление перегруженного оператора [] для доступа к элементу вектора (одномерного
 //массива). Эта версия вызывается в операторе присваивания и в конструкторе копирования.
 //This version is called in ASSIGNMENT OPERATOR and COPY the CONSTRUCTOR
 const double operator[] (ulong i) const;

 //3. OVERLOAD THE ASSIGNMENT OPERATOR
 //Объявление перегруженного оператора присваивания operator =
 void operator =(const TRealVector& V);
 //4. OVERLOAD THE STREAM INSERTION OPERATOR
 //Перегрузка операции потокового вывода (<<) для отображения элементов вектора
 friend ostream& operator <<(ostream& out, const TRealVector& V);
 //5. OVERLOAD THE COMPARISON OPERATOR (==)
 //Объявление перегруженного оператора сравнения двух векторов operator ==
 bool operator ==(const TRealVector& V) const;
 //6. OVERLOAD THE ASSIGNMENT OPERATOR
 //Объявление перегруженного оператора присваивания operator = компонентам вектора
 //действительного значения
 bool operator =(const double value);

 //**********************************************************************************
 //I. Объявление функций определения типа вектора
 //**********************************************************************************
 //Проверка вектора на вектор нулевого размера
 bool IsZeroSize() const;
 //Проверка вектора со всеми нулевыми элементами
 bool IsZero() const;
 //Проверка на скалярный вектор (все элементы вектора равны a)
 bool IsScalar() const;
 //Проверка на единичный вектор (все элементы вектора равны 1)
 bool IsUnit() const;

//-----------------------------------------------------------------------------------
//         ОБЪЯВЛЕНИЕ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССУ TRealVector
//-----------------------------------------------------------------------------------
 //Определение максимальной символьной длины элементов вектора
 friend uint MaxStrLen(const TRealVector& V, uint precision);
 //Статистический анализ: определение математического ожидания Expectation и среднеквадра-
 //тичного отклонения MeanSquareDeviation по значениям вектора V
 friend bool StatAnalysis(const rvector& V, double& Expect, double& MeanSqDev);

//-----------------------------------------------------------------------------------
//II. Объявление закрытых членов-функций класса TRealVector
//-----------------------------------------------------------------------------------
private:
 void Initial();//Инициализация членов-данных класса при его конструировании
 //Создание вектора определенного размера в оперативной памяти
 bool Create();
 void Delete();//Удаление вектора из оперативной памяти

//-----------------------------------------------------------------------------------
//III. Объявление защищенных членов-функций класса TRealVector
//-----------------------------------------------------------------------------------
protected:
 //**********************************************************************************
 //III.1 Объявление функций консольного ввода элементов векторов
 //      различного типа
 //**********************************************************************************
 //Ввод элементов вектора-строки и вектора-столбца действительных чисел
 void InPutVector(const string& name, bool confirm = true);
 //Ввод элементов скалярных вектора-строки или вектора-столбца
 void InPutScalar(const string& name, bool confirm = true);
};
/**** КОНЕЦ ОБЪЯВЛЕНИЯ КЛАССА - ДЕЙСТВИТЕЛЬНЫЙ ВЕКТОР - class TRealVector ****/

//***********************************************************************************
//Объявление класса - ВЕКТОР КОМПЛЕКСНЫХ ЧИСЕЛ - TComplexVector
//TComplexVector осуществляет создание комплексного вектора, хранение его элементов,
//выполнение основных математических операций над комплексными векторами и его элемен-
//тами, а также обеспечивает ряд других сервисных функций.
//***********************************************************************************
class TComplexVector {
//Объявление дружественных классов
//-----------------------------------------------------------------------------------
//Объявление защищенных членов-данных класса
//-----------------------------------------------------------------------------------
protected:
 bool type;  //тип вектора: строка (ROW) или столбец (COL)
 ulong size; //размерность вектора
 //Указатель на одномерный массив хранения компонент комплексного вектора
 complex *data;
//-----------------------------------------------------------------------------------
//I. Объявление общедоступных членов-функций класса TComplexVector
//-----------------------------------------------------------------------------------
public:
 //----------------------------------------------------------------------------------
 //I. ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TComplexVector
 //----------------------------------------------------------------------------------
 TComplexVector();//Объявление конструктора по умолчанию
 //Объявление конструктора с аргументами
 TComplexVector(ulong Size, bool Type, complex Init = complex(0,0));
 TComplexVector(ulong Size, bool Type, bool Init);
 TComplexVector(const TComplexVector& V);//Объявление конструктора копирования
 ~TComplexVector();//Объявление деструктора класса

 //----------------------------------------------------------------------------------
 // Получение характеристик вектора
 //----------------------------------------------------------------------------------
 //Проверка на вектор-строку
 bool IsRow() const {return (type == ROW) ? true : false;};
 //Проверка на вектор-столбец
 bool IsColumn() const {return (type == COL) ? true : false;};
 //Определение размерности вектора
 ulong Size() const {return size;};
 ulong GetSize() const {return size;};
 //Определение типа вектора
 bool Type() const {return type;};
 bool GetType() const {return type;};
 uint SubType() const; //Определение подтипа вектора
 //----------------------------------------------------------------------------------
 //Получение характеристик (свойств) вектора: тип и размер
 //----------------------------------------------------------------------------------
 void Properties(ulong& Size, bool& Type) const {Size = size; Type = type;};
 void Properties(PF_VECTOR& Info) const
  {Info.type = Type(); Info.subtype = SubType(); Info.size = Size();};
 //Получение свойств вектора в символьном виде
 string& Properties(string& s) const;
 //Наименование типа вектора (вектор-строка или вектор-столбец)
 string& GetType(string& s, bool brief = false, uint language = ENG) const;
 //Наименование подтипа вектора
 const char* GetSubType(uint language = ENG) const;
 string& GetSubType(string& s, uint language = ENG) const
 {return s = GetSubType(language);};
 //Полное наименование типа вектора (type + subtype)
 string& GetCompleteType(string& s, uint language = ENG) const;
 //----------------------------------------------------------------------------------
 // Установка свойств вектора
 //----------------------------------------------------------------------------------
 //Установка нового размера вектора с опцией восстановления значений элементов вектора
 //предыдущего размера.
 bool Resize(const ulong NewSize, bool Restore = false);
 //Установка новых характеристик вектора
 bool Set(ulong Size, bool Type, complex Init = complex(0,0));
 bool Set(ulong Size, bool Type, bool Init);
 bool SetType(bool NewType) {return type = NewType;};
 //----------------------------------------------------------------------------------
 // Доступ к элементам вектора
 //----------------------------------------------------------------------------------
 //Получение значения элемента вектора
 complex Get(ulong Index) const {return data[Index];};
 //Установка нового значения элемента вектора
 void Put(ulong Index, complex Value) {data[Index] = Value;};
 void Put(ulong Index, double Value) {data[Index] = complex(Value,0);};

 //----------------------------------------------------------------------------------
 //Инициализация элементов вектора случайными величинами
 //----------------------------------------------------------------------------------
 bool Random(double a = 0.0, double b = 1.0);//По равновероятному закону [a..b]

 //Консольное редактирование (ввод) элементов комплексного вектора
 void Edit(const string& name, bool confirm = true);
 //----------------------------------------------------------------------------------
 //Формирование подвектора из данного вектора
 //----------------------------------------------------------------------------------
 //Формирование подвектора из элементов вектора от индекса со значением left до
 //индекса со значением right
 cvector SubVector(ulong left, ulong right) const;
 //Формирование подвектора, состоящего из неповторяющихся значений элементов
 cvector Unique() const;
 //Формирование подвектора по значениям индексов вектора Index
 cvector SubVector(const ivector& Index) const;
 //----------------------------------------------------------------------------------
 //Алгоритмы сортировки элементов вектора
 //----------------------------------------------------------------------------------
 //Пузырьковая модифицированная сортировка по возрастанию и убыванию элементов
 bool BubbleSort(bool direct = ASCENDING, ulong *permutations = NULL,
                 ulong *comparisons = NULL);
 //Поиск заданного значения среди элементов вектора в заданном интервале
 bool Find(const complex& value, ulong* index = NULL, bool sort = UNSORTED,
           ulong left = 0L, ulong right = MAX_SIZE, bool direct = FORWARD) const;
 //Перестановка элементов вектора в заданном интервале в обратном порядке
 ulong Reverse(ulong left = 0L, ulong right = MAX_SIZE);
 //Перестановка элемента вектора с индексом index в конец вектора
 ulong MoveElemToEnd(ulong index);
 //Присваивание значений элементов одного вектора другому вектору
 cvector Assign(const cvector& V, ulong pos = 0L, ulong* counter = NULL) const;

 //**********************************************************************************
 //             Операции Линейной Алгебры над Комплексными Векторами
 //   Все операции линейной алгебры производятся с копией исходного вектора.
 //**********************************************************************************
 //Операция транспонирования комплексного вектора - осуществляется одновременное
 //осуществление операции транспонирования и комплексного сопряжения.
 cvector Transpose(bool conjugate = true) const;
 //Перегрузка унарного оператора (!) для получения транспонированного вектора
 cvector operator !();
 cvector Conj() const; //Операция сопряжения комплексного вектора
 //Перегрузка унарного оператора (~) для получения сопряженного вектора
 cvector operator ~();
 //----------------------------------------------------------------------------------
 //          Определение нормы (мер) комплексного вектора
 //----------------------------------------------------------------------------------
 double FirstNorm() const;
 double SecondNorm() const;
 double ThirdNorm() const;
 double PNorm(uint p = 2) const;
 double Norm(uint type = EUCLIDEAN_NORM, uint p = 2) const;
 //----------------------------------------------------------------------------------
 //Нормирование комплексного вектора
 //----------------------------------------------------------------------------------
 cvector Normalization() const;
 bool Normalization(uint NormType, uint p = 0);
 bool Normalization(cvector& Out, uint NormType = FIRST_NORM, uint p = 0) const;
 bool NormalizeToDB(rvector& Out, double MindB = -60) const;

 //Скалярное умножение двух комплексных векторов
 //(A,B) = A(a1,...,an)*B(b1,...,bn) = conj(a1)*b1+...+conj(an)*bn;
 bool ScalarProduct(const cvector& A, complex& result) const;
 friend bool ScalarProduct(const cvector& A, const cvector& B, complex& result);
 //(A,B) = A(a1,...,an)*B(b1,...,bn) = conj(a1)*b1+...+conj(an)*bn
 //Функция возвращает в norm_res норму вычисленного комплексного значения скалярного
 //произведения векторов A и B
 friend bool ScalarProduct(const cvector& A, const cvector& B, double& norm_res);

 //Увеличение комплексного вектора на действительное число value
 //B(b1,...,bn) = const + A(a1,...,an), bi = ai + const
 friend cvector operator +(const double value, const cvector& V);
 //B(b1,...,bn) = A(a1,...,an) + const, bi = ai + const
 friend cvector operator +(const cvector& V, const double value);

 //Увеличение комплексного вектора на комплексное число value
 //B(b1,...,bn) = const + A(a1,...,an), bi = ai + const
 friend cvector operator +(const complex value, const cvector& V);
 //B(b1,...,bn) = A(a1,...,an) + const, bi = ai + const
 friend cvector operator +(const cvector& V, const complex value);

 //Уменьшение комплексного вектора на действительное число value
 //B(b1,...,bn) = A(a1,...,an) - const, bi = ai - const
 friend cvector operator -(const cvector& V, const double value);

 //Уменьшение комплексного вектора на комплексное число value
 //B(b1,...,bn) = A(a1,...,an) - const, bi = ai - const
 friend cvector operator -(const cvector& V, const complex value);

 //Умножение комплексного вектора на действительное число value
 //B(b1,...,bn) = const * A(a1,...,an), bi = ai * const
 friend cvector operator *(const double value, const cvector& V);
 //B(b1,...,bn) = A(a1,...,an) * const, bi = ai * const
 friend cvector operator *(const cvector& V, const double value);

 //Умножение комплексного вектора на комплексное число value
 //B(b1,...,bn) = const * A(a1,...,an), bi = ai * const
 friend cvector operator *(const complex value, const cvector& V);
 //B(b1,...,bn) = A(a1,...,an) * const, bi = ai * const
 friend cvector operator *(const cvector& V, const complex value);

 //Деление комплексного вектора на действительное число value
 //B(b1,...,bn) = A(a1,...,an) / const, bi = ai / const
 cvector operator /(const double value) const;

 //Деление комплексного вектора на комплексное число value
 //B(b1,...,bn) = A(a1,...,an) / const, bi = ai / const
 cvector operator /(const complex value) const;

 //Сложение двух комплексных векторов
 //С(с1,...,cn) = A(a1,...,an) + B(b1,...,bn), ci = ai + bi;
 cvector operator +(const cvector& V) const;

 //Вычитание двух комплексных векторов
 //С(с1,...,cn) = A(a1,...,an) - B(b1,...,bn), ci = ai - bi;
 cvector operator -(const cvector& V) const;

 //Умножение двух комплексных векторов
 cmatrix operator *(const cvector& V) const;

 //Умножение комплексного вектора на вещественный вектор слева и справа
 //Умножение на вещественный вектор слева
 friend cmatrix operator *(const cvector& Z, const rvector& X);
 //Умножение на вещественный вектор справа
 friend cmatrix operator *(const rvector& X, const cvector& Z);

 //Умножение комплексного вектора на вещественную матрицу слева и справа
 //Умножение на вещественную матрицу слева
 friend cvector operator *(const cvector& V, const rmatrix& A);
 //Умножение на вещественную матрицу справа
 friend cvector operator *(const rmatrix& A, const cvector& V);

 //Умножение комплексного вектора на комплексную матрицу слева и справа
 //Умножение на комплексную матрицу слева
 friend cvector operator *(const cvector& V, const cmatrix& A);
 //Умножение на комплексную матрицу справа
 friend cvector operator *(const cmatrix& A, const cvector& V);

 //Поэлементное умножение векторов одинаковых размеров
 cvector MultByItem(const cvector& V) const;
 cvector MultByItem(const rvector& V) const;

 //Сложение элементов вектора
 complex SumByItem(ulong* counter = NULL) const;
 complex SumByItem(ulong left, ulong right=MAX_SIZE, ulong* counter=NULL) const;
 complex SumByItem(const ivector& index, bool check = false,
                   ulong* counter = NULL) const;
 complex SumByItem(const TArgVectorPredicate<complex,cvector>& Predicate,
                   ulong* counter = NULL) const;
 //----------------------------------------------------------------------------------
 //Умножение вектора на элементарную матрицу и элементарные матрицы специального
 //                              вида (elementary matrix)
 //ПРАВИЛА УМНОЖЕНИЯ:
 //1. Элементарная матрица умножается на вектор-столбец СПРАВА
 //2. Элементарная матрица умножается на вектор-строку СЛЕВА
 //3. Элементарная матрица всегда КВАДРАТНАЯ
 //4. Размерности вектора и элементарной матрицы должны быть РАВНЫ и отличны от 0
 //ЭЛЕМЕНТАРНАЯ МАТРИЦА - матрица E = I + B, где I - единичная матрица, B - мат-
 //рица ранга единица, т.е. матрица с единичной главной диагональю и одним вне-
 //диагональным элементом отличным от нуля.
 //       |1        |
 //       |  1      |
 // Ekl = |    1    |, E(k,l) != 0, k=4,l=2.
 //       |  x   1  |
 //       |        1|
 //----------------------------------------------------------------------------------
 //Элементарные матрицы специального вида. К ним относятся:
 //1. Диагональная элементарная  матрица Dk (DiagonalEM). Диагональная матрица с
 //   элементами Dk(i,i)=1 для всех i != k и Dk(k,k)!=0.
 //      |1        |
 //      |  1      |
 // Dk = |    x    |, k = 3.
 //      |      1  |
 //      |        1|
 //2. Нижняя столбцовая элементарная матрица Lkc (LowerColumnEM).  Внедиагональ-
 //   ные ненулевые элементы расположены только в k-м столбце под диагональю.
 //       |1        |
 //       |  1      |
 // Lkc = |    1    |, k = 3.
 //       |    x 1  |
 //       |    x   1|
 //3. Верхняя столбцовая элементарная матрица Ukc (UpperColumnEM). Внедиагональ-
 //   ные ненулевые элементы расположены только в k-м столбце над диагональю.
 //       |1   x    |
 //       |  1 x    |
 // Ukc = |    1    |, k = 3.
 //       |      1  |
 //       |        1|
 //4. Полная столбцовая элементарная матрица Tkc (CompleteColumnEM). Внедиагональ-
 //   ные ненулевые элементы расположены только в k-м столбце.
 //       |1   x    |
 //       |  1 x    |
 // Tkc = |    1    |, k = 3.
 //       |    x 1  |
 //       |    x   1|
 //5. Левая строчная элементарная матрица Lkr (LeftRowEM). Внедиагональные нену-
 //   левые элементы расположены только в k-й строке левее диагонали.
 //       |1        |
 //       |  1      |
 // Lkr = |x x 1    |, k = 3.
 //       |      1  |
 //       |        1|
 //6. Правая строчная элементарная матрица Ukr (RightRowEM). Внедиагональные
 //   ненулевые элементы расположены только в k-й строке справа от диагонали.
 //       |1        |
 //       |  1      |
 // Ukr = |    1 x x|, k = 3.
 //       |      1  |
 //       |        1|
 //7. Полная строчная элементарная матрица Tkr (CompleteRowEM). Внедиагональные
 //   ненулевые элементы расположены только в k-й строке.
 //       |1        |
 //       |  1      |
 // Tkr = |x x 1 x x|, k = 3.
 //       |      1  |
 //       |        1|
 //При  умножении  вектора на  элементарную, специальную элементарную или группу
 //специальных  элементарных матриц используется в качестве элементарной обыкно-
 //венная квадратная матрица. Квадратная матрица позволяет размещать группу эле-
 //ментарных специальных матриц. Поэтому  можно  реализовать выполнение операций
 //умножения  вектора  на несколько  элементарных матриц, элементы которых можно
 //хранить в одной квадратной  матрице. Например, квадратная матрица размерности
 //N, позволяет  хранить  одновременно  N DiagonalEM, N LowerColumnEM и N Upper-
 //ColumnEM.
 //----------------------------------------------------------------------------------
 //Умножение на диагональную элементарную матрицу Dk
 //k < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool DiagonalEM(const cmatrix& Q, ulong k);
 //Умножение на диагональные элементарные матрицы Dk, k=[first..last]
 //first < last < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool DiagonalEM(const cmatrix& Q, ulong first, ulong last);
 //Умножение на все диагональные элементарные матрицы Dk, k=[0..Q.Rows()-1]
 //Q.Rows()==Q.Cols()==V.Size() != 0
 bool DiagonalEM(const cmatrix& Q);

 //Умножение на нижнюю столбцовую элементарную матрицу Lkc
 //k < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool LowerColumnEM(const cmatrix& Q, ulong k);
 //Умножение на нижние столбцовые элементарные матрицы Lkc, k=[first..last]
 //first < last < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool LowerColumnEM(const cmatrix& Q, ulong first, ulong last);
 //Умножение на все нижние столбцовые элементарные матрицы Lkc, k=[0..Q.Rows()-1]
 //Q.Rows()==Q.Cols()==V.Size() != 0
 bool LowerColumnEM(const cmatrix& Q);

 //Умножение на верхнюю столбцовую элементарную матрицу Ukc
 //k < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool UpperColumnEM(const cmatrix& Q, ulong k);
 //Умножение на верхние столбцовые элементарные матрицы Ukc, k=[first..last]
 //first < last < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool UpperColumnEM(const cmatrix& Q, ulong first, ulong last);
 //Умножение на все верхние столбцовые элементарные матрицы Ukc, k=[0..Q.Rows()-1]
 //Q.Rows()==Q.Cols()==V.Size() != 0
 bool UpperColumnEM(const cmatrix& Q);

 //Умножение на полную столбцовую элементарную матрицу Tkc
 //k < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool CompleteColumnEM(const cmatrix& Q, ulong k);
 //Умножение на полные столбцовые элементарные матрицы Tkc, k=[first..last]
 //first < last < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool CompleteColumnEM(const cmatrix& Q, ulong first, ulong last);
 //Умножение на все полные столбцовые элементарные матрицы Tkc, k=[0..Q.Rows()-1]
 //Q.Rows()==Q.Cols()==V.Size() != 0
 bool CompleteColumnEM(const cmatrix& Q);

 //Умножение на левую строчную элементарную матрицу Lkr
 //k < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool LeftRowEM(const cmatrix& Q, ulong k);
 //Умножение на левые строчные элементарные матрицы Lkr, k=[first..last]
 //first < last < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool LeftRowEM(const cmatrix& Q, ulong first, ulong last);
 //Умножение на все левые строчные элементарные матрицы Lkr, k=[0..Q.Rows()-1]
 //Q.Rows()==Q.Cols()==V.Size() != 0
 bool LeftRowEM(const cmatrix& Q);

 //Умножение на правую строчную элементарную матрицу Ukr
 //k < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool RightRowEM(const cmatrix& Q, ulong k);
 //Умножение на правые строчные элементарные матрицы Ukr, k=[first..last]
 //first < last < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool RightRowEM(const cmatrix& Q, ulong first, ulong last);
 //Умножение на все правые строчные элементарные матрицы Ukr, k=[0..Q.Rows()-1]
 //Q.Rows()==Q.Cols()==V.Size() != 0
 bool RightRowEM(const cmatrix& Q);

 //Умножение на полную строчную элементарную матрицу Tkr
 //k < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool CompleteRowEM(const cmatrix& Q, ulong k);
 //Умножение на полные строчные элементарные матрицы Tkr, k=[first..last]
 //first < last < Q.Rows(), Q.Rows()==Q.Cols()==V.Size() != 0
 bool CompleteRowEM(const cmatrix& Q, ulong first, ulong last);
 //Умножение на все полные строчные элементарные матрицы Tkr, k=[0..Q.Rows()-1]
 //Q.Rows()==Q.Cols()==V.Size() != 0
 bool CompleteRowEM(const cmatrix& Q);

 //Умножение на обыкновенную элементарную матрицу Bij
 //Q.Rows()==Q.Cols()==V.Size() != 0 && (row < Q.Rows()) && (col < Q.Cols())
 bool OrdinaryEM(const cmatrix& Q, ulong row, ulong col);
//-----------------------------------------------------------------------------------
//              ОБЪЯВЛЕНИЕ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ
//-----------------------------------------------------------------------------------
 //1. OVERLOAD THE CALL FUNCTION OPERATOR ()
 //Объявление перегруженного оператора вызова функции для доступа к элементу вектора
 //(одномерного массива). Используется в программах пользователя.
 complex& operator() (ulong i);
 //Объявление перегруженного оператора вызова функции для доступа к элементу вектора
 //(одномерного массива). Эта версия вызывается в операторе присваивания и в конструк-
 //торе копирования.
 //This version is called in ASSIGNMENT OPERATOR and COPY the CONSTRUCTOR
 const complex operator() (ulong i) const;
 //2. OVERLOAD THE SUBSCRIPT OPERATOR []
 //Объявление перегруженного оператора доступа к элементу массива для доступа к
 //элементу вектора (одномерного массива). Используется в программах пользователя.
 complex& operator[] (ulong i);
 //Объявление перегруженного оператора [] для доступа к элементу вектора (одномерного
 //массива). Эта версия вызывается в операторе присваивания и в конструкторе копирования.
 //This version is called in ASSIGNMENT OPERATOR and COPY the CONSTRUCTOR
 const complex operator[] (ulong i) const;
 //3. OVERLOAD THE ASSIGNMENT OPERATOR
 //Объявление перегруженного оператора присваивания operator =
 void operator =(const TComplexVector& V);
 //4. OVERLOAD THE STREAM INSERTION OPERATOR
 //Перегрузка операции потокового вывода (<<) для отображения элементов вектора
 friend ostream& operator <<(ostream& out, const TComplexVector& V);
 //5. OVERLOAD THE COMPARISON OPERATOR (==)
 //Объявление перегруженного оператора сравнения двух векторов operator ==
 bool operator ==(const TComplexVector& V) const;
 //6. OVERLOAD THE ASSIGNMENT OPERATOR
 //Объявление перегруженного оператора присваивания operator = всем компонентам
 //вектора действительного значения
 bool operator =(const double value);
 //7. OVERLOAD THE ASSIGNMENT OPERATOR
 //Объявление перегруженного оператора присваивания operator = всем компонентам
 //вектора комплексного значения
 bool operator =(const complex value);
 //8. OVERLOAD THE ASSIGNMENT OPERATOR
 //Объявление перегруженного оператора присваивания operator = комплексному вектору
 //вещественного вектора
 cvector& operator =(const TRealVector& V);
 //**********************************************************************************
 //I. Объявление функций определения типа вектора
 //**********************************************************************************
 bool IsZeroSize() const; //Проверка вектора на вектор нулевого размера
 bool IsZero() const; //Проверка вектора со всеми нулевыми элементами
 //Проверка на скалярный вектор (все элементы вектора равны a)
 bool IsScalar() const;
 //Проверка на единичный вектор (все элементы вектора равны 1)
 bool IsUnit() const;

//-----------------------------------------------------------------------------------
//         ОБЪЯВЛЕНИЕ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССУ TComplexVector
//-----------------------------------------------------------------------------------
 //Определение максимальной символьной длины элементов вектора
 friend uint MaxStrLen(const TComplexVector& V, uint precision);
//-----------------------------------------------------------------------------------
//II. Объявление закрытых членов-функций класса TComplexVector
//-----------------------------------------------------------------------------------
private:
 void Initial();//Инициализация членов-данных класса при его конструировании
 bool Create();//Создание вектора определенного размера в оперативной памяти
 void Delete();//Удаление вектора из оперативной памяти

//-----------------------------------------------------------------------------------
//III. Объявление защищенных членов-функций класса TComplexVector
//-----------------------------------------------------------------------------------
protected:
 //----------------------------------------------------------------------------------
 //Объявление функций консольного ввода элементов векторов различного типа
 //----------------------------------------------------------------------------------
 //Ввод элементов вектора-строки и вектора-столбца комплексных чисел
 void InPutVector(const string& name, bool confirm = true);
 //Ввод элементов скалярных вектора-строки или вектора-столбца
 void InPutScalar(const string& name, bool confirm = true);
};
/**** КОНЕЦ ОБЪЯВЛЕНИЯ КЛАССА - КОМПЛЕКСНЫЙ ВЕКТОР - class TComplexVector ****/

//***********************************************************************************
//Объявление класса - ВЕКТОР ЦЕЛЫХ ЧИСЕЛ - TIntVector
//TIntVector осуществляет создание целочисленного вектора, хранение, доступ и изменение
//значений его элементов, а также обеспечивает ряд других сервисных функций. Данный
//класс необходим при осуществлении операций над определенными группами элементов ве-
//щественных и комплексных векторов и матриц, так как элементы данного класса могут
//использоваться для хранения индексов строк (столбцов) матриц или индексы элементов
//векторов над которыми операции допустимы.
//***********************************************************************************
class TIntVector {
//Объявление дружественных классов

//-----------------------------------------------------------------------------------
//Объявление защищенных членов-данных класса
//-----------------------------------------------------------------------------------
protected:
 bool type;  //тип вектора (вектор-строка или вектор-столбец)
 ulong size; //размерность вектора
 long *data; //указатель на массив с элементами целочисленного вектора
//-----------------------------------------------------------------------------------
//I. Объявление общедоступных членов-функций, конструкторов и деструктора класса TIntVector
//-----------------------------------------------------------------------------------
public:
 //***********************************************************************************
 //I. ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TIntVector
 //***********************************************************************************
 TIntVector();//Объявление конструктора по умолчанию
 //Объявление конструкторов с аргументами
 TIntVector(ulong Size, bool Type, long Init = 0L);
 TIntVector(ulong Size, long Init = 0L);
 TIntVector(const TIntVector& V);//Объявление конструктора копирования
 ~TIntVector();//Объявление деструктора класса

 //----------------------------------------------------------------------------------
 // Получение характеристик вектора
 //----------------------------------------------------------------------------------
 //Проверка на вектор-строку
 bool IsRow() const {return (type == ROW) ? true : false;};
 //Проверка на вектор-столбец
 bool IsColumn() const {return (type == COL) ? true : false;};
 //Определение размерности вектора
 ulong Size() const {return size;};
 ulong GetSize() const {return size;};
 //Определение типа вектора
 bool Type() const {return type;};
 bool GetType() const {return type;};
 uint SubType() const;//Определение подтипа вектора
 //Получение характеристик (свойств) вектора: тип и его размерность
 void Properties(ulong& Size, bool& Type) const {Size = size; Type = type;};
 void Properties(PF_VECTOR& Info) const
 {Info.type = Type(); Info.subtype = SubType(); Info.size = Size();};
 //----------------------------------------------------------------------------------
 //Получение свойств вектора в символьном виде
 string& Properties(string& s) const;
 //Наименование типа вектора (вектор-строка или вектор-столбец)
 string& GetType(string& s, bool brief = false, uint language = ENG) const;
 //Наименование подтипа вектора
 const char* GetSubType(uint language = ENG) const;
 string& GetSubType(string& s, uint language = ENG) const
 {return s = GetSubType(language);};
 //Полное наименование типа вектора (type + subtype)
 string& GetCompleteType(string& s, uint language = ENG) const;

 //----------------------------------------------------------------------------------
 // Установка свойств вектора
 //----------------------------------------------------------------------------------
 //Установка нового размера вектора с опцией восстановления значений элементов
 //вектора предыдущего размера.
 bool Resize(const ulong NewSize, bool Restore = false);
 //Установка новых характеристик вектора
 bool Set(ulong Size, bool Type, long Init = 0L);
 bool Set(ulong Size, long Init = 0L) {return Set(Size,Type(),Init);};
 bool SetType(bool NewType) {return type = NewType;};
 //----------------------------------------------------------------------------------
 // Доступ к элементам вектора
 //----------------------------------------------------------------------------------
 //Получение значения элемента вектора
 long Get(ulong Index) const {return data[Index];};
 //Установка нового значения элемента вектора
 void Put(ulong Index, long Value) {data[Index] = Value;};

 //----------------------------------------------------------------------------------
 //Инициализация элементов вектора случайными величинами
 //----------------------------------------------------------------------------------
 bool Rand();//По равновероятному закону

 //Консольное редактирование (ввод) элементов вектора
 void Edit(const string& name, bool confirm = true);
 //Получение значений элементов вектора в виде символьной строки
 string& ConvertToString(string& s, string& sep, string& etc, ulong count = 0) const;
 //Получение значений элементов вектора в виде символьной строки
 string& ConvertToString(string& s, ulong count, char* sep = NULL, char* etc = NULL) const;
 //Получение элементов вектора из символьной строки преобразованием символьного
 //представления целых чисел и их интервалов из строчного в двоичный типа long
 ulong GetDataFromString(const string& source, bool unique = false,
 const TArgVectorPredicate<long,ivector>* Predicate = NULL);
 //Преобразование строкового представления интервала целых чисел в вектор целых
 //чисел типа long
 ulong StrIntervalToVector(const string& source);
 //----------------------------------------------------------------------------------
 //Формирование подвектора из данного вектора
 //----------------------------------------------------------------------------------
 //Формирование подвектора из элементов вектора от индекса со значением left до
 //индекса со значением right
 ivector SubVector(ulong left, ulong right) const;
 //Формирование подвектора, состоящего из неповторяющихся значений элементов
 ivector Unique() const;
 //Формирование подвектора по значениям индексов вектора Index
 ivector SubVector(const ivector& Index) const;
 //Формирование подвектора из элементов исходного вектора, значения которых
 //удовлетворяют объекту-предикату TArgVectorPredicate<long,ivector>
 ivector SubVector(const TArgVectorPredicate<long,ivector>& Predicate) const;
 //----------------------------------------------------------------------------------
 //Алгоритмы сортировки элементов вектора
 //----------------------------------------------------------------------------------
 //Пузырьковая модифицированная сортировка по возрастанию и убыванию элементов
 bool BubbleSort(bool direct = ASCENDING, ulong *permutations = NULL,
                 ulong *comparisons = NULL);

 //Поиск заданного значения среди элементов вектора в заданном интервале
 bool Find(const long& value, ulong* index = NULL, bool sort = UNSORTED,
           ulong left = 0L, ulong right = MAX_SIZE, bool direct = FORWARD) const;

 //Перестановка элементов вектора в заданном интервале в обратном порядке
 ulong Reverse(ulong left = 0L, ulong right = MAX_SIZE);

 //Присваивание значений элементов одного вектора другому вектору
 ivector Assign(const ivector& V, ulong pos = 0L, ulong* counter = NULL) const;

//-----------------------------------------------------------------------------------
//              ОБЪЯВЛЕНИЕ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ
//-----------------------------------------------------------------------------------
 //1. OVERLOAD THE CALL FUNCTION OPERATOR ()
 //Объявление перегруженного оператора вызова функции для доступа к элементу вектора
 //(одномерного массива). Используется в программах пользователя.
 long& operator() (ulong i);
 //Объявление перегруженного оператора вызова функции для доступа к элементу вектора
 //(одномерного массива). Эта версия вызывается в операторе присваивания и в конструк-
 //торе копирования.
 //This version is called in ASSIGNMENT OPERATOR and COPY the CONSTRUCTOR
 const long operator() (ulong i) const;
 //2. OVERLOAD THE SUBSCRIPT OPERATOR []
 //Объявление перегруженного оператора доступа к элементу массива для доступа к
 //элементу вектора (одномерного массива). Используется в программах пользователя.
 long& operator[] (ulong i);
 //Объявление перегруженного оператора [] для доступа к элементу вектора (одномерного
 //массива). Эта версия вызывается в операторе присваивания и в конструкторе
 //копирования.
 //This version is called in ASSIGNMENT OPERATOR and COPY the CONSTRUCTOR
 const long operator[] (ulong i) const;

 //3. OVERLOAD THE ASSIGNMENT OPERATOR
 //Объявление перегруженного оператора присваивания operator =
 void operator =(const TIntVector& V);
 //4. OVERLOAD THE STREAM INSERTION OPERATOR
 //Перегрузка операции потокового вывода (<<) для отображения элементов вектора
 friend ostream& operator <<(ostream& out, const TIntVector& V);
 //5. OVERLOAD THE COMPARISON OPERATOR (==)
 //Объявление перегруженного оператора сравнения двух векторов operator ==
 bool operator ==(const TIntVector& V) const;
 //6. OVERLOAD THE ASSIGNMENT OPERATOR
 //Объявление перегруженного оператора присваивания operator = компонентам вектора
 //целочисленного значения
 bool operator =(const long value);
 //----------------------------------------------------------------------------------
 // Операции пересечения, объединеия и вычитания векторов, реализованные по правилам
 // алгебры множеств. Векторы считаются множествами целых чисел.
 //----------------------------------------------------------------------------------
 //7. OVERLOAD THE OPERATOR & - INTERSECTION OPERATION BETWEEN A and B
 //Объявление перегруженного оператора operator &, реализующий операцию пересечения
 //двух векторов
 friend ivector operator &(const ivector& A, const ivector& B);
 //8. OVERLOAD THE OPERATOR && - INTERSECTION OPERATION BETWEEN A and B
 //Объявление перегруженного оператора operator &&, реализующий операцию пересечения
 //двух векторов
 friend ivector operator &&(const ivector& A, const ivector& B);
 //9. OVERLOAD THE OPERATOR | - UNION OPERATION BETWEEN A and B
 //Объявление перегруженного оператора operator |, реализующий операцию объединения
 //двух векторов
 //10. OVERLOAD THE OPERATOR || - UNION OPERATION BETWEEN A and B
 //Объявление перегруженного оператора operator ||, реализующий операцию объединения
 //двух векторов
 friend ivector operator ||(const ivector& A, const ivector& B);
 //11. OVERLOAD THE OPERATOR ^
 //Объявление перегруженного оператора operator ^, реализующий операцию вычитания
 //двух векторов
 friend ivector operator ^(const ivector& A, const ivector& B);

 //**********************************************************************************
 //I. Объявление функций определения типа вектора
 //**********************************************************************************
 //Проверка вектора на вектор нулевого размера
 bool IsZeroSize() const;
 //Проверка вектора со всеми нулевыми элементами
 bool IsZero() const;
 //Проверка на скалярный вектор (все элементы вектора равны a)
 bool IsScalar() const;
 //Проверка на единичный вектор (все элементы вектора равны 1)
 bool IsUnit() const;

//-----------------------------------------------------------------------------------
//         ОБЪЯВЛЕНИЕ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССУ TIntVector
//-----------------------------------------------------------------------------------
 //Определение максимальной символьной длины элементов вектора
 friend uint MaxStrLen(const TIntVector& V);
//-----------------------------------------------------------------------------------
//II. Объявление закрытых членов-функций класса TIntVector
//-----------------------------------------------------------------------------------
private:
 void Initial();//Инициализация членов-данных класса при его конструировании
 bool Create();//Создание вектора определенного размера в оперативной памяти
 void Delete();//Удаление вектора из оперативной памяти

//-----------------------------------------------------------------------------------
//III. Объявление защищенных членов-функций класса TIntVector
//-----------------------------------------------------------------------------------
protected:
 //**********************************************************************************
 //Объявление функций консольного ввода элементов векторов различного типа
 //**********************************************************************************
 //Ввод элементов целочисленного вектора
 void InPutVector(const string& name, bool confirm = true);
 //Ввод элементов скалярного целочисленного вектора
 void InPutScalar(const string& name, bool confirm = true);
};
/******* КОНЕЦ ОБЪЯВЛЕНИЯ КЛАССА - ЦЕЛОЧИСЛЕННЫЙ  ВЕКТОР - class TIntVector ********/

//***********************************************************************************
// Объявление сервисных функций
//***********************************************************************************
//Функция ввода характеристик вектора
void InPutPF_VECTOR(PF_VECTOR& Info, const char* Name = NULL);

#endif //ЗАВЕРШЕНИЕ ОБЪЯВЛЕНИЯ ЗАГОЛОВОЧНОГО ФАЙЛА "MVECTOR.H"
