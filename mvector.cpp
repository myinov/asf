//mvector.cpp
//Реализация классов TRealVector, TComplexVector & TIntVector
//Initial date: March,8,1999. Final date:
//Copyright (c) JohnSoft 1999. All rights reserved. Borland C++ 5.01
#include "mvector.h"

#include "parsing.h"
//******************************************************************************
//Таблица соответствия наименования действительной матрицы ее типу
//******************************************************************************
const uint szVectorName = 6;
const MATRIX_NAME VectorName[6] = {
 //SubType   RUSSIAN NAME               ENGLISH NAME
{V_ZEROSIZE, "Вектор нулевого размера", "Zero-size vector" },  //0
{V_NUMBER,   "Вектор размера единица",  "One-size vector"  },  //1
{V_ORDINARY, "Вектор",                  "Vector"           },  //2
{V_ZERO,     "Нулевой вектор",          "Zero vector"      },  //3
{V_UNIT,     "Единичный вектор",        "Unit vector"      },  //4
{V_SCALAR,   "Скалярный вектор",        "Scalar vector"    } };//5

const double EPS = 1e-10; //Точность представления чисел
const char* sComplex = "Complex";

//******************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TRealVector
//******************************************************************************

//==============================================================================
//  РЕАЛИЗАЦИЯ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TRealVector
//   TRealVector CLASS CONSTRUCTORs & DESTRUCTOR REALIZATION
//==============================================================================
//******************************************************************************
//СТАТУС: 1; public; TRealVector constructor by default
//НАИМЕНОВАНИЕ ФУНКЦИИ: TRealVector()
//НАЗНАЧЕНИЕ: Конструктор по умолчанию класса TRealVector.
//Функция предназначена для создания класса TRealVector по умолчанию. По
//умолчанию конструируется вещественный вектор нулевого размера - V_ZEROSIZE.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TRealVector::TRealVector() { Initial(); }
//******************************************************************************
//СТАТУС: 2; public; TRealVector constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TRealVector(ulong Size, bool Type, double Init = 0.0)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TRealVector.
//   Функция предназначена  для  создания класса TRealVector согласно переданных
//параметров. Класс использует вызов функции Set(Size,Type,Init). Класс конструи-
//рует векторы двух типов - вектор-строку или вектор-столбец и инициализирует их
//элементы значением Init.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong Size - размерность вектора;
//2. bool Type  - тип вектора (COL || ROW);
//3. double Init (0.0) - инициализирующее значение для элементов вектора.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TRealVector::TRealVector(ulong Size, bool Type, double Init)
{Initial();//Начальная инициализация членов-данных класса
 Set(Size,Type,Init);//Установка характеристик конструируемого вектора
}
//******************************************************************************
//СТАТУС: 3; public; TRealVector constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TRealVector(ulong Size, bool Type, bool Init)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TRealVector.
//   Функция предназначена  для  создания класса TRealVector согласно переданных
//параметров. Класс использует вызов функции Set(Size,Type,Init). Класс конструи-
//рует векторы двух типов - вектор-строку или вектор-столбец. При Init == true,
//элементы вектора инициализируются случайными величинами, при Init == false,
//элементы вектора не инициализируются, что ускоряет конструирование объекта
//класса.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong Size - размерность вектора;
//2. bool Type  - тип вектора (COL || ROW);
//3. bool Init  - опция инициализации элементов вектора.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TRealVector::TRealVector(ulong Size, bool Type, bool Init)
{Initial();//Начальная инициализация членов-данных класса
 Set(Size,Type,Init);//Установка характеристик конструируемого вектора
}
//******************************************************************************
//СТАТУС: 3; public; TRealVector class copy constructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: TRealVector(const TRealVector& V)
//НАЗНАЧЕНИЕ: Конструктор копирования класса TRealVector.
//Функция предназначена для создания класса TRealVector по характеристикам
//аналогичного класса и копирования значений его элементов. Осуществляется кор-
//ректное копирование членов-указателей на данные копируемого класса в создавае-
//мый класс с целью недопущения ссылок указателей разных объектов класса на одно
//и то же место памяти. Для процедуры копирования используется ПЕРЕГРУЖЕННЫЙ
//ОПЕРАТОР ПРИСВАИВАНИЯ.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:const TRealVector& V - ссылка на объект TRealVector
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TRealVector::TRealVector(const TRealVector& V)
{Initial();//Начальная инициализация членов-данных класса
 //Установка характеристик вектора, вызовом перегруженного оператора =
 *this = V;
}
//******************************************************************************
//СТАТУС: 4; public; TRealVector class destructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: ~TRealVector()
//НАЗНАЧЕНИЕ: ДЕСТРУКТОР класса TRealVector
//Функция предназначена для удаления объекта класса TRealVector после завершения
//работы с ним. В ходе работы деструктор освобождает оперативную память занятую
//элементами и характеристиками действительного вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TRealVector::~TRealVector() {Delete();}

//===================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TRealVector
//    PUBLIC MEMBER-FUNCTION OF TRealVector CLASS REALIZATION
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& GetType(string& s, bool brief = OFF, uint language = ENG) const
//НАЗНАЧЕНИЕ: Формирование наименования типа вектора на русском или английском языке,
//в сокращенном или полном формате. Допускается многоязычный интерфейс корректировкой
//кода функции. Язык по умолчанию - английский. Формирование типа вектора (строка или
//столбец) осуществляется в строке s, передаваемой по ссылке. Функция возвращает ссылку
//на строку с наименованием типа вектора.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку для формирования имени типа вектора
//2. bool brief (OFF) - сокращенный или полный формат имени типа вектора
//3. uint language [ENG] - язык наименования типа вектора
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// string& s - ссылка на строку с сформированным именем типа вектора
//***********************************************************************************
string& TRealVector::GetType(string& s, bool brief, uint language) const
{if (language == RUS) //Формирование наименования типа вектора на русском языке
 {if (brief) s = (IsRow()) ? "строка" : "столбец";
  else s = (IsRow()) ? "Вектор-строка" : "Вектор-столбец";
 }
 else //Формирование наименования типа вектора на английском языке
 {if (brief) s = (IsRow()) ? "row" : "column";
  else s = (IsRow()) ? "Vector-row" : "Vector-column";
 }
return s;
}
//***********************************************************************************
//СТАТУС: I.2, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: const char* GetSubType(uint language = ENG) const
//НАЗНАЧЕНИЕ: Получение  наименования подтипа вектора. Таблица соответствия подтипов
//вектора с ее наименованиями представлена массивом VectorName. В массиве хранятся
//наименования векторов на русском и английском языке. Индексом для получения имени
//вектора служит ее подтип (subtype). Осуществляется обработка некорректного задания
//языка имени подтипа. Допускается многоязычный интерфейс корректировкой структуры
//MATRIX_NAME и массива VectorName. Язык по умолчанию - английский.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint language [ENG] - язык наименования подтипа вектора
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// const char *s - указатель на наименование вектора в таблице VectorName
//***********************************************************************************
const char* TRealVector::GetSubType(uint language) const
{char* s; //Указатель на строку
 uint index = SubType();
 switch (language)
 { case RUS: //указать наименование подтипа вектора на русском языке
    s = VectorName[index].rus_name; break;
   case ENG: //указать наименование подтипа вектора на английском языке
    s = VectorName[index].eng_name; break;
   //Наименование подтипа вектора на заданном языке отсутствует
   default: //указать наименование подтипа вектора на английском языке
    s = VectorName[index].eng_name; break;
 }
return s;
}
//***********************************************************************************
//СТАТУС: I.3, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& GetCompleteType(string& s, uint language = ENG) const
//НАЗНАЧЕНИЕ: Формирование полного наименования типа вектора (type + subtype) на рус-
//ском или английском. Допускается многоязычный интерфейс корректировкой кода функции.
//Язык  по  умолчанию - английский. Формирование полного типа вектора (строка или стол-
//бец) осуществляется в строке s, передаваемой по ссылке. Функция возвращает ссылку на
//строку с наименованием полного типа вектора.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку для формирования имени полного типа вектора;
//2. uint language [ENG] - язык наименования полного типа вектора.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// string& s - ссылка на строку с сформированным именем полного типа вектора
//***********************************************************************************
string& TRealVector::GetCompleteType(string& s, uint language) const
{//Формирование наименования подтипа вектора
 GetSubType(s, language);
 //Формирование типа вектора
 if (SubType() > V_NUMBER) {string t; GetType(t,ON,language); s.append("-"+t);}
 return s;
}
//***********************************************************************************
//СТАТУС: I.4; TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& GetData(string& s, uint precision = 6, string delim = string('')) const;
//НАЗНАЧЕНИЕ: Функция размещает в строке s, передаваемой по ссылке, значения элементов
//вектора в отформатированном виде.
//Формат вывода значений элементов вектора-строки:
// < X1<delim>X2<delim>X3...Xn\n >
//Формат вывода значений элементов вектора-столбца:
// < X1\n >
// < X2\n >
// < Xi\n >
// < Xn\n >, где Xi - значениe элемента вектора.
//При выводе элементов вещественного вектора приняты следующие соглашения:
//1. Все элементы вектора-столбца имеют ширину вывода равную наибольшей символьной
//   длине элемента вектора, который определяется функцией MaxStrLen(...)
//2. Выводятся только отрицательные знаки чисел.
//3. Точность вывода чисел с плавающей точкой определяется параметром precision, пере-
//   даваемым в функцию. Максимально возможное количество значащих цифр - 19.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которую заносятся элементы матрицы;
//2. uint precision - точность представления чисел с плавающей точкой;
//3. string& delim - строка символов-разделителей между двумя соседними числами.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с элементами вектора.
//***********************************************************************************
string& TRealVector::GetData(string& s, uint precision, string& delim) const
{s.resize(0);
 if (IsZeroSize()) return s.append("{}");
 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 if (IsColumn()) //Вектор-столбец
 {//Определение максимальной символьной длины элемента матрицы
  uint width = MaxStrWidthElem(precision);
  text.setf(ios::right);//Выравнивание по правому краю.
  //Вывод значений элементов в столбец. Каждый элемент выводится с новой строки
  for (ulong i = 0L; i < Size(); i++)
  {text << setw(width) << setprecision(precision) << data[i] << endl << ends;
   s.append(text.str()); text.seekp(0);
  }
 }
 else //Вектор-строка: все значения вектора располагаются в одну строку
 {for (ulong i = 0L; i < Size(); i++)
  {text << setprecision(precision) << data[i];
   if ((Size()-i) > 1) text << delim;
   text << ends;
   s.append(text.str()); text.seekp(0);
  }
 }
return s;
}
//***********************************************************************************
//СТАТУС: I.5; TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: uint MaxStrWidthElem(uint precision) const;
//НАЗНАЧЕНИЕ: Определение максимального символьного размер элемента вещественного век-
//тора. Используется для форматированного вывода элементов вещественного вектора. При
//вычислении максимальной символьной длины приняты следующие соглашения:
//1. Точность представления действительного числа равна precision.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//uint precision - количество выводимых цифр чисел с плавающей точкой.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint MaxWidth - максимальная символьная длина элемента вектора
//***********************************************************************************
uint TRealVector::MaxStrWidthElem(uint precision) const
{uint MaxWidth = 0;
 if (Size() == 0L) return MaxWidth;//Проверка вектора на нулевой размер
 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 uint width;
 //Просмотр всех элементов вещественного вектора
 for (ulong i = 0L; i < Size(); i++)
 {//Формирование символьного представления вещественного числа
  text << setprecision(precision) << data[i] << ends;
  //Определение максимальной символьной длины элемента вещественного вектора
  width = text.pcount()-1;
  if (width > MaxWidth) MaxWidth = width;
  text.seekp(0);
 }
return MaxWidth;
}
//***********************************************************************************
//СТАТУС: I.6; public member-function of class TRealVector
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Properties(string& s) const
//НАЗНАЧЕНИЕ: Функция формирует характеристики TRealVector в виде строки.
//ПРИМЕР: TYPE: <complete vector type>; DIMENSION: <size>.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строковый объект
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами вектора
//***********************************************************************************
string& TRealVector::Properties(string& s) const
{char buffer[80];
 string t;
 ostrstream text(buffer, sizeof(buffer));
 s.resize(0);
 //1. Формирование наименования типа вектора
 s.append("TYPE: ");
 text << "Real " << GetCompleteType(t) << ", " << ends;
 s.append(text.str()); text.seekp(0);
 //2. Формирование размерности вектора
 s.append("DIMENSION: ");
 text << Size() << ";" << endl << ends;
 s.append(text.str()); text.seekp(0);
return s;
}
//***********************************************************************************
//СТАТУС: I.7, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: uint SubType() const
//НАЗНАЧЕНИЕ: Определение подтипа вектора (нулевой вектор, единичный вектор, скалярный
//вектор и т.д.) согласно их классификации.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint subtype - подтип вектора
//***********************************************************************************
uint TRealVector::SubType() const
{if (Size() == 0) return V_ZEROSIZE; //Вектор нулевого размера
 else if (Size() == 1) return V_NUMBER; //Вектор размера единица
 else if (IsZero()) return V_ZERO; //Проверка на нулевую вектор-строку
 else if (IsUnit()) return V_UNIT; //Проверка на единичную вектор-строку
 else if (IsScalar()) return V_SCALAR; //Проверка на скалярную вектор-строку
 return V_ORDINARY;
}
//***********************************************************************************
//СТАТУС: I.8, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool Set(ulong VectorSize, bool VectorType, double Init = 0.0)
//НАЗНАЧЕНИЕ: Функция устанавливает новые характеристики вещественного вектора.
//При установке новых характеристик вектора все старые характеристики аннулируются,
//значения элементов вектора уничтожаются, устанавливаются новые размеры вектора.
//Функция устанавливает  два типа вектора: вектор-строку или вектор-столбец и
//инициализирует элементы вектора значением Init.
//Функция возвращает false, в случае невозможности выделения памяти под новый
//размер вектора (в этом случае вектор становится нулевого размера).
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong VectorSize - размерность вещественного вектора;
//2. bool VectorType  - тип вектора (COL || ROW);
//3. double Init (0.0) - инициализирующее значение.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealVector::Set(ulong VectorSize, bool VectorType, double Init)
{//Анализ на соответствие размеров старого и нового вектора
 if (Size() != VectorSize)
 {//1. Удаление элементов вектора со старыми размерами
  Delete();
  //2. Установка новых размеров вектора
  size = VectorSize;
  //3. Распределение памяти под хранение элементов вектора с новыми свойствами
  if (Create() == false) return false;
 }
 type = VectorType;
 //Инициализация элементов вектора
 for (ulong i = 0L; i < Size(); i++) data[i] = Init;
 return true;
}
//***********************************************************************************
//СТАТУС: I.9, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(ulong VectorSize, bool VectorType, bool Init)
//НАЗНАЧЕНИЕ: Функция устанавливает новые характеристики вещественного вектора.
//При установке новых характеристик вектора все старые характеристики аннулируются,
//значения элементов вектора уничтожаются, устанавливаются новые размеры вектора.
//Функция устанавливает  два типа вектора: вектор-строку или вектор-столбец.
//При Init == true элементы вектора инициализируются случайными величинами, при
//Init == false - инициализации элементов вектора не происходит.
//Функция возвращает false, в случае невозможности выделения памяти под новый
//размер вектора (в этом случае вектор становится нулевого размера).
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong VectorSize - размерность вещественного вектора;
//2. bool VectorType  - тип вектора (COL || ROW);
//3. bool Init  - опция инициализации элементов вектора случайными значениями.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealVector::Set(ulong VectorSize, bool VectorType, bool Init)
{//Анализ на соответствие размеров старого и нового вектора
 if (Size() != VectorSize)
 {Delete();//1. Удаление элементов вектора со старыми размерами
  size = VectorSize;//2. Установка новых размеров вектора
  //3. Распределение памяти под хранение элементов вектора с новыми свойствами
  if (Create() == false) return false;
 }
 type = VectorType;
 //Инициализация элементов вектора
 if (Init == true)
 {randomize();//Инициализация генератора случайных чисел
  for (ulong i = 0L; i < Size(); i++) data[i] = rand();
 }
 return true;
}
//***********************************************************************************
//СТАТУС: I.10, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Resize(const ulong NewSize, bool Restore = OFF)
//НАЗНАЧЕНИЕ: Функция изменяет размер вектора с возможностью восстановления значений
//элементов вектора предыдущего размера.
//Функция возвращает false, в случае невозможности выделения памяти под новый размер
//вектора (в этом случае вектор становится нулевого размера).
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ulong Size - новая размерность вектора
//2. bool Restore - опция восстановления значений элементов вектора предыдущего размера
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealVector::Resize(const ulong NewSize, bool Restore)
{//Проверка на совпадение старого и нового размеров вектора
 if (NewSize == Size()) return true;
 rvector V;
 if (Restore == ON) V = *this;
 bool OldType = Type();
 Delete();//Удаление элементов вектора старого размера
 //Установка свойств вектора
 size = NewSize; type = OldType;
 //Распределение памяти под новый размер вектора
 if (Create() == false) return false;
 if (Restore == ON) //Восстановление предыдущих значений элементов вектора
 {ulong Count = (V.Size() > Size()) ? Size() : V.Size();
   for (ulong i = 0L; i < Count; i++) data[i] = V[i];
 }
 return true;
}
//***********************************************************************************
//СТАТУС: I.11, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Random(double a = 0.0, double b = 1.0)
//НАЗНАЧЕНИЕ: Инициализация элементов вектора случайными величинами, распределенными
//по равновероятному закону в интервале [a..b]. Функция возвращает false для вектора
//нулевой длины.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double a (0) - нижняя граница интервала изменения равномерной СВ
//2. double b (1) - верхняя граница интервала изменения равномерной СВ
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//***********************************************************************************
bool TRealVector::Random(double a, double b)
{//Вектор нулевого размера не инициализируется
 if (Size() == 0L) return false;
 TRandomGenerator RNG(T_4);//Создание генератора случайных чисел
 //Инициализация элементов вектора СВ
 for (ulong i = 0L; i < Size(); i++) data[i] = RNG.Random(a, b);
 return true;
}
//***********************************************************************************
//СТАТУС: I.12, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Rand2PI()
//НАЗНАЧЕНИЕ: Инициализация элементов вектора случайными величинами, распределенными
//по равновероятному закону в интервале [0..2PI]. Функция возвращает false для вектора
//нулевой длины.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//***********************************************************************************
bool TRealVector::Rand2PI()
{//Вектор нулевого размера не инициализируется
 if (Size() == 0L) return false;
 TRandomGenerator RNG(T_4);//Создание генератора случайных чисел
 //Инициализация элементов вектора СВ
 for (ulong i = 0L; i < Size(); i++) data[i] = RNG.Rand2PI();
 return true;
}
//***********************************************************************************
//СТАТУС: I.13, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Gauss(double E = 0.0, double D = 1.0)
//НАЗНАЧЕНИЕ: Инициализация  элементов  вектора случайными величинами, распределенными
//по нормальному закону с математическим ожиданием E и дисперсией D. Функция возвращает
//false для вектора нулевой длины.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double E (0) - математическое ожидание гауссовой СВ
//2. double D (1) - дисперсия гауссовой СВ
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//***********************************************************************************
bool TRealVector::Gauss(double E, double D)
{//Вектор нулевого размера не инициализируется
 if (Size() == 0L) return false;
 TRandomGenerator RNG(T_8);//Создание генератора случайных чисел
 //Инициализация элементов вектора СВ
 for (ulong i = 0L; i < Size(); i++) data[i] = RNG.Gauss(E, D);
 return true;
}
//***********************************************************************************
//СТАТУС: I.14, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Relay()
//НАЗНАЧЕНИЕ: Инициализация элементов вектора случайными величинами, распределенными
//по закону Рэлея. Функция возвращает false для вектора нулевой длины.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//***********************************************************************************
bool TRealVector::Relay()
{//Вектор нулевого размера не инициализируется
 if (Size() == 0L) return false;
 TRandomGenerator RNG(T_4);//Создание генератора случайных чисел
 //Инициализация элементов вектора СВ
 for (ulong i = 0L; i < Size(); i++) data[i] = RNG.Relay();
 return true;
}
//***********************************************************************************
//СТАТУС: I.15, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Exp(double t = 1.0)
//НАЗНАЧЕНИЕ: Инициализация  элементов  вектора случайными величинами, распределенными
//по экспоненциальному закону с параметром t. Функция возвращает false для вектора
//нулевой длины.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: double t (1.0) - параметр экспоненциальной СВ
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//***********************************************************************************
bool TRealVector::Exp(double t)
{//Вектор нулевого размера не инициализируется
 if (Size() == 0L) return false;
 TRandomGenerator RNG(T_4);//Создание генератора случайных чисел
 //Инициализация элементов вектора СВ
 for (ulong i = 0L; i < Size(); i++) data[i] = RNG.Exp(t);
 return true;
}
//****************************************************************************************
//СТАТУС: I.16, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit(const string& name, bool confirm = true);
//НАЗНАЧЕНИЕ: КОНСОЛЬНОЕ РЕДАКТИРОВАНИЕ СВОЙСТВ и ЭЛЕМЕНТОВ ВЕКТОРА
//Функция предназначена для ввода/редактирования ВСЕХ элементов вектора, а также ее свойств
//в консольном режиме. В зависимости от типа действительного вектора подключается функция
//ввода элементов для данного вектора. Предусмотрен режим ввода элементов вектора с
//подтверждением введенных данных по каждому элементу вектора. Строка name задает наименование
//вектора. При вводе каждого элемента вектора предусматривается контроль корректности вводимых
//данных. При работе функции значения элементов вектора изменяются безвозвратно. Формат ввода
//следующий:
//----------------------------------------------------------------------------------------
//MODE: EDIT REAL VECTOR <name>
//TYPE: <vector type>; DIMENSION: <Size()>.
//----------------------------------------------------------------------------------------
//Select option:
//1. Change vector properties;
//2. Edit vector elements;
//3. Exit
//Enter number [1-3]: _
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование вектора;
//2. bool confirm - опция подтверждения ввода каждого элемента вещественного вектора.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TRealVector::Edit(const string& name, bool confirm)
{const string line(78,'-');
 STR_UINT Option[3] = {
  {1, "Change vector's properties" },
  {2, "Edit vector elements" },
  {3, "Exit" } };
 TB_STR_UINT TbOption = {3, Option};

 string head,t;
 uint nChoice;
 do //Начало цикла редактирования
 {//--------------------------------------------------------------------------------------
  //Вывод заголовка и свойств редактируемого вектора
  clrscr(); //Очистка экрана
  cout << line << endl;
  cout << "MODE: EDIT REAL VECTOR - <" << name << ">" << endl;
  cout << "     " << Properties(head);
  cout << line << endl;
  //----------------------------------------------------------------------------
  head.assign(" Select option: ");
  nChoice = ConsoleChoice(TbOption, 3, head.c_str(), 2);
  //Анализируем выбор пользователя
  if (nChoice == 1) //Изменение характеристик редактируемого вектора
  {PF_VECTOR Info;
   InPutPF_VECTOR(Info, name.c_str());
   Set(Info.size,Info.type);
   if (Info.subtype == V_NUMBER || Info.subtype == V_ORDINARY) Random();
   if (Info.subtype == V_UNIT) *this = 1.0;
   if (Info.subtype == V_SCALAR) *this = 2.0;
   cout << "New real vector's properties have just installed!" << endl;
   cout << "Vector is initialized according to its extended type." << endl;
   cout << "Press any key...\a"; getch();
  }
  else if (nChoice == 2) //Редактирование элементов
  {clrscr(); //Очистка экрана
   switch (SubType()) //Определение подтипа вектора
   {case V_ZEROSIZE: //Вектор нулевой длины (нулевого размера)
     cout << "\nMODE: INPUT ELEMENTS of <" << GetSubType(t) << ">" << endl;
     cout << "WARNING! Input elements of this vector are impossible." << endl;
     cout << "Press any key...\a"; getch();
     break;
    case V_ZERO: //Ввод элементов нулевого вектора
     break;
    case V_UNIT: //Ввод элементов единичного вектора
     break;
    case V_SCALAR: //Ввод элементов скалярного вектора
     InPutScalar(name,confirm);
     break;
    default: //Стандартный ввод элементов действительного вектора
     InPutVector(name,confirm);
   }
  }
  else if (nChoice == 3) //Выход из режима редактирования
  {//Запрос на выход из режима редактирования
   char c;
   cout << "Would you like to finish vector editing? [y/n]: "; cin >> c;
   if ((c == 'y') || (c == 'Y')) {clrscr(); break;}
  }
 } while (true); //Завершение цикла редактирования
}
//****************************************************************************************
//СТАТУС: I.17, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& ConvertToString(string& s, string& sep, string& etc, ulong count = 0L) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ СИМВОЛЬНОГО ПРЕДСТАВЛЕНИЯ ЗНАЧЕНИЙ ЭЛЕМЕНТОВ ВЕКТОРА
//Функция преобразует значения элементов вектора в их символьное представление и формирует
//строку s, состоящую из count элементов вектора, начиная с нулевого элемента. Элементы
//вектора разделяются символами строки sep (по умолчанию - пробелами). Если аргумент count
//указывает не на все элементы вектора, то за последним элементом выводится строка etc
//(по умолчанию - "..."). Формат вывода следующий:
//----------------------------------------------------------------------------------------
// <V[0]> <sep> <V[1]> <sep> ... <V[count-1]> [ <etc> ]
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку с формируемыми значениями элементов вектора;
//2. string& sep - символы-разделители между значениями элементов вектора;
//3. string& etc - строка, выводимая за последним значением элемента вектора,
//   если count != Size().
//4. ulong count (0) - количество выводимых элементов вектора, начиная с нулевого значения;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, содержащую символьное представление значений
//элементов вектора.
//****************************************************************************************
string& TRealVector::ConvertToString(string& s, string& sep, string& etc, ulong count) const
{//Анализ на вектор нулевого размера
 if (Size() == 0L) {s = "Zero-size vector"; return s;}
 //Установка корректных параметров
 if ((count == 0L) || (count >= Size())) count = Size();
 if (sep.empty()) sep.assign(1,' ');
 if (etc.empty()) etc.assign("...");
 //Формирование значений элементов вектора
 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 s.resize(0);
 for (ulong i = 0L; i < count; i++)
 {text << data[i];
  if (count-i > 1) text << sep;
  text << ends;
  s.append(text.str());
  text.seekp(0);
 }
 //Вывод строки etc
 if (count != Size()) {s.append(" "); s.append(etc);}
return s;
}
//****************************************************************************************
//СТАТУС: I.18, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& ToString(string& s, ulong MaxLenStr, uint precision) const;
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ СИМВОЛЬНОГО ПРЕДСТАВЛЕНИЯ ЗНАЧЕНИЙ ЭЛЕМЕНТОВ ВЕКТОРА
//Функция преобразует значения элементов вектора в их символьное представление и формирует
//строку s максимальной длиной MaxLenStr, начиная с нулевого элемента. Соседние элементы
//вектора разделяются одним пробелом. Если MaxLenStr равен нулю, то выводятся все элементы
//вектора. Если все элементы вектора не могут быть размещены в строке s длиной MaxLenStr,
//то за последним поместившимся элементом выводится многоточие (...). Для вектора нулевого
//размера формируется пустая строка. Минимальная длина строки для ненулевого вектора равна
//3 (...). Precision задает точность представления чисел с плавающей точкой. Формат вывода
//следующий:
//----------------------------------------------------------------------------------------
// <V[0]> <space> <V[1]> <space> ... <V[count-1]> [ <...> ]
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку с формируемыми значениями элементов вектора;
//2. ulong MaxLenStr - максимальная длина символьной строки s;
//3. uint precision - точность представления элементов вектора;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, со строковым представление значений элементов вектора.
//****************************************************************************************
string& TRealVector::ToString(string& s, ulong MaxLenStr, uint precision) const
{s.resize(0);
 if (Size() == 0L) return s; //Анализ на вектор нулевого размера
 //Установка индикатора проверки оставшейся длины строки
 bool lCheck = (MaxLenStr > 0L) ? true : false;
 ulong count = 0L;//Счетчик числа элементов вектора, размещенных в строке s
 ulong cur_size = 0L;//Текущий размер строки
 char buffer[40]; ostrstream text(buffer, sizeof(buffer));
 //---------------------------------------------------------------------------------------
 //Цикл размещения элементов вектора в строке s максимальной длины MaxLenStr
 for (ulong i = 0L; i < Size(); i++)
 {//Формирование символьного представления вещественного числа
  text << setprecision(precision) << data[i];
  if (lCheck) //Длина строки s ограничена
  {//Определение длины строки s с учетом размещения в ней i-го элемента вектора
   cur_size += text.pcount();
   if (cur_size >= MaxLenStr)
   {//Все элементы вектора не удалось разместить в строке s
    if (count != Size()-1) s.append("...");
    break;//Преждевременный выход из цикла
   }
   cur_size++;//Учитываем пробел между элементами вектора в строке s
  }
  if (++count < Size()) text << ' ';
  text << ends;
  s.append(text.str());//Размещение i-го элемента вектора в строке s
  text.seekp(0);
 }
return s;
}
//****************************************************************************************
//СТАТУС: I.19, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// ulong ToMultiLineString(string& s, ulong MaxLines = 0L, ulong MaxLenLine = 78,
//       uint precision = 6, char cStart = '{', char cEnd = '}') const;
//НАЗНАЧЕНИЕ: ФОРМАТИРОВАННЫЙ МНОГОСТРОЧНЫЙ ВЫВОД ЭЛЕМЕНТОВ ВЕКТОРА В СТРОКУ
//Функция представляет значения элементов вектора в многостроковом символьном формате.
//Максимальное количество подстрок в строке s определяется MaxLines. При MaxLines = 0
//количество строк не ограничивается. Ширина каждой строки определяется MaxLenLine.
//При MaxLenLine = 0 - все элементы выводятся в одну строку. Минимальная ширина строки
//равна 5 для представления строки вида <{...}>. Если вектор нулевого размера, то по
//умолчанию возвращается строка <{}>. Точность вывода задается параметром precision.
//Символы cStart и cEnd задают правую и левую границы между которыми размещаются эле-
//менты вектора. Если ширина строки меньше ширины элемента вектора, то вместо его зна-
//чения выводится <???>. Если все элементы вектора невозможно разместить в MaxLines
//строках, то за последним элементом, который может быть размещен в последней строке
//выводится - <...>. Соседние элементы разделяются символом пробела.
//Многостроковое символьное представление элементов вектора формируется в строке s.
//Функция возвращает кол-во строк, в которых удалось разместить элементы вектора.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку с формируемыми значениями элементов вектора в
//   многострочном представлении;
//2. ulong MaxLines - максимальное количество строк, в которых допускается размещение
//   элементов вектора;
//3. ulong MaxLenStr - максимальная ширина каждой строки;
//4. uint precision - точность представления элементов вектора;
//5. char cStart - начальный символ вывода элементов вектора в строку s;
//6. char cEnd - завершающий символ вывода элементов вектора в строку s;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ulong Lines - количество строк, в которых удалось разместить элементы вектора.
//***********************************************************************************
ulong TRealVector::ToMultiLineString(string& s, ulong MaxLines, ulong MaxLenLine,
      uint precision, char cStart, char cEnd) const
{s.resize(0);
 if (Size() == 0L) //Вектор нулевой длины
 {s.append(&cStart); s.append(&cEnd); return 0L;}
 char buffer[40]; ostrstream text(buffer, sizeof(buffer));
 //----------------------------------------------------------------------------------
 //Вывод всех элементов вектора в одну строку (MaxLenLine == 0)
 //----------------------------------------------------------------------------------
 if (MaxLenLine == 0L) //Длина строки не ограничена
 {s.append(&cStart);//Добавляем начальный символ
  for (ulong i = 0L; i < Size(); i++)
  {//Формирование символьного представления вещественного числа
   text << setprecision(precision) << data[i];
   if (i < Size()-1) text << ' ';
   text << ends;
   s.append(text.str());//Размещение i-го элемента вектора в строке s
   text.seekp(0);
  }
  s.append(&cEnd);//Добавляем завершающий символ
  return 1;
 }
 //----------------------------------------------------------------------------------
 //Вывод элементов вектора в одну или несколько строк, фиксированной ширины, без
 //ограничения на максимальное число строк (MaxLines == 0)
 //----------------------------------------------------------------------------------
 if (MaxLines == 0L) //Количество строк неограничено
 {//Установка ширины строки под размещение элементов вектора с учетом начального и
  //завершающего символов. Минимальная ширина Width == 3 ("???")
  ulong Width = (MaxLenLine < 3) ? 3 : MaxLenLine;
  if (cStart != 0) Width--; if (cEnd != 0) Width--; if (Width < 3) Width = 3;
  char cIndent = (cStart != 0) ? ' ' : (char) 0;//Символ отступа
  ulong LinesCount = 1L;//Счетчик числа строк
  ulong index = 0;//Индекс обрабатываемого элемента вектора
  ulong CurLenLine = 0L;//Длина текущей подстроки
  ulong LastElem = Size()-1;
  s.append(&cStart);
  //Размещение элементов вектора в s по подстрокам шириной не более Width
  do
  {text << setprecision(precision) << data[index] << ends;
   ulong LenElem = text.pcount()-1;//Длина символьного представления текущего элемента
   CurLenLine+= LenElem;
   if (CurLenLine <= Width) //Текущий элемент можно разместить в данной подстроке
   {s.append(text.str()); text.seekp(0);
    if (index != LastElem) //Текущий элемент вектора не последний
    {//Символ-разделитель между элементами
     if (Width-CurLenLine > 1) {s.append(1,' '); CurLenLine++;}
     else //Переход на новую строку
     {s.append(1,'\n'); s.append(&cIndent); CurLenLine = 0L; LinesCount++;}
    }
   }
   else //Текущий элемент вектора разместить в подстроке не удается
   {if (Width < LenElem)//Ширины подстроки недостаточно для размещения одного элемента
    {CurLenLine = CurLenLine - LenElem; text.seekp(0);
     if (Width-CurLenLine >= 3) //Размещаем '???' в данной подстроке
     {s.append("???");
      if (index != LastElem) //Элемент вектора не последний
      {CurLenLine += 3;
       if (Width-CurLenLine > 1) {s.append(1,' '); CurLenLine++;}
       else {s.append(1,'\n'); s.append(&cIndent); CurLenLine = 0L; LinesCount++;}
      }
     }
     else //Размещаем '???' в новой подстроке
     {s.append(1,'\n'); s.append(&cIndent); s.append("???"); LinesCount++;
      if (index != LastElem) //Элемент вектора не последний
      {CurLenLine = 3;
       if (Width-CurLenLine > 1) {s.append(1,' '); CurLenLine++;}
       else {s.append(1,'\n'); s.append(&cIndent); CurLenLine = 0L; LinesCount++;}
      }
     }
    }
    else //Размещаем элемент в новой подстроке
    {s.append(1,'\n'); s.append(&cIndent); s.append(text.str()); text.seekp(0);
     LinesCount++;
     if (index != LastElem) //Элемент вектора не последний
     {CurLenLine = LenElem;
      if (Width-CurLenLine > 1) {s.append(1,' '); CurLenLine++;}
      else {s.append(1,'\n'); s.append(&cIndent); CurLenLine = 0L; LinesCount++;}
     }
    }
   }
  } while (++index <= LastElem);
  s.append(&cEnd);
  return LinesCount;
 }

 /*
 //----------------------------------------------------------------------------------
 //Вывод элементов вектора в одну или несколько строк с ограниченной шириной строки
 //----------------------------------------------------------------------------------
 if (MaxLenLine < 5) MaxLenLine = 5;
 //Индикатор ограничения количества строк
 bool lCheck = (MaxLines != 0L) ? true : false;
 ulong LineCount = 1L;//Счетчик числа строк, в которых размещаются элементы вектора
 char cIndent = (cStart != '') ? ' ' : '';
 ulong index = 0;//Индекс элемента вектора, выводимого в строку
 //Цикл размещения элементов вектора в s по подстрокам шириной не более MaxLenLine
 do
 {ulong CurLenLine = (cStart != '') ? 1L : 0L;
  bool lFirst = true;//Индикатор вывода первого элемента в подстроке
  bool lBufEmpty;//Индикатор наличия в buffer строкового представления элемента
  //Формирование подстроки шириной не более MaxLenLine
  if (LineCount != 1) s.append(cIndent);
  else s.append(cStart);
  do
  {text << setprecision(precision) << data[index] << ends;
   CurLenLine += text.pcount()-1;
   if (CurLenLine > MaxLenLine) //Достигнут конец подстроки
   {if (lFirst)
    {if (lCheck && (LineCount == MaxLines)) s.append("???");// ??????
     index++; text.seekp(0); lBufEmpty = true;
    }
    else lBufEmpty = false;
    break;//Выход из цикла формирования подстроки
   }
   else //Конец подстроки не достигнут
   {s.append(text.str()); text.seekp(0); lBufEmpty = true; index++; ///???
    if ((index == Size()) || (CurLenLine == MaxLenLine)) break;
    else {s.append(' '); lFirst = false; CurLenLine++;} ///???
   }
  } while (true);


 } while (true);

 //----------------------------------------------------------------------------------
 //Цикл размещения элементов вектора в строке s максимальной длины MaxLenStr
 for (ulong i = 0L; i < Size(); i++)
 {//Формирование символьного представления вещественного числа
  text << setprecision(precision) << data[i];
  if (lCheck) //Длина строки s ограничена
  {//Определение длины строки s с учетом размещения в ней i-го элемента вектора
   cur_size += text.pcount();
   if (cur_size >= MaxLenStr)
   {//Все элементы вектора не удалось разместить в строке s
    if (count != Size()-1) s.append("...");
    break;//Преждевременный выход из цикла
   }
   cur_size++;//Учитываем пробел между элементами вектора в строке s
  }
  if (++count < Size()) text << ' ';
  text << ends;
  s.append(text.str());//Размещение i-го элемента вектора в строке s
  text.seekp(0);
 }
 */
return 1;
}
//****************************************************************************************
//СТАТУС: I.20, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//ulong GetDataFromString(const string& source, bool unique = false,
//                        const TArgVectorPredicate<double,rvector>* Predicate);
//НАЗНАЧЕНИЕ: Функция извлекает из строки source значения типа double в символьном виде,
//преобразует их в тип double и записывает их в вещественный вектор в порядке считывания из
//исходной строки. Функция преобразует в значения элементов вектора отдельные вещественные
//числа и их интервалы. Структура строки может быть представлена в виде:
//<STRING> = {[<Real Value> || <Interval>]<Sep>...[<Real Value> || <Interval>]},
//<Real Value> = [<Sign>]<Digit>[<Digits>.<Digits><E|e><[Sign]><Digits>] - вещественное число;
//<Interval> = <LeftBracket><Left>[<,><Left+Delta>]<..><Right><RightBracket> - интервал
//чисел типа long ;
//<LeftBracket> = <([> - левая скобка;
//<RightBracket> = <)]> - правая скобка;
//<Left> = <Real Value> - значение нижней границы интервала;
//<Left+Delta> = <Real Value> - следующее значение интервала после Left. По значениям <Left>
//и <Left+Delta> определяется дискретность интервала. Если данная величина пропущена, то
//шаг равен 1;
//<..> - двоеточие - обязательный параметр, который должен предшествовать <Right>;
//<Right> - значение верхней границы интервала;
//<Sep> = <SPACE,TAB> - символы-разделители между символьными представлениями чисел типа
//<double>;
//<Sign> = <+-> - знак числа;
//<Digit> = <0123456789> - числа, из которых складываются значения типа long.
//Пример: <-1.0, -4.24e+2, [0.2,1.3..10.6], 20, (11.3..20.9), -8, 12.0e-4>.
//Интервалы могут включать или не включать свои границы. Круглые скобки <()> означают, /что
//граница не входит в интервал, квадратные скобки <[] - граница входит в интервал. При любом
//шаге интервала, если <Right> принадлежит интервалу, данное значение всегда войдет в вектор.
//При отсутствии в строке закрывающейся скобки <RightBracket> функция завершает свою работу
//(в случае обнаружения предшествующей открывающейся скобки <LeftBracket>). Между <Left> и
//<Left+Delta> должна всегда следовать запятая, а перед <Right> двоеточие. Интервалы и
//отдельные целые числа могут разделяться символами-разделителями <Sep>. В общем случае, за
//исключением специального синтаксиса, введенного для интервалов - обязательное наличие
//закрывающейся скобки при наличии открывающейся, наличие символа <,> между левой границей
//интервала и следующим значением интервала (в случае его указания), а также двоеточия <..>
//перед Right - функция не критична к присутствию символов отличных от <Sep>,<Digit>,<Sign>,
//<..>. Функция игнорирует символы не относящиеся к вышеперечисленному множеству - алфавиту
//данной грамматики, не прерывая своей работы при их обнаружении. Функция прерывает свою
//работу в следующих случаях:
//1. Не обнаружено новых символов из множества <Sign>+<Digit> либо <LeftBracket>;
//2. После обнаружения символа из <LeftBracket> не обнаружено символа из <RightBracket>
//   - отсутствует правая скобка.
//При  преобразовании  интервалов в последовательность вещественных чисел должны выполняться
//следующие семантические правила:
//1. left < left+delta < right, т.е. между левой и правой границей должно располагаться
//   хотя бы одно вещественное число.
//Все  успешно  извлеченные  из  строки  вещественные числа размещаются в списке list<double>.
//После  завершения  разбора  строки  source значения в порядке их считывания из строки
//переносятся  в исходный  вектор при этом размерность исходного вектора изменяется и
//становится равной размеру списка. Если установлена опция unique, то функция предотвращает
//дублирование одинаковых значений, извлеченных из строки. С этой целью по каждому новому
//считанному значению перед его размещением в списке ведется поиск среди размещенных там
//значений. Если данное значение отсутствует в списке, то оно добавляется в данный список,
//в противном случае - игнорируется.
//Функция принимает указатель на шаблонный объект-предикат Predicate.
//Если Predicate != NULL, то все считанные из строки source вещественные числа передаются
//в качестве аргумента перегруженному оператору вызова функции () объекта-предиката
//TArgVectorPredicate. В  зависимости от текущего значения вещественного числа и функцио-
//нальных свойств предиката оператор вызова функции возвращает логическое значение - true
//или false. Результат работы оператора вызова функции свидетельствует о том, что удовлет-
//воряет или нет текущее целое значение условиям предиката. Объект-предикат используется в
//качестве фильтра для отбора определенных вещественных значений в качестве элементов вектора
//из всей последовательности вещественных чисел, извлеченных из строки. Если строка source
//не содержит ни одного вещественного значения, то исходный вектор становится вектором ну-
//левого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& source - ссылка на строку с символьным представлением вещественных чисел
//   в виде последовательности отдельных значений и интервалов;
//2. bool unique (false) - разрешение или запрещение дублирования значений элементов вектора,
//   считываемых из содержимого строки source.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong count - количество считанных из строки str элементов вектора
//****************************************************************************************
ulong TRealVector::GetDataFromString(const string& source, bool unique,
                   const TArgVectorPredicate<double, rvector>* Predicate)
{ulong count = 0L;
 long ind_number, ind_interval, index;
 std::list<double> List;
 rvector Interval;
 std::list<double>::iterator Iterator;
 double value;
 bool AddElement;
 string str(source);//Копирование исходной строки
 string ends;
 //Алфавит символьного представления вещественного числа, с которых вещественное число
 //может начинаться
 const string DigitSign("0123456789+-");
 //const string Sign("+-");
 const string LeftBracket("([");
 const string RightBracket(")]");
 //Цикл считывания из строки последовательности вещественных чисел и их интервалов
 do
 {//Проверка строки str на пустую строку
  if (str.empty()) break;
  index = string::npos;//NPOS
  //Поиск первого символа из множества <DigitSign> в str
  ind_number = str.find_first_of(DigitSign);
  if (ind_number != string::npos) index = ind_number;//NPOS = -1
  //Поиск первой левой скобки из множества <LeftBracket> в str
  ind_interval = str.find_first_of(LeftBracket);
  if (ind_interval != string::npos)
  {if (index != string::npos) //NPOS = -1
    index = (ind_number < ind_interval) ? ind_number : ind_interval;
   else index = ind_interval;
  }
  //Строка не содержит вещественных чисел и их интервалов
  if (index == string::npos) break;//Выход из цикла NPOS = -1
  str = str.substr(index);
  //Преобразование символьного представления вещественного числа в тип double
  if (index == ind_number)
  {if (StrToDouble(value,str,ends))//Преобразование произошло успешно
   {//************************************************************************************
    //Добавление нового значения к списку List
    //************************************************************************************
    //1. Проверка на возможность включения значения value в список List
    if (Predicate == NULL) AddElement = true;
    else AddElement = (*Predicate)(value);
    //2. Проверка значения value на уникальность
    if ((unique == true) && (AddElement == true))
    {//Поиск value в списке List
     Iterator = std::find(List.begin(),List.end(),value);
     //Значение value в списке содержится
     if (Iterator != List.end()) AddElement = false;
    }
    //Добавить элемент в конец списка
    if (AddElement) {List.push_back(value); count++;}
    str = ends;
   }
   //Ошибка при преобразовании вещественного значения из строкового в тип double
   //Переход к следующему символу строки str
   else {if (str.length() > 1) str = str.substr(1);}
  }
  //Преобразование символьного представления интервала в список вещественных чисел
  else if (index == ind_interval)
  {//Поиск первой правой скобки из множества <RightBracket> в str
   ind_interval = str.find_first_of(RightBracket);
   //Правая скобка не найдена, выход из цикла
   if (ind_interval == string::npos) break; //NPOS = -1
   //Извлечение подстроки с символьным представлением интервала чисел
   ends = str.substr(0,ind_interval+1);
   //Извлечение подстроки из строки str, начинающейся за правой скобкой интервала
   str = str.substr(ind_interval+1);
   //Преобразование строкового представления интервала вещественных чисел в список
   //типа double
   Interval.StrIntervalToVector(ends);
   //Вектор не является вектором нулевого размера
   if (!Interval.IsZeroSize())
   {//Цикл считывания данных из Interval в List
    for (ulong i = 0L; i < Interval.Size(); i++)
    {value = Interval[i];
     //******************************************************************************
     //Добавление нового значения к списку List
     //******************************************************************************
     //1. Проверка на возможность включения значения value в список List
     if (Predicate == NULL) AddElement = true;
     else AddElement = (*Predicate)(value);
     //2. Проверка значения value на уникальность
     if ((unique == true) && (AddElement == true))
     {//Поиск value в списке List
      Iterator = std::find(List.begin(),List.end(),value);
      //Значение value в списке содержится
      if (Iterator != List.end()) AddElement = false;
     }
     //Добавить элемент в конец списка
     if (AddElement) {List.push_back(value); count++;}
    }//Конец цикла считывания данных из Interval в List
   }
  }
 } while (true);
 //Считывание данных из списка List в исходный вектор
 if (List.empty()) Resize(0L); //Список является пустым
 else //Список содержит данные
 {//Устанавливаем размер исходного вектора равного размеру списка
  Resize(List.size());
  //Цикл копирования значений элементов списка List в исходный вектор
  for (ulong i = 0L; i < Size(); i++)
  {data[i] = List.front(); List.pop_front();}
 }
return count;//Количество считанных из строки данных
}
//***********************************************************************************
//СТАТУС: I.20, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// ulong StrIntervalToVector(const string& source, double eps = 1e-15);
//НАЗНАЧЕНИЕ: ПРЕОБРАЗОВАНИЕ СТРОКОВОГО ПРЕДСТАВЛЕНИЯ ИНТРЕВАЛА ВЕЩЕСТВЕННЫХ ЧИСЕЛ В
//            ВЕКТОР ЗНАЧЕНИЙ ТИПА <DOUBLE>
//Функция осуществляет извлечение из строки source  значений  элементов  вектора
//типа double в  символьном  виде, преобразовании  их в тип double и записи их в
//данный вектор. Функция  преобразовывает в значения элементов вектора интервалы
//вещественных  чисел. Символьная  структура  интервала вещественных чисел может
//быть представлена в следующем виде:
//<STRING> = <Interval>,
//<Interval> = <LeftBracket><Left>[<,><Left+Delta>]<..><Right><RightBracket> -
//интервал чисел типа double ;
//<LeftBracket> = <([> - левая скобка;
//<RightBracket> = <)]> - правая скобка;
//<Left> = <Long Value> - значение нижней границы интервала;
//<Left+Delta> = <Long Value> - следующее значение интервала после Left. По зна-
//чениям <Left> и <Left+Delta> определяется дискретность интервала. Если данная
//величина пропущена, то шаг равен 0.1;
//<..> - двоеточие - обязательный параметр, который должен предшествовать <Right>;
//<Right> - значение верхней границы интервала;
//<Sep> = <SPACE,TAB> - символы-разделители между символьными представлениями
//чисел типа <long>;
//<Long Value> = [<Sign>]<Digit>[<Digit>...<Digit>] - знаковое длинное целое;
//<Sign> = <+-> - знак числа;
//<Digit> = <0123456789> - числа, из которых складываются значения типа long.
//Примеры: [0.0,1.2..10.9], (11..20), (-10.9,0.01..+10.1], [20..100) и т.д.
//Интервалы могут включать или не включать свои границы. Круглые скобки <()>
//означают, что граница не входит в интервал, квадратные скобки <[] - граница
//входит в интервал. При любом шаге интервала, если <Right> принадлежит интерва-
//лу, данное значение всегда войдет в вектор.
//При разборе строки source действуют следующие СИНТАКСИЧЕСКИЕ ПРАВИЛА:
//1. Первым символом в строке, содержащим интервал обязательно должна быть откры-
//   вающая скобка <LeftBracket>, а последним символом должна быть закрывающая
//   скобка <RightBracket>;
//2. Между <Left> и <Left+Delta> должна всегда следовать запятая;
//3. Перед <Right> должно следовать двоеточие;
//4. Допускается пропуск <Left+Delta>, в этом случае шаг по умолчанию равен 0.1.
//   Наличие значений правой и левой границ интервала обязательно.
//При преобразовании интервалов в последовательность целых чисел должны выпол-
//няться следующие СЕМАНТИЧЕСКИЕ ПРАВИЛА:
//1. left < left+delta < right, т.е. между левой и правой границей должно распо-
//   лагаться хотя бы одно целое число.
//При несоблюдении вышеперечисленных правил, функция возвращает count == 0, а
//исходный вектор становится вектором нулевого размера.
//Все  успешно  извлеченные  из  строки  вещественные числа размещаются в списке
//list<double>.
//После завершения разбора строки source значения в порядке их считывания из
//строки переносятся в исходный вектор при этом размерность исходного вектора
//меняется и становится равной размеру списка. Если строка source не содержит ни
//одного вещественного значения, то исходный вектор становится вектором нулевого
//размера и функция возвращает count == 0.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& source - ссылка на строку с символьным представлением интервала
//   вещественных чисел;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ulong count - количество преобразованных из символьного представления интервала ве-
//щественных чисел значений элементов вектора
//double eps (1e-15) - точность сравнения
//***********************************************************************************
ulong TRealVector::StrIntervalToVector(const string& source, double eps)
{ulong count = 0L;
 Resize(0L);//Установка вектора в вектор нулевого размера
 string str = source;//Копирование исходной строки
 ulong pos;
 long index;
 //Нижняя, верхняя границы и дискретность интервала
 double left, right, delta;
 //Принадлежность значений границ интервала интервалу
 bool LeftBelong, RightBelong;
 //Признак установки шага интервала по умолчанию
 bool lDeltaDefault;
 std::list<double> List;
 double value; //Текущее вещественное число, извлеченное из строки
 //Алфавит символьного представления вещественного числа, с которых вещественное
 //число может начинаться и заканчиваться
 //const string DigSigns("0123456789+-");
 //Объект класса преобразования строки символов в вещественное число типа double
 TStrToDouble stod;
 //*****************************************************************************
 //1. Устанавливаем принадлежность границ интервалу
 //*****************************************************************************
 //Установка принадлежности нижней границы интервала
 if (str[0] == '(') LeftBelong = false;
 else if (str[0] == '[') LeftBelong = true;
 //Первый символ строки не является символом из множества <LeftBracket>
 else return count;
 //----------------------------------------------------------------------------
 //Установка принадлежности верхней границы интервала
 index = str.length()-1;
 if (str[index] == ')') RightBelong = false;
 else if (str[index] == ']') RightBelong = true;
 //Последний символ строки не является символом из множества <RightBracket>
 else return count;
 //****************************************************************************
 //2. Устанавливаем нижнюю границу интервала - left
 //****************************************************************************
 pos = index = 1;
 if (stod(str,pos,left) && !stod.IsEOS())
 {if (stod.GetTokenClass() == dtPoint) pos = pos-1;
  str = str.substr(index+pos);
 }
 else return count;

 //****************************************************************************
 //3. Устанавливаем дискретность интервала
 //****************************************************************************
 index = str.find_first_of(",");
 if (index == string::npos) lDeltaDefault = true;//Установка шага интервала по умолчанию NPOS=-1
 else
 {//Устанавливаем значение дискретности интервала
  lDeltaDefault = false;
  index += 1; pos = index;
  if (stod(str,pos,value) && !stod.IsEOS())
  {delta = value - left;
   if (stod.GetTokenClass() == dtPoint) pos--;
   str = str.substr(index+pos);
  }
  else return count;
 }
 //****************************************************************************
 //4. Устанавливаем правую границу интервала
 //****************************************************************************
 index = str.find("..");
 if (index == string::npos) return count; //NPOS = -1
 pos = index+2;
 str = str.substr(pos);
 pos = 0;
 if (stod(str,pos,right) == false) return count;
 //Установка дискретности интервала по умолчанию
 if (lDeltaDefault) delta = (right - left) * 0.1;

 //****************************************************************************
 //5. Проверка значений left, right и delta на непротиворечивость
 //****************************************************************************
 if (delta == 0.0) return count;
 if (right == left) return count;
 //Интервал должен быть ЗАМКНУТЫМ и СХОДЯЩИМСЯ к right
 if (fabs(right - left) <= fabs(right - (left + delta))) return count;
 //Между left & right всегда должно размещаться хотя бы одно значение
 if (delta > 0) //Шаг положительный
  if (left + delta >= right) return count;
 else if (delta < 0) //Шаг отрицательный
  if (left + delta <= right) return count;
 //****************************************************************************
 //6. Записываем значения принадлежащие интервалу в список List
 //****************************************************************************
 if (LeftBelong == false) value = left + delta;
 else value = left;
 do
 {List.push_back(value); count++;
  value += delta;
  if ((fabs(value-right) <= eps) || ((right > left) && (value > right)) ||
      ((left > right) && (value < right)))
  {if (RightBelong == true) {List.push_back(right); count++;}
   break;//Выход из цикла
  }
 } while (true);
 //****************************************************************************
 //7. Переписываем значения из списка List в данный вектор
 //****************************************************************************
 //Устанавливаем размер исходного вектора равного размеру списка
 Resize(List.size());
 //Цикл копирования значений элементов списка List в исходный вектор
 for (ulong i = 0L; i < Size(); i++)
 {data[i] = List.front(); List.pop_front();}
return count;
}
//***********************************************************************************
//СТАТУС: I.21, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:  rvector SubVector(ulong left, ulong right) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДВЕКТОРА ИЗ ДАННОГО ВЕКТОРА
//Функция формирует подвектор, начиная с элемента с индексом left, и до элемента с
//индексом right включительно. Если исходный вектор является вектором нулевого размера,
//то функция возвращает также подвектор нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left - левая граница;
//2. ulong right - правая граница.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rvector SubVector - подвектор исходного вектора
//***********************************************************************************
rvector TRealVector::SubVector(ulong left, ulong right) const
{rvector SubVector;
 //Проверка на вектор нулевого размера
 if (Size() == 0L) return SubVector;
 //Анализируем исключительные ситуации
 if (left > right) return SubVector;
 if ((left >= Size()) || (right >= Size())) return SubVector;
 if ((left == 0L) && (right == Size()-1)) return *this;
 //Формирование подвектора
 SubVector.Resize(right - left + 1); SubVector.SetType(Type());
 for (ulong i = left; i <= right; i++) SubVector.Put(i-left,data[i]);
return SubVector;
}
//***********************************************************************************
//СТАТУС: I.22, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:  rvector Unique() const;
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДВЕКТОРА ИЗ ДАННОГО ВЕКТОРА, ЗНАЧЕНИЯ ЭЛЕМЕНТОВ КОТОРОГО
//            НЕ ПОВТОРЯЮТСЯ (УНИКАЛЬНЫ)
//Функция формирует подвектор из элементов исходного вектора, включая в него только
//неповторяющиеся значения. Таким образом, результирующий вектор будет состоять из
//всех значений элементов исходного вектора в единственном представлении. Если исход-
//ный вектор является вектором нулевого размера, то функция возвращает также подвектор
//нулевого размера. Если в исходном векторе значения элементов не повторяются, то ре-
//зультирующий вектор совпадет с исходным.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rvector SubVector - подвектор исходного вектора с уникальными значениями
//***********************************************************************************
rvector TRealVector::Unique() const
{rvector Unique(0L,Type());
 if (Size() == 0L) return Unique;//Вектор нулевого размера
 //**********************************************************************************
 //1. Формирование списка с уникальными значениями элементов
 //**********************************************************************************
 std::list<double> List;
 std::list<double>::iterator Iterator;
 //Просмотр всех значений элементов исходного вектора
 for (ulong i = 0L; i < Size(); i++)
 {//Проверка на уникальность значения элемента вектора
  Iterator = std::find(List.begin(),List.end(),data[i]);
  if (Iterator == List.end()) List.push_back(data[i]);
 }
 //**********************************************************************************
 //2. Переписываем значения из списка List в данный вектор
 //**********************************************************************************
 //Устанавливаем размер исходного вектора равного размеру списка
 Unique.Resize(List.size());
 //Цикл копирования значений элементов списка List в исходный вектор
 for (ulong i = 0L; i < Unique.Size(); i++)
 {Unique.Put(i,List.front()); List.pop_front();}
return Unique;
}
//***********************************************************************************
//СТАТУС: I.23, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Unique(rvector& SubVector) const;
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДВЕКТОРА ИЗ ДАННОГО ВЕКТОРА, ЗНАЧЕНИЯ ЭЛЕМЕНТОВ КОТОРОГО
//            НЕ ПОВТОРЯЮТСЯ (УНИКАЛЬНЫ)
//Элементы подвектора будут размещаться в векторе SubVector, передаваемый в функцию по
//ссылке. Предыдущие значения SubVector уничтожаются. Если в исходном векторе значения
//элементов не повторяются, то SubVector совпадет с исходным вектором. Функция не из-
//меняет размерность и элементы исходного вектора.
//Функция формирует подвектор нулевого размера в следующих случаях:
//1) Исходный вектор - вектор нулевого размера;
//2) Не удалось выделить память под размещение уникальных значений исходного вектора
//   в векторе SubVector.
//Функция возвращает false, если SubVector будет вектором нулевой длины.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: rvector& SubVector - ссылка на вектор, в котором будут раз-
//мещаться неповторяющиеся значения исходного вектора.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат формирования подвектора с уникальными элементами
//***********************************************************************************
bool TRealVector::Unique(rvector& SubVector) const
{if (Size() == 0L) {SubVector.Resize(0L); return false;}//Вектор нулевого размера
 //**********************************************************************************
 //1. Формирование списка с уникальными значениями элементов
 //**********************************************************************************
 std::list<double> List;
 std::list<double>::iterator Iterator;
 //Просмотр всех значений элементов исходного вектора
 for (ulong i = 0L; i < Size(); i++)
 {//Проверка на уникальность значения элемента вектора
  Iterator = std::find(List.begin(),List.end(),data[i]);
  if (Iterator == List.end()) List.push_back(data[i]);
 }
 //**********************************************************************************
 //2. Переписываем значения из списка List в данный вектор
 //**********************************************************************************
 //Устанавливаем размер подвектора равным размеру списка
 if (!SubVector.Resize(List.size())) {List.resize(0L); return false;};
 //Цикл копирования значений элементов списка List в исходный вектор
 for (ulong i = 0L; i < SubVector.Size(); i++)
 {SubVector.Put(i,List.front()); List.pop_front();}
return true;
}
//***********************************************************************************
//СТАТУС: I.24, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:  rvector SubVector(const ivector& Index) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДВЕКТОРА ИЗ ДАННОГО ВЕКТОРА ПО ИНДЕКСАМ
//Функция формирует подвектор из элементов исходного вектора по индексам, значения ко-
//торых передаются через вектор индексов Index. Если исходный вектор или вектор индек-
//сов Index являются векторами нулевого размера, то функция возвращает также подвектор
//нулевого размера. Если Index содержит значения индексов, которые не соответствуют
//границам исходного вектора, то они игнорируются.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// const ivector& Index - ссылка на вектор со значениями индексов исходного вектора
// по которым будет сформирован подвектор.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rvector SubVector - подвектор исходного вектора элементы, которого расположены
//по индексам, указанным в векторе Index.
//***********************************************************************************
rvector TRealVector::SubVector(const ivector& Index) const
{rvector SubVector;
 //Проверка исходного вектора и вектора со значениями индексов на нулевой размер
 if (IsZeroSize() || Index.IsZeroSize()) return SubVector;
 //**********************************************************************************
 //1. Формирование списка со значениями элементов, расположенных по индексам,
 //   указанным в векторе Index
 //**********************************************************************************
 std::list<double> List;
 ulong index;
 for (ulong i = 0L; i < Index.Size(); i++)
 {index = Index[i];
  //Проверка значения индекса на соответствие границам исходного вектора
  if ((index >= 0L) && (index < Size())) List.push_back(data[index]);
 }
 if (List.size() == 0) return SubVector;
 //**********************************************************************************
 //2. Переписываем значения из списка List в данный вектор
 //**********************************************************************************
 //Устанавливаем размер исходного вектора равного размеру списка
 SubVector.Resize(List.size());
 //Цикл копирования значений элементов списка List в исходный вектор
 for (ulong i = 0L; i < SubVector.Size(); i++)
 {SubVector[i] = List.front(); List.pop_front();}
return SubVector;
}
//***********************************************************************************
//СТАТУС: I.25, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rvector SubVector(const TArgVectorPredicate<double,rvector>& Predicate) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДВЕКТОРА ИЗ ЭЛЕМЕНТОВ ДАННОГО ВЕКТОРА, ЗНАЧЕНИЯ
//            КОТОРЫХ УДОВЛЕТВОРЯЮТ ОБЪЕКТУ-ПРЕДИКАТУ TArgVectorPredicate
//Каждый элемент исходного вектора передается перегруженному оператору вызова функции
//объекта Predicate. Если значение элемента вектора удовлетворяет условиям объекта-пре-
//диката Predicate, то данное значение заносится в список. По окончании просмотра всех
//элементов исходного вектора по элементам списка формируется подвектор SubVector.
//Функция может возвратить подвектор нулевого размера в двух случаях, во-первых, если
//исходный вектор - это вектор нулевого размера, и, во-вторых, если ни одно из значе-
//ний исходного вектора не удовлетворяет условиям объекта-предиката.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const TArgVectorPredicate<double,rvector>& Predicate - ссылка на объект-предикат,
//определяющий какие элементы исходного вектора будут размещаться в подвекторе.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rvector SubVector - подвектор исходного вектора элементы, значения которого
//удовлетворяют объекту-предикату Predicate.
//***********************************************************************************
rvector TRealVector::SubVector(const TArgVectorPredicate<double,rvector>& Predicate)
const
{rvector SubVector;
 //Проверка на исходного вектора на нулевой размер
 if (Size() == 0L) return SubVector;
 //**********************************************************************************
 //1. Формирование списка со значениями элементов, удовлетворяющим условию
 //   объекта-предиката Predicate
 //**********************************************************************************
 std::list<double> List;
 double value;
 for (ulong i = 0L; i < Size(); i++)
 {//Проверка значения элемента на соответствие условиям предиката Predicate
  value = data[i];
  if (Predicate(value)) List.push_back(value);
 }
 //**********************************************************************************
 //2. Переписываем значения из списка List в данный вектор
 //**********************************************************************************
 //Устанавливаем размер исходного вектора равного размеру списка
 SubVector.Resize(List.size());
 //Цикл копирования значений элементов списка List в исходный вектор
 for (ulong i = 0L; i < SubVector.Size(); i++)
 {SubVector[i] = List.front(); List.pop_front();}
return SubVector;
}
//***********************************************************************************
//СТАТУС: I.26, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SubVector(rvector& SubVector,
//                      const TArgVectorPredicate<double,rvector>& Predicate) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДВЕКТОРА ИЗ ЭЛЕМЕНТОВ ДАННОГО ВЕКТОРА, ЗНАЧЕНИЯ
//            КОТОРЫХ УДОВЛЕТВОРЯЮТ ОБЪЕКТУ-ПРЕДИКАТУ TArgVectorPredicate
//Каждый элемент исходного вектора передается перегруженному оператору вызова функции
//объекта Predicate. Если значение элемента вектора удовлетворяет условиям объекта-пре-
//диката Predicate, то данное значение заносится в список. По окончанию просмотра всех
//элементов исходного вектора по элементам списка формируется подвектор SubVector, пе-
//редаваемый в функцию по ссылке. Предыдущие значения вектора SubVector уничтожаются.
//Функция формирует подвектор нулевого размера в следующих случаях:
//1) Исходный вектор - вектор нулевого размера;
//2) В исходном векторе нет элементов, удовлетворяющих условиям объекта-предиката;
//3) Не удалось выделить память под элементы подвектора.
//Функция возвращает false, если будет сформирован подвектор нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& SubVector - ссылка на вектор, в котором будет формироваться подвектор;
//2. const TArgVectorPredicate<double,rvector>& Predicate - ссылка на объект-предикат,
//   определяющий какие элементы исходного вектора будут размещаться в подвекторе.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат формирования подвектора, значения
//которого удовлетворяют объекту-предикату Predicate, из исходного вектора.
//***********************************************************************************
bool TRealVector::SubVector(rvector& SubVector,
     const TArgVectorPredicate<double,rvector>& Predicate) const
{//Проверка на исходного вектора на нулевой размер
 if (Size() == 0L) {SubVector.Resize(0L); return false;}
 //**********************************************************************************
 //1. Формирование списка со значениями элементов, удовлетворяющим условию
 //   объекта-предиката Predicate
 //**********************************************************************************
 std::list<double> List;
 double value;
 for (ulong i = 0L; i < Size(); i++)
 {//Проверка значения элемента на соответствие условиям предиката Predicate
  value = data[i];
  if (Predicate(value)) List.push_back(value);
 }
 //**********************************************************************************
 //2. Переписываем значения из списка List в данный вектор
 //**********************************************************************************
 if (List.size() == 0L) {SubVector.Resize(0L); return false;}
 //Устанавливаем размер исходного вектора равного размеру списка
 if (!SubVector.Resize(List.size())) {List.resize(0L); return false;}
 //Цикл копирования значений элементов списка List в исходный вектор
 for (ulong i = 0L; i < SubVector.Size(); i++)
 {SubVector[i] = List.front(); List.pop_front();}
return true;
}

//-----------------------------------------------------------------------------------
//Алгоритмы сортировки вектора
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: I.27, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool BubbleSort(bool direct = ASCENDING, ulong *permutations = NULL,
//                 ulong *comparisons = NULL)
//НАЗНАЧЕНИЕ: МОДИФИЦИРОВАННАЯ ПУЗЫРЬКОВАЯ СОРТИРОВКА ПО ВОЗРАСТАНИЮ ИЛИ ПО УБЫВАНИЮ
//            ЭЛЕМЕНТОВ ВЕКТОРА
//Функция реализует алгоритм пузырьковой сортировки, в ходе которой за каждый цикл
//просмотра элементов вектора с первого элемента до граничного элемента Border в пра-
//вой части вектора оказываются наибольшие или наименьшие элементы в зависимости от
//направления сортировки, задаваемого аргументом direct. При каждом последующем прос-
//мотре элементов вектора верхний предел просмотра уменьшается на единицу. Начальное
//значение Border = Size()-1. Если при очередном просмотре элементов вектора не прои-
//зошло ни одной перестановки, то алгоритм завершает свою работу, так как данный факт
//является критерием того, что все элементы вектора упорядочены по возрастанию
//(ASCENDING) или по убыванию (DESCENDING). Алгоритм применяется к векторам с размер-
//ностью большей 1. При работе алгоритма положение элементов вектора могут изменяться.
//Они не изменяются только для уже упорядоченного вектора. При работе алгоритма ведет-
//ся подсчет числа перестановок и сравнений, которые можно передать через указатели
//внешней по отношению к BubbleSort функции.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. bool direct - направление сортировки (по возрастанию или по убыванию);
//2. ulong *permutations (NULL) - количество перестановок в ходе сортировки;
//3. ulong *comparisons (NULL) - количество сравнений в ходе сортировки
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//***********************************************************************************
bool TRealVector::BubbleSort(bool direct, ulong *permutations, ulong *comparisons)
{//Проверка на вектора допустимого размера
 if (Size() < 2) return false;
 ulong Border = Size()-1;
 ulong p = 0L, c = 0L;
 double temp;
 bool permut;
 bool end = false;
 //Тип сортировки
 if (direct == ASCENDING) //Сортировка по возрастанию
 {do
  {permut = false;
   for (ulong i = 0L; i < Border; i++)
   {c++;
    if (data[i] > data[i+1]) //Выполнить перестановку
    {temp = data[i+1]; data[i+1] = data[i]; data[i] = temp;
     permut = true; p++;
    }
   }
   if ((permut == false) || (--Border == 0)) end = true;
  } while (!end);
 }
 else //Сортировка по убыванию
 {do
  {permut = false;
   for (ulong i = 0L; i < Border; i++)
   {c++;
    if (data[i] < data[i+1]) //Выполнить перестановку
    {temp = data[i+1]; data[i+1] = data[i]; data[i] = temp;
     permut = true; p++;
    }
   }
   if ((permut == false) || (--Border == 0)) end = true;
  } while (!end);
 }
 if (permutations != NULL) *permutations = p;
 if (comparisons != NULL) *comparisons = c;
 return true;
}
//****************************************************************************************
//СТАТУС: I.27a, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool BubbleSort(rmatrix& A, bool direct = ASCENDING)
//НАЗНАЧЕНИЕ: МОДИФИЦИРОВАННАЯ ПУЗЫРЬКОВАЯ СОРТИРОВКА ПО ВОЗРАСТАНИЮ ИЛИ ПО УБЫВАНИЮ
//            ЭЛЕМЕНТОВ ВЕКТОРА С ОДНОВРЕМЕННОЙ СОРТИРОВКОЙ СТОЛБЦОВ МАТРИЦЫ
//Функция вместе с сортировкой элементов вектора сортирует столбцы матрицы A. Количество
//столбцов матрицы должно соответствовать количеству элементов вектора. Считается, что
//j-столбец матрицы соответствует j-му элементу вектора. Поэтому в ходе перестановки j-го
//элемента вектора переставляется также j-й столбец матрицы A. В зависимости от опции
//direct элементы могут сортироваться в порядке возрастания или убывания. Функция возвра-
//щает true при успешном выполнении сортировки и false в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& A - ссылка на матрицу, столбцы которой сортируются с элементами вектора
//2. bool direct - направление сортировки (по возрастанию или по убыванию);
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//****************************************************************************************
bool TRealVector::BubbleSort(rmatrix& A, bool direct)
{//Проверка на возможность проведения сортировки
 if (this->Size() != A.Cols()) return false;
 if (Size() < 2) return false;

 ulong Border = Size()-1;
 double temp;
 bool permut;
 bool end = false;
 //Тип сортировки
 if (direct == ASCENDING) //Сортировка по возрастанию
 {do
  {permut = false;
   for (ulong i = 0L; i < Border; i++)
   {if (data[i] > data[i+1]) //Выполнить перестановку
    {temp = data[i+1]; data[i+1] = data[i]; data[i] = temp;
     //Переставляем столбцы матрицы
     A.ExchangeCols(i,i+1);
     permut = true;
    }
   }
   if ((permut == false) || (--Border == 0)) end = true;
  } while (!end);
 }
 else //Сортировка по убыванию
 {do
  {permut = false;
   for (ulong i = 0L; i < Border; i++)
   {if (data[i] < data[i+1]) //Выполнить перестановку
    {temp = data[i+1]; data[i+1] = data[i]; data[i] = temp;
     //Переставляем столбцы матрицы
     A.ExchangeCols(i,i+1);
     permut = true;
    }
   }
   if ((permut == false) || (--Border == 0)) end = true;
  } while (!end);
 }
 return true;
}
//***********************************************************************************
//СТАТУС: I.28, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool Find(const double& value, ulong* index = NULL, bool sort = UNSORTED,
//      ulong left = 0L, ulong right = MAX_SIZE, bool direct = FORWARD) const
//НАЗНАЧЕНИЕ: ПОИСК СРЕДИ ЭЛЕМЕНТОВ ВЕКТОРА В ЗАДАННОМ ИНТЕРВАЛЕ ЭЛЕМЕНТА
//            ВЕКТОРА С ОПРЕДЕЛЕННЫМ ЗНАЧЕНИЕМ
//Функция осуществляет поиск в интервале индексов вектора от left до right элемента
//вектора со значением равным value. В случае успеха функция возвращает значение true,
//а в переменную передаваемую в функцию через указатель index заносится индекс элемен-
//та вектора с заданным значением value. Если элемент со значением value не найден в
//интервале от left до right, то функция возвращает false, а в переменную, переданную
//через указатель index заносится значение MAX_SIZE ("за пределами"). Аргумент sort
//указывает на отсортированность элементов вектора. Если элементы вектора отсортирова-
//ны, то поиск значения, как правило, занимает меньше времени, чем в несортированном
//векторе. Ответственность за установку аргумента sort ложится на пользователя, так
//как если вектор не является отсортированным, а опция sort равна SORTED, может при-
//вести к неправильным результатам работы функции. Если sort == UNSORTED и вектор яв-
//ляется отсортированным, то результат работы функции будет всегда правильным, но при
//отсутствии элемента с заданным значением value приведет к увеличению времени работы
//функции. При sort == SORTED, функция автоматически настраивается на алгоритм поиска
//в отсортированном по возрастанию или по убыванию элементов векторе, путем сравнения
//первого и последнего его значений:
//1) V[0] > V[size()-1] - поиск в отсортированном по убыванию векторе;
//2) V[0] < V[size()-1] - поиск в отсортированном по возрастанию векторе;
//По умолчанию аргумент sort == UNSORTED, что всегда гарантирует правильность работы
//функции с возможным ее замедлением в случае вектора с отсортированными элементами.
//Интервал поиска задается двумя аргументами left - нижняя граница и right - верхняя
//граница. Верхняя и нижняя границы индексов вектора входят в интервал поиска элемента
//вектора с заданным значением. По умолчанию left = 0, а right = MAX_SIZE (максимально
//возможная размерность вектора - 2^32-1). Такие установки приводят к поиску элемента
//со значением value по всему вектору. Функция проверяет корректность нижней и верхней
//границы интервала - left <= right < Size(), в противном случае функция возвращает
//false. Если вектор является вектором нулевого размера, то функция также возвращает
//false.
//Функция предусматривает два направление поиска первого элемента вектора равного зна-
//чению value, задаваемого аргументом direct:
//1) Поиск в прямом направлении (FORWARD) от left до right;
//2) Поиск в обратном направлении (BACKWARD) от right до left.
//По умолчанию задается прямое направление поиска - direct = FORWARD. Работа функции
//не приводит к изменению внутренней структуры вектора, в котором осуществляется поиск
//элемента с заданным значением.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const double& value - ссылка на значение элемента, по которому будет происходить
//   поиск в векторе;
//2. ulong* index (NULL) - указатель на переменную, в которую будет заносится индекс
//   первого элемента вектора равного со значением value;
//3. bool sort (UNSORTED) - признак "отсортированности" элементов вектора;
//4. ulong left (0) - нижний индекс вектора, с которого будет происходить поиск;
//5. ulong right (MAX_SIZE ~ Size()-1) - верхний индекс вектора до которого будет
//   происходить поиск значения value, включая значение индекса right;
//6. bool direct (FORWARD) - направление поиска первого элемента вектора, совпадающего
//   со значением value.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак существования элемента со значением value в векторе.
//***********************************************************************************
bool TRealVector::Find(const double& value, ulong* index, bool sort, ulong left,
                       ulong right, bool direct) const
{bool lSuccess = false;
 if (IsZeroSize()) //Проверка на вектор нулевого размера
 {if (index != NULL) *index = MAX_SIZE;
  return lSuccess;
 }
 right = (right == MAX_SIZE) ? Size()-1 : right;
 //Проверка на корректность заданного интервала поиска
 if ((left > right) || (right >= Size()))
 {if (index != NULL) *index = MAX_SIZE;
  return lSuccess;
 }
 ulong pos = MAX_SIZE;
 if (sort == UNSORTED) //Поиск в неотсортированном векторе
 {if (direct == FORWARD) //Поиск в прямом направлении
  {for (ulong i = left; i <= right; i++)
   {if (data[i] == value) {lSuccess = true; pos = i; break;}
   }
  }
  else //Поиск в обратном направлении
  {for (ulong i = right; i <= left; i--)
   {if (data[i] == value) {lSuccess = true; pos = i; break;}
   }
  }
 }
 else //Поиск в отсортированном векторе
 {//Определение направления сортировки элементов вектора
  if (data[0] > data[Size()-1]) //Сортировка по убыванию
  {if (direct == FORWARD) //Поиск в прямом направлении
   {for (ulong i = left; i <= right; i++)
    {if (data[i] == value) {lSuccess = true; pos = i; break;}
     if (data[i] < value) break;
    }
   }
   else //Поиск в обратном направлении
   {for (ulong i = right; i <= left; i--)
    {if (data[i] == value) {lSuccess = true; pos = i; break;}
     if (data[i] > value) break;
    }
   }
  }
  else if (data[0] < data[Size()-1]) //Сортировка по возрастанию
  {if (direct == FORWARD) //Поиск в прямом направлении
   {for (ulong i = left; i <= right; i++)
    {if (data[i] == value) {lSuccess = true; pos = i; break;}
     if (data[i] > value) break;
    }
   }
   else //Поиск в обратном направлении
   {for (ulong i = right; i <= left; i--)
    {if (data[i] == value) {lSuccess = true; pos = i; break;}
     if (data[i] < value) break;
    }
   }
  }
  else //data[0] == data[Size()-1] - однородный вектор
  {if (direct == FORWARD) //Поиск в прямом направлении
    if (data[left] == value) {lSuccess = true; pos = left;}
   else //Поиск в обратном направлении
    if (data[right] == value) {lSuccess = true; pos = right;}
  }
 }
 if (index != NULL) *index = pos;
return lSuccess;
}
//***********************************************************************************
//СТАТУС: I.29, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong Reverse(ulong left = 0L, ulong right = MAX_SIZE)
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ЭЛЕМЕНТОВ ВЕКТОРА В ЗАДАННОМ ИНТЕРВАЛЕ В ОБРАТНОМ
//            ПОРЯДКЕ
//Функция изменяет порядок следования элементов вектора в интервале от индекса со зна-
//чением left до индекса со значением right (включая его) на обратный. Значения верхней
//и нижней границ интервала, в которой должна осуществляться перестановка должны удов-
//летворять следующим условиям:
// left <= right && right < Size(), в противном случае функция не выполняется.
//По умолчанию, функция осуществляет перестановку всех элементов вектора. Работа функ-
//ции приводит к изменению внутренней структуры вектора, так как осуществляется пере-
//становка элементов вектора в заданном интервале.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left (0) - нижний индекс вектора, с которого будет происходить перестановка
//   элементов вектора в обратном порядке;
//2. ulong right (MAX_SIZE ~ Size()-1) - верхний индекс вектора до которого будет
//   происходить перестановка элементов вектора в обратном порядке, включая значение
//   индекса right.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong permut - количество перестановок
//***********************************************************************************
ulong TRealVector::Reverse(ulong left, ulong right)
{ulong permut = 0L;//Количество перестановок
 right = (right == MAX_SIZE) ? Size()-1 : right;
 //Проверка на возможность или необходимость осуществления перестановки
 if ((Size() < 2) || (left >= right) || (right >= Size())) return permut;
 //Выполнение перестановки элементов вектора в обратном порядке
 double temp;
 while (left < right)
 {temp = data[left]; data[left] = data[right]; data[right] = temp;
  permut++; //Подсчет количества перестановок
  left++; right--; //Переход к другим индексам переставляемых элементов
 }
return permut;//Количество перестановок
}
//***********************************************************************************
//СТАТУС: I.30, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//rvector Assign(const rvector& V, ulong pos = 0L, ulong* counter = NULL) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ ЗНАЧЕНИЙ ЭЛЕМЕНТОВ ОДНОГО ВЕКТОРА ДРУГОМУ ВЕКТОРУ
//В качестве вектора-приемника используется исходный вектор, вектора-источника - век-
//тор V, передаваемый по ссылке. Присваивание элементов исходным вектором начинается
//с индекса pos, по умолчанию pos == 0. Вектор-источник может иметь любую размерность.
//Функция присваивает значения элементов вектора V копии исходного вектора, начиная с
//первого элемента вектора V, вплоть до последнего элемента вектора V или последнего
//элемента исходного вектора, в зависимости от соотношения начального индекса pos ис-
//ходного вектора, с которого начинается присваивание, размеров вектора-источника и
//вектора-приемника. Значения элементов исходного и структура вектора не изменяются в
//данной функцией (все необходимые операции присваивания осуществляются с копией век-
//тора-источника, которая является результатом работы функции).
//Функции передается необязательный указатель на переменную типа ulong - count. По
//умолчанию counter=NULL. В ходе работы функция подсчитывает кол-во элементов исходно-
//го вектора, которым присваивались значения элементов вектора V. Если указатель
//counter отличен от NULL, то по его адресу по окончании работы функции передается ко-
//личество элементов исходного вектора, принимавших участии в операции присваивания.
//Функция возвращает результирующий вектор нулевого размера в следующих исключительных
//ситуациях:
//1. Исходный вектор - вектор нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Начальный индекс pos в исходном векторе, начиная с которого осуществляется
//   присваивание, превышает верхнюю границу для данного исходного вектора.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на вектор-источник, значения элементов которого будут
//   присваиваться элементам исходного вектора;
//2. ulong pos - начальный индекс элемента исходного вектора, с которого начнется
//   присваивание значений элементов вектора-источника V;
//3. ulong* counter (NULL) - указатель на счетчик, в который будет записано количество
//   элементов исходного вектора, которым присваивались значения элементов вектора-
//   источника V.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rvector result - результирующий вектор выполнения операции присваивания значений
//                 элементов одного вектора другому вектору
//********************/**************************************************************
rvector TRealVector::Assign(const rvector& V, ulong pos, ulong* counter) const
{ulong count = 0L;
 rvector result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (pos >= Size()))
 { if (counter != NULL) *counter = count;
   return result;
 }
 result = *this; //Копирование исхоного вектора
 //----------------------------------------------------------------------------------
 //Выполнение операции присваивания значений одного вектора другому вектору
 ulong index;
 for (ulong i = 0L; i < V.Size(); i++)
 {index = i+pos;
  if (index < result.Size()) {result[index] = V[i]; count++;}
  else break; //Выход из цикла
 }
 if (counter != NULL) *counter = count;
return result;
}
//***********************************************************************************
//СТАТУС: I.31, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool AbsMaxMin(double& Max, double& Min) const
//НАЗНАЧЕНИЕ: ПОИСК МАКСИМАЛЬНОГО и МИНИМАЛЬНОГО ПО МОДУЛЮ ЭЛЕМЕНТОВ ВЕКТОРА
//Максимальное и минимальное по модулю значения присваиваются переменным Max и Min,
//передаваемым по ссылке. Функция возвращает false в случае вектора нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double& Max - ссылка на переменную, в которой будет размещаться максимальный по
//   модулю элемент вектора;
//2. double& Min - ссылка на переменную, в которой будет размещаться минимальный по
//   модулю элемент вектора;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат поиска максимального и минимального по модулю элементов
//***********************************************************************************
bool TRealVector::AbsMaxMin(double& Max, double& Min) const
{if (IsZeroSize()) return false;//Проверка на вектор нулевого размера
 //Поиск максимального и минимального по модулю элементов вектора
 Max = fabs(data[0]); Min = fabs(data[0]);
 double value;
 for (ulong i = 1; i < Size(); i++)
 {value = fabs(data[i]);
  if (Max < value) Max = value;
  if (Min > value) Min = value;
 }
 return true;
}
//***********************************************************************************
//СТАТУС: I.32, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool MaxMin(double& Max, double& Min) const
//НАЗНАЧЕНИЕ: ПОИСК МАКСИМАЛЬНОГО и МИНИМАЛЬНОГО ЭЛЕМЕНТОВ ВЕКТОРА
//Максимальное и минимальное значения присваиваются переменным Max и Min, передаваемым
//по ссылке. Функция возвращает false в случае вектора нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double& Max - ссылка на переменную, в которой будет размещаться максимальный
//   элемент вектора;
//2. double& Min - ссылка на переменную, в которой будет размещаться минимальный
//   элемент вектора;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат поиска максимального и минимального элементов вектора
//***********************************************************************************
bool TRealVector::MaxMin(double& Max, double& Min) const
{if (IsZeroSize()) return false;//Проверка на вектор нулевого размера
 //Поиск максимального и минимального элементов вектора
 Max = data[0]; Min = data[0];
 for (ulong i = 1; i < Size(); i++)
 {if (Max < data[i]) Max = data[i];
  if (Min > data[i]) Min = data[i];
 }
 return true;
}

//***********************************************************************************
//    РЕАЛИЗАЦИЯ ОПЕРАЦИЙ ЛИНЕЙНОЙ АЛГЕБРЫ над ДЕЙСТВИТЕЛЬНЫМИ ВЕКТОРАМИ
//   Все операции линейной алгебры производятся с копией исходного вектора.
//***********************************************************************************

//***********************************************************************************
//СТАТУС: I.1, TRealVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& Transpose() const
//НАЗНАЧЕНИЕ: ТРАНСПОНИРОВАНИЕ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Операция транспонирования производится с копией исходного вектора, который возвра-
//щается данной функцией. Операция транспонирования осуществляется только с векторами-
//столбцами и векторами-строками, которая меняет их на противоположные типы. При по-
//пытке транспонирования вектора нулевого размера возвращается вектор нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector result - транспонированный вектор
//***********************************************************************************
rvector TRealVector::Transpose() const
{rvector result;
 if (Size() == 0L) return result;//Проверка на вектор нулевой длины
 result = *this; //Создание копии исходного вектора
 result.SetType(!Type());
 return result;
}
//***********************************************************************************
//СТАТУС: I.2, TRealVector class overloading operator !
//OVERLOADING UNARY OPERATOR < ! >
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector operator !() const
//НАЗНАЧЕНИЕ: ТРАНСПОНИРОВАНИЕ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Функция осуществляет транспонирование вектора. Операция транспонирования производит-
//ся с копией исходного вектора, который возвращается данной функцией. Операция транс-
//понирования осуществляется только с векторами-столбцами и векторами-строками, кото-
//рая меняет их на противоположные типы. При попытке транспонирования вектора нулевого
//размера генерируется ошибка выполнения данной операции.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector result - транспонированный вектор
//***********************************************************************************
rvector TRealVector::operator !() const
{rvector result;
 if (Size() == 0L) return result; //Проверка на вектор нулевой длины
 result = *this; //Создание копии исходного вектора
 result.SetType(!Type());
 return result;
}
//***********************************************************************************
//СТАТУС: I.3, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double FirstNorm() const
//НАЗНАЧЕНИЕ: ПЕРВАЯ (КУБИЧЕСКАЯ) НОРМА ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Функция осуществляет определение первой (кубической) нормы вещественного вектора.
//Для n-мерного вектора X = (x1,x2,...,xn) первая норма вычисляется по формуле:
// ||X|| = max|Xi| by i, максимальное абсолютное значение элемента вектора X. При по-
//пытке определения нормы вектора нулевого размера возвращается 0.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - первая норма вектора
//***********************************************************************************
double TRealVector::FirstNorm() const
{double norm = 0.0;
 if (Size() == 0L) return norm;//Проверка на вектор нулевой длины
 //Поиск максимальной по абсолютной величины компоненты вещественного
 //вектора X = (x1,x2,...,xn)
 double value;
 for (ulong i = 0; i < Size(); i++)
 {value = fabs(data[i]);
  if (norm < value) norm = value;
 }
 return norm;
}
//***********************************************************************************
//СТАТУС: I.4, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double SecondNorm() const
//НАЗНАЧЕНИЕ: ВТОРАЯ (ОКТАЭДРИЧЕСКАЯ) НОРМА ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Функция осуществляет определение второй (октаэдрической) нормы вещественного вектора.
//Для n-мерного вектора X = (x1,x2,...,xn) вторая норма вычисляется по формуле:
// ||X|| = SUM|Xi| by i, сумма абсолютных значений элементов вектора X.
//При попытке определения нормы вектора нулевого размера возвращается 0.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - вторая норма вектора
//***********************************************************************************
double TRealVector::SecondNorm() const
{double norm = 0.0;
 if (Size() == 0L) return norm;//Проверка на вектор нулевой длины
 //Суммирование абсолютных величин компонент вещественного вектора X
 for (ulong i = 0; i < Size(); i++) norm += fabs(data[i]);
 return norm;
}
//***********************************************************************************
//СТАТУС: I.5, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double ThirdNorm() const
//НАЗНАЧЕНИЕ: ТРЕТЬЯ (СФЕРИЧЕСКАЯ, ЕВКЛИДОВА) НОРМА ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Функция осуществляет определение третьей нормы вещественного вектора, которая опре-
//деляет длину вектора. Для n-мерного вектора X = (x1,x2,...,xn) евклидова норма вы-
//числяется по формуле:  norm = sqrt(x1^2 + x2^2 + ... + xn^2).
//При попытке определения нормы вектора нулевого размера возвращается 0.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - евклидова норма (длина) вектора
//***********************************************************************************
double TRealVector::ThirdNorm() const
{double norm = 0.0;
 if (Size() == 0L) return norm;//Проверка на вектор нулевой длины
 //Суммирование квадратов абсолютных величин (норм) компонент вещественного
 //вектора X = (x1,x2,...,xn)
 for (ulong i = 0; i < Size(); i++) norm += data[i]*data[i];
 norm = sqrt(norm);//Вычисление нормы вещественного вектора
 return norm;
}
//***********************************************************************************
//СТАТУС: I.6, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double PNorm(uint p = 2) const
//НАЗНАЧЕНИЕ: P-НОРМА (НОРМЫ ГЕЛЬДЕРА) ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Для n-мерного вектора X = (x1,x2,...,xn) p-норма вычисляется по формуле:
// norm = {SUM|Vi|^p by i}^(1/p).
//При попытке определения нормы вектора нулевого размера возвращается 0.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//uint p - p-норма вектора, по умолчанию p = 2 - Евклидова норма.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - p-норма вектора
//***********************************************************************************
double TRealVector::PNorm(uint p) const
{double norm = 0.0;
 if (Size() == 0L) return norm; //Проверка на вектор нулевой длины
 if (p == 0) norm = FirstNorm();//Первая норма
 else if (p == 1) norm = SecondNorm();//Вторая норма
 else if (p == 2) norm = ThirdNorm();//Третья норма
 else  //Вычисление p-нормы вещественного вектора
 {for (ulong i = 0L; i < Size(); i++) norm += pow(fabs(data[i]),p);
  norm = pow(norm,1/p);
 }
return norm;
}
//***********************************************************************************
//СТАТУС: I.6, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double Norm(uint type, uint p = 2) const
//НАЗНАЧЕНИЕ: НОРМА ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Функция осуществляет определение нормы вещественного вектора в зависимости от значе-
//ния переменной type. Аргумент p необходим для определения p-нормы вектора. По умол-
//чанию функция определяет длину вектора X или его ЕВКЛИДОВУ НОРМУ. При попытке опре-
//деления нормы вектора нулевого размера или несуществующего типа нормы возвращается 0.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//uint type - тип определяемой нормы вещественного вектора;
//uint p - параметр для p-норма вектора, по умолчанию p = 2 - Евклидова норма.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - норма вектора заданного типа
//***********************************************************************************
double TRealVector::Norm(uint type, uint p) const
{double norm;
  switch (type)
  {//Определение первой (кубической) нормы
   case FIRST_NORM:
    norm = FirstNorm(); break;
   //Определение второй (октаэдрической) нормы
   case SECOND_NORM:
    norm = SecondNorm(); break;
   //Определение третьей (сферической, евклидовой) нормы или длины вектора
   case THIRD_NORM:
    norm = ThirdNorm(); break;
   //Определение p-нормы или нормы Гельдера
   case P_NORM:
    norm = PNorm(p); break;
   //Несуществующий тип нормы
   default:
    norm = 0.0;
  }
return norm;
}
//***********************************************************************************
//СТАТУС: I.7, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector Normalization() const
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Функция осуществляет операцию нормирования вещественного вектора. С этой целью,
//во-первых, вычисляется третья норма вектора - norm. Для n-мерного вектора
//X = (x1,x2,...,xn) евклидова норма (длина) вычисляется по формуле:
// norm = sqrt(x1^2 + x2^2 + ... + xn^2).
//Во-вторых, каждый компонент вектора X делится на найденную норму вектора X.
// X' = (x1/norm, x2/norm, ..., xn/norm), X' - нормированный вектор.
//Таким образом, ТРЕТЬЯ НОРМА НОРМИРОВАННОГО ВЕКТОРА РАВНА 1.
//При попытке нормировки вектора нулевого размера генерируется ошибка выполнения
//данной операции.
//Функция возвращает нормированный вектор, используя для проведения операции нормиров-
//ки копию исходного вектора, т.о. исходный вектор не претерпевает изменений.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector result - нормированный вектор
//***********************************************************************************
rvector TRealVector::Normalization() const
{rvector result;
 if (Size() == 0L) return result;//Проверка на вектор нулевой длины
 double value = ThirdNorm();//Вычисление нормы вещественного вектора
 if (value == 0.0) return result;
 result = *this;//Создание копии исходного вектора
 //Нормирование компонент вещественного вектора X = (x1,x2,...,xn)
 for (ulong i = 0; i < result.Size(); i++) result[i] = result[i]/value;
return result;
}
//***********************************************************************************
//СТАТУС: I.8, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Normalization(uint NormType, uint p = 0)
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Функция осуществляет операцию нормирования вещественного вектора. С этой целью,
//во-первых, вычисляется норма вектора - norm, согласно типу определения нормы, зада-
//ваемой параметрами NormType и p (показатель степени для p-норм Гельдера). Во-вторых,
//каждый компонент вектора X делится на найденную норму вектора X.
// X' = (x1/norm, x2/norm, ..., xn/norm), X' - нормированный вектор.
//При попытке нормировки вектора нулевого размера функция возвращает false. Функция
//осуществляет нормирование исходного вектора, т.о. исходный вектор изменяется. Если
//тип нормы не определен либо норма равна 0, то исходный вектор не изменяется.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint NormType - тип нормировки вещественного вектора;
//2. uint p - параметр для p-норма вектора, по умолчанию p = 0 - первая норма.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealVector::Normalization(uint NormType, uint p)
{if (Size() == 0L) return false;//Проверка на вектор нулевой длины
 double norm = Norm(NormType,p);//Вычисление нормы вектора
 if (norm == 0.0) return false;
 //Нормирование компонент вещественного вектора X = (x1,x2,...,xn)
 for (ulong i = 0L; i < Size(); i++) data[i] = data[i]/norm;
return true;
}
//***********************************************************************************
//СТАТУС: I.9, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool Normalization(rvector& Out, uint NormType = FIRST_NORM, uint p = 0) const
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Функция осуществляет операцию нормирования вещественного вектора. С этой целью,
//во-первых, вычисляется норма вектора - norm, согласно типу определения нормы, зада-
//ваемой параметрами NormType и p (показатель степени для p-норм Гельдера). Во-вторых,
//каждый компонент вектора X делится на найденную норму вектора X.
// X' = (x1/norm, x2/norm, ..., xn/norm), X' - нормированный вектор.
//При попытке нормировки вектора нулевого размера функция возвращает false. Функция не
//изменяет исходный вектор, нормировка производится с вектором Out. Если тип нормы не
//определен либо норма равна 0, то вектор Out преобразуется в вектор нулевой длины.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& Out - ссылка на результирующий вектор
//2. uint NormType - тип нормировки вещественного вектора;
//3. uint p - параметр для p-норма вектора, по умолчанию p = 0 - первая норма.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealVector::Normalization(rvector& Out, uint NormType, uint p) const
{Out.Resize(0L);
 if (Size() == 0L) return false;//Проверка на вектор нулевой длины
 double norm = Norm(NormType,p);//Вычисление нормы вектора
 if (norm == 0.0) return false;
 Out = *this;
 //Нормирование компонент вещественного вектора X = (x1,x2,...,xn)
 for (ulong i = 0L; i < Size(); i++) Out.Put(i,data[i]/norm);
return true;
}
//***********************************************************************************
//СТАТУС: I.10, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool NormalizeToDB(bool Power = true, double MindB = -60)
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА в ДЕЦИБЕЛАХ
//Функция осуществляет операцию нормирования вещественного вектора в децибелах. С этой
//целью, во-первых, вычисляется первая норма вектора. Во-вторых, каждый компонент век-
//тора X делится на найденную норму вектора X.
// X' = (x1/norm, x2/norm, ..., xn/norm), X' - нормированный вектор.
//В-третьих, элементы вектора логарифмируются:
//a) Power = true: 10*log10(Xi);
//b) Power = false: 20*log10(Xi).
//Все элементы вектора должны быть ПОЛОЖИТЕЛЬНЫМИ, (Xi > 0), иначе функция возвращает
//false и нормирование не осуществляется.
//При попытке нормировки вектора нулевого размера функция возвращает false. Функция
//изменяет исходный вектор.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. bool Power - опция логарифмирования (по мощности или напряжению)
//2. double MindB - минимальный пороговый уровень
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealVector::NormalizeToDB(bool Power, double MindB)
{if (Size() == 0L) return false;//Проверка на вектор нулевой длины
 //Поиск максимального значения и отрицательных, нулевых значений
 bool Negative = false;
 double Max = 0.0;
 for (ulong i = 0L; i < Size(); i++)
 {if (data[i] < 0.0) {Negative = true; break;}
  if (Max < data[i]) Max = data[i];
 }
 if ((Max < EPS) || (Negative)) return false;
 //Нормирование компонент вещественного вектора [0..1]
 for (ulong i = 0L; i < Size(); i++) data[i] = data[i]/Max;
 //Нормирование в dB с установкой нижнего порогового уровня [0..MindB]
 double value;
 MindB = (MindB >= 0.0) ? -60.0 : MindB;
 for (ulong i = 0L; i < Size(); i++)
 {value = data[i];
  if (fabs(value) < EPS) data[i] = MindB;//Нулевое значение
  else
  {value = (Power) ? 10*log10(value) : 20*log10(value);
   if (value < MindB) value = MindB;
   data[i] = value;
  }
 }
return true;
}
//***********************************************************************************
//СТАТУС: I.11, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool NormalizeToDB(rvector& Out, bool Power = true, double MindB = -60) const
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА в ДЕЦИБЕЛАХ
//С этой целью, во-первых, вычисляется первая норма вектора. Во-вторых, каждый компо-
//нент вектора X делится на найденную норму вектора X.
// X' = (x1/norm, x2/norm, ..., xn/norm), X' - нормированный вектор.
//В-третьих, элементы вектора логарифмируются:
//a) Power = true: 10*log10(Xi);
//b) Power = false: 20*log10(Xi).
//Все элементы вектора должны быть ПОЛОЖИТЕЛЬНЫМИ, (Xi > 0), иначе функция возвращает
//false и нормирование не осуществляется. При попытке нормировки вектора нулевого раз-
//мера функция возвращает false. Функция не изменяет исходный вектор, результаты нор-
//мировки заносятся в вектор Out, передаваемый по ссылке.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& Out - ссылка на результирующий вектор
//2. bool Power - опция логарифмирования (по мощности или напряжению)
//3. double MindB - минимальный пороговый уровень
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealVector::NormalizeToDB(rvector& Out, bool Power, double MindB) const
{Out.Resize(0L);
 if (Size() == 0L) return false;//Проверка на вектор нулевой длины
 //Поиск максимального значения и отрицательных, нулевых значений
 bool Negative = false;
 double Max = 0.0;
 for (ulong i = 0L; i < Size(); i++)
 {if (data[i] < 0.0) {Negative = true; break;}
  if (Max < data[i]) Max = data[i];
 }
 if ((Max < EPS) || (Negative)) return false;
 Out.Resize(Size());
 //Нормирование компонент вещественного вектора [0..1]
 for (ulong i = 0L; i < Size(); i++) Out.Put(i,data[i]/Max);
 //Нормирование в dB с установкой нижнего порогового уровня [0..MindB]
 double value;
 MindB = (MindB >= 0.0) ? -60.0 : MindB;
 for (ulong i = 0L; i < Out.Size(); i++)
 {value = Out.Get(i);
  if (fabs(value) < EPS) Out.Put(i,MindB);//Нулевое значение
  else
  {value = (Power) ? 10*log10(value) : 20*log10(value);
   if (value < MindB) value = MindB;
   Out.Put(i,value);
  }
 }
return true;
}
//***********************************************************************************
//СТАТУС: I.12, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ScalarProduct(const rvector& A, double& result) const
//НАЗНАЧЕНИЕ: СКАЛЯРНОЕ ПРОИЗВЕДЕНИЕ ДВУХ ВЕКТОРОВ (SCALAR PRODUCT)
//Функция предназначена для вычисления скалярного произведения двух векторов
//A=(a1,a2,...,an) и B=(b1,b2,...,bn).
//Скалярное произведение (A,B) векторов A и B пространства или плоскости - это
//произведение их модулей на косинус угла t между ними:
// (A,B) = |A||B|cos(t), если A != 0, B != 0, (|A|,|B| - нормы (длины) векторов)
// (A,B) = 0,            если A = 0, или (и) B = 0;
//Если в ортонормированном базисе векторы A и B имеют координаты (a1,a2,...,an)
//и (b1,b2,...,bn), то СКАЛЯРНОЕ ПРОИЗВЕДЕНИЕ вычисляется по формуле:
// (A,B) = a1*b1 + a2*b2 + ... + an*bn.
//Для осуществления операции скалярного произведения необходимы два условия:
//1. Векторы A и B должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ;
//2. Векторы A и B не должны быть ВЕКТОРАМИ НУЛЕВОЙ ДЛИНЫ.
//Если два вышеперечисленных условия не выполняется, то функция возвращает false.
//Результатом скалярного произведения двух векторов всегда является ЧИСЛО.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& A - ссылка на вещественный вектор, с которым производится
//   операция скалярного умножения двух векторов.
//2. double& result - ссылка на переменную с результат выполнения операции
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции
//***********************************************************************************
bool TRealVector::ScalarProduct(const rvector& A, double& result) const
{result = 0.0;
 //Вычисление скалярного произведения осуществляется с вектором (векторами) нулевого
 //размера (длины)
 if ((IsZeroSize()) || (A.IsZeroSize())) return false;
 //Вычисление скалярного произведения осуществляется с векторами
 //разной размерности
 if (Size() != A.Size()) return false;
 //Вычисление скалярного произведения двух вещественных векторов
 for (ulong i = 0; i < Size(); i++) result += data[i] * A.Get(i);
 return true;
}
//***********************************************************************************
//СТАТУС: I.13, friend function of the TRealVector class
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool ScalarProduct(const rvector& A, const rvector& B, double& result)
//НАЗНАЧЕНИЕ: СКАЛЯРНОЕ ПРОИЗВЕДЕНИЕ ДВУХ ВЕКТОРОВ (SCALAR PRODUCT)
//Функция предназначена для вычисления скалярного произведения двух векторов
//A=(a1,a2,...,an) и B=(b1,b2,...,bn).
//Скалярное произведение (A,B) векторов A и B пространства или плоскости - это
//произведение их модулей на косинус угла t между ними:
// (A,B) = |A||B|cos(t), если A != 0, B != 0, (|A|,|B| - нормы (длины) векторов)
// (A,B) = 0,            если A = 0, или (и) B = 0;
//Если в ортонормированном базисе векторы A и B имеют координаты (a1,a2,...,an)
//и (b1,b2,...,bn), то СКАЛЯРНОЕ ПРОИЗВЕДЕНИЕ вычисляется по формуле:
// (A,B) = a1*b1 + a2*b2 + ... + an*bn.
//Для осуществления операции скалярного произведения необходимы два условия:
//1. Векторы A и B должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ;
//2. Векторы A и B не должны быть ВЕКТОРАМИ НУЛЕВОЙ ДЛИНЫ.
//Если два вышеперечисленных условия не выполняется, то функция возвращает false.
//Результатом скалярного произведения двух векторов всегда является ЧИСЛО.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& A - ссылка на вещественный вектор, с которым производится
//   операция скалярного умножения двух векторов.
//2. const rvector& B - ссылка на вещественный вектор, с которым производится
//   операция скалярного умножения двух векторов.
//3. double& result - ссылка на переменную с результат выполнения операции
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции
//***********************************************************************************
bool ScalarProduct(const rvector& A, const rvector& B, double& result)
{result = 0.0;
 //Вычисление скалярного произведения осуществляется с вектором (векторами)
 //нулевого размера (длины)
 if ((A.IsZeroSize()) || (B.IsZeroSize())) return false;
 //Вычисление скалярного произведения осуществляется с векторами разной размерности
 if (A.Size() != B.Size()) return false;
 //Вычисление скалярного произведения двух вещественных векторов
 for (ulong i = 0; i < A.Size(); i++) result += A.Get(i) * B.Get(i);
 return true;
}
//***********************************************************************************
//СТАТУС: I.14, friend function of the TRealVector class
//OVERLOADING ADDITION OPERATION (+) by Increasing Vector on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend rvector operator +(const double value, const rvector& V);
//НАЗНАЧЕНИЕ: УВЕЛИЧЕНИЕ КОМПОНЕНТ ВЕКТОРА НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию сложения вектора с действительным числом. Число
//прибавляется слева.
//B(b1,...,bn) = const + A(a1,...,an), bi = ai + const
//Для осуществления операции сложения вектора с числом необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевой длины.
//Результатом сложения вектора с числом всегда является ВЕКТОР.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const double value - вещественное число, складываемое с вектором.
//2. const rvector& V - ссылка на вещественный вектор, к компонентам которого
//   добавляется вещественное число value.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rvector result - вектор V, увеличенный на значение value
//***********************************************************************************
rvector operator +(const double value, const rvector& V)
{if (V.Size() == 0L) return V;//Сложение с вектором нулевого размера
 rvector result(V);//Копирование свойств вектора
 //Цикл увеличения компонент вектора V на величину value
 for (ulong i = 0L; i < V.Size(); i++) result.Put(i,result.Get(i)+value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.15, friend function of the TRealVector class
//OVERLOADING ADDITION OPERATION (+) by Increasing Vector on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend rvector operator +(const rvector& V, const double value);
//НАЗНАЧЕНИЕ: УВЕЛИЧЕНИЕ КОМПОНЕНТ ВЕКТОРА НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию сложения вектора с действительным числом. Число
//прибавляется справа.
//B(b1,...,bn) = A(a1,...,an) + const, bi = ai + const
//Для осуществления операции сложения вектора с числом необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевой длины.
//Результатом сложения вектора с числом всегда является ВЕКТОР.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на вещественный вектор, к компонентам которого
//   добавляется вещественное число value.
//2. const double value - вещественное число, складываемое с вектором.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rvector result - вектор V, увеличенный на значение value
//***********************************************************************************
rvector operator +(const rvector& V, const double value)
{if (V.Size() == 0L) return V;//Сложение с вектором нулевого размера
 rvector result(V);//Копирование свойств вектора
 //Цикл увеличения компонент вектора V на величину value
 for (ulong i = 0L; i < V.Size(); i++) result.Put(i,result.Get(i)+value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.16, friend function of the TRealVector class
//OVERLOADING DECREASE OPERATION (-) by Decreasing Vector on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend rvector operator +(const rvector& V, const double value)
//НАЗНАЧЕНИЕ: УМЕНЬШЕНИЕ КОМПОНЕНТ ВЕКТОРА НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию вычитания из компонент вектора действительного числа
//value. Действительное число value должно располагаться ТОЛЬКО СПРАВА от вектора V.
// B(b1, ..., bn) = A(a1, ..., an) - const, bi = ai - const
//Для осуществления операции вычитания из вектора числа необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевой длины.
//Результатом вычитания из вектора числа всегда является ВЕКТОР.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на вещественный вектор, компоненты которого
//   уменьшаются на вещественное число value.
//2. const double value - вещественное число, вычитаемое из вектора.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector result - вектор V, уменьшенный на значение value
//***********************************************************************************
rvector operator -(const rvector& V, const double value)
{if (V.Size() == 0L) return V;//Сложение с вектором нулевого размера
 rvector result(V);//Копирование свойств вектора
 //Цикл уменьшения компонент вектора V на величину value
 for (ulong i = 0L; i < V.Size(); i++) result.Put(i,result.Get(i)-value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.17, friend function of the TRealVector class
//OVERLOADING MULTIPLICATION OPERATION (*) by Multiply Vector on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend rvector operator *(const double value, const rvector& V);
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ КОМПОНЕНТ ВЕКТОРА НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию умножения вектора на действительное число. Число умножает-
//ся слева.
//B(b1,...,bn) = const * A(a1,...,an), bi = ai * const
//Для осуществления операции умножения вектора на число необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевой длины. Результатом умно-
//жения вектора на число всегда является ВЕКТОР.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const double value - вещественное число, умножаемое на вектор.
//2. const rvector& V - ссылка на вещественный вектор, компоненты которого
//   умножаются на вещественное число value.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector result - вектор V, умноженный на значение value
//***********************************************************************************
rvector operator *(const double value, const rvector& V)
{if (V.Size() == 0L) return V;//Умножение с вектором нулевого размера
 rvector result(V); //Копирование свойств вектора
 //Цикл умножения компонент вектора V на величину value
 for (ulong i = 0L; i < V.Size(); i++) result.Put(i,result.Get(i)*value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.18, friend function of the TRealVector class
//OVERLOADING MULTIPLICATION OPERATION (*) by Multiply Vector on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend rvector operator *(const rvector& V, const double value)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ КОМПОНЕНТ ВЕКТОРА НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Число умножается справа.
//B(b1,...,bn) = A(a1,...,an) * const, bi = ai * const
//Для осуществления операции умножения вектора на число необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевой длины. Результатом ум-
//ножения вектора на число всегда является ВЕКТОР.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на вещественный вектор, компоненты которого
//   умножаются на вещественное число value.
//2. const double value - вещественное число, умножаемое на вектор.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector result - вектор V, умноженный на значение value
//***********************************************************************************
rvector operator *(const rvector& V, const double value)
{if (V.Size() == 0L) return V;//Умножение на вектор нулевого размера
 rvector result(V);//Копирование свойств вектора
 //Цикл умножения компонент вектора V на величину value
 for (ulong i = 0L; i < V.Size(); i++)  result.Put(i,result.Get(i)*value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.19, public function of the TRealVector class
//OVERLOADING DIVISION OPERATION (/) by Dividing Vector on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector operator /(const double value) const
//НАЗНАЧЕНИЕ: ДЕЛЕНИЕ КОМПОНЕНТ ВЕКТОРА НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Операция деления некоммутативна и делитель - число value - должно быть расположено
//слева от вещественного вектора.
//B(b1,...,bn) = A(a1,...,an) / const, bi = ai / const
//Для осуществления операции деления вектора на число необходимо два условия:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//2. Делитель value не должен быть РАВНЫМ НУЛЮ.
//Если условия не выполняются, то возвращается вектор нулевого размера.
//Результатом деления вектора на число всегда является ВЕКТОР.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const double value - вещественное число, делимое на вектор.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector result - вектор V, разделенный на значение value
//***********************************************************************************
rvector TRealVector::operator /(const double value) const
{rvector result;
 if (Size() == 0L) return result;//Деление с вектором нулевого размера
 if (fabs(value) < EPS) return result;//Попытка деления на ноль
 result = *this;//Копирование свойств вектора
 //Цикл деления компонент вектора V на величину value
 for (ulong i = 0L; i < result.Size(); i++)  result.Put(i,result.Get(i)/value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.20; public; TRealVector class overloading operator +
//OVERLOADING ADDITION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector operator +(const TRealVector& V) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СЛОЖЕНИЯ ДВУХ ВЕКТОРОВ.
//Функция реализует перегрузку оператора (+) с целью сложения двух вещественных векто-
//ров X(x1,...,xn) и Y(y1,...,yn):
//Z(z1,z2,...,zN) = X(x1,x2,...,xN) + Y(y1,y2,...,yN), zi = xi + yi.
//Складывать можно только векторы ОДНОГО ТИПА и ОДНОЙ РАЗМЕРНОСТИ. Если векторы разных
//типов (вектор-строка и вектор-столбец), разной размерности или один из векторов -
//вектор нулевой размерности, то возвращается вектор нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TRealVector& V - ссылка на складываемый вектор.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector result - вектор суммы двух векторов.
//***********************************************************************************
rvector TRealVector::operator +(const TRealVector& V) const
{rvector result;
 //Операция сложения производится с вектором (векторами) нулевого размера
 if ((IsZeroSize()) || (V.IsZeroSize())) return result;
 //Операция сложения производится с векторами разной размерности
 if (Size() != V.Size()) return result;
 //Операция сложения производится с векторами разных типов
 if (Type() != V.Type()) return result;
 result = *this;//Копирование свойств исходного вектора
 //Операция сложения двух векторов
 for (ulong i = 0; i < Size(); i++) result.Put(i,data[i]+V.Get(i));
 return result; //Вектор суммы двух векторов
}
//***********************************************************************************
//СТАТУС: I.21; public; TRealVector class overloading operator -
//OVERLOADING SUBTRACTION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector operator -(const TRealVector& V) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЧИТАНИЯ ДВУХ ВЕКТОРОВ.
//Функция реализует перегрузку оператора (-) с целью вычитания двух вещественных век-
//торов X(x1,...,xn) и Y(y1,...,yn):
//Z(z1,z2,...,zN) = X(x1,x2,...,xN) - Y(y1,y2,...,yN), zi = xi - yi.
//Вычитать можно только векторы ОДНОГО ТИПА и ОДНОЙ РАЗМЕРНОСТИ. Если векторы разных
//типов (вектор-строка и вектор-столбец), разной размерности или один из векторов -
//вектор нулевой размерности, то возвращается вектор нулевой длины.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TRealVector& V - ссылка на вычитаемый вектор.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector result - вектор разности двух векторов.
//***********************************************************************************
rvector TRealVector::operator -(const TRealVector& V) const
{rvector result;
 //Операция вычитания производится с вектором (векторами) нулевого размера
 if ((IsZeroSize()) || (V.IsZeroSize())) return result;
 //Операция вычитания производится с векторами разной размерности
 if (Size() != V.Size()) return result;
 //Операция вычитания производится с векторами разных типов
 if (Type() != V.Type()) return result;
 result = *this;//Копирование свойств исходного вектора
 //Операция вычитания двух векторов
 for (ulong i = 0; i < Size(); i++) result.Put(i,data[i]-V.Get(i));
 return result;//Вектор разности двух векторов
}
//***********************************************************************************
//СТАТУС: I.22; public; TRealVector class overloading operator *
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix operator *(const TRealVector& V) const;
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ ДВУХ ВЕКТОРОВ.
//Функция реализует перегрузку оператора (*) с целью умножения двух вещественных век-
//торов X(x1,...,xn) и Y(y1,...,yn). Умножение двух векторов определяется только для
//такой пары двух векторов, у которого число столбцов первого сомножителя равно числу
//строк второго сомножителя. Правила умножения вектора на вектор следующие:
//1. Векторы должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ;
//2. Умножаются ВЕКТОР-СТОЛБЕЦ на ВЕКТОР-СТРОКУ либо ВЕКТОР-СТРОКА на
//   ВЕКТОР-СТОЛБЕЦ.
//3. Размерности векторов не должны быть нулевыми.
//Если данные условия не выполняются, то возвращается матрица нулевого размера. При
//умножении двух векторов одинаковой размерности и противоположных типов в общем слу-
//чае получается МАТРИЦА. При умножении вектора-столбца A размерностью (n x 1) на век-
//тор-строку B размерностью (1 x n) получается КВАДРАТНАЯ МАТРИЦА размерности (n x n).
//Каждый элемент такой матрицы вычисляется по формуле: c(i,j) = a(i) * b(j).
//При умножении вектора-строки A размерностью (1 x n) на вектор-столбец B размерности
//(n x 1) получается КВАДРАТНАЯ МАТРИЦА C размерностью (1 x 1). Данная операция экви-
//валентна операции скалярного умножения двух векторов, результатом которой является
//получение ОДНОГО ЧИСЛА. Элемент такой матрицы вычисляется по формуле скалярного ум-
//ножения двух вещественных векторов: c(1,1) = a1*b1 + a2*b2 + ... + an*bn.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TRealVector& V - ссылка на умножаемый вектор
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - матрица умножения двух векторов
//***********************************************************************************
rmatrix TRealVector::operator *(const TRealVector& V) const
{rmatrix result;
 //Операция умножения производится с вектором (векторами) нулевого размера
 if ((Size() == 0L) || (V.Size() == 0L)) return result;
 //Операция умножения производится с векторами разной размерности
 if (Size() != V.Size()) return result;
 //Операция умножения производится с векторами одинаковых типов
 if (Type() == V.Type()) return result;
 //Операция умножения вектора-столбца на вектор-строку
 if (IsColumn() == true)
 {//Установка типа результирующей квадратной матрицы
  result.Set(Size(),Size(),false);
  for (ulong i = 0; i < Size(); i++)
   for (ulong j = 0; j < Size(); j++)
    result.Put(i,j,data[i]*V.Get(j));
 }
 //Операция умножения вектора-строки на вектор-столбец
 else if (IsRow() == true)
 {result.Set(1L,1L,false);
  double value = 0.0;
  for (ulong i = 0; i < Size(); i++) value += data[i] * V.Get(i);
   result.Put(0,0,value);
 }
 return result; //Матрица умножения двух векторов
}
//***********************************************************************************
//СТАТУС: I.23; friend function of the TRealVector class overloading operator *
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//   friend rvector operator *(const rvector& V, const rmatrix& A)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ СЛЕВА ВЕЩЕСТВЕННОГО ВЕКТОРА НА
//            ВЕЩЕСТВЕННУЮ МАТРИЦУ
//Функция реализует перегрузку оператора (*) с целью умножения слева вещественного
//вектора X(1 x n) на вещественную матрицу A(n x p). Правила умножения слева вектора
//на матрицу следующие:
//1. Вектор должен быть ВЕКТОРОМ-СТРОКОЙ;
//2. Умножаются ВЕКТОР-СТРОКА на МАТРИЦУ, у которой количество строк n должно быть
//   равно размерности вектора-строки.
//3. Размерности вектора и матрицы не должны быть нулевыми.
//Если данные условия не выполняются, то возвращается вектор нулевого размера.
//Результатом умножения слева вектора-строки на матрицу является ВЕКТОР-СТРОКА:
// X(1 x n) * A(n x p) = Y(1 x p)
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TRealVector& V - ссылка на умножаемый вектор.
//2. const TRealMatrix& A - ссылка на умножаемую матрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rvector result - вектор-строка как результат умножения вектора-строки на
// вещественную матрицу.
//***********************************************************************************
rvector operator *(const rvector& V, const rmatrix& A)
{rvector result;
 //Операция умножения производится с вектором нулевого размера
 if (V.Size() == 0L) return result;
 //Операция умножения производится на матрицу нулевого размера
 if ((A.Cols() == 0L) || (A.Rows() == 0L)) return result;
 //Операция умножения слева производится с вектором-столбцом
 if (V.IsColumn()) return result;
 //Операция умножения слева вектора-строки на матрицу производится с разными
 //размером вектора и количеством строк матрицы.
 if (V.Size() != A.Rows()) return result;
 //Установка свойств результирующего вектора-строки. Размерность результирующе-
 //го вектора равна количеству столбцов матрицы.
 result.Set(A.Cols(),ROW,0.0);
 //Операция умножения слева вектора-строки на матрицу
 for (ulong i = 0; i < A.Cols(); i++)
  for (ulong j = 0; j < A.Rows(); j++)
   result.Put(i,result.Get(i)+ V.Get(j) * A.Get(j,i));
 return result; //Результирующий вектор умножения вектора на матрицу слева
}
//***********************************************************************************
//СТАТУС: I.24; friend function of the TRealVector class overloading operator *
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//   friend rvector operator *(const rmatrix& A, const rvector& V)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ СПРАВА ВЕЩЕСТВЕННОГО ВЕКТОРА НА
//            ВЕЩЕСТВЕННУЮ МАТРИЦУ
//Функция реализует перегрузку оператора (*) с целью умножения справа вещественного
//вектора X(n x 1) на вещественную матрицу A(m x n). Правила умножения справа вектора
//на матрицу следующие:
//1. Вектор должен быть ВЕКТОРОМ-СТОЛБЦОМ;
//2. Умножаются МАТРИЦА на ВЕКТОР-СТОЛБЕЦ, у которой количество столбцов n должно
//   быть равно размерности вектора-столбца.
//3. Размерности вектора и матрицы не должны быть нулевыми.
//Если данные условия не выполняются, то возвращается вектор нулевого размера.
//Результатом умножения справа вектора-стролбца на матрицу является
//ВЕКТОР-СТОЛБЕЦ: A(m x n) * X(n x 1) = Y(m x 1).
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TRealVector& V - ссылка на умножаемый вектор.
//2. const TRealMatrix& A - ссылка на умножаемую матрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rvector result - вектор-столбец как результат умножения вектора-столбца на
// вещественную матрицу справа.
//***********************************************************************************
rvector operator *(const rmatrix& A, const rvector& V)
{rvector result;
 //Операция умножения производится с вектором нулевого размера
 if (V.Size() == 0L) return result;
 //Операция умножения производится на матрицу нулевого размера
 if ((A.Cols() == 0L) || (A.Rows() == 0L)) return result;
 //Операция умножения справа производится с вектором-строкой
 if (V.IsRow()) return result;
 //Операция умножения справа вектора-стролбца на матрицу производится с разными
 //размером вектора и количеством столбцов матрицы.
 if (V.Size() != A.Cols()) return result;
 //Установка свойств результирующего вектора-столбца. Размерность результирующего
 //вектора равна количеству строк матрицы.
 result.Set(A.Rows(),COL,0.0);
 //Операция умножения справа вектора-столбца на матрицу
 for (ulong i = 0; i < A.Rows(); i++)
  for (ulong j = 0; j < A.Cols(); j++)
   result.Put(i, result.Get(i) + V.Get(j) * A.Get(i,j));
 return result; //Результирующий вектор умножения справа вектора на матрицу
}
//***********************************************************************************
//СТАТУС: I.25, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector MultByItem(const rvector& V) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ ДВУХ ДЕЙСТВИТЕЛЬНЫХ ВЕКТОРОВ
//Функция перемножает значения элементов двух векторов, которые соответствуют одинако-
//вым значениям индексов. Результатом работы функции является вещественный вектор,
//совпадающий с размерами перемножаемых поэлементно векторов. Каждый элемент резуль-
//тирующего вектора вычисляется по формуле: C[i] = A[i]*B[i].
//В случае, если один из перемножаемых векторов оказывается вектором нулевого размера
//или размерности векторов не совпадают, функция возвращает вектор нулевого размера.
//Тип результирующего вектора совпадает с типом вектора this. При вычислении результи-
//рующего вектора исходные векторы не изменяются.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// const rvector& V - ссылка на второй умножаемый поэлементно вектор.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rvector result - вектор, образованный при поэлементном умножении двух векторов
//                 одинаковых размеров.
//***********************************************************************************
rvector TRealVector::MultByItem(const rvector& V) const
{rvector result;
 //Проверка на возможность поэлементного умножения двух векторов
 if ((Size() == 0L) || (V.Size() == 0L) || (Size() != V.Size())) return result;
 //Поэлементное умножение векторов
 result.Set(Size(),Type(),0.0);
 for (ulong i = 0L; i < Size(); i++) result.Put(i,data[i]*V.Get(i));
return result;
}
//***********************************************************************************
//СТАТУС: I.26, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector MultByItem(const сvector& V) const;
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ ДЕЙСТВИТЕЛЬНОГО и КОМПЛЕКСНОГО ВЕКТОРОВ
//Функция перемножает значения элементов двух векторов, которые соответствуют одинако-
//вым значениям индексов. Результатом работы функции является комплексный вектор, сов-
//падающий с размерами перемножаемых поэлементно векторов. Каждый элемент результирую-
//щего вектора вычисляется по формуле: C[i] = A[i]*B[i].
//В случае, если один из перемножаемых векторов оказывается вектором нулевого размера
//или размерности векторов не совпадают, функция возвращает вектор нулевого размера.
//Тип результирующего вектора совпадает с типом вектора this. При вычислении резуль-
//тирующего вектора исходные векторы не изменяются.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// const сvector& V - ссылка на второй умножаемый поэлементно вектор.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//сvector result - вектор, образованный при поэлементном умножении двух векторов
//                 одинаковых размеров.
//***********************************************************************************
cvector TRealVector::MultByItem(const cvector& V) const
{cvector result;
 //Проверка на возможность поэлементного умножения двух векторов
 if ((Size() == 0L) || (V.Size() == 0L) || (Size() != V.Size())) return result;
 //Поэлементное умножение векторов
 result.Set(Size(),Type(),C_ZERO);
 for (ulong i = 0L; i < Size(); i++) result.Put(i,data[i]*V.Get(i));
return result;
}
//***********************************************************************************
//СТАТУС: I.27, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double SumByItem(ulong* counter = NULL) const
//НАЗНАЧЕНИЕ: СУММИРОВАНИЕ ВСЕХ ЭЛЕМЕНТОВ ВЕКТОРА
//Результатом работы функции является сумма значений элементов вектора. Функция не
//изменяет значений и структуру исходного вектора.
//Функции передается необязательный указатель на переменную типа ulong - count. По
//умолчанию counter=NULL. В ходе работы функция подсчитывает кол-во элементов вектора,
//которые участвовали в суммировании. Если указатель counter отличен от NULL, то по его
//адресу по окончании работы функции передается количество суммируемых элементов. Если
//исходный вектор - вектор нулевого размера, то функция возвращает нуль.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// ulong* counter (NULL) - указатель на счетчик, в который будет записано количество
// элементов вектора, по которым осуществлялось суммирование.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double sum - сумма всех значений элементов вектора
//***********************************************************************************
double TRealVector::SumByItem(ulong* counter) const
{double sum = 0.0;
 //Проверка на вектор нулевого размера
 if (Size() == 0L) {if (counter != NULL) *counter = 0; return sum;}
 //Сложение всех значений элементов вектора
 for (ulong i = 0L; i < Size(); i++) sum += data[i];
 if (counter != NULL) *counter = Size();
return sum;
}
//***********************************************************************************
//СТАТУС: I.28, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// double SumByItem(ulong left, ulong right=MAX_SIZE, ulong* counter=NULL) const
//НАЗНАЧЕНИЕ: СУММИРОВАНИЕ ЗНАЧЕНИЙ ЭЛЕМЕНТОВ ВЕКТОРА В ОПРЕДЕЛЕННОМ ИНТЕРВАЛЕ
//Функция суммирует значения элементов вектора в интервале, заданном нижней гра-
//ницей индексов вектора - left и верхней границей индексов вектора - right. По
//умолчанию right задается равным верхней границей данного вектора. Нижняя и
//верхняя границы индексов включаются в интервал, в котором будет осуществляться
//суммирование элементов вектора, индексы которых принадлежат заданному интерва-
//лу. Результатом работы функции является сумма значений элементов вектора в за-
//данном интервале индексов. Функция не изменяет значений и структуру исходного
//вектора.
//Функции передается необязательный указатель на переменную типа ulong - count.
//По умолчанию counter=NULL. В ходе работы функция подсчитывает кол-во элементов
//вектора, которые участвовали в суммировании. Если указатель counter отличен от
//NULL, то по его адресу по окончании работы функции передается количество эле-
//ментов, которые суммировались.
//Функция возвращает нулевое значение суммы значений элементов вектора в следую-
//щих исключительных ситуациях:
//1. Исходный вектор - вектор нулевого размера;
//2. Левая или правая границы интервала выходят за допустимые значения индексов
//   исходного вектора;
//3. Левая граница интервала суммирования больше правой границы.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left - левая (нижняя) граница интервала суммирования элементов;
//2. ulong right - правая (верхняя) граница интервала суммирования элементов.
//3. ulong* counter (NULL) - указатель на счетчик, в который будет записано ко-
//   личество элементов вектора, по которым осуществлялось суммирование.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//double sum - сумма значений элементов вектора в заданном интервале индексов
//*****************************************************************************
double TRealVector::SumByItem(ulong left, ulong right, ulong* counter) const
{double sum = 0.0;
 //Проверка на вектор нулевого размера
 if (Size() == 0L) {if (counter != NULL) *counter = 0; return sum;}
 if (right == MAX_SIZE) right = Size();
 //Проверка на корректность задаваемых границ интервала
 if ((left >= Size()) || (right >= Size()) || (left > right))
 {if (counter != NULL) *counter = 0; return sum;}
 //Сложение значений элементов вектора в заданном интервале индексов
 for (ulong i = left; i <= right; i++) sum += data[i];
 if (counter != NULL) *counter = (right-left+1);
return sum;
}
//*****************************************************************************
//СТАТУС: I.29, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//  double SumByItem(const ivector& index, bool check = false,
//                   ulong* counter = NULL) const
//НАЗНАЧЕНИЕ: СУММИРОВАНИЕ ЗНАЧЕНИЙ ЭЛЕМЕНТОВ ВЕКТОРА, КОТОРЫЕ СООТВЕТСТВУЮТ
//            ОПРЕДЕЛЕННЫМ ИНДЕКСАМ ЭЛЕМЕНТОВ ИСХОДНОГО ВЕКТОРА
//Значения индексов исходного вектора, по которым будет осуществляться суммирова-
//ние элементов вектора, передаются в векторе index. Аргумент check указывает на
//проведение проверки значений индексов на соответствие допустимым значениям ин-
//дексов исходного вектора. При check = true, создается объект-предикат, который
//осуществляет селекцию корректных значений индексов, и формируется подвектор
//вектора index с корректными значениями индексов. Созданный подвектор далее ис-
//пользуется для суммирования значений элементов вектора по заданным индексам.
//При check = false фильтрация некорректных значений индексов не осуществляется.
//В этом случае ответственность за корректность всех значений индексов возлагает-
//ся на пользователя и при некорректном задании значения индекса, выходящего за
//пределы допустимых значений индексов для данного вектора, приведет к аварийно-
//му завершению работы всей программы. При check = false функция быстрее выпол-
//няет необходимые действия, так как не тратится время на фильтрацию некоррект-
//ных значений индексов, передавемых вектором index.
//Функции передается необязательный указатель на переменную типа ulong - count.
//По умолчанию counter=NULL. В ходе работы функция подсчитывает кол-во элементов
//вектора, которые участвовали в суммировании. Если указатель counter отличен от
//NULL, то по его адресу по окончании работы функции передается количество эле-
//ментов, которые суммировались.
//Результатом работы функции является сумма значений элементов вектора по задан-
//ным индексам. Функция не изменяет значений и структуру исходного вектора.
//Функция возвращает нулевое значение суммы значений элементов вектора в следую-
//щих исключительных ситуациях:
//1. Исходный вектор - вектор нулевого размера;
//2. Вектор со значениями индексов является вектором нулевого размера;
//3. При выполнении фильтрации некорректных значений индексов (check = true)
//   полученный подвектор вектора index является вектором нулевого размера, что
//   означает отсутствие в векторе index корректных индексов для исходного вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& index - ссылка на вектор со значениями индексов по которым
//   будет осуществляться суммирование элементов исходного вектора;
//2. bool check - индикатор фильтрации некорректных значений индексов в index.
//3. ulong* counter (NULL) - указатель на счетчик, в который будет записано ко-
//   личество элементов вектора, по которым осуществлялось суммирование.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//double sum - сумма значений элементов вектора по заданным индексам элементов
//*****************************************************************************
double TRealVector::SumByItem(const ivector& index, bool check, ulong* counter)
const
{double sum = 0.0;
 //Проверка на векторы нулевого размера
 if (IsZeroSize() || index.IsZeroSize())
 {if (counter != NULL) *counter = 0L; return sum;}
 ivector Index = index;
 if (check) //Проверка на корректность значений индексов
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Size()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  if (Index.IsZeroSize()) {if (counter != NULL) *counter = 0; return sum;}
 }
 //Сложение значений элементов вектора, соответсвующих определенным индексам
 for (ulong i = 0L; i <= Index.Size(); i++) sum += data[Index(i)];
 if (counter != NULL) *counter = Index.Size();
return sum;
}
//*****************************************************************************
//СТАТУС: I.30, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// double SumByItem(const TArgVectorPredicate<double,rvector>& Predicate,
//                  ulong* counter = NULL) const
//НАЗНАЧЕНИЕ: СУММИРОВАНИЕ ЗНАЧЕНИЙ ЭЛЕМЕНТОВ ВЕКТОРА, КОТОРЫЕ УДОВЛЕТВОРЯЮТ
//            УСЛОВИЯМ ОБЪЕКТА-ПРЕДИКАТА
//Перед суммированием каждое значение элемента исходного вектора в качестве аргу-
//мента передается перегруженному оператору вызова функции объекта-предиката
//Predicate. Перегруженный оператор вызова функции объекта Predicate в зависимос-
//ти от значения аргумента возвращает булевское значение - true или false. Если
//объект-предикат возвращает true, то такое значение элемента вектора суммирует-
//ся с остальными значениями элементов вектора, для которых Predicate вернул зна-
//чение true. Если Predicate возвращает значение false, то данное значение эле-
//мента вектора не допускается к суммированию. Работу объекта-предиката можно
//сравнить с фильтром, который пропускает или не пропускает определенные данные.
//Результатом работы функции является сумма значений элементов вектора, удовлет-
//воряющие условиям объекта-предиката. Функция не изменяет значений и структуру
//исходного вектора.
//Функции передается необязательный указатель на переменную типа ulong - count.
//По умолчанию counter=NULL. В ходе работы функция подсчитывает кол-во элементов
//вектора, которые участвовали в суммировании. Если указатель counter отличен от
//NULL, то по его адресу по окончании работы функции передается количество эле-
//ментов, которые суммировались.
//Функция возвращает нулевое значение суммы значений элементов вектора в следую-
//щих исключительных ситуациях:
//1. Исходный вектор - вектор нулевого размера;
//2. Ни одно из значений элементов вектора не удовлетворяет условиям
//   объекта-предиката Predicate;
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TArgVectorPredicate<double,rvector>& Predicate - ссылка на объект-пре-
//   дикат, по которому будет осуществляться отбор значений элементов вектора
//   для их суммирования;
//2. ulong* counter (NULL) - указатель на счетчик, в который будет записано ко-
//   личество элементов вектора, по которым осуществлялось суммирование.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//double sum - сумма значений элементов вектора по заданным индексам элементов
//*****************************************************************************
double TRealVector::SumByItem(const TArgVectorPredicate<double,rvector>& Predicate,
                              ulong* counter) const
{double sum = 0.0;
 ulong count = 0L;
 if (Size() == 0L) //Вектор нулевого размера
 { if (counter != NULL) *counter = count; return sum; }
 double value;
 //Сложение значений элементов вектора, удовлетворяющим условиям Predicate
 for (ulong i = 0L; i < Size(); i++)
 {value = data[i];
  if (Predicate(value)) {sum += value; count++;}
 }
 if (counter != NULL) *counter = count;
return sum;
}
//*****************************************************************************
//СТАТУС: I.31, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool DiagonalEM(const rmatrix& Q, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ДИАГОНАЛЬНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Dk.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицу Dk. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Dk;
//2. ulong k - k-й диагональный элемент матрицы отличный от нуля и единицы,
//   0 <= k < Q.Rows().
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::DiagonalEM(const rmatrix& Q, ulong k)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (k >= Q.Rows())) return false;
 //Реализация операции умножения
 data[k] = data[k]*Q.Get(k,k);
return true;
}
//*****************************************************************************
//СТАТУС: I.32, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool DiagonalEM(const rmatrix& Q, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ГРУППУ ДИАГОНАЛЬНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Dk.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Dk. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матриц Dk;
//2. ulong first - индекс первой диагональной элементарной матрицы;
//3. ulong last -  индекс последней диагональной элементарной матрицы;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::DiagonalEM(const rmatrix& Q, ulong first, ulong last)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 for (ulong i = first; i <= last; i++) data[i] = data[i]*Q.Get(i,i);
return true;
}
//*****************************************************************************
//СТАТУС: I.33, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool DiagonalEM(const rmatrix& Q)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВСЕ ДИАГОНАЛЬНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Dk.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Dk. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
// матриц Dk;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::DiagonalEM(const rmatrix& Q)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L))
  return false;
 //Реализация операции умножения
 for (ulong i = 0; i < Size(); i++) data[i] = data[i]*Q.Get(i,i);
return true;
}
//*****************************************************************************
//СТАТУС: I.34, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LowerColumnEM(const rmatrix& Q, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА НИЖНЮЮ СТОЛБЦОВУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Lkc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицу Lkc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Lkc;
//2. ulong k - k-й столбец матрицы, поддиагональные элементы которого отличны от
//   нуля, 0 <= k < Q.Rows().
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::LowerColumnEM(const rmatrix& Q, ulong k)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {for (ulong i = k+1; i < Q.Rows(); i++) //По строкам Q
   data[i] += data[k]*Q.Get(i,k);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {for (ulong i = k+1; i < Q.Rows(); i++) //По строкам Q
   data[k] += data[i]*Q.Get(i,k); //Накопление суммы произведений
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.35, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool LowerColumnEM(const rmatrix& Q, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ГРУППУ НИЖНИХ СТОЛБЦОВЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Lkc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Lkc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матриц Lkc;
//2. ulong first - индекс первой нижней столбцовой элементарной матрицы;
//3. ulong last -  индекс последней нижней столбцовой элементарной матрицы;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::LowerColumnEM(const rmatrix& Q, ulong first, ulong last)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.36, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LowerColumnEM(const rmatrix& Q)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВСЕ НИЖНИЕ СТОЛБЦОВЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Lkc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Lkc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
// матриц Lkc.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::LowerColumnEM(const rmatrix& Q)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L))
  return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {for (ulong j = 0; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {for (ulong j = 0; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.37, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool UpperColumnEM(const rmatrix& Q, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВЕРХНЮЮ СТОЛБЦОВУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Ukc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицу Ukc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Ukc;
//2. ulong k - k-й столбец матрицы, наддиагональные элементы которого отличны от
//   нуля, 0 <= k < Q.Rows().
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::UpperColumnEM(const rmatrix& Q, ulong k)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {for (ulong i = 0; i < k; i++) //По строкам Q
   data[i] += data[k]*Q.Get(i,k);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {for (ulong i = 0; i < k; i++) //По строкам Q
   data[k] += data[i]*Q.Get(i,k); //Накопление суммы произведений
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.38, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool UpperColumnEM(const rmatrix& Q, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ГРУППУ ВЕРХНИХ СТОЛБЦОВЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Ukc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Ukc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матриц Ukc;
//2. ulong first - индекс первой верхней столбцовой элементарной матрицы;
//3. ulong last -  индекс последней верхней столбцовой элементарной матрицы;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::UpperColumnEM(const rmatrix& Q, ulong first, ulong last)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.39, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool UpperColumnEM(const rmatrix& Q)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВСЕ ВЕРХНИЕ СТОЛБЦОВЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Ukc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Ukc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
// матриц Ukc.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::UpperColumnEM(const rmatrix& Q)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L))
  return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {for (ulong j = 1; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {for (ulong j = 1; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.40, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CompleteColumnEM(const rmatrix& Q, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ПОЛНУЮ СТОЛБЦОВУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Tkc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицу Tkc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Tkc;
//2. ulong k - k-й столбец матрицы с ненулевыми элементами, 0 <= k < Q.Rows().
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::CompleteColumnEM(const rmatrix& Q, ulong k)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на наддиагональные элементы k-го столбца
  for (ulong i = 0; i < k; i++) data[i] += data[k]*Q.Get(i,k);
  //Умножение на поддиагональные элементы k-го столбца
  for (ulong i = k+1; i < Q.Rows(); i++) data[i] += data[k]*Q.Get(i,k);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на наддиагональные элементы k-го столбца
  for (ulong i = 0; i < k; i++) data[k] += data[i]*Q.Get(i,k);
  //Умножение на поддиагональные элементы k-го столбца
  for (ulong i = k+1; i < Q.Rows(); i++) data[k] += data[i]*Q.Get(i,k);
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.41, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CompleteColumnEM(const rmatrix& Q, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ГРУППУ ПОЛНЫХ СТОЛБЦОВЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Tkc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Tkc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матриц Tkc;
//2. ulong first - индекс первой полной столбцовой элементарной матрицы;
//3. ulong last -  индекс последней полной столбцовой элементарной матрицы;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::CompleteColumnEM(const rmatrix& Q, ulong first, ulong last)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на верхние столбцовые элементарные матрицы
  for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
  //Умножение на нижние столбцовые элементарные матрицы
  for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на верхние столбцовые элементарные матрицы
  for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
  //Умножение на нижние столбцовые элементарные матрицы
  for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.42, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CompleteColumnEM(const rmatrix& Q)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВСЕ ПОЛНЫЕ СТОЛБЦОВЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Tkc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Tkc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
// матриц Tkc.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::CompleteColumnEM(const rmatrix& Q)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L))
  return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на все верхние столбцовые элементарные матрицы
  for (ulong j = 1; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
  //Умножение на все нижние столбцовые элементарные матрицы
  for (ulong j = 0; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на все верхние столбцовые элементарные матрицы
  for (ulong j = 1; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
  //Умножение на все верхние столбцовые элементарные матрицы
  for (ulong j = 0; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.43, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LeftRowEM(const rmatrix& Q, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ЛЕВУЮ СТРОЧНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Lkr.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицу Lkr. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Lkr;
//2. ulong k - k-я строка матрицы с ненулевыми элементами, расположенные слева
//   от главной диагонали, 0 <= k < Q.Rows().
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::LeftRowEM(const rmatrix& Q, ulong k)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на элементы k-й строки, расположенные левее главной диагонали
  for (ulong j = 0; j < k; j++) data[k] += data[j]*Q.Get(k,j);//По столбцам Q
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на элементы k-й строки, расположенные левее главной диагонали
  for (ulong j = 0; j < k; j++) data[j] += data[k]*Q.Get(k,j);//По столбцам Q
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.44, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool LeftRowEM(const rmatrix& Q, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ГРУППУ ЛЕВЫХ СТРОЧНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Lkr.
//Функция  осуществляет  проверку на возможность умножения вектора на матрицу Q,
//содержащую  матрицы Lkr. Функция  при возможности  умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матриц Lkr;
//2. ulong first - индекс первой левой строчной элементарной матрицы;
//3. ulong last -  индекс последней левой строчной элементарной матрицы;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::LeftRowEM(const rmatrix& Q, ulong first, ulong last)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на левые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на левые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.45, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LeftRowEM(const rmatrix& Q)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВСЕ ЛЕВЫЕ СТРОЧНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Lkr.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Lkr. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
// матриц Lkr.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::LeftRowEM(const rmatrix& Q)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L))
     return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на все левые строчные элементарные матрицы
  for (ulong i = 1; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на все левые строчные элементарные матрицы
  for (ulong i = 1; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.46, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool RightRowEM(const rmatrix& Q, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ПРАВУЮ СТРОЧНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Ukr.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицу Ukr. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Ukr;
//2. ulong k - k-я строка матрицы с ненулевыми элементами, расположенными справа
//   от главной диагонали, 0 <= k < Q.Rows().
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::RightRowEM(const rmatrix& Q, ulong k)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на элементы k-й строки, расположенные справа от главной диагонали
  //По столбцам Q, накопление суммы произведений
  for (ulong j = k+1; j < Q.Cols(); j++) data[k] += data[j]*Q.Get(k,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на элементы k-й строки, расположенные справа от главной диагонали
  //По столбцам Q
  for (ulong j = k+1; j < Q.Cols(); j++) data[j] += data[k]*Q.Get(k,j);
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.47, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool RightRowEM(const rmatrix& Q, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ГРУППУ ПРАВЫХ СТРОЧНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Ukr.
//Функция  осуществляет  проверку на возможность умножения вектора на матрицу Q,
//содержащую  матрицы Ukr. Функция  при возможности  умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матриц Ukr;
//2. ulong first - индекс первой правой строчной элементарной матрицы;
//3. ulong last -  индекс последней правой строчной элементарной матрицы;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::RightRowEM(const rmatrix& Q, ulong first, ulong last)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на правые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на правые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.48, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool RightRowEM(const rmatrix& Q)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВСЕ ПРАВЫЕ СТРОЧНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Ukr.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Ukr. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
// матриц Ukr.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::RightRowEM(const rmatrix& Q)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L))
     return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на все правые строчные элементарные матрицы
  for (ulong i = 0; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на все правые строчные элементарные матрицы
  for (ulong i = 0; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.49, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CompleteRowEM(const rmatrix& Q, ulong k);
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ПОЛНУЮ СТРОЧНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Tkr.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицу Tkr. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Ukr;
//2. ulong k - k-я строка матрицы с ненулевыми элементами, 0 <= k < Q.Rows().
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::CompleteRowEM(const rmatrix& Q, ulong k)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на элементы k-й строки, расположенные слева от главной диагонали
  //По столбцам Q, накопление суммы произведений
  for (ulong j = 0; j < k; j++) data[k] += data[j]*Q.Get(k,j);

  //Умножение на элементы k-й строки, расположенные справа от главной диагонали
  //По столбцам Q, накопление суммы произведений
  for (ulong j = k+1; j < Q.Cols(); j++) data[k] += data[j]*Q.Get(k,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на элементы k-й строки, расположенные слева от главной диагонали
  //По столбцам Q
  for (ulong j = 0; j < k; j++) data[j] += data[k]*Q.Get(k,j);

  //Умножение на элементы k-й строки, расположенные справа от главной диагонали
  //По столбцам Q
  for (ulong j = k+1; j < Q.Cols(); j++) data[j] += data[k]*Q.Get(k,j);
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.50, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CompleteRowEM(const rmatrix& Q, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ГРУППУ ПОЛНЫХ СТРОЧНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Tkr.
//Функция  осуществляет  проверку на возможность умножения вектора на матрицу Q,
//содержащую  матрицы Tkr. Функция  при возможности  умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матриц Tkr;
//2. ulong first - индекс первой полной строчной элементарной матрицы;
//3. ulong last -  индекс последней полной строчной элементарной матрицы;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::CompleteRowEM(const rmatrix& Q, ulong first, ulong last)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на левые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений

  //Умножение на правые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на левые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);

  //Умножение на правые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.51, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CompleteRowEM(const rmatrix& Q)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВСЕ ПОЛНЫЕ СТРОЧНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Tkr.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Tkr. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
// матриц Tkr.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::CompleteRowEM(const rmatrix& Q)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L))
  return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на все левые строчные элементарные матрицы
  for (ulong i = 1; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений

  //Умножение на все правые строчные элементарные матрицы
  for (ulong i = 0; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на все левые строчные элементарные матрицы
  for (ulong i = 1; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);

  //Умножение на все правые строчные элементарные матрицы
  for (ulong i = 0; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.52, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool OrdinaryEM(const rmatrix& Q, ulong row, ulong col)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ЭЛЕМЕНТАРНУЮ МАТРИЦУ Bij.
//Функция  осуществляет  проверку на возможность умножения вектора на матрицу Q,
//содержащую  матрицу Bij. Функция  при возможности  умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Bij;
//2. ulong row - строка элементарной матрицы с ненулевым элементом;
//3. ulong col - столбец элементарной матрицы с ненулевым элементов;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TRealVector::OrdinaryEM(const rmatrix& Q, ulong row, ulong col)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (!Q.IsSquare()) || (Q.Rows() == 0L) ||
     (row >= Q.Rows()) || (col >= Q.Cols())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q: V' = Q*V
 {if (row != col) data[row] += data[col]*Q.Get(row,col);
  else data[row] *= Q.Get(row,col);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q: V' = V*Q
 {if (row != col) data[col] += data[row]*Q.Get(row,col);
  else data[col] *= Q.Get(row,col);
 }
return true;
}

//------------------------------------------------------------------------------
//              РЕАЛИЗАЦИЯ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ
//------------------------------------------------------------------------------
//*****************************************************************************
//СТАТУС: I.1; public; TRealVector class overloading operator()
//OVERLOADING OPERATOR OF FUNCTION CALL
//НАИМЕНОВАНИЕ ФУНКЦИИ: double& operator() (ulong i)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЗОВА ФУНКЦИИ класса TRealVector
//Функция предназначена для доступа к одному элементу вектора.
//Осуществляется проверка корректности индекса по которому располагается требуе-
//мый элемент вектора. Функция вызывается во всех пользовательских функциях,
//кроме вызова в операторе присваивания и конструкторе копирования, т.к. в
//качестве аргументов последних передается константный объект.
//Доступ к членам-данным константных объектов можно осуществлять только с исполь-
//зованием константных функций.
//ПРИМЕР ВЫЗОВА: V(3), где i=3 - индекс элемента вещественного вектора. Нумера-
//ция элементов вектора начинается с 0.
//Если индекс элемента вектора некорректен, то возвращается его первый элемент.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint i - индекс элемента вектора
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double value - ссылка на a[i] компонент вектора
//*****************************************************************************
double& TRealVector::operator() (ulong i)
{if (Size() == 0L) return data[0];//Попытка доступа к вектору нулевого размера
 //Проверка корректности индексов доступа к элементу вектора
 if (i >= Size()) return data[0];  //Индекс i выходит за границы вектора
 return data[i];
}
//*****************************************************************************
//СТАТУС: I.2; public; TRealVector class overloading operator()
//OVERLOADING OPERATOR OF FUNCTION CALL
//НАИМЕНОВАНИЕ ФУНКЦИИ: const double operator() (ulong i) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЗОВА ФУНКЦИИ класса TRealVector
//Функция предназначена для доступа к одному элементу вектора.
//Осуществляется проверка корректности индекса по которому располагается требуе-
//мый элемент вектора. Функция вызывается в операторе присваивания и конструкто-
//ре копирования, т.к. в качестве их аргументов передается константный объект.
//Доступ к членам-данным константных объектов можно осуществлять только с исполь-
//зованием константных функций.
//ПРИМЕР ВЫЗОВА: A(3), где i=3 - индекс вещественного вектора. Нумерация элемен-
//тов вектора начинается с 0.
//Если индекс элемента вектора некорректен, то возвращается его первый элемент.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint i - индекс элемента вектора
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: const double value - a[i] компонент вектора
//*****************************************************************************
const double TRealVector::operator() (ulong i) const
{if (Size() == 0L) return data[0];//Попытка доступа к вектору нулевого размера
 //Проверка корректности индексов доступа к элементу вектора
 if (i >= Size()) return data[0]; //Индекс i выходит за границы вектора
 return data[i];
}
//*****************************************************************************
//СТАТУС: I.3; public; TRealVector class overloading operator[]
//OVERLOADING THE SUBSCRIPT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: double& operator[] (ulong i)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР [] класса TRealVector
//Функция предназначена для доступа к одному элементу вектора.
//Осуществляется проверка корректности индекса по которому располагается требуе-
//мый элемент вектора. Функция вызывается во всех пользовательских функциях,
//кроме вызова в операторе присваивания и конструкторе копирования, т.к. в
//качестве аргументов последних передается константный объект.
//Доступ к членам-данным константных объектов можно осуществлять только с исполь-
//зованием константных функций.
//ПРИМЕР ВЫЗОВА: V[3], где i=3 - индекс элемента вещественного вектора. Нумера-
//ция элементов вектора начинается с 0.
//Если индекс элемента вектора некорректен, то возвращается его первый элемент
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint i - индекс элемента вектора
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double& value - ссылка на a[i] компонент вектора
//*****************************************************************************
double& TRealVector::operator[] (ulong i)
{if (Size() == 0L) return data[0];//Попытка доступа к вектору нулевого размера
 //Проверка корректности индексов доступа к элементу вектора
 if (i >= Size()) return data[0];  //Индекс i выходит за границы вектора
 return data[i];
}
//*****************************************************************************
//СТАТУС: I.4; public; TRealVector class overloading operator[]
//OVERLOADING SUBSCRIPT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: const double operator[] (ulong i) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР [] класса TRealVector
//Функция предназначена для доступа к одному элементу вектора.
//Осуществляется проверка корректности индекса по которому располагается требуе-
//мый элемент вектора. Функция вызывается в операторе присваивания и конструкто-
//ре копирования, т.к. в качестве их аргументов передается константный объект.
//Доступ к членам-данным константных объектов можно осуществлять только с исполь-
//зованием константных функций.
//ПРИМЕР ВЫЗОВА: A[3], где i=3 - индекс вещественного вектора. Нумерация элемен-
//тов вектора начинается с 0.
//Если индекс элемента вектора некорректен, то возвращается его первый элемент.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint i - индекс элемента вектора
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: const double value - a[i] компонент вектора
//*****************************************************************************
const double TRealVector::operator[] (ulong i) const
{if (Size() == 0L) return data[0];//Попытка доступа к вектору нулевого размера
 //Проверка корректности индексов доступа к элементу вектора
 if (i >= Size()) return data[0]; //Индекс i выходит за границы вектора
 return data[i];
}
//*****************************************************************************
//СТАТУС: I.5; public; TRealVector class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: operator =(const TRealVector& V)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ класса TRealVector.
//Функция осуществляет копирование характеристик и значений элементов из одного
//вещественного вектора в другой. Осуществляется корректное копирование членов-
//указателей на данные копируемого класса в создаваемый класс с целью недопуще-
//ния ссылок указателей разных объектов класса на одно и то же место памяти.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TRealVector& V - ссылка на копируемый вектор.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TRealVector::operator =(const TRealVector& V)
{if (this == &V) return;//Предотвращение попытки присваивания объекта самому себе
 //Установка свойств копирующего вектора
 Resize(V.Size()); SetType(V.Type());
 //Копирование значений элементов вектора V
 for (ulong i = 0L; i < Size(); i++) data[i] = V.Get(i);
}
//***********************************************************************************
//СТАТУС: I.6;  TRealVector class friend overloading operator <<
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend ostream& operator <<(ostream& out, const TRealVector& V);
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВЫВОДА класса TRealVector.
//Функция предназначена для вывода в поток характеристик вектора и ее элементов.
//Функция возвращает ссылку на поток, что позволяет записывать в программе операторы
//вывода в поток каскадно. Формат вывода значений элементов вектора:
// <x >, где x - значениe элемента вектора.
//При выводе элементов вещественного вектора приняты следующие соглашения:
//1. Все элементы вектора имеют ширину вывода равную наибольшей символьной длине
//   элемента вектора, который определяется функцией MaxStrLen(...)
//2. Выводятся только отрицательные знаки чисел.
//3. Точность вывода чисел с плавающей точкой определяется установленным до вывода
//   элементов вектора значением функции потокового вывода precision. Максимально
//   возможное количество значащих цифр - 19.
//4. Элементы вектор-строки выводятся в строку, а вектор-столбца - в столбец.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на объект потока вывода;
//2. сonst TRealVector& V - ссылка на вектор, выводимый в поток.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ostream& out - ссылка на объект потока вывода.
//***********************************************************************************
ostream& operator <<(ostream& out, const TRealVector& V)
{string s;
 uint precision = out.precision();
 V.Properties(s); //Получение свойств вектора V в виде строки
 out << s;//Вывод характеристик вектора
 if (V.IsZeroSize()) return out;
 //Определение типа вектора: вектор-строка или вектор-столбец
 if (V.IsColumn()) //Вектор-столбец
 {long flags = out.flags();
  //Определение максимальной символьной длины элемента матрицы
  uint MaxLen = MaxStrLen(V,precision);
  out.setf(ios::right);//Выравнивание по правому краю.
  //Вывод значений элементов вектора-столбца V в поток. Каждый элемент выводится с
  //новой строки
  for (ulong i = 0L; i < V.Size(); i++)
   out << setw(MaxLen) << setprecision(precision) << V(i) << endl;
  out.flags(flags);//Восстанавливаем значения флагов потока
 }
 else //Вектор-строка: все значения вектора располагаются в одну строку
 {out << '{';
  for (ulong i = 0L; i < V.Size(); i++)
  {out << setprecision(precision) << V(i);
   if ((V.Size()-i) > 1) out << " ";
   else out << '}' << endl;
  }
 }
return out;
}
//***********************************************************************************
//СТАТУС: I.7; public; TRealVector class overloading operator ==
//OVERLOADING COMPARISON OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ==(const TRealVector& V) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СРАВНЕНИЯ ДВУХ ВЕКТОРОВ.
//Функция реализует перегрузку оператора (==) с целью сравнения двух вещественных
//векторов X(x1,...,xn) и Y(y1,...,yn). N-мерные вектора X = (x1,x2,...,xN)
//и Y = (y1,y2,...,yN) считаются РАВНЫМИ, если их соответствующие компоненты совпадают,
//т.е. xi == yi для i = 1,2,...,n. Сравнивать можно только векторы ОДНОГО ТИПА и ОДНОЙ
//РАЗМЕРНОСТИ. Если векторы равны, то возвращается true, в противном случае - false.
//Если векторы разных типов (вектор-строка и вектор-столбец), разной размерности или
//при попытке сравнения с вектором нулевой размерности функция возвращает false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TRealVector& V - ссылка на сравниваемый вектор
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool compare
//***********************************************************************************
bool TRealVector::operator ==(const TRealVector& V) const
{bool equal = false;
 //Операция сравнения производится с вектором (векторами) нулевого размера
 if ((IsZeroSize()) && (V.IsZeroSize())) return true;
 //Операция сравнения производится с векторами разной размерности
 if (Size() != V.Size()) return equal;
 //Операция сравнения производится с векторами разных типов
 if (Type() != V.Type()) return equal;
 //Покомпонентное сравнение векторов
 equal = true;
 for (ulong i = 0; i < Size(); i++)
  if (fabs(data[i] - V.data[i]) > EPS)
  {equal = false;
   break; //Преждевременный выход из цикла сравнения компонент векторов
  }
 return equal;//Результат сравнения векторов
}
//******************************************************************************
//СТАТУС: I.8; public; TRealVector class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator =(const double value)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ КОМПОНЕНТАМ ВЕКТОРА
//            ДЕЙСТВИТЕЛЬНОГО ЧИСЛА.
//Функция осуществляет присваивание ВСЕМ компонентам вектора значения value.
//При попытке присваивания вектору нулевой размерности действительного числа
//функция возвращает false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const double value - присваиваемое вектору значение
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак результата присваивания
//******************************************************************************
bool TRealVector::operator =(const double value)
{if (Size() == 0L) return false;//Присваивание вектору нулевого размера
 //Цикл присваивания компонентам вектора значения value
 for (ulong i = 0; i < Size(); i++) data[i] = value;
 return true;
}

//==============================================================================
// II. РЕАЛИЗАЦИЯ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TRealVector
//     PRIVATE MEMBER-FUNCTION OF TRealVector CLASS REALIZATION
//==============================================================================
//******************************************************************************
//СТАТУС: II.1., private, TRealVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Initial()
//НАЗНАЧЕНИЕ: Начальная инициализация характеристик вещественного вектора при
//его конструировании.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TRealVector::Initial()
{//Начальная инициализация защищенных членов-данных класса
 type = ROW;  //Вектор-строка нулевого размера
 size = 0L;   //Установка размерности вектора
 data = NULL; //Установка указателя на элементы вектора в NULL
}
//******************************************************************************
//СТАТУС: II.2., private, TRealVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Create()
//НАЗНАЧЕНИЕ: Распределение оперативной памяти под элементы вещественного вектора
//без их инициализации. Количество элементов вектора определяется переменной size.
//Если size равна 0, то создается вектор нулевого размера. В случае нехватки па-
//мяти  генерируется ошибка, вектору присваивается нулевой размер. Элементы век-
//тора хранятся в одномерном массиве data.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TRealVector::Create()
{if (Size() == 0) {Initial(); return true;} //Вектор нулевого размера
 //Распределение памяти под элементы вектора без их инициализация
 try
  {
    data = new double[Size()];//Распределение памяти под элементы вектора
  }
  // ENTER THIS BLOCK ONLY IF xalloc IS THROWN.
  // YOU COULD REQUEST OTHER ACTIONS BEFORE TERMINATING
  catch (std::bad_alloc) {Initial(); return false;}  //xalloc x
 return true;
}
//******************************************************************************
//СТАТУС: II.3., private, TRealVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Delete()
//НАЗНАЧЕНИЕ: Удаление из оперативной памяти элементов вещественного вектора.
//После завершения работы функции получается вектор нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TRealVector::Delete()
{//Вектор нулевого размера
 if (data == NULL) {Initial(); return;}
 delete[] data;//Удаление элементов вектора
 Initial();
}

//==============================================================================
// III. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TRealVector
//      PROTECTED MEMBER-FUNCTION OF TRealVector CLASS REALIZATION
//==============================================================================
//*****************************************************************************
//СТАТУС: III.1., protected, TRealVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsZeroSize() const
//НАЗНАЧЕНИЕ: Проверка вектора на вектор нулевого размера. В случае удачи функция
//возвращает - true и false - в противном случае. Свойства вектора нулевого
//размера: 1. size == 0 || data == NULL
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - true - вектор нулевого размера
//                                       false - вектор не нулевого размера
//*****************************************************************************
bool TRealVector::IsZeroSize() const
{
 return (Size() == 0L) ? true : false;//Проверка на size == 0
}
//*****************************************************************************
//СТАТУС: III.2., protected, TRealVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsZero() const
//НАЗНАЧЕНИЕ: Проверка вектора на вектор со всеми нулевыми элементами. В случае
//удачи функция возвращает - true и false - в противном случае. Свойства вектора
//со всеми нулевыми элементами:
//1. size != 0 - вектор должен быть не НУЛЕВОГО РАЗМЕРА;
//2. V[i] = 0 - ВСЕ элементы вектора должны быть равны НУЛЮ.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - вектор со всеми нулевыми элементами;
//                false - не нулевой вектор.
//*****************************************************************************
bool TRealVector::IsZero() const
{bool lSuccess = false;
 if (Size() == 0L) return lSuccess;//Проверка на вектор нулевого размера
 lSuccess = true;
 //Цикл проверки свойства 2
 for (ulong i = 0; i < Size(); i++)
 {if (fabs(data[i]) > EPS) //Все элементы д.б. нулевыми
     {lSuccess = false; break;}
 }
return lSuccess;
}
//*****************************************************************************
//СТАТУС: III.3., protected, TRealVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsScalar() const
//НАЗНАЧЕНИЕ: Проверка вектора на СКАЛЯРНЫЙ ВЕКТОР. В случае удачи возвращается
//true и false - в противном случае. Свойства скалярного вектора:
//1. size != 0 - вектор должен быть не НУЛЕВОГО РАЗМЕРА;
//2. V[i] = a - ВСЕ элементы вектора должны быть равны между собой и отличны от
//   нуля.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - вектор скалярный;
//                false - вектор не скалярный.
//*****************************************************************************
bool TRealVector::IsScalar() const
{bool lSuccess = false;
 if (Size() == 0L) return lSuccess;//Проверка на вектор нулевого размера
 //Цикл проверки свойства 2
 if (fabs(data[0]) < EPS) return lSuccess;
 lSuccess = true;
 double a = data[0];
 for (ulong i = 1; i < Size(); i++)
 {if (fabs(data[i] - a) > EPS) //Все элементы д.б. равными a
  {lSuccess = false; break;}
 }
return lSuccess;
}
//*****************************************************************************
//СТАТУС: III.4., protected, TRealVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsUnit() const
//НАЗНАЧЕНИЕ: Проверка вектора на ЕДИНИЧНЫЙ ВЕКТОР. В случае удачи возвращается
//true и false - в противном случае. Свойства единичного вектора:
//1. size != 0 - вектор должен быть не НУЛЕВОГО РАЗМЕРА;
//2. V[i] = 1 - ВСЕ элементы вектора должны быть равны 1.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - вектор единичный; false - вектор не единичный.
//*****************************************************************************
bool TRealVector::IsUnit() const
{bool lSuccess = false;
 if (Size() == 0L) return lSuccess;//Проверка на вектор нулевого размера
 //Цикл проверки свойства 2
 lSuccess = true;
 for (ulong i = 0; i < Size(); i++)
 {if (fabs(data[i] - 1.0) > EPS) //Все элементы д.б. равны 1
  {lSuccess = false; break;}
 }
return lSuccess;
}

//----------------------------------------------------------------------------------------
// III. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ФУНКЦИЙ КЛАССА TRealVector
//      КОНСОЛЬНОГО ВВОДА ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//----------------------------------------------------------------------------------------
//****************************************************************************************
//СТАТУС: III.1., protected, TRealVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutVector(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Функция вводит значения элементов действительного вектора. Формат ввода элементов:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <vector name>;
//      TYPE: <vector type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>]: <real value>.
//Функция позволяет вводить действительные векторы TRealVector произвольных типов. При вводе
//элементов вектора проверяется корректность действительных чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование действительного вектора;
//2. bool confirm (true) - опция подтверждения введенных данных по каждому элементу вектора.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TRealVector::InPutVector(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемого вектора
 cout << endl;
 cout << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << "     " << Properties(s);
 cout << line << endl;
 //----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода всех элементов действительного вектора
 for (ulong i = 0; i < Size(); i++)
 {cout << name << "[" << (i+1) << "]: ";
  data[i] = EditDouble(confirm); //Ввод i-го элемента вектора
  ClrScr(x,y);//Очистка экрана
 }
 cout << "All elements of " << GetCompleteType(s) << " <" << name
      << "> are entered!" << endl;
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.2., protected, TRealVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutScalar(const string& name, bool confirm = true);
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ СКАЛЯРНОГО ВЕКТОРА
//Функция вводит значения элементов скалярного вектора. Формат ввода элементов вектора:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <vector name>;
//      TYPE: <vector type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//Diagonal elements value: <real value>.
//При вводе значений элементов вектора проверяется корректность действительных чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name  - наименование действительного вектора;
//2. bool confirm (true) - подтверждение ввода данных каждого элемента вектора.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TRealVector::InPutScalar(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 double value;
 //----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемого вектора
 cout << endl;
 cout << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << "     " << Properties(s);
 cout << line << endl;
 //----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Обнуление элементов вектора
 for (ulong i = 0L; i < Size(); i++) data[i] = 0.0;
 //Ввод одного элемента скалярного вектора
 cout << "Element value: ";
 value = EditDouble(confirm); //Ввод элемента вектора
 //Цикл присваивания элементам скалярного вектора значения value
 for (ulong i = 0L; i < Size(); i++) data[i] = value;

 ClrScr(x,y);//Очистка экрана
 cout << "All elements of " << GetCompleteType(s) << " <" << name
      << "> are entered!" << endl;
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}

//========================================================================================
//    РЕАЛИЗАЦИЯ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССУ TRealVector
//    REALIZATION of THE FRIEND FUNCTION TO TRealVector CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: FRIEND FUNCTION to TRealVector class # 1
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend uint MaxStrLen(const TRealVector& V, uint precision)
//НАЗНАЧЕНИЕ: Определение максимального символьного размер элемента вещественного вектора
//V. Используется для рационального отображения элементов вещественного вектора. При вычис-
//лении максимальной символьной длины приняты следующие соглашения:
//1. Точность представления действительного числа равна precision.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TRealVector& V - ссылка на вещественный вектор.
//2. uint precision - количество выводимых цифр чисел с плавающей точкой.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint MaxLen - максимальная символьная длина элемента вектора V
//****************************************************************************************
uint MaxStrLen(const TRealVector& V, uint precision)
{uint MaxLen = 0;
 //Проверка вектора на нулевой размер
 if (V.Size() == 0L) return MaxLen;
 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 uint count;
 //Цикл считывания элементов вещественного вектора
 for (ulong i = 0L; i < V.Size(); i++)
 {//Формирование символьного представления вещественного числа
  text << setprecision(precision) << V(i) << ends;
  //Определение максимальной символьной длины элемента вещественного вектора
  count = text.pcount()-1;
  if (count > MaxLen) MaxLen = count;
  text.seekp(0);
 }
return MaxLen;
}
//****************************************************************************************
//СТАТУС: FRIEND FUNCTION to TRealVector class # 2
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool StatAnalysis(const rvector& V, double& Expect, double& MeanSqDev)
//НАЗНАЧЕНИЕ: Статистический анализ: определение математического ожидания Expectation и
//среднеквадратичного отклонения MeanSquareDeviation по значениям вектора V. Для вектора
//нулевого размера функция возвращает false, величинам Expect и MeanSqDev присваивается 0.
//Формулы для вычисления оценок мат. ожидания и дисперсии следующие:
// E = SUM(Vi)/N, 0<=i<N, Vi - i-ый элемент вектора V, N - размер вектора V;
// Disp = [SUM(Vi^2)/N - E^2]*N/N-1, E - оценка мат. ожидания;
// MeanSqDev = Sqrt[Disp] - оценка среднеквадратичного отклонения.
//Вектор V содержит выборку данных, по которым производится статистический анализ.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на вещественный вектор со значениями выборки;
//2. double& Expect - ссылка на переменную-приемник оценки мат. ожидания выборки;
//3. double& MeanSqDev - ссылка на переменную-приемник оценки СКВО выборки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//****************************************************************************************
bool StatAnalysis(const rvector& V, double& Expect, double& MeanSqDev)
{Expect = MeanSqDev = 0.0;//Начальная инициализация
 ulong N = V.Size();//Размер вектора с обрабатываемыми данными
 if (N == 0) return false;//Вектор нулевого размера
 if (N == 1) {Expect = V.Get(0); return true;}
 //Статистический анализ
 double x;
 for (ulong i = 0L; i < N; i++)
 {x = V.Get(i)/N;
  Expect += x;//Вычисление оценки мат. ожидания
  MeanSqDev += x*V.Get(i);//Вычисление величины SUM(Vi^2)/N
 }
 //Вычисление дисперсии оценки и среднеквадратичного отклонения
 MeanSqDev = (MeanSqDev - Expect*Expect)/(N-1);
 MeanSqDev *= N;
 MeanSqDev = sqrt(fabs(MeanSqDev));
 return true;
}

//********************** Конец реализации класса TRealVector *****************************

//******************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TComplexVector
//******************************************************************************

//==============================================================================
//  РЕАЛИЗАЦИЯ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TComplexVector
//   TComplexVector CLASS CONSTRUCTORs & DESTRUCTOR REALIZATION
//==============================================================================
//******************************************************************************
//СТАТУС: 1; public TComplexVector constructor by default
//НАИМЕНОВАНИЕ ФУНКЦИИ: TComplexVector()
//НАЗНАЧЕНИЕ: Конструктор по умолчанию класса TComplexVector.
//Функция предназначена для создания класса TComplexVector по умолчанию. По
//умолчанию конструируется комплексный вектор нулевого размера - V_ZEROSIZE.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TComplexVector::TComplexVector() {Initial();}
//******************************************************************************
//СТАТУС: 2; public TComplexVector constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TComplexVector(ulong Size, bool Type, complex Init = C_ZERO)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TComplexVector.
//   Функция предназначена для создания класса TComplexVector согласно переданных
//параметров. Используется вызов функции Set(Size,Type,Init). Класс конструирует
//векторы двух типов - вектор-строку или вектор-столбец и инициализирует их эле-
//менты значением Init.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong Size - размерность вектора;
//2. bool Type  - тип вектора (COL || ROW);
//3. double Init (0.0) - инициализирующее значение для элементов вектора.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TComplexVector::TComplexVector(ulong Size, bool Type, complex Init)
{Initial();//Начальная инициализация членов-данных класса
 Set(Size,Type,Init);//Установка характеристик конструируемого вектора
}
//******************************************************************************
//СТАТУС: 3; public TComplexVector constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TComplexVector(ulong Size, bool Type, bool Init)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TComplexVector.
//   Функция предназначена для создания класса TComplexVector согласно переданных
//параметров. Используется вызов функции Set(Size,Type,Init). Класс конструирует
//векторы двух типов - вектор-строку или вектор-столбец. При Init == true элементы
//вектора инициализируются случайными величинами, при Init == false - инициализации
//элементов вектора не происходит, что ускоряет создание объекта класса.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong Size - размерность вектора;
//2. bool Type  - тип вектора (COL || ROW);
//3. bool Init  - опция инициализации элементов вектора случайными величинами
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TComplexVector::TComplexVector(ulong Size, bool Type, bool Init)
{Initial();//Начальная инициализация членов-данных класса
 Set(Size,Type,Init);//Установка характеристик конструируемого вектора
}
//******************************************************************************
//СТАТУС: 4; public TComplexVector class copy constructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: TComplexVector(const TComplexVector& V)
//НАЗНАЧЕНИЕ: Конструктор копирования класса TComplexVector.
//Функция предназначена для создания класса TComplexVector по характеристикам
//аналогичного класса и копирования значений его элементов. Осуществляется кор-
//ректное копирование членов-указателей на данные копируемого класса в создавае-
//мый класс с целью недопущения ссылок указателей разных объектов класса на одно
//и то же место памяти. Для процедуры копирования используется ПЕРЕГРУЖЕННЫЙ
//ОПЕРАТОР ПРИСВАИВАНИЯ.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TComplexVector& V - ссылка на объект TComplexVector
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TComplexVector::TComplexVector(const TComplexVector& V)
{Initial();//Начальная инициализация членов-данных класса
 //Установка характеристик вектора, вызовом перегруженного оператора =
 *this = V;
}
//******************************************************************************
//СТАТУС: 5; public TComplexVector class destructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: ~TComplexVector()
//НАЗНАЧЕНИЕ: ДЕСТРУКТОР класса TComplexVector
//Функция предназначена для удаления объекта класса TComplexVector после завер-
//шения работы с ним. В ходе работы деструктор освобождает оперативную память
//занятую элементами и характеристиками комплексного вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TComplexVector::~TComplexVector() { Delete(); }

//==============================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TComplexVector
//    PUBLIC MEMBER-FUNCTION OF TComplexVector CLASS REALIZATION
//==============================================================================
//******************************************************************************
//СТАТУС: I.1, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& GetType(string& s, bool brief = OFF, uint language = ENG) const
//НАЗНАЧЕНИЕ: Формирование наименования типа вектора на русском или английском
//языке, в сокращенном или полном формате. Допускается многоязычный интерфейс
//корректировкой кода функции. Язык по умолчанию - английский. Формирование типа
//вектора (строка или столбец) осуществляется в строке s, передаваемой по ссылке.
//Функция возвращает ссылку на строку с наименованием типа вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку для формирования имени типа вектора
//2. bool brief (OFF) - сокращенный или полный формат имени типа вектора
//3. uint language [ENG] - язык наименования типа вектора
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// string& s - ссылка на строку с сформированным именем типа вектора
//******************************************************************************
string& TComplexVector::GetType(string& s, bool brief, uint language) const
{if (language == RUS) //Формирование наименования типа вектора на русском языке
 {if (brief) s = (IsRow()) ? "строка" : "столбец";
  else s = (IsRow()) ? "Комплексный вектор-строка" : "Комплексный вектор-столбец";
 }
 else //Формирование наименования типа вектора на английском языке
 {if (brief) s = (IsRow()) ? "row" : "column";
  else s = (IsRow()) ? "Complex vector-row" : "Complex vector-column";
 }
return s;
}
//******************************************************************************
//СТАТУС: I.2, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: const char* GetSubType(uint language = ENG) const
//НАЗНАЧЕНИЕ: Получение  наименования подтипа вектора. Таблица соответствия под-
//типов вектора с ее наименованиями представлена массивом VectorName. В массиве
//хранятся наименования векторов на русском и английском языке. Индексом для по-
//лучения имени вектора служит ее подтип (subtype). Осуществляется обработка
//некорректного задания языка имени подтипа. Допускается многоязычный интерфейс
//корректировкой структуры MATRIX_NAME и массива VectorName. Язык по умолчанию -
//английский.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint language [ENG] - язык наименования подтипа вектора
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// const char *s - указатель на наименование вектора в таблице VectorName
//******************************************************************************
const char* TComplexVector::GetSubType(uint language) const
{char* s; //Указатель на строку
 uint index = SubType();
 switch (language)
 { case RUS: //указать наименование подтипа вектора на русском языке
    s = VectorName[index].rus_name; break;
   case ENG: //указать наименование подтипа вектора на английском языке
    s = VectorName[index].eng_name; break;
   //Наименование подтипа вектора на заданном языке отсутствует
   default: //указать наименование подтипа вектора на английском языке
    s = VectorName[index].eng_name; break;
 }
return s;
}
//******************************************************************************
//СТАТУС: I.3, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& GetCompleteType(string& s, uint language = ENG) const
//НАЗНАЧЕНИЕ: Формирование полного наименования типа вектора (type + subtype) на
//русском или английском. Допускается многоязычный интерфейс корректировкой кода
//функции. Язык  по  умолчанию - английский. Формирование  полного  типа вектора
//(строка или столбец)  осуществляется в строке s, передаваемой по ссылке. Функ-
//ция возвращает ссылку на строку с наименованием полного типа вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку для формирования имени полного типа вектора
//2. uint language [ENG] - язык наименования полного типа вектора
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// string& s - ссылка на строку с сформированным именем полного типа вектора
//******************************************************************************
string& TComplexVector::GetCompleteType(string& s, uint language) const
{GetSubType(s, language);//Формирование наименования подтипа вектора
 //Формирование типа вектора
 if (SubType() > V_NUMBER) {string t; GetType(t,ON,language); s.append("-"+t);}
 return s;
}
//******************************************************************************
//СТАТУС: I.4; public member-function of class TComplexVector
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Properties(string& s) const
//НАЗНАЧЕНИЕ: Функция формирует характеристики TComplexVector в виде строки.
//ПРИМЕР: TYPE: <complete vector type>; DIMENSION: <size>.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строковый объект
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами вектора
//******************************************************************************
string& TComplexVector::Properties(string& s) const
{char buffer[80];
 string t;
 ostrstream text(buffer, sizeof(buffer));
 s.resize(0);
 //1. Формирование наименования типа вектора
 s.append("TYPE: ");
 text << "Complex " << GetCompleteType(t) << ", " << ends;
 s.append(text.str()); text.seekp(0);
 //2. Формирование размерности вектора
 s.append("DIMENSION: ");
 text << Size() << ";" << endl << ends;
 s.append(text.str()); text.seekp(0);
return s;
}
//******************************************************************************
//СТАТУС: I.5, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: uint SubType() const
//НАЗНАЧЕНИЕ: Определение подтипа вектора (нулевой вектор, единичный вектор,
//скалярный вектор и т.д.) согласно их классификации.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint subtype - подтип вектора
//******************************************************************************
uint TComplexVector::SubType() const
{if (Size() == 0) return V_ZEROSIZE; //Вектор нулевого размера
 else if (Size() == 1) return V_NUMBER; //Вектор размера единица
 else if (IsZero()) return V_ZERO; //Проверка на нулевую вектор-строку
 else if (IsUnit()) return V_UNIT; //Проверка на единичную вектор-строку
 else if (IsScalar()) return V_SCALAR; //Проверка на скалярную вектор-строку
 return V_ORDINARY;
}
//******************************************************************************
//СТАТУС: I.6, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool Set(ulong VectorSize, bool VectorType, complex Init = C_ZERO)
//НАЗНАЧЕНИЕ: Функция устанавливает новые характеристики комплексного вектора.
//При установке новых характеристик вектора все старые характеристики аннулируются,
//значения элементов вектора уничтожаются, устанавливаются новые размеры вектора.
//Функция устанавливает  два типа вектора: вектор-строку или вектор-столбец и
//инициализирует элементы вектора значением Init.
//Функция возвращает false, в случае невозможности выделения памяти под новый
//размер вектора (в этом случае вектор становится нулевого размера).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong VectorSize - размерность комплексного вектора;
//2. bool VectorType  - тип вектора (COL || ROW);
//3. double Init (0.0) - инициализирующее значение.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexVector::Set(ulong VectorSize, bool VectorType, complex Init)
{//Анализ на соответствие размеров старого и нового вектора
 if (Size() != VectorSize)
 {Delete();//1. Удаление элементов вектора со старыми размерами
  size = VectorSize;//2. Установка новых размеров вектора
  //3. Распределение памяти под хранение элементов вектора с новыми свойствами
  if (Create() == false) return false;
 }
 type = VectorType;
 //Инициализация элементов вектора
 for (ulong i = 0L; i < Size(); i++) data[i] = Init;
 return true;
}
//******************************************************************************
//СТАТУС: I.7, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(ulong VectorSize, bool VectorType, bool Init)
//НАЗНАЧЕНИЕ: Функция устанавливает новые характеристики комплексного вектора.
//При установке новых характеристик вектора все старые характеристики аннулируются,
//значения элементов вектора уничтожаются, устанавливаются новые размеры вектора.
//Функция устанавливает  два типа вектора: вектор-строку или вектор-столбец.
//При Init == true элементы вектора инициализируются случайными значениями, а
//при Init == false - инициализации не происходит, что ускоряет создание вектора
//с новыми свойствами.
//Функция возвращает false, в случае невозможности выделения памяти под новый
//размер вектора (в этом случае вектор становится нулевого размера).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong VectorSize - размерность комплексного вектора;
//2. bool VectorType  - тип вектора (COL || ROW);
//3. bool Init  - опция инициализации элементов вектора.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexVector::Set(ulong VectorSize, bool VectorType, bool Init)
{//Анализ на соответствие размеров старого и нового вектора
 if (Size() != VectorSize)
 {Delete();//1. Удаление элементов вектора со старыми размерами
  size = VectorSize;//2. Установка новых размеров вектора
  //3. Распределение памяти под хранение элементов вектора с новыми свойствами
  if (Create() == false) return false;
 }
 type = VectorType;
 //Инициализация элементов вектора
 if (Init == true)
 {randomize();//Инициализация генератора случайных чисел
  for (ulong i = 0L; i < Size(); i++) data[i] = complex(rand(),rand());
 }
 return true;
}
//******************************************************************************
//СТАТУС: I.7, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Resize(const ulong NewSize, bool Restore = OFF)
//НАЗНАЧЕНИЕ: Функция изменяет размер вектора с возможностью восстановления зна-
//чений элементов вектора предыдущего размера.
//Функция возвращает false, в случае невозможности выделения памяти под новый
//размер вектора (в этом случае вектор становится нулевого размера).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ulong Size - новая размерность вектора
//2. bool Restore - опция восстановления значений элементов вектора предыдущего
//   размера
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexVector::Resize(const ulong NewSize, bool Restore)
{//Проверка на совпадение старого и нового размеров вектора
 if (NewSize == Size()) return true;
 cvector V;
 if (Restore == ON) V = *this;
 bool OldType = Type();
 Delete();//Удаление элементов вектора старого размера
 //Установка свойств вектора
 size = NewSize; type = OldType;
 //Распределение памяти под новый размер вектора
 if (Create() == false) return false;
 if (Restore == ON) //Восстановление предыдущих значений элементов вектора
 {ulong Count = (V.Size() > Size()) ? Size() : V.Size();
   for (ulong i = 0L; i < Count; i++) data[i] = V[i];
 }
 return true;
}
//*****************************************************************************
//СТАТУС: I.8, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Random(double a = 0.0, double b = 1.0)
//НАЗНАЧЕНИЕ: Инициализация элементов вектора случайными величинами, распреде-
//ленными по равновероятному закону в интервале [a..b]. Функция возвращает false
//для вектора нулевой длины. Функция инициализирует реальную и мнимую части эле-
//ментов комплексного вектора равомернораспределенными СВ от [a..b]
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double a (0) - нижняя граница интервала изменения равномерной СВ
//2. double b (1) - верхняя граница интервала изменения равномерной СВ
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//*****************************************************************************
bool TComplexVector::Random(double a, double b)
{//Вектор нулевого размера не инициализируется
 if (Size() == 0L) return false;
 TRandomGenerator RNG(T_4);//Создание генератора случайных чисел
 //Инициализация элементов вектора СВ
 for (ulong i = 0L; i < Size(); i++)
  data[i] = complex(RNG.Random(a, b),RNG.Random(a, b));
 return true;
}
//****************************************************************************************
//СТАТУС: I.9, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit(const string& name, bool confirm = true);
//НАЗНАЧЕНИЕ: КОНСОЛЬНОЕ РЕДАКТИРОВАНИЕ СВОЙСТВ и ЭЛЕМЕНТОВ ВЕКТОРА
//Функция вводит/редактирует ВСЕ значения элементов вектора и ее свойств в консольном режиме.
//В зависимости от типа комплексного вектора подключается функция ввода элементов для данного
//вектора. Предусмотрен режим ввода элементов вектора с подтверждением введенных данных по
//каждому элементу вектора. Строка name задает наименование вектора. При вводе каждого
//элемента вектора предусматривается контроль корректности вводимых данных. При работе
//функции значения элементов вектора изменяются безвозвратно. Формат ввода следующий:
//----------------------------------------------------------------------------------------
//MODE: EDIT COMPLEX VECTOR <name>
//TYPE: <vector type>; DIMENSION: <Size()>.
//----------------------------------------------------------------------------------------
//Select option:
//1. Change vector performance;
//2. Edit vector elements;
//3. Exit
//Enter number [1-3]: _
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование вектора;
//2. bool confirm - режим подтверждения введеных данных каждого элемента вещественного
//   вектора.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TComplexVector::Edit(const string& name, bool confirm)
{const string line(78,'-');
 STR_UINT Option[3] = {
  {1, "Change vector's properties" },
  {2, "Edit vector elements" },
  {3, "Exit" } };
 TB_STR_UINT TbOption = {3, Option};

 string head,t;
 uint nChoice;
 do //Начало цикла редактирования
 {//---------------------------------------------------------------------------
  //Вывод заголовка и свойств редактируемого вектора
  clrscr(); //Очистка экрана
  cout << line << endl;
  cout << "MODE: EDIT COMPLEX VECTOR - <" << name << ">" << endl;
  cout << "     " << Properties(head);
  cout << line << endl;
  //---------------------------------------------------------------------------
  head.assign(" Select option: ");
  nChoice = ConsoleChoice(TbOption, 3, head.c_str(), 2);
  //Анализируем выбор пользователя
  if (nChoice == 1) //Изменение характеристик редактируемого вектора
  {PF_VECTOR Info;
   InPutPF_VECTOR(Info, name.c_str());
   Set(Info.size,Info.type);
   if (Info.subtype == V_NUMBER || Info.subtype == V_ORDINARY) Random();
   if (Info.subtype == V_UNIT) *this = complex(1.0,0);
   if (Info.subtype == V_SCALAR) *this = complex(2.0,0);
   cout << "New complex vector's properties have just installed!" << endl;
   cout << "Vector is initialized according to its extended type." << endl;
   cout << "Press any key...\a"; getch();
  }
  else if (nChoice == 2) //Редактирование элементов
  {clrscr(); //Очистка экрана
   switch (SubType()) //Определение подтипа вектора
   {case V_ZEROSIZE: //Вектор нулевой длины (нулевого размера)
     cout << "\nMODE: INPUT ELEMENTS of <" << GetSubType(t) << ">" << endl;
     cout << "WARNING! Input elements of this vector are impossible." << endl;
     cout << "Press any key...\a"; getch();
     break;
    case V_ZERO: //Ввод элементов нулевого вектора
     break;
    case V_UNIT: //Ввод элементов единичного вектора
     break;
    case V_SCALAR: //Ввод элементов скалярного вектора
     InPutScalar(name,confirm);
     break;
    default: //Стандартный ввод элементов комплексного вектора
     InPutVector(name,confirm);
   }
  }
  else if (nChoice == 3) //Выход из режима редактирования
  {//Запрос на выход из режима редактирования
   char c;
   cout << "Would you like to leave from the edit mode? [y/n]: "; cin >> c;
   if ((c == 'y') || (c == 'Y')) {clrscr(); break;}
  }
 } while (true); //Завершение цикла редактирования
}
//*****************************************************************************
//СТАТУС: I.10, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:  cvector SubVector(ulong left, ulong right) const;
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДВЕКТОРА ИЗ ДАННОГО ВЕКТОРА
//Функция формирует подвектор, начиная с элемента с индексом left, и до элемента
//с индексом right включительно. Если исходный вектор является вектором нулевого
//размера, то функция возвращает также подвектор нулевого размера.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left - левая граница;
//2. ulong right - правая граница;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector SubVector - подвектор исходного вектора
//*****************************************************************************
cvector TComplexVector::SubVector(ulong left, ulong right) const
{cvector SubVector(0L,Type());
 if (Size() == 0) return SubVector;//Проверка на вектор нулевого размера
 //Анализируем исключительные ситуации
 if (left > right) return SubVector;
 if ((left >= Size()) || (right >= Size())) return SubVector;
 if ((left == 0L) && (right == Size()-1)) return *this;
 //Формирование подвектора
 SubVector.Resize(right - left + 1);
 for (ulong i = left; i <= right; i++) SubVector.Put(i-left, data[i]);
return SubVector;
}
//*****************************************************************************
//СТАТУС: I.11, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:  cvector Unique() const;
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДВЕКТОРА ИЗ ДАННОГО ВЕКТОРА, ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
//            КОТОРОГО НЕ ПОВТОРЯЮТСЯ (УНИКАЛЬНЫ)
//Функция формирует подвектор из элементов исходного вектора, включая в него
//только неповторяющиеся значения. Таким образом, результирующий вектор будет
//состоять из всех значений элементов исходного вектора в единственном представ-
//лении. Если исходный вектор является вектором нулевого размера, то функция
//возвращает также подвектор нулевого размера. Если в исходном векторе значения
//элементов не повторяются, то результирующий вектор совпадет с исходным.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector SubVector - подвектор с уникальными значениями
//*****************************************************************************
cvector TComplexVector::Unique() const
{cvector Unique(0L,Type());
 if (Size() == 0L) return Unique;//Вектор нулевого размера
 //****************************************************************************
 //1. Формирование списка с уникальными значениями элементов
 //****************************************************************************
 std::list<double> Real;
 std::list<double> Image;
 std::list<double>::iterator RealIter;
 std::list<double>::iterator ImageIter;
 complex z;
 //Просмотр всех значений элементов исходного вектора
 for (ulong i = 0L; i < Size(); i++)
 {//Проверка на уникальность значения элемента вектора
  bool find = false;
  z = data[i];
  RealIter = Real.begin(); ImageIter = Image.begin();
  while ((RealIter != Real.end()) && (find != true))
  {if ((*RealIter == real(z)) && (*ImageIter == imag(z))) find = true;
   else {RealIter++; ImageIter++;}
  }
  if (find == false) {Real.push_back(real(z)); Image.push_back(imag(z));}
 }
 //****************************************************************************
 //2. Переписываем значения из списка List в данный вектор
 //****************************************************************************
 //Устанавливаем размер исходного вектора равного размеру списка
 Unique.Resize(Real.size());
 //Цикл копирования значений элементов списка List в исходный вектор
 for (ulong i = 0L; i < Unique.Size(); i++)
 {z = complex(Real.front(), Image.front());
  Real.pop_front(); Image.pop_front();
  Unique.Put(i,z);
 }
return Unique;
}
//*****************************************************************************
//СТАТУС: I.12, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:  cvector SubVector(const ivector& Index) const;
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДВЕКТОРА ИЗ ДАННОГО ВЕКТОРА ПО ИНДЕКСАМ
//Функция формирует подвектор из элементов исходного вектора по индексам, значе-
//ния которых передаются через вектор индексов Index. Если исходный вектор или
//вектор индексов Index являются векторами нулевого размера, то функция возвра-
//щает также подвектор нулевого размера. Если Index содержит значения индексов,
//которые не соответствуют границам исходного вектора, то они игнорируются.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// const ivector& Index - ссылка на вектор со значениями индексов исходного век-
// тора по которым будет сформирован подвектор.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//cvector SubVector - подвектор исходного вектора элементы, которого расположены
//по индексам, указанным в векторе Index.
//*****************************************************************************
cvector TComplexVector::SubVector(const ivector& Index) const
{cvector SubVector(0L,Type());
 //Проверка исходного вектора и вектора со значениями индексов на нулевой размер
 if (IsZeroSize() || Index.IsZeroSize()) return SubVector;
 //****************************************************************************
 //1. Формирование списка с корректными значениями индексов, указанными в
 //   векторе Index
 //****************************************************************************
 std::list<long> List;
 ulong index;
 for (ulong i = 0L; i < Index.Size(); i++)
 {index = Index[i];
  //Проверка значения индекса на соответствие границам исходного вектора
  if ((index >= 0L) && (index < Size())) List.push_back(index);
 }
 if (List.size() == 0) return SubVector;
 //****************************************************************************
 //2. Переписываем значения из списка List в данный вектор
 //****************************************************************************
 //Устанавливаем размер исходного вектора равного размеру списка
 SubVector.Resize(List.size());
 //Цикл копирования значений элементов списка List в исходный вектор
 for (ulong i = 0L; i < SubVector.Size(); i++)
 {index = List.front(); SubVector.Put(i,data[index]); List.pop_front(); }
return SubVector;
}
//----------------------------------------------------------------------------
//Алгоритмы сортировки вектора
//----------------------------------------------------------------------------
//*****************************************************************************
//СТАТУС: I.13, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool BubbleSort(bool direct = ASCENDING, ulong *permutations = NULL,
//                 ulong *comparisons = NULL);
//НАЗНАЧЕНИЕ: МОДИФИЦИРОВАННАЯ ПУЗЫРЬКОВАЯ СОРТИРОВКА ПО ВОЗРАСТАНИЮ ИЛИ
//            ПО УБЫВАНИЮ ЭЛЕМЕНТОВ ВЕКТОРА
//Функция реализует алгоритм пузырьковой сортировки, в ходе которой за каждый
//цикл просмотра элементов вектора с первого элемента до граничного элемента
//Border в правой части вектора оказываются наибольшие или наименьшие элементы
//в зависимости от направления сортировки, задаваемого аргументом direct. При
//каждом последующем просмотре элементов вектора верхний предел просмотра умень-
//шается на единицу. Начальное значение Border = Size()-1. Если при очередном
//просмотре элементов вектора не произошло ни одной перестановки, то алгоритм
//завершает свою работу, так как данный факт является критерием того, что все
//элементы вектора упорядочены по возрастанию (ASCENDING) или по убыванию
//(DESCENDING). Алгоритм применяется к векторам с размерностью большей 1. При
//работе алгоритма положение элементов вектора могут изменяться. Они не изменяют-
//ся только для уже упорядоченного вектора. При работе алгоритма ведется подсчет
//числа перестановок и сравнений, которые можно передать через указатели внешней
//по отношению к BubbleSort функции. Функция возвращает false для вектора нулевого
//размера или размера единица.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. bool direct - направление сортировки (по возрастанию или по убыванию);
//2. ulong *permutations (NULL) - количество перестановок в ходе сортировки;
//3. ulong *comparisons (NULL) - количество сравнений в ходе сортировки
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - признак выполнения функции
//*****************************************************************************
bool TComplexVector::BubbleSort(bool direct, ulong *permutations, ulong *comparisons)
{if (Size() < 2) return false;//Проверка вектора на допустимого размера
 ulong Border = Size()-1;
 ulong p = 0L, c = 0L;
 complex temp;
 bool permut;
 bool end = false;
 //Тип сортировки
 if (direct == ASCENDING) //Сортировка по возрастанию
 {do
  {permut = false;
   for (ulong i = 0L; i < Border; i++)
   {c++;
    if (data[i] > data[i+1]) //Выполнить перестановку
    {temp = data[i+1]; data[i+1] = data[i]; data[i] = temp;
     permut = true; p++;
    }
   }
   if ((permut == false) || (--Border == 0)) end = true;
  } while (!end);
 }
 else //Сортировка по убыванию
 {do
  {permut = false;
   for (ulong i = 0L; i < Border; i++)
   {c++;
    if (data[i] < data[i+1]) //Выполнить перестановку
    {temp = data[i+1]; data[i+1] = data[i]; data[i] = temp;
     permut = true; p++;
    }
   }
   if ((permut == false) || (--Border == 0)) end = true;
  } while (!end);
 }
 if (permutations != NULL) *permutations = p;
 if (comparisons != NULL) *comparisons = c;
 return true;
}
//*****************************************************************************
//СТАТУС: I.14, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool Find(const complex& value, ulong* index = NULL, bool sort = UNSORTED,
//      ulong left = 0L, ulong right = MAX_SIZE, bool direct = FORWARD) const;
//НАЗНАЧЕНИЕ: ПОИСК СРЕДИ ЭЛЕМЕНТОВ ВЕКТОРА В ЗАДАННОМ ИНТЕРВАЛЕ ЭЛЕМЕНТА
//            ВЕКТОРА С ОПРЕДЕЛЕННЫМ ЗНАЧЕНИЕМ
//Функция осуществляет поиск в интервале индексов вектора от left до right эле-
//мента вектора со значением равным value. В случае успеха функция возвращает
//значение true, а в переменную передаваемую в функцию через указатель index за-
//носится индекс элемента вектора с заданным значением value. Если элемент со
//значением value не найден в интервале от left до right, то функция возвращает
//false, а в переменную, переданную через указатель index заносится значение
//MAX_SIZE ("за пределами"). Аргумент sort указывает на отсортированность элемен-
//тов вектора. Если элементы вектора отсортированы, то поиск значения, как прави-
//ло, занимает меньше времени, чем в несортированном векторе. Ответственность за
//установку аргумента sort ложится на пользователя, так как если вектор не являет-
//ся отсортированны, а опция sort равна SORTED, может привести к неправильным
//результатам работы функции. Если sort == UNSORTED и вектор является отсортиро-
//ванным, то результат работы функции будет всегда правильным, но при отсутствии
//элемента с заданным значением value приведет к увеличению времени работы функ-
//ции. При sort == SORTED, функция автоматически настраивается на алгоритм поиска
//в отсортированном по возрастанию или по убыванию элементов векторе, путем срав-
//нения первого и последнего его значений:
//1) V[0] > V[size()-1] - поиск в отсортированном по убыванию векторе;
//2) V[0] < V[size()-1] - поиск в отсортированном по возрастанию векторе;
//По умолчанию аргумент sort == UNSORTED, что всегда гарантирует правильность
//работы функции с возможным ее замедлением в случае вектора с отсортированными
//элементами.
//Интервал поиска задается двумя аргументами left - нижняя граница и right -
//верхняя граница. Верхняя и нижняя границы индексов вектора входят в интервал
//поиска элемента вектора с заданным значением. По умолчанию left = 0, а right =
//MAX_SIZE (максимально возможная размерность вектора - 2^32-1). Такие установки
//приводят к поиску элемента со значением value по всему вектору. Функция прове-
//ряет корректность нижней и верхней границы интервала - left <= right < Size(),
//в противном случае функция возвращает false. Если вектор является вектором ну-
//левого размера, то функция также возвращает false.
//Функция предусматривает два направление поиска первого элемента вектора равно-
//го значению value, задаваемого аргументом direct:
//1) Поиск в прямом направлении (FORWARD) от left до right;
//2) Поиск в обратном направлении (BACKWARD) от right до left.
//По умолчанию задается прямое направление поиска - direct = FORWARD.
//Работа функции не приводит к изменению внутренней структуры вектора, в котором
//осуществляется поиск элемента с заданным значением.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const complex& value - ссылка на значение элемента, по которому будет происхо-
//   дить поиск в векторе;
//2. ulong* index (NULL) - указатель на переменную, в которую будет заносится
//   индекс первого элемента вектора равного со значением value;
//3. bool sort (UNSORTED) - признак "отсортированности" элементов вектора;
//4. ulong left (0) - нижний индекс вектора, с которого будет происходить поиск;
//5. ulong right (MAX_SIZE ~ Size()-1) - верхний индекс вектора до которого будет
//   происходить поиск значения value, включая значение индекса right;
//6. bool direct (FORWARD) - направление поиска первого элемента вектора, совпа-
//   дающего со значением value.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак существования элемента со значением value в векторе.
//*****************************************************************************
bool TComplexVector::Find(const complex& value, ulong* index, bool sort, ulong left,
                      ulong right, bool direct) const
{bool lSuccess = false;
 if (Size() == 0L) //Вектор нулевого размера
 {if (index != NULL) *index = MAX_SIZE; return lSuccess;}
 right = (right == MAX_SIZE) ? Size()-1 : right;
 //Проверка на корректность заданного интервала поиска
 if ((left > right) || (right >= Size()))
 {if (index != NULL) *index = MAX_SIZE;
  return lSuccess;
 }
 ulong pos = MAX_SIZE;
 //Поиск в неотсортированном векторе
 if (sort == UNSORTED)
 {if (direct == FORWARD) //Поиск в прямом направлении
  {for (ulong i = left; i <= right; i++)
   {if (data[i] == value) {lSuccess = true; pos = i; break;}
   }
  }
  else //Поиск в обратном направлении
  {for (ulong i = right; i <= left; i--)
   {if (data[i] == value) {lSuccess = true; pos = i; break;}
   }
  }
 }
 //Поиск в отсортированном векторе
 else
 {//Определение направления сортировки элементов вектора
  if (data[0] > data[Size()-1]) //Сортировка по убыванию
  {if (direct == FORWARD) //Поиск в прямом направлении
   {for (ulong i = left; i <= right; i++)
    {if (data[i] == value) {lSuccess = true; pos = i; break;}
     if (data[i] < value) break;
    }
   }
   else //Поиск в обратном направлении
   {for (ulong i = right; i <= left; i--)
    {if (data[i] == value) {lSuccess = true; pos = i; break;}
     if (data[i] > value) break;
    }
   }
  }
  else if (data[0] < data[Size()-1]) //Сортировка по возрастанию
  {if (direct == FORWARD) //Поиск в прямом направлении
   {for (ulong i = left; i <= right; i++)
    {if (data[i] == value) {lSuccess = true; pos = i; break;}
     if (data[i] > value) break;
    }
   }
   else //Поиск в обратном направлении
   {for (ulong i = right; i <= left; i--)
    {if (data[i] == value) {lSuccess = true; pos = i; break;}
     if (data[i] < value) break;
    }
   }
  }
  else //data[0] == data[Size()-1] - однородный вектор
  {if (direct == FORWARD) //Поиск в прямом направлении
    if (data[left] == value) {lSuccess = true; pos = left;}
   else //Поиск в обратном направлении
    if (data[right] == value) {lSuccess = true; pos = right;}
  }
 }
 if (index != NULL) *index = pos;
return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.15, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong Reverse(ulong left = 0L, ulong right = MAX_SIZE);
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ЭЛЕМЕНТОВ ВЕКТОРА В ЗАДАННОМ ИНТЕРВАЛЕ В ОБРАТНОМ ПОРЯДКЕ
//Функция изменяет порядок следования элементов вектора в интервале от индекса со значением
//left до индекса со значением right (включая его) на обратный. Значения верхней и нижней
//границ интервала, в которой должна осуществляться перестановка должны удовлетворять сле-
//дующим условиям: left <= right && right < Size(), в противном случае функция не выполняется.
//По умолчанию, функция осуществляет перестановку всех элементов вектора. Работа функции
//приводит к изменению внутренней структуры вектора, так как осуществляется перестановка
//элементов вектора в заданном интервале.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left (0) - нижний индекс вектора, с которого будет происходить
//   перестановка элементов вектора в обратном порядке;
//2. ulong right (MAX_SIZE ~ Size()-1) - верхний индекс вектора до которого будет
//   происходить перестановка элементов вектора в обратном порядке, включая значение
//   индекса right.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong permut - количество перестановок
//****************************************************************************************
ulong TComplexVector::Reverse(ulong left, ulong right)
{ulong permut = 0L;//Количество перестановок
 right = (right == MAX_SIZE) ? Size()-1 : right;
 //Проверка на возможность или необходимость осуществления перестановки
 if ((Size() < 2) || (left >= right) || (right >= Size())) return permut;
 //Выполнение перестановки элементов вектора в обратном порядке
 complex temp;
 while (left < right)
 {temp = data[left]; data[left] = data[right]; data[right] = temp;
  permut++; //Подсчет количества перестановок
  left++; right--; //Переход к другим индексам переставляемых элементов
 }
return permut;//Количество перестановок
}
//****************************************************************************************
//СТАТУС: I.16, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong MoveElemToEnd(ulong index)
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ЭЛЕМЕНТА ВЕКТОРА В КОНЕЦ ВЕКТОРА
//Функция переставляет элемент вектора с номером индекс в конец вектора. Работа функции
//приводит к изменению внутренней структуры вектора. Возвращается количество перестановок
//необходимых для размещения элемента вектора с номером index в его конец.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//ulong idex - порядковый номер элемента вектора, который необходимо разместить в его конце
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong permut - количество перестановок
//****************************************************************************************
ulong TComplexVector::MoveElemToEnd(ulong index)
{ulong permut = 0L;//Количество перестановок
 ulong LastIndex = this->Size()-1;//Номер последнего элемента вектора
 complex z;
 while (index < LastIndex)
 {z = data[index]; data[index] = data[index+1]; data[index+1] = z;
  permut++; //Подсчет количества перестановок
  ++index;
 }
return permut;//Количество перестановок
}
//****************************************************************************************
//СТАТУС: I.17, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//cvector Assign(const cvector& V, ulong pos = 0L, ulong* counter = NULL) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ ЗНАЧЕНИЙ ЭЛЕМЕНТОВ ОДНОГО ВЕКТОРА ДРУГОМУ ВЕКТОРУ
//В качестве вектора-приемника используется исходный вектор, вектора-источника - вектор V,
//передаваемый по ссылке. Присваивание элементов исходным вектором начинается с индекса pos,
//по умолчанию pos == 0. Вектор-источник может иметь любую размерность. Функция присваивает
//значения элементов вектора V копии исходного вектора, начиная с первого элемента вектора
//V, вплоть до последнего элемента вектора V или последнего элемента исходного вектора, в
//зависимости от соотношения начального индекса pos исходного вектора, с которого начинается
//присваивание, размеров вектора-источника и вектора-приемника. Значения элементов исходного
//вектора и его структура не изменяются в результате работы данной функции, так как все
//необходимые операции присваивания осуществляются с копией вектора-источника, которая и
//является результатом работы функции. Функции передается необязательный указатель на пере-
//менную типа ulong - count. По умолчанию counter=NULL. В ходе работы функция подсчитывает
//кол-во элементов исходного вектора, которым присваивались значения элементов вектора V.
//Если указатель counter отличен от NULL, то по его адресу по окончании работы функции пе-
//редается количество элементов исходного вектора, принимавших участии в операции присваивания.
//Функция возвращает результирующий вектор нулевого размера в следующих исключительных
//ситуациях:
//1. Исходный вектор - вектор нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Начальный индекс pos в исходном векторе, начиная с которого осуществляется
//   присваивание, превышает верхнюю границу для данного исходного вектора.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на вектор-источник, значения элементов которого
//   будут присваиваться элементам исходного вектора;
//2. ulong pos - начальный индекс элемента исходного вектора, с которого начнется
//   присваивание значений элементов вектора-источника V;
//3. ulong* counter (NULL) - указатель на счетчик, в который будет записано ко-
//   личество элементов исходного вектора, которым присваивались значения эле-
//   ментов вектора-источника V.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//cvector result - результирующий вектор выполнения операции присваивания значе-
//                 ний элементов одного вектора другому вектору
//****************************************************************************************
cvector TComplexVector::Assign(const cvector& V, ulong pos, ulong* counter) const
{ulong count = 0L;
 cvector result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (pos >= Size()))
 { if (counter != NULL) *counter = count;
   return result;
 }
 result = *this;//Копирование исходного вектора
 //Выполнение операции присваивания значений одного вектора другому вектору
 ulong index;
 for (ulong i = 0L; i < V.Size(); i++)
 {index = i+pos;
  if (index < result.Size()) {result[index] = V[i]; count++;}
  else break; //Выход из цикла
 }
 if (counter != NULL) *counter = count;
return result;
}

//****************************************************************************************
//    РЕАЛИЗАЦИЯ ОПЕРАЦИЙ ЛИНЕЙНОЙ АЛГЕБРЫ над КОМПЛЕКСНЫМИ ВЕКТОРАМИ
//   Все операции линейной алгебры производятся с копией исходного вектора.
//****************************************************************************************

//*****************************************************************************
//СТАТУС: I.1, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector& Transpose(bool conjugate = true) const
//НАЗНАЧЕНИЕ: ТРАНСПОНИРОВАНИЕ КОМПЛЕКСНОГО ВЕКТОРА
//Функция осуществляет транспонирование вектора. Операция транспонирования произ-
//водится с копией исходного вектора, который возвращается по ссылке данной функ-
//цией. Операция транспонирования осуществляется только с векторами-столбцами и
//векторами-строками, которая меняет их на противоположные типы. При попытке
//транспонирования вектора нулевого размера функция возвращает вектор нулевого
//размера.
//При проведении операции транспонирования комплексного вектора часто бывает
//необходимо получить сопряженно-транспонированный вектор. С этой целью вводится
//в вызов функции Transpose передаваемый параметр conjugate, установленный по
//умолчанию в true, который определяет получение ТРАНСПОНИРОВАННОГО или СОПРЯЖЕН-
//НО-ТРАНСПОНИРОВАННОГО ВЕКТОРА данному. Сопряженно-транспонированный вектор дан-
//ному необходим для правильного осуществления операции скалярного умножения двух
//комплексных векторов.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// bool conjugate - определяет получение транспонированного или сопряженно-транс-
// понированного вектора данному.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// cvector& result - ссылка на транспонированный или сопряженно-транспонирован-
// ный вектор данному.
//*****************************************************************************
cvector TComplexVector::Transpose(bool conjugate) const
{cvector result(0,Type());
 if (Size() == 0L) return result;//Вектор нулевой длины
 result = *this;//Создание копии исходного вектора
 result.SetType(!Type());
 if (conjugate) //Получение сопряженно-транспонированного вектора
  for (ulong i = 0; i < result.Size(); i++) result.Put(i,conj(result.Get(i)));
return result;
}
//*****************************************************************************
//СТАТУС: I.2, TComplexVector class overloading operator !
//OVERLOADING UNARY OPERATOR < ! >
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector operator !()
//НАЗНАЧЕНИЕ: ТРАНСПОНИРОВАНИЕ КОМПЛЕКСНОГО ВЕКТОРА
//Функция осуществляет транспонирование вектора. Операция транспонирования произ-
//водится с исходным вектором. Операция транспонирования осуществляется только с
//векторами-столбцами и векторами-строками, которая меняет их на противоположные
//типы. При попытке транспонирования вектора нулевого размера функция возвращает
//вектор нулевой длины.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: (cvector) *this - транспонированный вектор данному.
//*****************************************************************************
cvector TComplexVector::operator !()
{if (Size() == 0L) return *this;//Вектор нулевого размера
 SetType(!Type());
 return *this;
}
//*****************************************************************************
//СТАТУС: I.3, TComplexVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector Conj() const
//НАЗНАЧЕНИЕ: СОПРЯЖЕНИЕ КОМПЛЕКСНОГО ВЕКТОРА
//Функция осуществляет операцию комплексного сопряжения вектора. Данная операция
//производится с копией исходного вектора, который возвращается по ссылке данной
//функцией.
//При попытке сопряжения вектора нулевого размера функция возвращает вектор
//нулевой длины.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector result - сопряженный вектор данному.
//*****************************************************************************
cvector TComplexVector::Conj() const
{if (Size() == 0L) return *this;//Вектор нулевой длины
 cvector result(*this);//Создание копии исходного вектора
 //Получение комплексно-сопряженного вектора данному
 for (ulong i = 0; i < result.Size(); i++) result.Put(i,conj(result.Get(i)));
 return result;
}
//*****************************************************************************
//СТАТУС: I.4, TComplexVector class overloading operator ~
//OVERLOADING UNARY OPERATOR < ~ >
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector operator ~();
//НАЗНАЧЕНИЕ: СОПРЯЖЕНИЕ КОМПЛЕКСНОГО ВЕКТОРА
//Функция осуществляет операцию комплексного сопряжения вектора данному. Опера-
//ция сопряжения производится с исходным вектором. При попытке сопряжения векто-
//ра нулевого размера возвращается вектор нулевого размера.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: (cvector) *this - сопряженный вектор данному.
//*****************************************************************************
cvector TComplexVector::operator ~()
{if (Size() == 0L) return *this;//Проверка на вектор нулевой длины
 //Получение комплексно-сопряженного вектора данному
 for (ulong i = 0; i < Size(); i++) data[i] = conj(data[i]);
 return *this;
}
//*****************************************************************************
//СТАТУС: I.5, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double FirstNorm() const
//НАЗНАЧЕНИЕ: ПЕРВАЯ (КУБИЧЕСКАЯ) НОРМА КОМПЛЕКСНОГО ВЕКТОРА
//Функция осуществляет определение первой (кубической) нормы комплексного век-
//тора. Для n-мерного вектора X = (x1,x2,...,xn) первая норма вычисляется по сле-
//дующей формуле:
// ||X|| = max|Xi| by i, максимальное абсолютное значение элемента вектора X.
// |Xi| = sqrt(Re(Xi)^2 + Im(Xi)^2).
//При попытке определения нормы вектора нулевого размера функция возвращает 0.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - первая норма вектора
//*****************************************************************************
double TComplexVector::FirstNorm() const
{double norm = 0.0;
 if (Size() == 0L) return norm;//Вектор нулевой длины
 //Поиск максимальной по абсолютной величины компоненты комплексного
 //вектора X = (x1,x2,...,xn)
 double value;
 for (ulong i = 0; i < Size(); i++)
 {value = abs(data[i]);
  if (norm < value) norm = value;
 }
return norm;
}
//*****************************************************************************
//СТАТУС: I.6, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double SecondNorm() const
//НАЗНАЧЕНИЕ: ВТОРАЯ (ОКТАЭДРИЧЕСКАЯ) НОРМА КОМПЛЕКСНОГО ВЕКТОРА
//Функция осуществляет определение второй (октаэдрической) нормы комплексного
//вектора. Для n-мерного вектора X = (x1,x2,...,xn) вторая норма вычисляется по
//следующей формуле:
// ||X|| = SUM|Xi| by i, сумма абсолютных значений элементов вектора X.
//При попытке определения нормы вектора функция возвращает 0.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - вторая норма вектора
//*****************************************************************************
double TComplexVector::SecondNorm() const
{double norm = 0.0;
 if (Size() == 0L) return norm;//Проверка на вектор нулевой длины
 //Суммирование абсолютных величин компонент комплексного вектора X
 for (ulong i = 0; i < Size(); i++) norm += abs(data[i]);
return norm;
}
//*****************************************************************************
//СТАТУС: I.7, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double ThirdNorm() const
//НАЗНАЧЕНИЕ: ТРЕТЬЯ (СФЕРИЧЕСКАЯ, ЕВКЛИДОВА) НОРМА КОМПЛЕКСНОГО ВЕКТОРА
//Функция осуществляет определение третьей нормы комплексного вектора, которая
//определяет длину вектора. Для n-мерного вектора X = (x1,x2,...,xn) евклидова
//норма вычисляется по следующей формуле:
// norm = sqrt(x1^2 + x2^2 + ... + xn^2).
//При попытке определения нормы вектора нулевого размера функция возвращает 0.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double value - евклидова норма (длина) вектора
//*****************************************************************************
double TComplexVector::ThirdNorm() const
{double value = 0.0;
 if (Size() == 0L) return value;//Вектор нулевой длины
 //Суммирование квадратов абсолютных величин (норм) компонент комплексного
 //вектора X = (x1,x2,...,xn)
 for (ulong i = 0; i < Size(); i++) value += norm(data[i]);
 value = sqrt(value);//Вычисление нормы комплексного вектора
return value;
}
//*****************************************************************************
//СТАТУС: I.8, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double PNorm(uint p = 2) const
//НАЗНАЧЕНИЕ: P-НОРМА (НОРМЫ ГЕЛЬДЕРА) КОМПЛЕКСНОГО ВЕКТОРА
//Функция осуществляет определение p-нормы комплексного вектора. Для n-мерного
//вектора X = (x1,x2,...,xn) p-норма вычисляется по следующей формуле:
// norm = {SUM|Vi|^p by i}^(1/p).
//При попытке определения нормы вектора нулевого размера функция возвращает 0.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//uint p - p-норма вектора, по умолчанию p = 2 - Евклидова норма.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - p-норма вектора
//*****************************************************************************
double TComplexVector::PNorm(uint p) const
{double norm = 0.0;
 if (Size() == 0L) return norm;//Вектор нулевой длины
 if (p == 0) norm = FirstNorm();//Первая норма
 //Вычисление p-нормы комплексного вектора
 else if (p == 1) norm = SecondNorm();//Вторая норма
 else if (p == 2) norm = ThirdNorm();//Третья норма
 else
 {for (ulong i = 0L; i < Size(); i++) norm += pow(abs(data[i]),p);
  norm = pow(norm,1/p);
 }
 return norm;
}
//*****************************************************************************
//СТАТУС: I.8, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double Norm(uint type, uint p = 2) const
//НАЗНАЧЕНИЕ: НОРМА КОМПЛЕКСНОГО ВЕКТОРА
//Функция осуществляет определение нормы комплексного вектора в зависимости от
//значения переменной type. Аргумент p необходим для определения p-нормы вектора.
//По умолчанию функция определяет длину вектора X или его ЕВКЛИДОВУ НОРМУ.
//При попытке определения нормы вектора нулевого размера генерируется ошибка вы-
//полнения данной операции.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//uint type - тип определяемой нормы комплексного вектора;
//uint p - параметр для p-норма вектора, по умолчанию p = 2 - Евклидова норма.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - норма вектора заданного типа
//*****************************************************************************
double TComplexVector::Norm(uint type, uint p) const
{double norm;
  switch (type)
  {case FIRST_NORM: //Определение первой (кубической) нормы
    norm = FirstNorm(); break;
   case SECOND_NORM: //Определение второй (октаэдрической) нормы
    norm = SecondNorm(); break;
   //Определение третьей (сферической, евклидовой) нормы или длины вектора
   case THIRD_NORM:
    norm = ThirdNorm(); break;
   case P_NORM: //Определение p-нормы или нормы Гельдера
    norm = PNorm(p); break;
   default: //Несуществующий тип нормы
    norm = 0.0;
  }
return norm;
}
//*****************************************************************************
//СТАТУС: I.9, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: сvector Normalization() const
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ КОМПЛЕКСНОГО ВЕКТОРА
//Функция осуществляет операцию нормирования комплексного вектора. С этой целью,
//во-первых, вычисляется третья норма вектора - norm. Для n-мерного вектора
//X = (x1,x2,...,xn) третья норма или длина вектора вычисляется по следующей
//формуле: norm = sqrt(norm(x1) + norm(x2) + ... + norm(xn)).
//Во-вторых, каждый компонент вектора X делится на найденную норму вектора X.
// X' = (x1/norm, x2/norm, ..., xn/norm), X' - нормированный вектор.
//Таким образом, ЕВКЛИДОВА НОРМА НОРМИРОВАННОГО ВЕКТОРА РАВНА 1.
//При попытке нормировки вектора нулевого размера возвращается вектор нулевого
//размера.
//Функция возвращает нормированный вектор, используя для проведения операции
//нормировки копию исходного вектора, т.о. исходный вектор не претерпевает изме-
//нений.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector result - нормированный вектор
//*****************************************************************************
cvector TComplexVector::Normalization() const
{cvector result(0L,Type());
 if (Size() == 0L) return result;//Вектор нулевой длины
 if (IsZero()) return result;//Нулевой вектор
 double value = ThirdNorm();//Вычисление нормы комплексного вектора
 if (value == 0.0) return result;
 result = *this;//Создание копии исходного вектора
 //Нормирование компонент комплексного вектора X = (x1,x2,...,xn)
 for (ulong i = 0; i < result.Size(); i++) result.Put(i,result.Get(i)/value);
return result;
}
//*****************************************************************************
//СТАТУС: I.10, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Normalization(uint NormType, uint p = 0)
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ КОМПЛЕКСНОГО ВЕКТОРА
//Функция осуществляет операцию нормирования комплексного вектора. С этой целью,
//во-первых, вычисляется норма вектора - norm, согласно типу определения нормы,
//задаваемой параметрами NormType и p (показатель степени для p-норм Гельдера).
//Во-вторых, каждый компонент вектора X делится на найденную норму вектора X.
// X' = (x1/norm, x2/norm, ..., xn/norm), X' - нормированный вектор.
//При попытке нормировки вектора нулевого размера функция возвращает false.
//Функция осуществляет нормирование исходного вектора, т.о. исходный вектор
//изменяется. Если тип нормы не определен либо норма равна 0, то исходный вектор
//не изменяется.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint NormType - тип нормировки комплексного вектора;
//2. uint p - параметр для p-норма вектора, по умолчанию p = 0 - первая норма.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//*****************************************************************************
bool TComplexVector::Normalization(uint NormType, uint p)
{if (Size() == 0L) return false;//Вектор нулевой длины
 double norm = Norm(NormType,p);//Вычисление нормы вектора
 if (norm == 0.0) return false;
 //Нормирование компонент комплексного вектора X = (x1,x2,...,xn)
 for (ulong i = 0L; i < Size(); i++) data[i] = data[i]/norm;
return true;
}
//*****************************************************************************
//СТАТУС: I.11, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool Normalization(cvector& Out, uint NormType = FIRST_NORM, uint p = 0) const
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ КОМПЛЕКСНОГО ВЕКТОРА
//Функция осуществляет операцию нормирования комплексного вектора. С этой целью,
//во-первых, вычисляется норма вектора - norm, согласно типу определения нормы,
//задаваемой параметрами NormType и p (показатель степени для p-норм Гельдера).
//Во-вторых, каждый компонент вектора X делится на найденную норму вектора X.
// X' = (x1/norm, x2/norm, ..., xn/norm), X' - нормированный вектор.
//При попытке нормировки вектора нулевого размера функция возвращает false.
//Функция не изменяет исходный вектор, нормировка производится с вектором Out.
//изменяется. Если тип нормы не определен либо норма равна 0, то вектор Out
//преобразуется в вектор нулевой длины.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& Out - ссылка на результирующий вектор
//2. uint NormType - тип нормировки комплексного вектора;
//3. uint p - параметр для p-норма вектора, по умолчанию p = 0 - первая норма.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//*****************************************************************************
bool TComplexVector::Normalization(cvector& Out, uint NormType, uint p) const
{Out.Resize(0L);
 if (Size() == 0L) return false;//Вектор нулевой длины
 double norm = Norm(NormType,p);//Вычисление нормы вектора
 if (norm == 0.0) return false;
 Out = *this;
 //Нормирование компонент комплексного вектора X = (x1,x2,...,xn)
 for (ulong i = 0L; i < Size(); i++) Out.Put(i,data[i]/norm);
return true;
}
//*****************************************************************************
//СТАТУС: I.12, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool NormalizeToDB(rvector& Out, double MindB = -60) const
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ КОМПЛЕКСНОГО ВЕКТОРА в ДЕЦИБЕЛАХ
//Функция осуществляет операцию нормирования комплексного вектора в децибелах.
//С этой целью, во-первых, вычисляется первая норма вектора. Во-вторых, каждый
//компонент вектора X делится на найденную норму вектора X.
// X' = (x1/norm, x2/norm, ..., xn/norm), X' - нормированный вектор.
//В-третьих, элементы вектора логарифмируются: Power = true: 10*log10(norm(Xi)).
//При попытке нормировки вектора нулевого размера функция возвращает false.
//Функция не изменяет исходный вектор, результаты нормировки заносятся в вектор
//Out, передаваемый по ссылке.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& Out - ссылка на результирующий вектор
//2. double MindB - минимальный пороговый уровень
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//*****************************************************************************
bool TComplexVector::NormalizeToDB(rvector& Out, double MindB) const
{Out.Resize(0L);
 if (Size() == 0L) return false;//Вектор нулевой длины
 //Поиск максимального значения
 double Max = 0.0;
 for (ulong i = 0L; i < Size(); i++)
 {if (Max < norm(data[i])) Max = norm(data[i]);}
 if (Max < EPS) return false;
 Out.Resize(Size());
 //Нормирование компонент вещественного вектора [0..1]
 for (ulong i = 0L; i < Size(); i++) Out.Put(i,norm(data[i])/Max);
 //Нормирование в dB с установкой нижнего порогового уровня [0..MindB]
 double value;
 MindB = (MindB >= 0.0) ? -60.0 : MindB;
 for (ulong i = 0L; i < Out.Size(); i++)
 {value = Out.Get(i);
  if (fabs(value) < EPS) Out.Put(i,MindB);//Нулевое значение
  else
  {value = 10*log10(value);
   if (value < MindB) value = MindB;
   Out.Put(i,value);
  }
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.13, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ScalarProduct(const cvector& A, complex& result) const
//НАЗНАЧЕНИЕ: СКАЛЯРНОЕ ПРОИЗВЕДЕНИЕ ДВУХ ВЕКТОРОВ (SCALAR PRODUCT)
//Функция предназначена для вычисления скалярного произведения двух векторов
//A=(a1,a2,...,an) и B=(b1,b2,...,bn).
//Скалярное произведение (A,B) векторов A и B пространства или плоскости - это
//произведение их модулей на косинус угла t между ними:
// (A,B) = |A||B|cos(t), если A != 0, B != 0, (|A|,|B| - нормы (длины) векторов)
// (A,B) = 0,            если A = 0, или (и) B = 0;
//Если в ортонормированном базисе векторы A и B имеют координаты (a1,a2,...,an)
//и (b1,b2,...,bn), то СКАЛЯРНОЕ ПРОИЗВЕДЕНИЕ вычисляется по формуле:
// (A,B) = conj(a1)*b1 + conj(a2)*b2 + ... + conj(an)*bn.
//Для осуществления операции скалярного произведения необходимы два условия:
//1. Векторы A и B должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ;
//2. Векторы A и B не должны быть ВЕКТОРАМИ НУЛЕВОЙ ДЛИНЫ.
//Если два вышеперечисленных условия не выполняется, то функция возвращает false
//Результатом скалярного произведения двух векторов всегда является ЧИСЛО.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& A - ссылка на комплексный вектор, с которым производится
//   операция скалярного умножения двух векторов.
//2. complex& result - значение скалярного произведения
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак осуществления операции
//*****************************************************************************
bool TComplexVector::ScalarProduct(const cvector& A, complex& result) const
{result = C_ZERO;
 //Вычисление скалярного произведения осуществляется с вектором (векторами)
 //нулевого размера (длины)
 if ((Size() == 0L) || (A.Size() == 0L)) return false;
 //Вычисление скалярного произведения осуществляется с векторами разной размерности
 if (Size() != A.Size()) return false;
 //Вычисление скалярного произведения двух комплексных векторов
 for (ulong i = 0; i < Size(); i++) result += conj(data[i]) * A.Get(i);
 return true;
}
//*****************************************************************************
//СТАТУС: I.14, friend function of the TComplexVector class
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool ScalarProduct(const cvector& A, const cvector& B, complex& result)
//НАЗНАЧЕНИЕ: СКАЛЯРНОЕ ПРОИЗВЕДЕНИЕ ДВУХ ВЕКТОРОВ (SCALAR PRODUCT)
//Функция предназначена для вычисления скалярного произведения двух векторов
//A=(a1,a2,...,an) и B=(b1,b2,...,bn).
//Скалярное произведение (A,B) векторов A и B пространства или плоскости - это
//произведение их модулей на косинус угла t между ними:
// (A,B) = |A||B|cos(t), если A != 0, B != 0, (|A|,|B| - нормы (длины) векторов)
// (A,B) = 0,            если A = 0, или (и) B = 0;
//Если в ортонормированном базисе векторы A и B имеют координаты (a1,a2,...,an)
//и (b1,b2,...,bn), то СКАЛЯРНОЕ ПРОИЗВЕДЕНИЕ вычисляется по формуле:
// (A,B) = conj(a1)*b1 + conj(a2)*b2 + ... + conj(an)*bn.
//Для осуществления операции скалярного произведения необходимы два условия:
//1. Векторы A и B должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ;
//2. Векторы A и B не должны быть ВЕКТОРАМИ НУЛЕВОЙ ДЛИНЫ.
//Если два вышеперечисленных условия не выполняется, то функция возвращает false.
//Результатом скалярного произведения двух векторов всегда является ЧИСЛО.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& A - ссылка на вещественный вектор, с которым производится
//   операция скалярного умножения двух векторов.
//2. const cvector& B - ссылка на вещественный вектор, с которым производится
//   операция скалярного умножения двух векторов.
//3. complex& result - значение скалярного произведения
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции
//*****************************************************************************
bool ScalarProduct(const cvector& A, const cvector& B, complex& result)
{result = C_ZERO;
 //Вычисление скалярного произведения осуществляется с вектором (векторами)
 //нулевого размера (длины)
 if ((A.Size() == 0L) || (B.Size() == 0L)) return false;
 //Вычисление скалярного произведения осуществляется с векторами разной размерности
 if (A.Size() != B.Size()) return false;
 //Вычисление скалярного произведения двух комплексных векторов
 for (ulong i = 0; i < A.Size(); i++) result += conj(A.Get(i)) * B.Get(i);
 return true;
}
//****************************************************************************************
//СТАТУС: I.14a, friend function of the TComplexVector class
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool ScalarProduct(const cvector& A, const cvector& B, double& norm_res)
//НАЗНАЧЕНИЕ: СКАЛЯРНОЕ ПРОИЗВЕДЕНИЕ ДВУХ ВЕКТОРОВ (SCALAR PRODUCT)
//Функция предназначена для вычисления скалярного произведения двух векторов
//A=(a1,a2,...,an) и B=(b1,b2,...,bn).
//Скалярное произведение (A,B) векторов A и B пространства или плоскости - это
//произведение их модулей на косинус угла t между ними:
// (A,B) = |A||B|cos(t), если A != 0, B != 0, (|A|,|B| - нормы (длины) векторов)
// (A,B) = 0,            если A = 0, или (и) B = 0;
//Если в ортонормированном базисе векторы A и B имеют координаты (a1,a2,...,an)
//и (b1,b2,...,bn), то СКАЛЯРНОЕ ПРОИЗВЕДЕНИЕ вычисляется по формуле:
// (A,B) = conj(a1)*b1 + conj(a2)*b2 + ... + conj(an)*bn.
//Для осуществления операции скалярного произведения необходимы два условия:
//1. Векторы A и B должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ;
//2. Векторы A и B не должны быть ВЕКТОРАМИ НУЛЕВОЙ ДЛИНЫ.
//Если два вышеперечисленных условия не выполняется, то функция возвращает false.
//Результатом скалярного произведения двух векторов всегда является норма вычисленного
//комплексного числа, значение которой передается в переменную norm_res.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& A - ссылка на вещественный вектор, с которым производится
//   операция скалярного умножения двух векторов.
//2. const cvector& B - ссылка на вещественный вектор, с которым производится
//   операция скалярного умножения двух векторов.
//3. double& norm_res - норма, вычисленного скалярного произведения комплексных векторов
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции
//****************************************************************************************
bool ScalarProduct(const cvector& A, const cvector& B, double& norm_res)
{complex result = C_ZERO;
 norm_res = 0;
 //Вычисление скалярного произведения осуществляется с вектором (векторами)
 //нулевого размера (длины)
 if ((A.Size() == 0L) || (B.Size() == 0L)) return false;
 //Вычисление скалярного произведения осуществляется с векторами разной размерности
 if (A.Size() != B.Size()) return false;
 //Вычисление скалярного произведения двух комплексных векторов
 for (ulong i = 0; i < A.Size(); i++) result += conj(A.Get(i)) * B.Get(i);
 norm_res = norm(result);
 return true;
}
//*****************************************************************************
//СТАТУС: I.15, friend function of the TComplexVector class
//OVERLOADING ADDITION OPERATION (+) by Increasing Vector on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cvector operator +(const double value, const cvector& V)
//НАЗНАЧЕНИЕ: УВЕЛИЧЕНИЕ КОМПОНЕНТ ВЕКТОРА НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию сложения комплексного вектора с действительным чис-
//лом. Число прибавляется слева. Действительное число прибавляется только к дейст-
//вительным частям компонент комплексного вектора.
//B(b1,...,bn) = const + A(a1,...,an), bi = ai + const
//Для осуществления операции сложения вектора с числом необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевого размера.
//Результатом сложения вектора с числом всегда является ВЕКТОР.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const double value - вещественное число, складываемое с вектором.
//2. const cvector& V - ссылка на комплексный вектор, к компонентам которого
//   добавляется вещественное число value.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector result - вектор V, увеличенный на значение value
//*****************************************************************************
cvector operator +(const double value, const cvector& V)
{if (V.Size() == 0L) return V;//Сложение с вектором нулевого размера
 cvector result(V);//Копирование свойств вектора
 //Цикл увеличения компонент вектора V на величину value
 for (ulong i = 0L; i < V.Size(); i++) result.Put(i,result.Get(i)+value);
 return result;
}
//*****************************************************************************
//СТАТУС: I.16, friend function of the TComplexVector class
//OVERLOADING ADDITION OPERATION (+) by Increasing Vector on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cvector operator +(const cvector& V, const double value)
//НАЗНАЧЕНИЕ: УВЕЛИЧЕНИЕ КОМПОНЕНТ ВЕКТОРА НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию сложения вектора с действительным числом. Число
//прибавляется справа.
//B(b1,...,bn) = A(a1,...,an) + const, bi = ai + const
//Для осуществления операции сложения вектора с числом необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевого размера.
//Результатом сложения вектора с числом всегда является ВЕКТОР.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, к компонентам которого
//   добавляется вещественное число value.
//2. const double value - вещественное число, складываемое с вектором.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector result - вектор V, увеличенный на значение value
//*****************************************************************************
cvector operator +(const cvector& V, const double value)
{if (V.Size() == 0L) return V;//Сложение с вектором нулевой длины
 cvector result(V); //Копирование свойств вектора
 //Цикл увеличения компонент вектора V на величину value
 for (ulong i = 0L; i < V.Size(); i++) result.Put(i,result.Get(i)+value);
 return result;
}
//*****************************************************************************
//СТАТУС: I.17, friend function of the TComplexVector class
//OVERLOADING ADDITION OPERATION (+) by Increasing Vector on the Complex Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cvector operator +(const complex value, const cvector& V)
//НАЗНАЧЕНИЕ: УВЕЛИЧЕНИЕ КОМПОНЕНТ ВЕКТОРА НА КОМПЛЕКСНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию сложения комплексного вектора с комплексным числом.
//Число прибавляется слева. Комплексное число прибавляется ко всем элементам
//комплексного вектора.
//B(b1,...,bn) = const + A(a1,...,an), bi = ai + const
//Для осуществления операции сложения вектора с числом необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевого размера.
//Результатом сложения вектора с числом всегда является ВЕКТОР.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const complex value - комплексное число, складываемое с вектором.
//2. const cvector& V - ссылка на комплексный вектор, к компонентам которого
//   добавляется комплексное число value.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector result - вектор V, увеличенный на значение value
//*****************************************************************************
cvector operator +(const complex value, const cvector& V)
{if (V.Size() == 0L) return V;//Сложение с вектором нулевого размера
 cvector result(V);//Копирование свойств вектора
 //Цикл увеличения компонент вектора V на величину value
 for (ulong i = 0L; i < V.Size(); i++) result.Put(i,result.Get(i)+value);
 return result;
}
//*****************************************************************************
//СТАТУС: I.18, friend function of the TComplexVector class
//OVERLOADING ADDITION OPERATION (+) by Increasing Vector on the Complex Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cvector operator +(const cvector& V, const complex value)
//НАЗНАЧЕНИЕ: УВЕЛИЧЕНИЕ КОМПОНЕНТ ВЕКТОРА НА КОМПЛЕКСНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию сложения вектора с комплексным числом. Число приба-
//вляется справа.
//B(b1,...,bn) = A(a1,...,an) + const, bi = ai + const
//Для осуществления операции сложения вектора с числом необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевого размера.
//Результатом сложения вектора с числом всегда является ВЕКТОР.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, к компонентам которого
//   добавляется комплексное число value.
//2. const complex value - комплексное число, складываемое с вектором.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:cvector result - вектор V, увеличенный на значение value
//*****************************************************************************
cvector operator +(const cvector& V, const complex value)
{if (V.Size() == 0L) return V;//Сложение с вектором нулевого размера
 cvector result(V);//Копирование свойств вектора
 //Цикл увеличения компонент вектора V на величину value
 for (ulong i = 0L; i < V.Size(); i++) result.Put(i,result.Get(i)+value);
 return result;
}
//*****************************************************************************
//СТАТУС: I.19, friend function of the TComplexVector class
//OVERLOADING DECREASE OPERATION (-) by Decreasing Vector on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cvector operator -(const cvector& V, const double value)
//НАЗНАЧЕНИЕ: УМЕНЬШЕНИЕ КОМПОНЕНТ ВЕКТОРА НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию вычитания из компонент вектора действительного числа
//value. Действительное число value должно располагаться ТОЛЬКО СПРАВА от
//вектора V.
// B(b1, ..., bn) = A(a1, ..., an) - const, bi = ai - const
//Для осуществления операции вычитания из вектора числа необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевого размера.
//Результатом сложения вектора с числом всегда является ВЕКТОР.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, компоненты которого
//   уменьшаются на вещественное число value.
//2. const double value - вещественное число, вычитаемое из вектора.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:cvector result - вектор V, уменьшенный на значение value
//*****************************************************************************
cvector operator -(const cvector& V, const double value)
{if (V.Size() == 0L) return V;//Сложение с вектором нулевого размера
 cvector result(V);//Копирование свойств вектора
 //Цикл уменьшения компонент вектора V на величину value
 for (ulong i = 0L; i < V.Size(); i++) result.Put(i,result.Get(i)-value);
 return result;
}
//*****************************************************************************
//СТАТУС: I.20, friend function of the TComplexVector class
//OVERLOADING DECREASE OPERATION (-) by Decreasing Vector on the Complex Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cvector operator -(const cvector& V, const complex value)
//НАЗНАЧЕНИЕ: УМЕНЬШЕНИЕ КОМПОНЕНТ ВЕКТОРА НА КОМПЛЕКСНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию вычитания из компонент вектора комплексного числа
//value. Комплексное число value должно располагаться ТОЛЬКО СПРАВА от вектора V.
// B(b1, ..., bn) = A(a1, ..., an) - const, bi = ai - const
//Для осуществления операции вычитания из вектора числа необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевого размера.
//Результатом сложения вектора с числом всегда является ВЕКТОР.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, компоненты которого
//   уменьшаются на комплексное число value.
//2. const double value - комплексное число, вычитаемое из вектора.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:cvector result - вектор V, уменьшенный на значение value
//*****************************************************************************
cvector operator -(const cvector& V, const complex value)
{if (V.Size() == 0L) return V;//Сложение с вектором нулевого размера
 cvector result(V);//Копирование свойств вектора
 //Цикл уменьшения компонент вектора V на величину value
 for (ulong i = 0L; i < V.Size(); i++) result.Put(i,result.Get(i)-value);
 return result;
}
//*****************************************************************************
//СТАТУС: I.21, friend function of the TComplexVector class
//OVERLOADING MULTIPLICATION OPERATION (*) by Multiply Vector on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cvector operator *(const double value, const cvector& V)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ КОМПОНЕНТ ВЕКТОРА НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию умножения вектора на действительное число. Число
//умножается слева.
//B(b1,...,bn) = const * A(a1,...,an), bi = ai * const
//Для осуществления операции умножения вектора на число необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевого размера.
//Результатом умножения вектора на число всегда является ВЕКТОР.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const double value - вещественное число, умножаемое на вектор.
//2. const cvector& V - ссылка на комплексный вектор, компоненты которого
//   умножаются на вещественное число value.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:cvector result - вектор V, умноженный на значение value
//*****************************************************************************
cvector operator *(const double value, const cvector& V)
{if (V.Size() == 0L) return V;//Умножение с вектором нулевого размера
 cvector result(V);//Копирование свойств вектора
 //Цикл умножения компонент вектора V на величину value
 for (ulong i = 0L; i < V.Size(); i++) result.Put(i,result.Get(i)*value);
 return result;
}
//*****************************************************************************
//СТАТУС: I.22, friend function of the TComplexVector class
//OVERLOADING MULTIPLICATION OPERATION (*) by Multiply Vector on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cvector operator *(const cvector& V, const double value)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ КОМПОНЕНТ ВЕКТОРА НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию умножения вектора на действительное число. Число
//умножается справа.
//B(b1,...,bn) = A(a1,...,an) * const, bi = ai * const
//Для осуществления операции умножения вектора на число необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевого размера.
//Результатом умножения вектора на число всегда является ВЕКТОР.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, компоненты которого
//   умножаются на вещественное число value.
//2. const double value - вещественное число, умножаемое на вектор.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:cvector result - вектор V, умноженный на значение value
//*****************************************************************************
cvector operator *(const cvector& V, const double value)
{if (V.Size() == 0L) return V;//Умножение с вектором нулевого размера
 cvector result(V);//Копирование свойств вектора
 //Цикл умножения компонент вектора V на величину value
 for (ulong i = 0L; i < V.Size(); i++) result.Put(i,result.Get(i)*value);
 return result;
}
//*****************************************************************************
//СТАТУС: I.23, friend function of the TComplexVector class
//OVERLOADING MULTIPLICATION OPERATION (*) by Multiply Vector on the Complex Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cvector operator *(const complex value, const cvector& V)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ КОМПОНЕНТ ВЕКТОРА НА КОМПЛЕКСНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию умножения вектора на комплексное число. Число
//умножается слева.
//B(b1,...,bn) = Z(a+ib)* A(a1,...,an), bi = Z * ai
//Для осуществления операции умножения вектора на число необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевого размера.
//Результатом умножения вектора на число всегда является ВЕКТОР.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const complex value - комплексное число, умножаемое на вектор.
//2. const cvector& V - ссылка на комплексный вектор, компоненты которого
//   умножаются на комплексное число value.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:cvector result - вектор V, умноженный на значение value
//*****************************************************************************
cvector operator *(const complex value, const cvector& V)
{if (V.Size() == 0L) return V;//Умножение с вектором нулевого размера
 cvector result(V);//Копирование свойств вектора
 //Цикл умножения компонент вектора V на величину value
 for (ulong i = 0L; i < V.Size(); i++) result.Put(i,result.Get(i)*value);
 return result;
}
//*****************************************************************************
//СТАТУС: I.24, friend function of the TComplexVector class
//OVERLOADING MULTIPLICATION OPERATION (*) by Multiply Vector on the Complex Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cvector operator *(const cvector& V, const complex value)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ КОМПОНЕНТ ВЕКТОРА НА КОМПЛЕКСНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию умножения вектора на комплексное число. Число
//умножается справа.
//B(b1,...,bn) = A(a1,...,an) * Z(a+ib), bi = ai * Z
//Для осуществления операции умножения вектора на число необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевой длины.
//Результатом умножения вектора на число всегда является ВЕКТОР.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, компоненты которого
//   умножаются на комплексное число value.
//2. const double value - комплексное число, умножаемое на вектор.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:cvector result - вектор V, умноженный на значение value
//*****************************************************************************
cvector operator *(const cvector& V, const complex value)
{if (V.Size() == 0L) return V;//Умножение с вектором нулевого размера
 cvector result(V);//Копирование свойств вектора
 //Цикл умножения компонент вектора V на величину value
 for (ulong i = 0L; i < V.Size(); i++) result.Put(i,result.Get(i)*value);
 return result;
}
//*****************************************************************************
//СТАТУС: I.25, public function of the TComplexVector class
//OVERLOADING DIVISION OPERATION (/) by Dividing Vector on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector operator /(const double value) const
//НАЗНАЧЕНИЕ: ДЕЛЕНИЕ КОМПОНЕНТ ВЕКТОРА НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию деления вектора на действительное число. Операция
//деления некоммутативна и делитель - число value - должно быть расположено сле-
//ва от вещественного вектора.
//B(b1,...,bn) = A(a1,...,an) / const, bi = ai / const
//Для осуществления операции деления вектора на число необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевого размера.
//Результатом умножения вектора на число всегда является ВЕКТОР.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const double value - вещественное число, делимое на вектор.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector result - вектор V, разделенный на значение value
//*****************************************************************************
cvector TComplexVector::operator /(const double value) const
{cvector result;
 if (Size() == 0L) return result;//Деление с вектором нулевого размера
 if (value == 0) return result;//Попытка деления на ноль
 result = *this;//Копирование свойств вектора
 //Цикл деления компонент вектора V на величину value
 for (ulong i = 0L; i < result.Size(); i++) result.Put(i,result.Get(i)/value);
 return result;
}
//*****************************************************************************
//СТАТУС: I.26, public function of the TComplexVector class
//OVERLOADING DIVISION OPERATION (/) by Dividing Vector on the Complex Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector operator /(const complex value) const
//НАЗНАЧЕНИЕ: ДЕЛЕНИЕ КОМПОНЕНТ ВЕКТОРА НА КОМПЛЕКСНУЮ ВЕЛИЧИНУ value.
//Функция реализует операцию деления вектора на комплексное число. Операция
//деления некоммутативна и делитель - число value - должно быть расположено сле-
//ва от вещественного вектора.
//B(b1,...,bn) = A(a1,...,an) / Z(a+ib), bi = ai / Z
//Для осуществления операции деления вектора на число необходимо одно условие:
//1. Вектор A не должен быть ВЕКТОРОМ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается вектор нулевого размера.
//Результатом умножения вектора на число всегда является ВЕКТОР.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const complex value - комплексное число, делимое на вектор.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector result - вектор V, разделенный на значение value
//*****************************************************************************
cvector TComplexVector::operator /(const complex value) const
{cvector result;
 if (IsZeroSize()) return result;//Деление с вектором нулевого размера
 //Попытка деления на ноль
 if ((complex) value == (complex) C_ZERO) return result;
 result = *this;//Копирование свойств вектора
 //Цикл деления компонент вектора V на величину value
 for (ulong i = 0L; i < result.Size(); i++) result.Put(i,result.Get(i)/value);
 return result;
}
//*****************************************************************************
//СТАТУС: I.27; public; TComplexVector class overloading operator +
//OVERLOADING ADDITION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector operator +(const TComplexVector& V) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СЛОЖЕНИЯ ДВУХ ВЕКТОРОВ.
//Функция реализует перегрузку оператора (+) с целью сложения двух комплексных
//векторов X(x1,...,xn) и Y(y1,...,yn):
//Z(z1,z2,...,zN) = X(x1,x2,...,xN) + Y(y1,y2,...,yN), zi = xi + yi.
//Складывать можно только векторы ОДНОГО ТИПА и ОДНОЙ РАЗМЕРНОСТИ. Если векторы
//разных типов (вектор-строка и вектор-столбец), разной размерности или один из
//векторов - вектор нулевой размерности, то возвращается вектор нулевого размера.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:const TComplexVector& V - ссылка на складываемый вектор
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector result - вектор суммы двух векторов
//*****************************************************************************
cvector TComplexVector::operator +(const TComplexVector& V) const
{cvector result(0L,Type());
 //Операция сложения производится с вектором (векторами) нулевого размера
 if ((Size() == 0L) || (V.Size() == 0L)) return result;
 //Операция сложения производится с векторами разной размерности
 if (Size() != V.Size()) return result;
 //Операция сложения производится с векторами разных типов
 if (Type() != V.Type()) return result;
 result.Resize(Size());//Установка размера результирующего вектора
 //Операция сложения двух векторов
 for (ulong i = 0; i < Size(); i++) result.Put(i,data[i]+V.Get(i));
 return result; //Вектор суммы двух векторов
}
//*****************************************************************************
//СТАТУС: I.28; public; TComplexVector class overloading operator -
//OVERLOADING SUBTRACTION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector operator -(const TComplexVector& V) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЧИТАНИЯ ДВУХ ВЕКТОРОВ.
//Функция реализует перегрузку оператора (-) с целью вычитания двух комплексных
//векторов X(x1,...,xn) и Y(y1,...,yn):
//Z(z1,z2,...,zN) = X(x1,x2,...,xN) - Y(y1,y2,...,yN), zi = xi - yi.
//Вычитать можно только векторы ОДНОГО ТИПА и ОДНОЙ РАЗМЕРНОСТИ. Если векторы
//разных типов (вектор-строка и вектор-столбец), разной размерности или один из
//векторов - вектор нулевой размерности, то возвращается вектор нулевого размера.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TComplexVector& V - ссылка на вычитаемый вектор
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector result - вектор разности двух векторов
//*****************************************************************************
cvector TComplexVector::operator -(const TComplexVector& V) const
{cvector result(0L,Type());
 //Операция вычитания производится с вектором (векторами) нулевого размера
 if ((Size() == 0L) || (V.Size() == 0L)) return result;
 //Операция вычитания производится с векторами разной размерности
 if (Size() != V.Size()) return result;
 //Операция вычитания производится с векторами разных типов
 if (Type() != V.Type()) return result;
 result.Resize(Size());//Копирование свойств исходного вектора
 //Операция вычитания двух векторов
 for (ulong i = 0; i < Size(); i++) result.Put(i,data[i]-V.Get(i));
 return result; //Вектор разности двух векторов
}
//*****************************************************************************
//СТАТУС: I.29; public; TComplexVector class overloading operator *
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix operator *(const TComplexVector& V) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ ДВУХ ВЕКТОРОВ.
//Функция реализует перегрузку оператора (*) с целью умножения двух комплексных
//векторов X(x1,...,xn) и Y(y1,...,yn). Умножение двух векторов определяется
//только для такой пары двух векторов, у которого число столбцов первого сомно-
//жителя равно числу строк второго сомножителя. Таким образом, правила умножения
//вектора на вектор следующие:
//1. Векторы должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ;
//2. Умножаются ВЕКТОР-СТОЛБЕЦ на ВЕКТОР-СТРОКУ либо
//              ВЕКТОР-СТРОКА на ВЕКТОР-СТОЛБЕЦ.
//3. Размерности векторов не должны быть нулевыми.
//Если данные условия не выполняются, то возвращается матрица нулевого размера.
//При умножении двух векторов одинаковой размерности и противоположных типов в
//общем случае получается МАТРИЦА. При умножении вектора-столбца A размерностью
//(n x 1) на вектор-строку B размерностью (1 x n) получается КВАДРАТНАЯ МАТРИЦА
//C размерностью (n x n). Каждый элемент такой матрицы вычисляется по формуле:
// c(i,j) = a(i) * b(j).
//При умножении вектора-строки A размерностью (1 x n) на вектор-столбец B размер-
//ностью (n x 1) получается КВАДРАТНАЯ МАТРИЦА C размерностью (1 x 1). Данная
//операция эквивалентна операции скалярного умножения двух векторов, результатом
//которой является получение ОДНОГО ЧИСЛА. Элемент такой матрицы вычисляется по
//следующей формуле:
// c(1,1) = a1*b1 + a2*b2 + ... + an*bn.
//ЗАМЕЧАНИЕ. При перегрузке оператора умножения(*) двух векторов, в случае умно-
//жения вектора-строки на вектор-столбец данная операция НЕ ЭКВИВАЛЕНТНА опера-
//ции скалярного умножения комплексных векторов, так как умножение элементов век-
//тора-строки на элементы вектора-столбца выполняется без операции комплексного
//сопряжения элементов вектора-строки. Чтобы данные операции были эквивалентны
//друг другу необходимо осуществить операцию комплексного сопряжения над элемен-
//тами вектора-строки.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TComplexVector& V - ссылка на умножаемый вектор
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - комплексная матрица умножения двух векторов.
//*****************************************************************************
cmatrix TComplexVector::operator *(const TComplexVector& V) const
{cmatrix result;
 //Операция умножения с вектором (векторами) нулевого размера
 if ((Size() == 0L) || (V.Size() == 0L)) return result;
 //Операция умножения с векторами разной размерности
 if (Size() != V.Size()) return result;
 //Операция умножения с векторами одинаковых типов
 if (Type() == V.Type()) return result;

 if (IsColumn() == true)//Умножение вектора-столбца на вектор-строку
 {result.Set(Size(),Size(),false);//Установка размера результирующей матрицы
  for (ulong i = 0; i < Size(); i++)
   for (ulong j = 0; j < Size(); j++)
    result.Put(i,j,data[i]*V.Get(j));
  }
 else if (IsRow() == true) //Умножение вектора-строки на вектор-столбец
 {result.Set(1,1,false);//Установка размера результирующей матрицы
  complex value = C_ZERO;
  for (ulong i = 0; i < Size(); i++) value += data[i] * V.Get(i);
  result.Put(0,0,value);
 }
 return result; //Матрица умножения двух комплексных векторов
}
//*****************************************************************************
//СТАТУС: I.30; friend function of the TComplexVector class overloading
//              operator *
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//   friend cmatrix operator *(const cvector& Z, const rvector& X)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ КОМПЛЕКСНОГО ВЕКТОРА НА ВЕЩЕСТВЕН-
//            НЫЙ ВЕКТОР СЛЕВА.
//Функция реализует перегрузку оператора (*) с целью умножения комплексного век-
//тора на действительный вектор Z(z1,...,zn) и X(x1,...,xn). Умножение двух век-
//торов определяется только для такой пары двух векторов, у которого число столб-
//цов первого сомножителя равно числу строк второго сомножителя. Таким образом,
//правила умножения
//вектора на вектор следующие:
//1. Векторы должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ;
//2. Умножаются ВЕКТОР-СТОЛБЕЦ на ВЕКТОР-СТРОКУ либо
//              ВЕКТОР-СТРОКА на ВЕКТОР-СТОЛБЕЦ.
//3. Размерности векторов не должны быть нулевыми.
//Если данные условия не выполняются, то возвращается матрица нулевого размера.
//При умножении двух векторов одинаковой размерности и противоположных типов в
//общем случае получается МАТРИЦА. При умножении вектора-столбца A размерностью
//(n x 1) на вектор-строку B размерностью (1 x n) получается КВАДРАТНАЯ МАТРИЦА
//C размерностью (n x n). Каждый элемент такой матрицы вычисляется по формуле:
// c(i,j) = a(i) * b(j).
//При умножении вектора-строки A размерностью (1 x n) на вектор-столбец B размер-
//ностью (n x 1) получается КВАДРАТНАЯ МАТРИЦА C размерностью (1 x 1). Данная
//операция эквивалентна операции скалярного умножения двух векторов, результатом
//которой является получение ОДНОГО ЧИСЛА. Элемент такой матрицы вычисляется по
//следующей формуле:
// c(1,1) = a1*b1 + a2*b2 + ... + an*bn.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& Z - ссылка на умножаемый комплексный вектор.
//2. const rvector& X - ссылка на умножаемый вещественный вектор.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - комплексная матрица умножения двух векторов.
//*****************************************************************************
cmatrix operator *(const cvector& Z, const rvector& X)
{cmatrix result;
 //Умножение с вектором (векторами) нулевого размера
 if ((Z.Size() == 0L) || (X.Size() == 0L)) return result;
 //Умножение с векторами разной размерности
 if (Z.Size() != X.Size()) return result;
 //Умножение с векторами одинаковых типов
 if (Z.Type() == X.Type()) return result;

 if (Z.IsColumn() == true) //Умножение вектора-столбца на вектор-строку
 {result.Set(Z.Size(),Z.Size(),false);//Установка размера матрицы
  for (ulong i = 0; i < Z.Size(); i++)
   for (ulong j = 0; j < X.Size(); j++)
    result.Put(i,j, Z.Get(i) * X.Get(j));
 }
 else if (Z.IsRow() == true) //Умножение вектора-строки на вектор-столбец
 {result.Set(1,1,false);//Установка размера матрицы
  complex value = C_ZERO;
  for (ulong i = 0; i < Z.Size(); i++) value += Z.Get(i) * X.Get(i);
  result.Put(0,0,value);
 }
 return result; //Матрица умножения комплексного вектора на вещественный вектор
}
//*****************************************************************************
//СТАТУС: I.31; friend function of the TComplexVector class overloading operator *
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//   friend cmatrix operator *(const rvector& X, const cvector& Z)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ КОМПЛЕКСНОГО ВЕКТОРА НА
//            ВЕЩЕСТВЕННЫЙ ВЕКТОР СПРАВА.
//Функция реализует перегрузку оператора (*) с целью умножения комплексного век-
//тора на действительный вектор Z(z1,...,zn) и X(x1,...,xn). Умножение двух век-
//торов определяется только для такой пары двух векторов, у которого число столб-
//цов первого сомножителя равно числу строк второго сомножителя. Таким образом,
//правила умножения
//вектора на вектор следующие:
//1. Векторы должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ;
//2. Умножаются ВЕКТОР-СТОЛБЕЦ на ВЕКТОР-СТРОКУ либо
//              ВЕКТОР-СТРОКА на ВЕКТОР-СТОЛБЕЦ.
//3. Размерности векторов не должны быть нулевыми.
//Если данные условия не выполняются, то возвращается матрица нулевого размера.
//При умножении двух векторов одинаковой размерности и противоположных типов в
//общем случае получается МАТРИЦА. При умножении вектора-столбца A размерностью
//(n x 1) на вектор-строку B размерностью (1 x n) получается КВАДРАТНАЯ МАТРИЦА
//C размерностью (n x n). Каждый элемент такой матрицы вычисляется по формуле:
// c(i,j) = a(i) * b(j).
//При умножении вектора-строки A размерностью (1 x n) на вектор-столбец B размер-
//ностью (n x 1) получается КВАДРАТНАЯ МАТРИЦА C размерностью (1 x 1). Данная
//операция эквивалентна операции скалярного умножения двух векторов, результатом
//которой является получение ОДНОГО ЧИСЛА. Элемент такой матрицы вычисляется по
//следующей формуле:
// c(1,1) = a1*b1 + a2*b2 + ... + an*bn.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& X - ссылка на умножаемый вещественный вектор.
//2. const cvector& Z - ссылка на умножаемый комплексный вектор.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// cmatrix result - комплексная матрица умножения двух векторов.
//*****************************************************************************
cmatrix operator *(const rvector& X, const cvector& Z)
{cmatrix result;
 //Умножение с вектором (векторами) нулевого размера
 if ((Z.Size() == 0L) || (X.Size() == 0L)) return result;
 //Умножение с векторами разной размерности
 if (Z.Size() != X.Size()) return result;
 //Умножение с векторами одинаковых типов
 if (Z.Type() == X.Type()) return result;

 if (X.IsColumn() == true) //Умножение вектора-столбца на вектор-строку
 {result.Set(X.Size(),X.Size(),false);//Установка размера матрицы
  for (ulong i = 0; i < X.Size(); i++)
   for (ulong j = 0; j < Z.Size(); j++)
    result.Put(i,j,Z.Get(j)*X.Get(i));
 }
 else if (X.IsRow() == true) //Умножение вектора-строки на вектор-столбец
 {result.Set(1,1,false);//Установка размера матрицы
  complex value = C_ZERO;
  for (ulong i = 0; i < X.Size(); i++) value += Z.Get(i) * X.Get(i);
  result.Put(0,0,value);
  }
 return result; //Матрица умножения комплексного вектора на вещественный вектор
}
//*****************************************************************************
//СТАТУС: I.32; friend function of the TComplexVector class overloading operator*
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//   friend cvector operator *(const cvector& V, const rmatrix& A)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ СЛЕВА КОМПЛЕКСНОГО ВЕКТОРА НА
//            ВЕЩЕСТВЕННУЮ МАТРИЦУ
//Функция реализует перегрузку оператора (*) с целью умножения слева комплексно-
//го вектора X(1 x n) на вещественную матрицу A(n x p). Правила умножения слева
//вектора на матрицу следующие:
//1. Вектор должен быть ВЕКТОРОМ-СТРОКОЙ;
//2. Умножаются ВЕКТОР-СТРОКА на МАТРИЦУ, у которой количество строк n должно
//   быть равно размерности вектора-строки.
//3. Размерности вектора и матрицы не должны быть нулевыми.
//Если данные условия не выполняются, то возвращается вектор нулевого размера.
//Результатом умножения слева вектора-строки на матрицу является ВЕКТОР-СТРОКА:
// X(1 x n) * A(n x p) = Y(1 x p)
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TComplexVector& V - ссылка на умножаемый комплексный вектор.
//2. const TRealMatrix& A - ссылка на умножаемую вещественную матрицу.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector result - вектор-строка как результат умножения
//вектора-строки на вещественную матрицу.
//*****************************************************************************
cvector operator *(const cvector& V, const rmatrix& A)
{cvector result;
 if (V.Size() == 0L) return result;//Умножение с вектором нулевого размера
 if (A.IsZeroSize()) return result;//Умножение на матрицу нулевого размера
 //Операция умножения слева производится с вектором-столбцом
 if (V.IsColumn()) return result;
 //Операция умножения слева вектора-строки на матрицу производится с разными
 //размером вектора и количеством строк матрицы.
 if (V.Size() != A.Rows()) return result;
 //Установка свойств результирующего вектора-строки. Размерность результирующего
 //вектора равна количеству столбцов матрицы.
 result.Set(A.Cols(),ROW,C_ZERO);
 //Операция умножения слева вектора-строки на матрицу
 for (ulong i = 0; i < A.Cols(); i++)
  for (ulong j = 0; j < A.Rows(); j++)
   result.Put(i,result.Get(i) + V.Get(j)*A.Get(j,i));
 return result; //Матрица умножения двух векторов
}
//*****************************************************************************
//СТАТУС: I.33; friend function of the TComplexVector class overloading operator *
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend cvector operator *(const rmatrix& A, const cvector& V)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ СПРАВА КОМПЛЕКСНОГО ВЕКТОРА НА
//            ВЕЩЕСТВЕННУЮ МАТРИЦУ
//Функция реализует перегрузку оператора (*) с целью умножения справа комплексно-
//го вектора X(n x 1) на вещественную матрицу A(m x n). Правила умножения справа
//вектора на матрицу следующие:
//1. Вектор должен быть ВЕКТОРОМ-СТОЛБЦОМ;
//2. Умножаются МАТРИЦА на ВЕКТОР-СТОЛБЕЦ, у которой количество столбцов n должно
//   быть равно размерности вектора-столбца.
//3. Размерности вектора и матрицы не должны быть нулевыми.
//Если данные условия не выполняются, то возвращается вектор нулевого размера.
//Результатом умножения справа вектора-стролбца на матрицу ВЕКТОР-СТОЛБЕЦ:
//A(m x n) * X(n x 1) = Y(m x 1).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TRealMatrix& A - ссылка на умножаемую матрицу.
//2. const TComplexVector& V - ссылка на умножаемый вектор.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// cvector result - вектор-столбец как результат умножения вектора-столбца на
// вещественную матрицу справа.
//*****************************************************************************
cvector operator *(const rmatrix& A, const cvector& V)
{cvector result;
 if (V.Size() == 0L) return result;//Умножение с вектором нулевого размера
 if (A.IsZeroSize()) return result;//Умножение на матрицу нулевого размера
 if (V.IsRow()) return result;//Умножение справа производится с вектором-строкой
 //Операция умножения справа вектора-стролбца на матрицу производится с разными
 //размером вектора и количеством столбцов матрицы.
 if (V.Size() != A.Cols()) return result;
 //Установка свойств результирующего вектора-столбца. Размерность результирую-
 //щего вектора равна количеству строк матрицы.
 result.Set(A.Rows(),COL,C_ZERO);
 //Операция умножения справа вектора-столбца на матрицу
  for (ulong i = 0; i < A.Rows(); i++)
   for (ulong j = 0; j < A.Cols(); j++)
    result.Put(i,result.Get(i) + V.Get(j) * A.Get(i,j));
 return result; //Результирующий вектор умножения справа вектора на матрицу
}
//*****************************************************************************
//СТАТУС: I.34;friend function of the TComplexVector class overloading operator*
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend cvector operator *(const cvector& V, const cmatrix& A)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ СЛЕВА КОМПЛЕКСНОГО ВЕКТОРА НА
//            КОМПЛЕКСНУЮ МАТРИЦУ
//Функция реализует перегрузку оператора (*) с целью умножения слева комплексно-
//го вектора X(1 x n) на комплексную матрицу A(n x p). Правила умножения слева
//вектора на матрицу следующие:
//1. Вектор должен быть ВЕКТОРОМ-СТРОКОЙ;
//2. Умножаются ВЕКТОР-СТРОКА на МАТРИЦУ, у которой количество строк n должно
//   быть равно размерности вектора-строки.
//3. Размерности вектора и матрицы не должны быть нулевыми.
//Если данные условия не выполняются, то возвращается вектор нулевого размера.
//Результатом умножения слева вектора-строки на матрицу является ВЕКТОР-СТРОКА:
// X(1 x n) * A(n x p) = Y(1 x p)
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TComplexVector& V - ссылка на умножаемый комплексный вектор.
//2. const TComplexMatrix& A - ссылка на умножаемую комплексную матрицу.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// cvector result - вектор-строка как результат умножения вектора-строки на
// комплексную матрицу.
//*****************************************************************************
cvector operator *(const cvector& V, const cmatrix& A)
{cvector result;
 if (V.Size() == 0L) return result;//Умножение с вектором нулевого размера
 if (A.IsZeroSize()) return result;//Умножение на матрицу нулевого размера
 //Операция умножения слева производится с вектором-столбцом
 if (V.IsColumn()) return result;
 //Операция умножения слева вектора-строки на матрицу производится с разными
 //размером вектора и количеством строк матрицы.
 if (V.Size() != A.Rows()) return result;
 //Установка свойств результирующего вектора-строки. Размерность результирующего
 //вектора равна количеству столбцов матрицы.
 result.Set(A.Cols(),ROW,C_ZERO);
 //Операция умножения слева вектора-строки на матрицу
 for (ulong i = 0; i < A.Cols(); i++)
  for (ulong j = 0; j < A.Rows(); j++)
   result.Put(i, result.Get(i) + V.Get(j) * A.Get(j,i));
 return result; //Вектор умножения слева вектора на матрицу
}
//*****************************************************************************
//СТАТУС: I.35;friend function of the TComplexVector class overloading operator *
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend cvector operator *(const cmatrix& A, const cvector& V)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ СПРАВА КОМПЛЕКСНОГО ВЕКТОРА НА
//            КОМПЛЕКСНУЮ МАТРИЦУ
//Функция реализует перегрузку оператора (*) с целью умножения справа комплексно-
//го вектора X(n x 1) на комплексную матрицу A(m x n). Правила умножения справа
//вектора на матрицу следующие:
//1. Вектор должен быть ВЕКТОРОМ-СТОЛБЦОМ;
//2. Умножаются МАТРИЦА на ВЕКТОР-СТОЛБЕЦ, у которой количество столбцов n должно
//   быть равно размерности вектора-столбца.
//3. Размерности вектора и матрицы не должны быть нулевыми.
//Если данные условия не выполняются, то возвращается вектор нулевого размера.
//Результатом умножения справа вектора-стролбца на матрицу является
//ВЕКТОР-СТОЛБЕЦ: A(m x n) * X(n x 1) = Y(m x 1).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TComplexMatrix& A - ссылка на умножаемую матрицу.
//2. const TComplexVector& V - ссылка на умножаемый вектор.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// cvector result - вектор-столбец как результат умножения вектора-столбца на
// комплексную матрицу справа.
//*****************************************************************************
cvector operator *(const cmatrix& A, const cvector& V)
{cvector result;
 if (V.Size() == 0L) return result;//Умножение с вектором нулевого размера
 if (A.IsZeroSize()) return result;//Умножение на матрицу нулевого размера
 //Умножение справа производится с вектором-строкой
 if (V.IsRow()) return result;
 //Операция умножения справа вектора-стролбца на матрицу производится с разными
 //размером вектора и количеством столбцов матрицы.
 if (V.Size() != A.Cols()) return result;
 //Установка свойств результирующего вектора-столбца. Размерность результирующего
 //вектора равна количеству строк матрицы.
 result.Set(A.Rows(),COL,C_ZERO);
 //Операция умножения справа вектора-столбца на матрицу
 for (ulong i = 0; i < A.Rows(); i++)
  for (ulong j = 0; j < A.Cols(); j++)
   result.Put(i, result.Get(i) + V.Get(j) * A.Get(i,j));
 return result; //Результирующий вектор умножения справа вектора на матрицу
}
//*****************************************************************************
//СТАТУС: I.36, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector MultByItem(const cvector& V) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ ДВУХ КОМПЛЕКСНЫХ ВЕКТОРОВ
//Функция перемножает значения элементов двух векторов, которые соответствуют
//одинаковым значениям индексов. Результатом работы функции является комплексный
//вектор, совпадающий с размерами перемножаемых поэлементно векторов. Каждый
//элемент результирующего вектора вычисляется по формуле: C[i] = A[i]*B[i].
//В случае, если один из перемножаемых векторов оказывается вектором нулевого
//размера или размерности векторов не совпадают, функция возвращает вектор нуле-
//вого размера. Тип результирующего вектора совпадает с типом вектора this. При
//вычислении результирующего вектора исходные векторы не изменяются.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// const сvector& V - ссылка на второй умножаемый поэлементно вектор.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//сvector result - вектор, образованный при поэлементном умножении двух векторов
//                 одинаковых размеров.
//*****************************************************************************
cvector TComplexVector::MultByItem(const cvector& V) const
{cvector result;
 //Проверка на возможность поэлементного умножения двух векторов
 if ((IsZeroSize()) || (V.IsZeroSize()) || (Size() != V.Size())) return result;
 //Поэлементное умножение векторов
 result.Set(Size(),Type(),C_ZERO);
 for (ulong i = 0L; i < Size(); i++) result.Put(i,data[i]*V.Get(i));
return result;
}
//*****************************************************************************
//СТАТУС: I.37, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector MultByItem(const rvector& V) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ КОМПЛЕКСНОГО и ДЕЙСТВИТЕЛЬНОГО ВЕКТОРОВ
//Функция перемножает значения элементов двух векторов, которые соответствуют
//одинаковым значениям индексов. Результатом работы функции является комплексный
//вектор, совпадающий с размерами перемножаемых поэлементно векторов. Каждый
//элемент результирующего вектора вычисляется по формуле: C[i] = A[i]*B[i].
//В случае, если один из перемножаемых векторов оказывается вектором нулевого
//размера или размерности векторов не совпадают, функция возвращает вектор нуле-
//вого размера. Тип результирующего вектора совпадает с типом вектора this. При
//вычислении результирующего вектора исходные векторы не изменяются.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// const rvector& V - ссылка на второй умножаемый поэлементно вектор.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//сvector result - вектор, образованный при поэлементном умножении двух векторов
//                 одинаковых размеров.
//*****************************************************************************
cvector TComplexVector::MultByItem(const rvector& V) const
{cvector result;
 //Проверка на возможность поэлементного умножения двух векторов
 if ((IsZeroSize()) || (V.IsZeroSize()) || (Size() != V.Size())) return result;
 //Поэлементное умножение векторов
 result.Set(Size(),Type(),C_ZERO);
 for (ulong i = 0L; i < Size(); i++) result.Put(i,data[i]*V.Get(i));
return result;
}
//*****************************************************************************
//СТАТУС: I.38, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex SumByItem(ulong* counter = NULL) const;
//НАЗНАЧЕНИЕ: СУММИРОВАНИЕ ВСЕХ ЭЛЕМЕНТОВ ВЕКТОРА
//Функция суммирует все значения элементов вектора. Результатом работы функции
//является сумма значений элементов вектора. Функция не изменяет значений и
//структуру исходного вектора.
//Функции передается необязательный указатель на переменную типа ulong - count.
//По умолчанию counter=NULL. В ходе работы функция подсчитывает кол-во элементов
//вектора, которые участвовали в суммировании. Если указатель counter отличен от
//NULL, то по его адресу по окончании работы функции передается количество эле-
//ментов, которые суммировались.
//Если исходный вектор - вектор нулевого размера, то функция возвращает нуль.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// ulong* counter (NULL) - указатель на счетчик, в который будет записано коли-
// чество элементов вектора, по которым осуществлялось суммирование.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex sum - сумма всех значений элементов вектора
//*****************************************************************************
complex TComplexVector::SumByItem(ulong* counter) const
{complex sum = C_ZERO;
 if (Size() == 0L) //Проверка на вектор нулевого размера
 {if (counter != NULL) *counter = 0; return sum;}
 //Сложение всех значений элементов вектора
 for (ulong i = 0L; i < Size(); i++) sum += data[i];
 if (counter != NULL) *counter = Size();
return sum;
}
//*****************************************************************************
//СТАТУС: I.39, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//  complex SumByItem(ulong left, ulong right = MAX_SIZE,
//                    ulong* counter = NULL) const
//НАЗНАЧЕНИЕ: СУММИРОВАНИЕ ЗНАЧЕНИЙ ЭЛЕМЕНТОВ ВЕКТОРА В ОПРЕДЕЛЕННОМ ИНТЕРВАЛЕ
//Функция суммирует значения элементов вектора в интервале, заданном нижней гра-
//ницей индексов вектора - left и верхней границей индексов вектора - right. По
//умолчанию right задается равным верхней границей данного вектора. Нижняя и
//верхняя границы индексов включаются в интервал, в котором будет осуществляться
//суммирование элементов вектора, индексы которых принадлежат заданному интерва-
//лу. Результатом работы функции является сумма значений элементов вектора в за-
//данном интервале индексов. Функция не изменяет значений и структуру исходного
//вектора.
//Функции передается необязательный указатель на переменную типа ulong - count.
//По умолчанию counter=NULL. В ходе работы функция подсчитывает кол-во элементов
//вектора, которые участвовали в суммировании. Если указатель counter отличен от
//NULL, то по его адресу по окончании работы функции передается количество эле-
//ментов, которые суммировались.
//Функция возвращает нулевое значение суммы значений элементов вектора в следую-
//щих исключительных ситуациях:
//1. Исходный вектор - вектор нулевого размера;
//2. Левая или правая границы интервала выходят за допустимые значения индексов
//   исходного вектора;
//3. Левая граница интервала суммирования больше правой границы.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left - левая (нижняя) граница интервала суммирования элементов;
//2. ulong right - правая (верхняя) граница интервала суммирования элементов.
//3. ulong* counter (NULL) - указатель на счетчик, в который будет записано ко-
//   личество элементов вектора, по которым осуществлялось суммирование.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//complex sum - сумма значений элементов вектора в заданном интервале индексов
//*****************************************************************************
complex TComplexVector::SumByItem(ulong left, ulong right, ulong* counter) const
{complex sum = C_ZERO;
 //Вектор нулевого размера
 if (Size() == 0L) {if (counter != NULL) *counter = 0; return sum;}
 if (right == MAX_SIZE) right = Size();
 //Проверка на корректность задаваемых границ интервала
 if ((left >= Size()) || (right >= Size()) || (left > right))
 {if (counter != NULL) *counter = 0; return sum;}
 //Сложение значений элементов вектора в заданном интервале индексов
 for (ulong i = left; i <= right; i++) sum += data[i];
 if (counter != NULL) *counter = (right-left+1);
return sum;
}
//*****************************************************************************
//СТАТУС: I.40, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//  complex SumByItem(const ivector& index, bool check = false,
//                    ulong* counter = NULL) const
//НАЗНАЧЕНИЕ: СУММИРОВАНИЕ ЗНАЧЕНИЙ ЭЛЕМЕНТОВ ВЕКТОРА, КОТОРЫЕ СООТВЕТСТВУЮТ
//            ОПРЕДЕЛЕННЫМ ИНДЕКСАМ ЭЛЕМЕНТОВ ИСХОДНОГО ВЕКТОРА
//Значения индексов исходного вектора, по которым будет осуществляться суммирова-
//ние элементов вектора, передаются в векторе index. Аргумент check указывает на
//проведение проверки значений индексов на соответствие допустимым значениям ин-
//дексов исходного вектора. При check = true, создается объект-предикат, который
//осуществляет селекцию корректных значений индексов, и формируется подвектор
//вектора index с корректными значениями индексов. Созданный подвектор далее ис-
//пользуется для суммирования значений элементов вектора по заданным индексам.
//При check = false фильтрация некорректных значений индексов не осуществляется.
//В этом случае ответственность за корректность всех значений индексов возлагает-
//ся на пользователя и при некорректном задании значения индекса, выходящего за
//пределы допустимых значений индексов для данного вектора, приведет к аварийно-
//му завершению работы всей программы. При check = false функция быстрее выпол-
//няет необходимые действия, так как не тратится время на фильтрацию некоррект-
//ных значений индексов, передавемых вектором index.
//Функции передается необязательный указатель на переменную типа ulong - count.
//По умолчанию counter=NULL. В ходе работы функция подсчитывает кол-во элементов
//вектора, которые участвовали в суммировании. Если указатель counter отличен от
//NULL, то по его адресу по окончании работы функции передается количество эле-
//ментов, которые суммировались.
//Результатом работы функции является сумма значений элементов вектора по задан-
//ным индексам. Функция не изменяет значений и структуру исходного вектора.
//Функция возвращает нулевое значение суммы значений элементов вектора в следую-
//щих исключительных ситуациях:
//1. Исходный вектор - вектор нулевого размера;
//2. Вектор со значениями индексов является вектором нулевого размера;
//3. При выполнении фильтрации некорректных значений индексов (check = true)
//   полученный подвектор вектора index является вектором нулевого размера, что
//   означает отсутствие в векторе index корректных индексов для исходного вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& index - ссылка на вектор со значениями индексов по которым
//   будет осуществляться суммирование элементов исходного вектора;
//2. bool check - индикатор фильтрации некорректных значений индексов в index.
//3. ulong* counter (NULL) - указатель на счетчик, в который будет записано ко-
//   личество элементов вектора, по которым осуществлялось суммирование.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//complex sum - сумма значений элементов вектора по заданным индексам элементов
//*****************************************************************************
complex TComplexVector::SumByItem(const ivector& index, bool check,
                                  ulong* counter) const
{complex sum = C_ZERO;
 if (IsZeroSize() || index.IsZeroSize()) //Векторы нулевого размера
 {if (counter != NULL) *counter = 0; return sum;}
 ivector Index = index;
 if (check) //Проверка на корректность значений индексов
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Size()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  if (Index.IsZeroSize()) {if (counter != NULL) *counter = 0; return sum;}
 }
 //Сложение значений элементов вектора, соответсвующих определенным индексам
 for (ulong i = 0L; i <= Index.Size(); i++) sum += data[Index.Get(i)];
 if (counter != NULL) *counter = Index.Size();
return sum;
}
//*****************************************************************************
//СТАТУС: I.41, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// complex SumByItem(const TArgVectorPredicate<complex,cvector>& Predicate,
//                   ulong* counter = NULL) const
//НАЗНАЧЕНИЕ: СУММИРОВАНИЕ ЗНАЧЕНИЙ ЭЛЕМЕНТОВ ВЕКТОРА, КОТОРЫЕ УДОВЛЕТВОРЯЮТ
//            УСЛОВИЯМ ОБЪЕКТА-ПРЕДИКАТА
//Перед суммированием каждое значение элемента исходного вектора в качестве аргу-
//мента передается перегруженному оператору вызова функции объекта-предиката
//Predicate. Перегруженный оператор вызова функции объекта Predicate в зависимос-
//ти от значения аргумента возвращает булевское значение - true или false. Если
//объект-предикат возвращает true, то такое значение элемента вектора суммирует-
//ся с остальными значениями элементов вектора, для которых Predicate вернул зна-
//чение true. Если Predicate возвращает значение false, то данное значение эле-
//мента вектора не допускается к суммированию. Работу объекта-предиката можно
//сравнить с фильтром, который пропускает или не пропускает определенные данные.
//Результатом работы функции является сумма значений элементов вектора, удовлет-
//воряющие условиям объекта-предиката. Функция не изменяет значений и структуру
//исходного вектора.
//Функции передается необязательный указатель на переменную типа ulong - count.
//По умолчанию counter=NULL. В ходе работы функция подсчитывает кол-во элементов
//вектора, которые участвовали в суммировании. Если указатель counter отличен от
//NULL, то по его адресу по окончании работы функции передается количество эле-
//ментов, которые суммировались.
//Функция возвращает нулевое значение суммы значений элементов вектора в следую-
//щих исключительных ситуациях:
//1. Исходный вектор - вектор нулевого размера;
//2. Ни одно из значений элементов вектора не удовлетворяет условиям
//   объекта-предиката Predicate;
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TArgVectorPredicate<double,rvector>& Predicate - ссылка на объект-пре-
//   дикат, по которому будет осуществляться отбор значений элементов вектора
//   для их суммирования;
//2. ulong* counter (NULL) - указатель на счетчик, в который будет записано ко-
//   личество элементов вектора, по которым осуществлялось суммирование.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//complex sum - сумма значений элементов вектора по заданным индексам элементов
//*****************************************************************************
complex TComplexVector::
SumByItem(const TArgVectorPredicate<complex,cvector>& Predicate, ulong* counter)
const
{complex sum = C_ZERO;
 ulong count = 0L;
 //Вектор нулевого размера
 if (IsZeroSize()) {if (counter != NULL) *counter = count; return sum;}
 complex value;
 //Сложение значений элементов вектора, удовлетворяющим условиям Predicate
 for (ulong i = 0L; i < Size(); i++)
 {value = data[i];
  if (Predicate(value)) {sum += value; count++;}
 }
 if (counter != NULL) *counter = count;
return sum;
}
//*****************************************************************************
//СТАТУС: I.42, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool DiagonalEM(const cmatrix& Q, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ДИАГОНАЛЬНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Dk.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицу Dk. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Dk;
//2. ulong k - k-й диагональный элемент матрицы отличный от нуля и единицы,
//   0 <= k < Q.Rows().
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TComplexVector::DiagonalEM(const cmatrix& Q, ulong k)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (k >= Q.Rows())) return false;
 //Реализация операции умножения
 data[k] = data[k]*Q.Get(k,k);
return true;
}
//*****************************************************************************
//СТАТУС: I.43, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool DiagonalEM(const cmatrix& Q, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ГРУППУ ДИАГОНАЛЬНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Dk.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Dk. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матриц Dk;
//2. ulong first - индекс первой диагональной элементарной матрицы;
//3. ulong last -  индекс последней диагональной элементарной матрицы;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TComplexVector::DiagonalEM(const cmatrix& Q, ulong first, ulong last)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 for (ulong i = first; i <= last; i++) data[i] = data[i]*Q.Get(i,i);
return true;
}
//*****************************************************************************
//СТАТУС: I.44, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool DiagonalEM(const cmatrix& Q)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВСЕ ДИАГОНАЛЬНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Dk.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Dk. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
// матриц Dk;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TComplexVector::DiagonalEM(const cmatrix& Q)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L))
    return false;
 //Реализация операции умножения
 for (ulong i = 0; i < Size(); i++) data[i] = data[i]*Q.Get(i,i);
return true;
}
//*****************************************************************************
//СТАТУС: I.45, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LowerColumnEM(const cmatrix& Q, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА НИЖНЮЮ СТОЛБЦОВУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Lkc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицу Lkc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Lkc;
//2. ulong k - k-й столбец матрицы, поддиагональные элементы которого отличны от
//   нуля, 0 <= k < Q.Rows().
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TComplexVector::LowerColumnEM(const cmatrix& Q, ulong k)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {for (ulong i = k+1; i < Q.Rows(); i++) //По строкам Q
   data[i] += data[k]*Q.Get(i,k);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {for (ulong i = k+1; i < Q.Rows(); i++) //По строкам Q
   data[k] += data[i]*Q.Get(i,k); //Накопление суммы произведений
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.46, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool LowerColumnEM(const cmatrix& Q, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ГРУППУ НИЖНИХ СТОЛБЦОВЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Lkc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Lkc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матриц Lkc;
//2. ulong first - индекс первой нижней столбцовой элементарной матрицы;
//3. ulong last -  индекс последней нижней столбцовой элементарной матрицы;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TComplexVector::LowerColumnEM(const cmatrix& Q, ulong first, ulong last)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.47, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LowerColumnEM(const cmatrix& Q)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВСЕ НИЖНИЕ СТОЛБЦОВЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Lkc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Lkc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//матриц Lkc.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TComplexVector::LowerColumnEM(const cmatrix& Q)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L))
     return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {for (ulong j = 0; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {for (ulong j = 0; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.48, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool UpperColumnEM(const cmatrix& Q, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВЕРХНЮЮ СТОЛБЦОВУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Ukc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицу Ukc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Ukc;
//2. ulong k - k-й столбец матрицы, наддиагональные элементы которого отличны от
//   нуля, 0 <= k < Q.Rows().
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TComplexVector::UpperColumnEM(const cmatrix& Q, ulong k)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {for (ulong i = 0; i < k; i++) //По строкам Q
   data[i] += data[k]*Q.Get(i,k);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {for (ulong i = 0; i < k; i++) //По строкам Q
   data[k] += data[i]*Q.Get(i,k); //Накопление суммы произведений
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.49, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool UpperColumnEM(const cmatrix& Q, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ГРУППУ ВЕРХНИХ СТОЛБЦОВЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Ukc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Ukc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матриц Ukc;
//2. ulong first - индекс первой верхней столбцовой элементарной матрицы;
//3. ulong last -  индекс последней верхней столбцовой элементарной матрицы;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TComplexVector::UpperColumnEM(const cmatrix& Q, ulong first, ulong last)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.50, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool UpperColumnEM(const cmatrix& Q)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВСЕ ВЕРХНИЕ СТОЛБЦОВЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Ukc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Ukc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//матриц Ukc.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TComplexVector::UpperColumnEM(const cmatrix& Q)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L))
     return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {for (ulong j = 1; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {for (ulong j = 1; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
 }
return true;
}
//******************************************************************************
//СТАТУС: I.51, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CompleteColumnEM(const cmatrix& Q, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ПОЛНУЮ СТОЛБЦОВУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Tkc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицу Tkc. Функция при возможности умножения изменяет элементы
//вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Tkc;
//2. ulong k - k-й столбец матрицы с ненулевыми элементами, 0 <= k < Q.Rows().
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexVector::CompleteColumnEM(const cmatrix& Q, ulong k)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на наддиагональные элементы k-го столбца
  for (ulong i = 0; i < k; i++) data[i] += data[k]*Q.Get(i,k);
  //Умножение на поддиагональные элементы k-го столбца
  for (ulong i = k+1; i < Q.Rows(); i++) data[i] += data[k]*Q.Get(i,k);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на наддиагональные элементы k-го столбца
  for (ulong i = 0; i < k; i++) data[k] += data[i]*Q.Get(i,k);
  //Умножение на поддиагональные элементы k-го столбца
  for (ulong i = k+1; i < Q.Rows(); i++) data[k] += data[i]*Q.Get(i,k);
 }
return true;
}
//******************************************************************************
//СТАТУС: I.52, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CompleteColumnEM(const cmatrix& Q, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ГРУППУ ПОЛНЫХ СТОЛБЦОВЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Tkc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Tkc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матриц Tkc;
//2. ulong first - индекс первой полной столбцовой элементарной матрицы;
//3. ulong last -  индекс последней полной столбцовой элементарной матрицы;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TComplexVector::CompleteColumnEM(const cmatrix& Q, ulong first, ulong last)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на верхние столбцовые элементарные матрицы
  for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
  //Умножение на нижние столбцовые элементарные матрицы
  for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на верхние столбцовые элементарные матрицы
  for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
  //Умножение на нижние столбцовые элементарные матрицы
  for (ulong j = first; j <= last; j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.53, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CompleteColumnEM(const cmatrix& Q)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВСЕ ПОЛНЫЕ СТОЛБЦОВЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Tkc.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Tkc. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//матриц Tkc.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TComplexVector::CompleteColumnEM(const cmatrix& Q)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L))
     return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на все верхние столбцовые элементарные матрицы
  for (ulong j = 1; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
  //Умножение на все нижние столбцовые элементарные матрицы
  for (ulong j = 0; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[i] += data[j]*Q.Get(i,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на все верхние столбцовые элементарные матрицы
  for (ulong j = 1; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = 0; i < j; i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
  //Умножение на все верхние столбцовые элементарные матрицы
  for (ulong j = 0; j < Q.Cols(); j++) //По столбцам Q
   for (ulong i = j+1; i < Q.Rows(); i++) //По строкам Q
    data[j] += data[i]*Q.Get(i,j); //Накопление суммы произведений
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.54, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LeftRowEM(const cmatrix& Q, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ЛЕВУЮ СТРОЧНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Lkr.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицу Lkr. Функция при возможности умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Lkr;
//2. ulong k - k-я строка матрицы с ненулевыми элементами, расположенные слева
//   от главной диагонали, 0 <= k < Q.Rows().
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TComplexVector::LeftRowEM(const cmatrix& Q, ulong k)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на элементы k-й строки, расположенные левее главной диагонали
  for (ulong j = 0; j < k; j++) data[k] += data[j]*Q.Get(k,j);//По столбцам Q
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на элементы k-й строки, расположенные левее главной диагонали
  for (ulong j = 0; j < k; j++) data[j] += data[k]*Q.Get(k,j);//По столбцам Q
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.55, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool LeftRowEM(const cmatrix& Q, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ГРУППУ ЛЕВЫХ СТРОЧНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Lkr.
//Функция  осуществляет  проверку на возможность умножения вектора на матрицу Q,
//содержащую  матрицы Lkr. Функция  при возможности  умножения изменяет элементы
//вектора.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матриц Lkr;
//2. ulong first - индекс первой левой строчной элементарной матрицы;
//3. ulong last -  индекс последней левой строчной элементарной матрицы;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//*****************************************************************************
bool TComplexVector::LeftRowEM(const cmatrix& Q, ulong first, ulong last)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на левые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на левые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);
 }
return true;
}
//******************************************************************************
//СТАТУС: I.56, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LeftRowEM(const cmatrix& Q)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВСЕ ЛЕВЫЕ СТРОЧНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Lkr.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Lkr. Функция при возможности умножения изменяет элементы
//вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//матриц Lkr.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexVector::LeftRowEM(const cmatrix& Q)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L))
     return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на все левые строчные элементарные матрицы
  for (ulong i = 1; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на все левые строчные элементарные матрицы
  for (ulong i = 1; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);
 }
return true;
}
//******************************************************************************
//СТАТУС: I.57, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool RightRowEM(const cmatrix& Q, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ПРАВУЮ СТРОЧНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Ukr.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицу Ukr. Функция при возможности умножения изменяет элементы
//вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Ukr;
//2. ulong k - k-я строка матрицы с ненулевыми элементами, расположенными справа
//   от главной диагонали, 0 <= k < Q.Rows().
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexVector::RightRowEM(const cmatrix& Q, ulong k)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на элементы k-й строки, расположенные справа от главной диагонали
  //По столбцам Q, накопление суммы произведений
  for (ulong j = k+1; j < Q.Cols(); j++) data[k] += data[j]*Q.Get(k,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на элементы k-й строки, расположенные справа от главной диагонали
  //По столбцам Q
  for (ulong j = k+1; j < Q.Cols(); j++) data[j] += data[k]*Q.Get(k,j);
 }
return true;
}
//******************************************************************************
//СТАТУС: I.58, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool RightRowEM(const cmatrix& Q, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ГРУППУ ПРАВЫХ СТРОЧНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Ukr.
//Функция  осуществляет  проверку на возможность умножения вектора на матрицу Q,
//содержащую  матрицы Ukr. Функция  при возможности  умножения изменяет элементы
//вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матриц Ukr;
//2. ulong first - индекс первой правой строчной элементарной матрицы;
//3. ulong last -  индекс последней правой строчной элементарной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexVector::RightRowEM(const cmatrix& Q, ulong first, ulong last)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на правые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на правые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);
 }
return true;
}
//******************************************************************************
//СТАТУС: I.59, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool RightRowEM(const cmatrix& Q)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВСЕ ПРАВЫЕ СТРОЧНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Ukr.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Ukr. Функция при возможности умножения изменяет элементы
//вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//матриц Ukr.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexVector::RightRowEM(const cmatrix& Q)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L))
     return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на все правые строчные элементарные матрицы
  for (ulong i = 0; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на все правые строчные элементарные матрицы
  for (ulong i = 0; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);
 }
return true;
}
//******************************************************************************
//СТАТУС: I.60, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CompleteRowEM(const cmatrix& Q, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ПОЛНУЮ СТРОЧНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Tkr.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицу Tkr. Функция при возможности умножения изменяет элементы
//вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Ukr;
//2. ulong k - k-я строка матрицы с ненулевыми элементами, 0 <= k < Q.Rows().
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexVector::CompleteRowEM(const cmatrix& Q, ulong k)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на элементы k-й строки, расположенные слева от главной диагонали
  //По столбцам Q, накопление суммы произведений
  for (ulong j = 0; j < k; j++) data[k] += data[j]*Q.Get(k,j);

  //Умножение на элементы k-й строки, расположенные справа от главной диагонали
  //По столбцам Q, накопление суммы произведений
  for (ulong j = k+1; j < Q.Cols(); j++) data[k] += data[j]*Q.Get(k,j);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на элементы k-й строки, расположенные слева от главной диагонали
  //По столбцам Q
  for (ulong j = 0; j < k; j++) data[j] += data[k]*Q.Get(k,j);

  //Умножение на элементы k-й строки, расположенные справа от главной диагонали
  //По столбцам Q
  for (ulong j = k+1; j < Q.Cols(); j++) data[j] += data[k]*Q.Get(k,j);
 }
return true;
}
//******************************************************************************
//СТАТУС: I.61, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CompleteRowEM(const cmatrix& Q, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ГРУППУ ПОЛНЫХ СТРОЧНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Tkr.
//Функция  осуществляет  проверку на возможность умножения вектора на матрицу Q,
//содержащую  матрицы Tkr. Функция  при возможности  умножения изменяет элементы
//вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матриц Tkr;
//2. ulong first - индекс первой полной строчной элементарной матрицы;
//3. ulong last -  индекс последней полной строчной элементарной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexVector::CompleteRowEM(const cmatrix& Q, ulong first, ulong last)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L) ||
     (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на левые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений

  //Умножение на правые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на левые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);

  //Умножение на правые строчные элементарные матрицы
  for (ulong i = first; i <= last; i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);
 }
return true;
}
//******************************************************************************
//СТАТУС: I.62, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CompleteRowEM(const cmatrix& Q)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ВСЕ ПОЛНЫЕ СТРОЧНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Tkr.
//Функция осуществляет проверку на возможность умножения вектора на матрицу Q,
//содержащую матрицы Tkr. Функция при возможности умножения изменяет элементы
//вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//матриц Tkr.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexVector::CompleteRowEM(const cmatrix& Q)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (Q.Rows() != Q.Cols()) || (Q.Rows() == 0L))
     return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q
 {//Умножение на все левые строчные элементарные матрицы
  for (ulong i = 1; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений

  //Умножение на все правые строчные элементарные матрицы
  for (ulong i = 0; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[i] += data[j]*Q.Get(i,j); //Накопление суммы произведений
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q
 {//Умножение на все левые строчные элементарные матрицы
  for (ulong i = 1; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = 0; j < i; j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);

  //Умножение на все правые строчные элементарные матрицы
  for (ulong i = 0; i < Q.Rows(); i++) //По строкам Q
   for (ulong j = i+1; j < Q.Cols(); j++) //По столбцам Q
    data[j] += data[i]*Q.Get(i,j);
 }
return true;
}
//******************************************************************************
//СТАТУС: I.63, TComplexVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool OrdinaryEM(const cmatrix& Q, ulong row, ulong col)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА ЭЛЕМЕНТАРНУЮ МАТРИЦУ Bij.
//Функция  осуществляет  проверку на возможность умножения вектора на матрицу Q,
//содержащую  матрицу Bij. Функция  при возможности  умножения изменяет элементы
//вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Bij;
//2. ulong row - строка элементарной матрицы с ненулевым элементом;
//3. ulong col - столбец элементарной матрицы с ненулевым элементов;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexVector::OrdinaryEM(const cmatrix& Q, ulong row, ulong col)
{//Проверка на возможность умножения вектора на элементарную матрицу
 if ((Q.Rows() != Size()) || (!Q.IsSquare()) || (Q.Rows() == 0L) ||
     (row >= Q.Rows()) || (col >= Q.Cols())) return false;
 //Реализация операции умножения
 if (IsColumn()) //Умножение ВЕКТОРА-СТОЛБЦА на Q: V' = Q*V
 {if (row != col) data[row] += data[col]*Q.Get(row,col);
  else data[row] *= Q.Get(row,col);
 }
 else //Умножение ВЕКТОРА-СТРОКИ на Q: V' = V*Q
 {if (row != col) data[col] += data[row]*Q.Get(row,col);
  else data[col] *= Q.Get(row,col);
 }
return true;
}

//------------------------------------------------------------------------------
//           РЕАЛИЗАЦИЯ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ КЛАССА TComplexVector
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1; public; TComplexVector class overloading operator()
//OVERLOADING OPERATOR OF FUNCTION CALL
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex& operator() (ulong i)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЗОВА ФУНКЦИИ класса TComplexVector
//Функция предназначена для доступа к одному элементу вектора.
//Осуществляется проверка корректности индекса по которому располагается требуе-
//мый элемент вектора. Функция вызывается во всех пользовательских функциях,
//кроме вызова в операторе присваивания и конструкторе копирования, т.к. в
//качестве аргументов последних передается константный объект.
//Доступ к членам-данным константных объектов можно осуществлять только с исполь-
//зованием константных функций.
//ПРИМЕР ВЫЗОВА: V(3), где i=3 - индекс элемента комплексного вектора. Нумерация
//элементов вектора начинается с 0.
//Если индекс элемента вектора некорректен, то возвращается его первый элемента.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong i - индекс элемента вектора
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex& value - ссылка на a[i] компонент вектора
//******************************************************************************
complex& TComplexVector::operator() (ulong i)
{if (Size() == 0L) return data[0];//Доступ к вектору нулевого размера
 //Проверка корректности индексов доступа к элементу вектора
 if (i >= Size()) return data[0];  //Индекс i выходит за границы вектора
 return data[i];
}
//*****************************************************************************
//СТАТУС: I.2; public; TComplexVector class overloading operator()
//OVERLOADING OPERATOR OF FUNCTION CALL
//НАИМЕНОВАНИЕ ФУНКЦИИ: const complex operator() (ulong i) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЗОВА ФУНКЦИИ класса TComplexVector
//Функция предназначена для доступа к одному элементу вектора.
//Осуществляется проверка корректности индекса по которому располагается требуе-
//мый элемент вектора. Функция вызывается в операторе присваивания и конструкто-
//ре копирования, т.к. в качестве их аргументов передается константный объект.
//Доступ к членам-данным константных объектов можно осуществлять только с исполь-
//зованием константных функций.
//ПРИМЕР ВЫЗОВА: A(3), где i=3 - индекс комплексного вектора. Нумерация элемен-
//тов вектора начинается с 0.
//Если индекс элемента вектора некорректен, то возвращается его первый элемент.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong i - индекс элемента вектора
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: const complex value - a[i] компонент вектора
//*****************************************************************************
const complex TComplexVector::operator() (ulong i) const
{if (Size() == 0L) return data[0];//Доступ к вектору нулевого размера
 //Проверка корректности индексов доступа к элементу вектора
 if (i >= Size()) return data[0]; //Индекс i выходит за границы вектора
 return data[i];
}
//*****************************************************************************
//СТАТУС: I.3; public; TComplexVector class overloading operator[]
//OVERLOADING THE SUBSCRIPT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex& operator[] (ulong i)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР [] класса TComplexVector
//Функция предназначена для доступа к одному элементу вектора.
//Осуществляется проверка корректности индекса по которому располагается требуе-
//мый элемент вектора. Функция вызывается во всех пользовательских функциях,
//кроме вызова в операторе присваивания и конструкторе копирования, т.к. в
//качестве аргументов последних передается константный объект.
//Доступ к членам-данным константных объектов можно осуществлять только с исполь-
//зованием константных функций.
//ПРИМЕР ВЫЗОВА: V[3], где i=3 - индекс элемента комплексного вектора. Нумерация
//элементов вектора начинается с 0.
//Если индекс элемента вектора некорректен, то возвращается его первый элемент.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong i - индекс элемента вектора
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex& value - ссылка на a[i] компонент вектора
//*****************************************************************************
complex& TComplexVector::operator[] (ulong i)
{if (Size() == 0L) return data[0];//Доступ к вектору нулевого размера
 //Проверка корректности индексов доступа к элементу вектора
 if (i >= Size()) return data[0];  //Индекс i выходит за границы вектора
 return data[i];
}
//*****************************************************************************
//СТАТУС: I.4; public; TComplexVector class overloading operator[]
//OVERLOADING SUBSCRIPT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: const complex operator[] (ulong i) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР [] класса TComplexVector
//Функция предназначена для доступа к одному элементу вектора.
//Осуществляется проверка корректности индекса по которому располагается требуе-
//мый элемент вектора. Функция вызывается в операторе присваивания и конструкто-
//ре копирования, т.к. в качестве их аргументов передается константный объект.
//Доступ к членам-данным константных объектов можно осуществлять только с исполь-
//зованием константных функций.
//ПРИМЕР ВЫЗОВА: A[3], где i=3 - индекс комплексного вектора. Нумерация элемен-
//тов вектора начинается с 0.
//Если индекс элемента вектора некорректен, то возвращается его первый элемент.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong i - индекс элемента вектора
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: const complex value - a[i] компонент вектора
//*****************************************************************************
const complex TComplexVector::operator[] (ulong i) const
{if (Size() == 0L) return data[0];//Доступ к вектору нулевого размера
 //Проверка корректности индексов доступа к элементу вектора
 if (i >= Size()) return data[0]; //Индекс i выходит за границы вектора
 return data[i];
}
//*****************************************************************************
//СТАТУС: I.5; public; TComplexVector class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: operator =(const TComplexVector& V)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ класса TComplexVector.
//Функция осуществляет копирование характеристик и значений элементов из одного
//комплексного вектора в другой. Осуществляется корректное копирование членов-
//указателей на данные копируемого класса в создаваемый класс с целью недопуще-
//ния ссылок указателей разных объектов класса на одно и то же место памяти.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TComplexVector& V - ссылка на копируемый вектор
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TComplexVector::operator =(const TComplexVector& V)
{//Предотвращение попытки присваивания объекта самому себе
 if (this == &V) return;
 Resize(V.Size()); SetType(V.Type());//Установка свойств копирующего вектора
 //Копирование значений элементов вектора V
 for (ulong i = 0L; i < Size(); i++) data[i] = V.Get(i);
}
//*****************************************************************************
//СТАТУС: I.6;  TComplexVector class friend overloading operator <<
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend ostream& operator <<(ostream& out, const TComplexVector& V)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВЫВОДА класса TComplexVector.
//Функция предназначена для вывода в поток характеристик вектора и ее элементов.
//Функция возвращает ссылку на поток, что позволяет записывать в программе опе-
//раторы вывода в поток каскадно. Формат вывода значений элементов вектора:
// <x;>, где x - значениe элемента вектора.
//При выводе элементов комплексного вектора приняты следующие соглашения:
//1. Все элементы вектора имеют ширину вывода равную наибольшей символьной длине
//   элемента вектора, который определяется функцией MaxStrLen(...)
//2. Выводятся только отрицательные знаки чисел.
//3. Точность вывода чисел с плавающей точкой определяется установленным до вы-
//   вода элементов матрицы значением функции потокового вывода precision. Мак-
//   симально возможное количество значащих цифр - 19.
//4. Элементы вектор-строки выводятся в строку, а вектор-столбца - в столбец.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на объект потока вывода
//2. сonst TComplexVector& V - ссылка на вектор, выводимый в поток.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ostream& out - ссылка на объект потока вывода.
//*****************************************************************************
ostream& operator <<(ostream& out, const TComplexVector& V)
{string s;
 uint precision = out.precision();
 long flags = out.flags();
 V.Properties(s); //Получение свойств вектора V в виде строки
 out << s;//Вывод характеристик вектора
 if (V.Size() == 0L) return out;
 //Определение типа вектора: вектор-строка или вектор-столбец
 bool ColVector = V.IsColumn();
 //Определение максимальной символьной длины элемента матрицы
 uint MaxLen = MaxStrLen(V,precision);
 out.setf(ios::right);//Выравнивание по правому краю.
 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 complex value;
 //Вывод значений элементов комплексного вектора V в поток
 for (ulong i = 0L; i < V.Size(); i++)
 {value = V.Get(i);
  //Формирование символьного представления комплексного числа
  //Формирование реальной части комплексного числа
  if ((real(value) != 0) || (imag(value) == 0))
   text << setprecision(precision) << real(value);
  //Формирование мнимой части комплексного числа
  if (imag(value) != 0)
  {if ((imag(value) > 0) && (real(value) != 0))
    text << "+" << setprecision(precision) << imag(value);
   else if ((imag(value) > 0) && (real(value) == 0))
    text << setprecision(precision) << imag(value);
   else if (imag(value) < 0)
    text << setprecision(precision) << imag(value);
   text << "i;";
  }
  else text << ";";
  text << ends;
  s.assign(text.str()); text.seekp(0);
  out << setw(MaxLen) << s;

  if ((V.Size()-i) > 1) out << " ";
  //Элементы вектора-столбца выводятся с новой строки
  if (ColVector == true) out << endl;
 }
 out.flags(flags);
return out;
}
//*****************************************************************************
//СТАТУС: I.7; public; TComplexVector class overloading operator ==
//OVERLOADING COMPARISON OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ==(const TComplexVector& V) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СРАВНЕНИЯ ДВУХ ВЕКТОРОВ.
//Функция реализует перегрузку оператора (==) с целью сравнения двух комплексных
//векторов X(x1,...,xn) и Y(y1,...,yn). N-мерные вектора X = (x1,x2,...,xN)
//и Y = (y1,y2,...,yN) считаются РАВНЫМИ, если их соответствующие компоненты
//совпадают, т.е. если xi = yi для i = 1,2,...,n. Сравнивать можно только векто-
//ры ОДНОГО ТИПА и ОДНОЙ РАЗМЕРНОСТИ. Если векторы равны, то возвращается true,
//в противном случае - false. Если векторы разных типов (вектор-строка и вектор-
//столбец), разной размерности или при попытке сравнения с вектором нулевой раз-
//мерности возвращается false.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TComplexVector& V - ссылка на сравниваемый вектор.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool compare - результат сравнения
//*****************************************************************************
bool TComplexVector::operator ==(const TComplexVector& V) const
{//Операция сравнения производится с вектором (векторами) нулевого размера
 if ((Size() == 0L) && (V.Size() == 0L)) return true;
 //Операция сравнения производится с векторами разной размерности
 if (Size() != V.Size()) return false;
 //Операция сравнения производится с векторами разных типов
 if (Type() != V.Type()) return false;
 //Покомпонентное сравнение векторов
 bool equal = true;
 for (ulong i = 0; i < Size(); i++)
  if (fabs(real(data[i]) - real(V.data[i])) > EPS ||
      fabs(imag(data[i]) - imag(V.data[i])) > EPS)
  {equal = false;
   break; //Преждевременный выход из цикла сравнения компонент векторов
  }
 return equal;//Результат сравнения векторов
}
//*****************************************************************************
//СТАТУС: I.8; public; TComplexVector class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator =(const double value)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ КОМПОНЕНТАМ ВЕКТОРА
//            ДЕЙСТВИТЕЛЬНОГО ЧИСЛА.
//Функция осуществляет присваивание ВСЕМ компонентам вектора значения value.
//При попытке присваивания вектору нулевой размерности действительного числа
//возвращается false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const double value - присваеваемое вектору значение
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции
//******************************************************************************
bool TComplexVector::operator =(const double value)
{if (Size() == 0L) return false;//Присваивание вектору нулевого размера
 //Цикл присваивания компонентам вектора значения value
 for (ulong i = 0; i < Size(); i++) data[i] = value;
 return true;
}
//*****************************************************************************
//СТАТУС: I.9; public; TComplexVector class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator =(const complex value)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ ВСЕМ КОМПОНЕНТАМ ВЕКТОРА
//            КОМПЛЕКСНОГО ЧИСЛА.
//Функция осуществляет присваивание ВСЕМ компонентам вектора значения value.
//При попытке присваивания вектору нулевой размерности комплексного числа
//возвращается false.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const complex value - присваиваемое вектору значение.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции
//*****************************************************************************
bool TComplexVector::operator =(const complex value)
{if (Size() == 0L) return false;//Присваивание вектору нулевого размера
 //Цикл присваивания компонентам вектора значения value
 for (ulong i = 0; i < Size(); i++) data[i] = value;
 return true;
}
//*****************************************************************************
//СТАТУС: I.10; public; TComplexVector class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector& operator =(const TRealVector& V)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ ЭЛЕМЕНТОВ ВЕЩЕСТВЕННОГО
//            ВЕКТОРА TRealVector КОМПЛЕКСНОМУ ВЕКТОРУ TComplexVector
//Функция осуществляет копирование характеристик и значений элементов из вещест-
//венного вектора в комплексный вектор. Осуществляется корректное копирование
//членов-указателей на данные копируемого класса в создаваемый класс с целью
//недопущения ссылок указателей разных объектов класса на одно и то же место
//памяти.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TRealVector& V - ссылка на копируемый вектор.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector& this - ссылка на исходный комплексный вектор
//*****************************************************************************
cvector& TComplexVector::operator =(const TRealVector& V)
{Resize(V.Size()); SetType(V.Type()); //Установка свойств копирующего вектора
 //Копирование значений элементов вектора V
 for (ulong i = 0L; i < Size(); i++) data[i] = V.Get(i);
return *this;
}
//==============================================================================
// II. РЕАЛИЗАЦИЯ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TComplexVector
//     PRIVATE MEMBER-FUNCTION OF TComplexVector CLASS REALIZATION
//==============================================================================
//******************************************************************************
//СТАТУС: II.1., private TComplexVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Initial()
//НАЗНАЧЕНИЕ: Начальная инициализация характеристик комплексного вектора при его
//конструировании.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexVector::Initial()
{//Начальная инициализация защищенных членов-данных класса
 type = V_ZEROSIZE;//Комплексный вектор нулевого размера
 size = 0L;        //Установка размерности вектора
 data = NULL;      //Установка указателя на элементы вектора в NULL
}
//******************************************************************************
//СТАТУС: II.2., private TComplexVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Create()
//НАЗНАЧЕНИЕ: Распределение оперативной памяти под элементы комплексного вектора
//без начальной инициализации элементов. Количество элементов вектора определяется
//переменной size. Если size равна 0, то создается вектор нулевого размера. В
//случаес нехватки памяти возвращается false. Элементы комплексного вектора хра-
//нятся в одномерном массиве data.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//******************************************************************************
bool TComplexVector::Create()
{if (Size() == 0) {Initial(); return true;} //Вектор нулевого размера
 //Распределение памяти под элементы вектора
 try
  { data = new complex[Size()]; //Распределение памяти под элементы вектора
  }
  // ENTER THIS BLOCK ONLY IF xalloc IS THROWN.
  // YOU COULD REQUEST OTHER ACTIONS BEFORE TERMINATING
  catch (std::bad_alloc) {Initial(); return false;}//xalloc x
 return true;
}
//******************************************************************************
//СТАТУС: II.3., private, TComplexVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Delete()
//НАЗНАЧЕНИЕ: Удаление из оперативной памяти элементов комплексного вектора.
//После завершения работы функции получается вектор нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexVector::Delete()
{//Проверка на вектор нулевого размера
 if (data == NULL) {Initial(); return;} //Вектор нулевого размера
 delete[] data;//Удаление элементов вектора
 Initial();
}
//==============================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TComplexVector
//    ОПРЕДЕЛЕНИЯ ТИПА КОМПЛЕКСНОГО ВЕКТОРА
//    PUBLIC MEMBER-FUNCTION OF TComplexVector CLASS REALIZATION
//==============================================================================
//******************************************************************************
//СТАТУС: I.1., public, TComplexVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsZeroSize() const
//НАЗНАЧЕНИЕ: Проверка комплексного вектора на вектор нулевого размера. В случае
//удачи функция возвращает - true и false - в противном случае. Свойства вектора
//нулевого размера: size == 0 || data == NULL
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - вектор со всеми нулевыми элементами;
//                false - не нулевой вектор.
//*****************************************************************************
bool TComplexVector::IsZeroSize() const
{//Проверка на size == 0
 return (Size() == 0L) ? true : false;
}
//*****************************************************************************
//СТАТУС: I.2., public, TComplexVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsZero() const
//НАЗНАЧЕНИЕ: Проверка комплексного вектора на вектор со всеми нулевыми элемента-
//ми. В случае удачи функция возвращает - true и false - в противном случае.
//Свойства комплексного вектора со всеми нулевыми элементами:
//1. size != 0 - вектор должен быть не НУЛЕВОГО РАЗМЕРА;
//2. V[i] = 0 - ВСЕ элементы вектора должны быть равны НУЛЮ.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - вектор со всеми нулевыми элементами;
//                false - не нулевой вектор.
//*****************************************************************************
bool TComplexVector::IsZero() const
{bool lSuccess = false;
 if (IsZeroSize()) return lSuccess;//Вектор нулевого размера
 lSuccess = true;
 for (ulong i = 0; i < Size(); i++) //Цикл проверки свойства 2
 {//Все элементы д.б. нулевыми
  if ((fabs(real(data[i])) > EPS) || (fabs(imag(data[i])) > EPS))
  {lSuccess = false; break;}
 }
return lSuccess;
}
//******************************************************************************
//СТАТУС: I.3., public, TComplexVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsScalar() const
//НАЗНАЧЕНИЕ: Проверка комплексного вектора на СКАЛЯРНЫЙ ВЕКТОР. В случае удачи
//функция возвращает - true и false - в противном случае. Свойства комплексного
//скалярного вектора:
//1. size != 0 - вектор должен быть не НУЛЕВОГО РАЗМЕРА;
//2. V[i] = a - ВСЕ элементы вектора должны быть равны между собой и отличны от
//   нуля.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - вектор скалярный;
//                false - вектор не скалярный.
//******************************************************************************
bool TComplexVector::IsScalar() const
{bool lSuccess = false;
 if (IsZeroSize()) return lSuccess; //Вектор нулевой длины
 //Цикл проверки свойства 2
 if ((fabs(real(data[0])) < EPS) && (fabs(imag(data[0])) < EPS)) return lSuccess;
 lSuccess = true;
 complex a = data[0];
 for (ulong i = 1; i < Size(); i++)
 {//Все элементы д.б. равными a
  if ((fabs(real(data[i]) - real(a)) > EPS) ||
      (fabs(imag(data[i]) - imag(a)) > EPS))
  {lSuccess = false; break;}
 }
return lSuccess;
}
//******************************************************************************
//СТАТУС: I.4., public, TComplexVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsUnit() const
//НАЗНАЧЕНИЕ: Проверка комплексного вектора на ЕДИНИЧНЫЙ ВЕКТОР. В случае удачи
//функция возвращает - true и false - в противном случае. Свойства комплексного
//единичного вектора:
//1. size != 0 - вектор должен быть не НУЛЕВОГО РАЗМЕРА;
//2. V[i] = 1 - ВСЕ элементы вектора должны быть равны 1.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - вектор единичный;
//                false - вектор не единичный.
//******************************************************************************
bool TComplexVector::IsUnit() const
{bool lSuccess = false;
 if (IsZeroSize()) return lSuccess;//Вектор нулевой длины
 lSuccess = true;
 for (ulong i = 0; i < Size(); i++) //Цикл проверки свойства 2
 {//Все элементы д.б. равны (1,0) с точностью EPS
  if ((fabs(real(data[i]) - 1.0) > EPS) && (fabs(imag(data[i])) > EPS))
  {lSuccess = false; break;}
 }
return lSuccess;
}

//========================================================================================
// III. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TComplexVector
//      PROTECTED MEMBER-FUNCTION OF TComplexVector CLASS REALIZATION
//========================================================================================
//----------------------------------------------------------------------------------------
// III. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ФУНКЦИЙ КЛАССА TComplexVector
//      КОНСОЛЬНОГО ВВОДА ЭЛЕМЕНТОВ КОМПЛЕКСНОГО ВЕКТОРА
//----------------------------------------------------------------------------------------
//****************************************************************************************
//СТАТУС: III.5., protected, TComplexVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutVector(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ КОМПЛЕКСНОГО ВЕКТОРА
//Функция вводит значения элементов комплексного вектора. Формат ввода элементов вектора:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <vector name>;
//      TYPE: <vector type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>]: <complex value>.
//Функция позволяет вводить комплексные векторы TComplexVector произвольных типов. При вводе
//элементов вектора проверяется корректность комплексных чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование комплексного вектора;
//2. bool confirm - опция подтверждения введеных данных каждого элемента вектора.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TComplexVector::InPutVector(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемого вектора
 cout << endl;
 cout << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << "     " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода всех элементов действительного вектора
 for (ulong i = 0; i < Size(); i++)
 {cout << name << "[" << (i+1) << "]: ";
   data[i] = EditComplex(confirm); //Ввод i-го элемента вектора
   ClrScr(x,y);//Очистка экрана
 }
 cout << "All elements of " << GetCompleteType(s) << " <" << name
      << "> are entered!" << endl;
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.2., protected, TComplexVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutScalar(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ СКАЛЯРНОГО ВЕКТОРА
//Функция вводит значения элементов скалярного вектора. Формат ввода элементов вектора:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <vector name>;
//      TYPE: <vector type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//Elements value: <real value>.
//При вводе элементов вектора осуществляется проверка их корректности.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование комплексного вектора;
//2. bool confirm - подтверждение введеных данных по каждому элементу вектора.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TComplexVector::InPutScalar(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 complex value;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемого вектора
 cout << endl;
 cout << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << "     " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Обнуление элементов вектора
 for (ulong i = 0L; i < Size(); i++) data[i] = C_ZERO;
 //Ввод первого элемента скалярного вектора
 cout << "Element value: ";
 value = EditComplex(confirm); //Ввод элемента вектора
 //Цикл присваивания элементам скалярного вектора значения value
 for (ulong i = 0L; i < Size(); i++) data[i] = value;
 ClrScr(x,y);//Очистка экрана
 cout << "All elements of " << GetCompleteType(s) << " <" << name
      << "> are entered!" << endl;
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}

//==============================================================================
//    РЕАЛИЗАЦИЯ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССУ TComplexVector
//    REALIZATION of THE FRIEND FUNCTION TO TComplexVector CLASS
//==============================================================================
//******************************************************************************
//СТАТУС: FRIEND FUNCTION to TRealVector class # 1
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend uint MaxStrLen(const TComplexVector& V, uint precision)
//НАЗНАЧЕНИЕ:
//Функция определяет максимальный символьный размер элемента комплексного векто-
//ра V. Функция используется для рационального отображения элементов комплексно-
//го вектора.
//При вычислении максимальной символьной длины приняты следующие соглашения:
//1. Точность представления реальной и мнимой частей комплексного числа равна
//   precision.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TComplexVector& V - ссылка на комплексный вектор.
//2. uint precision - количество выводимых цифр чисел с плавающей точкой.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//uint MaxLen - максимальная символьная длина элемента вектора V.
//******************************************************************************
uint MaxStrLen(const TComplexVector& V, uint precision)
{uint MaxLen = 0;
 if (V.IsZeroSize()) return MaxLen; //Вектор нулевого размера
 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 complex z;
 uint count;
 //Цикл считывания элементов комплексного вектора
 for (ulong i = 0L; i < V.Size(); i++)
 {z = V.Get(i);
  //Формирование символьного представления комплексного числа
  //Анализ реальной части числа
  if ((real(z) != 0) || (imag(z) == 0))
   text << setprecision(precision) << real(z);
  //Анализ мнимой части числа
  if (imag(z) != 0)
  {if (imag(z) > 0) text << "+" << setprecision(precision) << imag(z);
   else text << setprecision(precision) << imag(z);
   text << "i;";
  }
  else text << ";";
  text << ends;
  //Определение максимальной символьной длины элемента комплексного вектора
  count = text.pcount()-1;
  if (count > MaxLen) MaxLen = count;
  text.seekp(0);
 }
return MaxLen;
}
//***************** Конец реализации класса TComplexVector *********************

//*****************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TIntVector
//*****************************************************************************

//==============================================================================
//  РЕАЛИЗАЦИЯ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TIntVector
//   TIntVector CLASS CONSTRUCTORs & DESTRUCTOR REALIZATION
//==============================================================================
//*****************************************************************************
//СТАТУС: 1; public TIntVector constructor by default
//НАИМЕНОВАНИЕ ФУНКЦИИ: TIntVector()
//НАЗНАЧЕНИЕ: Конструктор по умолчанию класса TIntVector.
//Функция предназначена для создания класса TIntVector по умолчанию. По
//умолчанию конструируется целочисленный вектор нулевого размера - V_ZEROSIZE.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TIntVector::TIntVector() {Initial();}
//*****************************************************************************
//СТАТУС: 2; public TIntVector constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TIntVector(ulong Size, bool Type, long Init = 0L)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TIntVector.
//   Функция создает экземпляр класса TIntVector согласно переданных параметров.
//Конструктор использует вызов функции Set(Size,Type,Init), создавая векторы двух
//типов - вектор-строку или вектор-столбец и инициализируя их значением Init.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong Size - размерность вектора;
//2. bool Type  - тип вектора (COL || ROW);
//3. double Init (0.0) - инициализирующее значение для элементов вектора.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TIntVector::TIntVector(ulong Size, bool Type, long Init)
{Initial();//Начальная инициализация членов-данных класса
 Set(Size,Type,Init);//Установка характеристик вектора
}
//******************************************************************************
//СТАТУС: 3; public TIntVector constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TIntVector(ulong Size, long Init)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TIntVector.
//Функция предназначена для создания класса TIntVector согласно переданных
//параметров. По умолчанию: type = ROW.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ulong Size - размерность вектора
//2. const long Init  - инициализирущая величина
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TIntVector::TIntVector(ulong Size, long Init)
{Initial();//Начальная инициализация членов-данных класса
 Set(Size,ROW,Init);//Установка характеристик вектора
}
//******************************************************************************
//СТАТУС: 4; public TIntVector class copy constructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: TIntVector(const TIntVector& V)
//НАЗНАЧЕНИЕ: Конструктор копирования класса TIntVector.
//Функция предназначена для создания класса TIntVector по характеристикам
//аналогичного класса и копирования значений его элементов. Осуществляется кор-
//ректное копирование членов-указателей на данные копируемого класса в создавае-
//мый класс с целью недопущения ссылок указателей разных объектов класса на одно
//и то же место памяти. Для процедуры копирования используется ПЕРЕГРУЖЕННЫЙ
//ОПЕРАТОР ПРИСВАИВАНИЯ.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TIntVector& V - ссылка на объект класса TIntVector.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TIntVector::TIntVector(const TIntVector& V)
{Initial();//Начальная инициализация членов-данных класса
 *this = V;//Установка характеристик вектора, вызовом перегруженного оператора =
}
//******************************************************************************
//СТАТУС: 5; public TIntVector class destructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: ~TIntVector()
//НАЗНАЧЕНИЕ: ДЕСТРУКТОР класса TIntVector
//Функция предназначена для удаления объекта класса TIntVector после завершения
//работы с ним. В ходе работы деструктор освобождает оперативную память занятую
//элементами и характеристиками целочисленного вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TIntVector::~TIntVector() {Delete();}

//==============================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TIntVector
//    PUBLIC MEMBER-FUNCTION OF TIntVector CLASS REALIZATION
//==============================================================================
//******************************************************************************
//СТАТУС: I.1, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& GetType(string& s, bool brief = OFF, uint language = ENG) const
//НАЗНАЧЕНИЕ: Формирование наименования типа вектора на русском или английском
//языке, в сокращенном или полном формате. Допускается многоязычный интерфейс
//корректировкой кода функции. Язык по умолчанию - английский. Формирование типа
//вектора (строка или столбец) осуществляется в строке s, передаваемой по ссылке.
//Функция возвращает ссылку на строку с наименованием типа вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку для формирования имени типа вектора
//2. bool brief (OFF) - сокращенный или полный формат имени типа вектора
//3. uint language [ENG] - язык наименования типа вектора
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// string& s - ссылка на строку с сформированным именем типа вектора
//******************************************************************************
string& TIntVector::GetType(string& s, bool brief, uint language) const
{if (language == RUS) //Формирование наименования типа вектора на русском языке
 {if (brief) s = (IsRow()) ? "строка" : "столбец";
  else s = (IsRow()) ? "Вектор-строка" : "Вектор-столбец";
 }
 else //Формирование наименования типа вектора на английском языке
 {if (brief) s = (IsRow()) ? "row" : "column";
  else s = (IsRow()) ? "Vector-row" : "Vector-column";
 }
return s;
}
//******************************************************************************
//СТАТУС: I.2, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: const char* GetSubType(uint language = ENG) const
//НАЗНАЧЕНИЕ: Получение  наименования подтипа вектора. Таблица соответствия под-
//типов вектора с ее наименованиями представлена массивом VectorName. В массиве
//хранятся наименования векторов на русском и английском языке. Индексом для по-
//лучения имени вектора служит ее подтип (subtype). Осуществляется обработка
//некорректного задания языка имени подтипа. Допускается многоязычный интерфейс
//корректировкой структуры MATRIX_NAME и массива VectorName. Язык по умолчанию -
//английский.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint language [ENG] - язык наименования подтипа вектора
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// const char *s - указатель на наименование вектора в таблице VectorName
//******************************************************************************
const char* TIntVector::GetSubType(uint language) const
{char* s; //Указатель на строку
 uint index = SubType();
 switch (language)
 { case RUS: //указать наименование подтипа вектора на русском языке
    s = VectorName[index].rus_name; break;
   case ENG: //указать наименование подтипа вектора на английском языке
    s = VectorName[index].eng_name; break;
   //Наименование подтипа вектора на заданном языке отсутствует
   default: //указать наименование подтипа вектора на английском языке
    s = VectorName[index].eng_name; break;
 }
return s;
}
//******************************************************************************
//СТАТУС: I.3, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& GetCompleteType(string& s, uint language = ENG) const
//НАЗНАЧЕНИЕ: Формирование полного наименования типа вектора (type + subtype) на
//русском или английском. Допускается многоязычный интерфейс корректировкой кода
//функции. Язык  по  умолчанию - английский. Формирование  полного  типа вектора
//(строка или столбец)  осуществляется в строке s, передаваемой по ссылке. Функ-
//ция возвращает ссылку на строку с наименованием полного типа вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку для формирования имени полного типа вектора
//2. uint language [ENG] - язык наименования полного типа вектора
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// string& s - ссылка на строку с сформированным именем полного типа вектора
//******************************************************************************
string& TIntVector::GetCompleteType(string& s, uint language) const
{GetSubType(s, language);//Формирование наименования подтипа вектора
 //Формирование типа вектора
 if (SubType() > V_NUMBER) {string t; GetType(t,ON,language); s.append("-"+t);}
 return s;
}
//******************************************************************************
//СТАТУС: I.4; public member-function of class TIntVector
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Properties(string& s) const
//НАЗНАЧЕНИЕ: Функция формирует характеристики TIntVector в виде строки.
//ПРИМЕР: TYPE: <complete vector type>; DIMENSION: <size>.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строковый объект
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами вектора
//******************************************************************************
string& TIntVector::Properties(string& s) const
{char buffer[80];
 string t;
 ostrstream text(buffer, sizeof(buffer));
 s.resize(0);
 //-----------------------------------------------------------------------------
 //1. Формирование наименования типа вектора
 s.append("TYPE: ");
 text << "Integer " << GetCompleteType(t) << ", " << ends;
 s.append(text.str()); text.seekp(0);
 //2. Формирование размерности вектора
 s.append("DIMENSION: ");
 text << Size() << ";" << endl << ends;
 s.append(text.str()); text.seekp(0);
return s;
}
//******************************************************************************
//СТАТУС: I.5, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: uint SubType() const
//НАЗНАЧЕНИЕ: Определение подтипа вектора (нулевой вектор, единичный вектор,
//скалярный вектор и т.д.) согласно их классификации.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint subtype - подтип вектора
//******************************************************************************
uint TIntVector::SubType() const
{if (Size() == 0) return V_ZEROSIZE; //Вектор нулевого размера
 else if (Size() == 1) return V_NUMBER; //Вектор размера единица
 else if (IsZero()) return V_ZERO; //Проверка на нулевую вектор-строку
 else if (IsUnit()) return V_UNIT; //Проверка на единичную вектор-строку
 else if (IsScalar()) return V_SCALAR; //Проверка на скалярную вектор-строку
 return V_ORDINARY;
}
//******************************************************************************
//СТАТУС: I.6, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool Set(ulong VectorSize, bool VectorType, long Init = 0L)
//НАЗНАЧЕНИЕ: Функция устанавливает новые характеристики целочисленного вектора.
//При установке новых характеристик вектора все старые характеристики аннулируются,
//значения элементов вектора уничтожаются, устанавливаются новые размеры вектора.
//Функция устанавливает  два типа вектора: вектор-строку или вектор-столбец и
//инициализирует элементы вектора значением Init.
//Функция возвращает false, в случае невозможности выделения памяти под новый
//размер вектора (в этом случае вектор становится нулевого размера).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong VectorSize - размерность целочисленного вектора;
//2. bool VectorType  - тип вектора (COL || ROW);
//3. long Init (0L) - инициализирующее значение.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TIntVector::Set(ulong VectorSize, bool VectorType, long Init)
{//Анализ на соответствие размеров старого и нового вектора
 if (Size() != VectorSize)
 {Delete();//1. Удаление элементов вектора со старыми размерами
  size = VectorSize;//2. Установка новых размеров вектора
  //3. Распределение памяти под хранение элементов вектора с новыми свойствами
  if (Create() == false) return false;
 }
 type = VectorType;
 //Инициализация элементов вектора
 for (ulong i = 0L; i < Size(); i++) data[i] = Init;
 return true;
}
//******************************************************************************
//СТАТУС: I.7, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Resize(const ulong NewSize, bool Restore = OFF)
//НАЗНАЧЕНИЕ: Функция изменяет размер вектора с возможностью восстановления зна-
//чений элементов вектора предыдущего размера.
//Функция возвращает false, в случае невозможности выделения памяти под новый
//размер вектора (в этом случае вектор становится нулевого размера).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ulong Size - новая размерность вектора
//2. bool Restore - опция восстановления значений элементов вектора предыдущего
//   размера
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TIntVector::Resize(const ulong NewSize, bool Restore)
{//Проверка на совпадение старого и нового размеров вектора
 if (NewSize == Size()) return true;
 ivector V;
 if (Restore == ON) V = *this;
 bool OldType = Type();
 Delete();//Удаление элементов вектора старого размера
 //Установка свойств вектора
 size = NewSize; type = OldType;
 //Распределение памяти под новый размер вектора
 if (Create() == false) return false;
 if (Restore == ON) //Восстановление предыдущих значений элементов вектора
 {ulong Count = (V.Size() > Size()) ? Size() : V.Size();
   for (ulong i = 0L; i < Count; i++) data[i] = V[i];
 }
 return true;
}
//***********************************************************************************
//СТАТУС: I.8, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Rand()
//НАЗНАЧЕНИЕ: Инициализация элементов вектора случайными величинами, распределенными
//по равновероятному закону. Функция возвращает false для вектора нулевой длины.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//***********************************************************************************
bool TIntVector::Rand()
{//Вектор нулевого размера не инициализируется
 if (Size() == 0L) return false;
 TRandomGenerator RNG(T_4);//Создание генератора случайных чисел
 //Инициализация элементов вектора СВ
 for (ulong i = 0L; i < Size(); i++) data[i] = RNG.Rand();
 return true;
}
//****************************************************************************************
//СТАТУС: I.9, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНОЕ РЕДАКТИРОВАНИЕ СВОЙСТВ и ЭЛЕМЕНТОВ ВЕКТОРА
//Функция вводит/редактирует ВСЕ значения элементов вектора и ее свойства в консольном
//режиме. В зависимости от типа целочисленного вектора подключается функция ввода элементов
//для данного вектора. Предусмотрен режим ввода элементов вектора с подтверждением введенных
//данных каждого его элемента. Строка name задает наименование вектора. При вводе каждого
//элемента вектора предусматривается контроль корректности вводимых данных. При работе
//функции значения элементов вектора изменяются безвозвратно. Формат ввода следующий:
//----------------------------------------------------------------------------------------
//MODE: EDIT REAL VECTOR <name>
//TYPE: <vector type>; DIMENSION: <Size()>.
//----------------------------------------------------------------------------------------
//Select option:
//1. Change vector performance;
//2. Edit vector elements;
//3. Exit
//Enter number [1-3]: _
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование вектора;
//2. bool confirm - подтверждение введеных данных по каждому элементу вектора.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TIntVector::Edit(const string& name, bool confirm)
{const string line(78,'-');
 STR_UINT Option[3] = {
  {1, "Change vector's properties" },
  {2, "Edit vector elements" },
  {3, "Exit" } };
 TB_STR_UINT TbOption = {3, Option};

 string head,t;
 uint nChoice;
 do //Начало цикла редактирования
 {//----------------------------------------------------------------------------
  //Вывод заголовка и свойств редактируемого вектора
  clrscr(); //Очистка экрана
  cout << line << endl;
  cout << "MODE: EDIT INTEGER VECTOR - <" << name << ">" << endl;
  cout << "     " << Properties(head);
  cout << line << endl;
  //----------------------------------------------------------------------------
  head =  " Select option: ";
  nChoice = ConsoleChoice(TbOption, 3, head.c_str(), 2);
  //Анализируем выбор пользователя
  if (nChoice == 1) //Изменение характеристик редактируемого вектора
  {PF_VECTOR Info;
   InPutPF_VECTOR(Info, name.c_str());
   Set(Info.size,Info.type);
   if (Info.subtype == V_NUMBER || Info.subtype == V_ORDINARY) Rand();
   if (Info.subtype == V_UNIT) *this = 1;
   if (Info.subtype == V_SCALAR) *this = 2;
   cout << "New real vector's properties have just installed!" << endl;
   cout << "Vector is initialized according to its extended type." << endl;
   cout << "Press any key...\a"; getch();
  }
  else if (nChoice == 2) //Редактирование элементов
  {clrscr(); //Очистка экрана
   switch (SubType()) //Определение подтипа вектора
   {case V_ZEROSIZE: //Вектор нулевой длины (нулевого размера)
     cout << "\nMODE: INPUT ELEMENTS of <" << GetSubType(t) << ">" << endl;
     cout << "WARNING! Input elements of this vector are impossible." << endl;
     cout << "Press any key...\a"; getch();
     break;
    case V_ZERO: //Ввод элементов нулевого вектора
     break;
    case V_UNIT: //Ввод элементов единичного вектора
     break;
    case V_SCALAR: //Ввод элементов скалярного вектора
     InPutScalar(name,confirm);
     break;
    default: //Стандартный ввод элементов действительного вектора
     InPutVector(name,confirm);
   }
  }
  else if (nChoice == 3) //Выход из режима редактирования
  {//Запрос на выход из режима редактирования
   char c;
   cout << "Would you like to leave from the edit mode? [y/n]: "; cin >> c;
   if ((c == 'y') || (c == 'Y')) {clrscr(); break;}
  }
 } while (true); //Завершение цикла редактирования
}
//****************************************************************************************
//СТАТУС: I.10, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& ConvertToString(string& s, string& sep, string& etc, ulong count) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ СИМВОЛЬНОГО ПРЕДСТАВЛЕНИЯ ЗНАЧЕНИЙ ЭЛЕМЕНТОВ ВЕКТОРА
//Функция преобразует целые значения элементов вектора в их символьное представление и
//формирует строку s, состоящую из count элементов вектора, начиная с нулевого элемента.
//Элементы вектора разделяются символами строки sep (по умолчанию - пробелами). Если аргумент
//count указывает не на все элементы вектора, то за последним элементом выводится строка etc
//(по умолчанию - "..."). Формат вывода следующий:
//----------------------------------------------------------------------------------------
// <V[0]> <sep> <V[1]> <sep> ... <V[count-1]> [ <etc> ]
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку с формируемыми значениями элементов вектора;
//2. string& sep - символы-разделители между значениями элементов вектора;
//3. string& etc - строка, выводимая за последним значением элемента вектора,
//   если count != Size().
//4. ulong count - количество выводимых значений элементов вектора, начиная с
//   нулевого значения;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, содержащую символьное представление значений
//элементов вектора.
//****************************************************************************************
string& TIntVector::ConvertToString(string& s, string& sep, string& etc, ulong count) const
{char buffer[80];
 ostrstream text (buffer, sizeof(buffer));
 s.resize(0);
 //Анализ на вектор нулевого размера
 if (Size() == 0L) {s = "Null vector"; return s;}
 //Установка корректных параметров
 if ((count == 0L) || (count >= Size())) count = Size();
 if (sep.empty()) sep.assign(1,' ');
 if (etc.empty()) etc.assign("...");
 //Формирование значений элементов вектора
 for (ulong i = 0L; i < count; i++)
 {text << data[i];
  if (count-i > 1) text << sep;
  text << ends;
  s.append(text.str());
  text.seekp(0);
 }
 //Вывод строки etc
 if (count != Size()) {s.append(" "); s.append(etc);}
return s;
}
//****************************************************************************************
//СТАТУС: I.10a, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& ConvertToString(string& s, ulong count, char* sep = NULL, char* etc = NULL) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ СИМВОЛЬНОГО ПРЕДСТАВЛЕНИЯ ЗНАЧЕНИЙ ЭЛЕМЕНТОВ ВЕКТОРА
//Функция преобразует целые значения элементов вектора в их символьное представление и
//формирует строку s, состоящую из count элементов вектора, начиная с нулевого элемента.
//Элементы вектора разделяются символами строки sep (по умолчанию - пробелом). Если аргумент
//count указывает не на все элементы вектора, то за последним элементом выводится строка etc
//(по умолчанию - "..."). Формат вывода следующий:
//----------------------------------------------------------------------------------------
// <V[0]> <sep> <V[1]> <sep> ... <V[count-1]> [ <etc> ]
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку с формируемыми значениями элементов вектора;
//2. ulong count - количество выводимых значений элементов вектора, начиная с нулевого
//   значения;
//3. char* sep - символы-разделители между значениями элементов вектора;
//4. char* etc - строка, выводимая за последним значением элемента вектора, если
//   count != Size().
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с элементами вектора.
//****************************************************************************************
string& TIntVector::ConvertToString(string& s, ulong count, char* sep, char* etc) const
{char buffer[80];
 ostrstream text (buffer, sizeof(buffer));
 s.resize(0);
 //Анализ на вектор нулевого размера
 if (Size() == 0L) {s = "Null vector"; return s;}
 //Установка корректных параметров
 if ((count == 0L) || (count >= Size())) count = Size();
 if (sep == NULL) sep = " ";
 if (etc == NULL) etc = "...";
 //Формирование значений элементов вектора
 for (ulong i = 0L; i < count; i++)
 {text << data[i];
  if (count-i > 1) text << sep;
  text << ends;
  s.append(text.str());
  text.seekp(0);
 }
 //Вывод строки etc
 if ((count != Size()) && (etc != NULL)) {s.append(" "); s.append(etc);}
return s;
}
//******************************************************************************
//СТАТУС: I.11, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:  ivector SubVector(ulong left, ulong right) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДВЕКТОРА ИЗ ДАННОГО ВЕКТОРА
//Функция формирует подвектор, начиная с элемента с индексом left, и до элемента
//с индексом right включительно. Если исходный вектор является вектором нулевого
//размера, то функция возвращает также подвектор нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left - левая граница;
//2. ulong right - правая граница;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ivector SubVector - подвектор исходного вектора
//******************************************************************************
ivector TIntVector::SubVector(ulong left, ulong right) const
{ivector SubVector(0L,Type());
 if (IsZeroSize()) return SubVector;//Вектор нулевого размера
 //Анализируем исключительные ситуации
 if (left > right) return SubVector;
 if ((left >= Size()) || (right >= Size())) return SubVector;
 if ((left == 0L) && (right == Size()-1)) return *this;
 //Формирование подвектора
 SubVector.Resize(right-left+1);
 for (ulong i = left; i <= right; i++) SubVector.Put(i-left,data[i]);
return SubVector;
}
//******************************************************************************
//СТАТУС: I.12, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:  ivector Unique() const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДВЕКТОРА ИЗ ДАННОГО ВЕКТОРА, ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
//            КОТОРОГО НЕ ПОВТОРЯЮТСЯ (УНИКАЛЬНЫ)
//Функция формирует подвектор из элементов исходного вектора, включая в него
//только неповторяющиеся значения. Таким образом, результирующий вектор будет
//состоять из всех значений элементов исходного вектора в единственном представ-
//лении. Если исходный вектор является вектором нулевого размера, то функция
//возвращает также подвектор нулевого размера. Если в исходном векторе значения
//элементов не повторяются, то результирующий вектор совпадет с исходным.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ivector SubVector - подвектор с уникальными значениями
//******************************************************************************
ivector TIntVector::Unique() const
{ivector Unique;
 if (Size() == 0L) return Unique;//Вектор нулевого размера
 //*****************************************************************************
 //1. Формирование списка с уникальными значениями элементов
 //*****************************************************************************
 std::list<long> List;
 std::list<long>::iterator Iterator;
 //Просмотр всех значений элементов исходного вектора
 for (ulong i = 0L; i < Size(); i++)
 {//Проверка на уникальность значения элемента вектора
  Iterator = std::find(List.begin(),List.end(),data[i]);
  if (Iterator == List.end()) List.push_back(data[i]);
 }
 //*****************************************************************************
 //2. Переписываем значения из списка List в данный вектор
 //*****************************************************************************
 //Устанавливаем размер исходного вектора равного размеру списка
 Unique.Resize(List.size()); Unique.SetType(Type());
 //Цикл копирования значений элементов списка List в исходный вектор
 for (ulong i = 0L; i < Unique.Size(); i++)
 {Unique.Put(i,List.front()); List.pop_front();}
return Unique;
}
//******************************************************************************
//СТАТУС: I.13, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ivector SubVector(const ivector& Index) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДВЕКТОРА ИЗ ДАННОГО ВЕКТОРА ПО ИНДЕКСАМ
//Функция формирует подвектор из элементов исходного вектора по индексам, значе-
//ния которых передаются через вектор индексов Index. Если исходный вектор или
//вектор индексов Index являются векторами нулевого размера, то функция возвра-
//щает также подвектор нулевого размера. Если Index содержит значения индексов,
//которые не соответствуют границам исходного вектора, то они игнорируются.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// const ivector& Index - ссылка на вектор со значениями индексов исходного век-
// тора по которым будет сформирован подвектор.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ivector SubVector - подвектор исходного вектора элементы, которого расположены
//по индексам, указанным в векторе Index.
//******************************************************************************
ivector TIntVector::SubVector(const ivector& Index) const
{ivector SubVector;
 //Проверка исходного вектора и вектора со значениями индексов на нулевой размер
 if (IsZeroSize() || Index.IsZeroSize()) return SubVector;
 //*****************************************************************************
 //1. Формирование списка со значениями элементов, расположенных по индексам,
 //   указанным в векторе Index
 //*****************************************************************************
 std::list<long> List;
 ulong index;
 for (ulong i = 0L; i < Index.Size(); i++)
 {index = Index[i];
  //Проверка значения индекса на соответствие границам исходного вектора
  if ((index >= 0L) && (index < Size())) List.push_back(data[index]);
 }
 if (List.size() == 0) return SubVector;
 //*****************************************************************************
 //2. Переписываем значения из списка List в данный вектор
 //*****************************************************************************
 //Устанавливаем размер исходного вектора равного размеру списка
 SubVector.Resize(List.size()); SubVector.SetType(Type());
 //Цикл копирования значений элементов списка List в исходный вектор
 for (ulong i = 0L; i < SubVector.Size(); i++)
 {SubVector.Put(i,List.front()); List.pop_front();}
return SubVector;
}
//******************************************************************************
//СТАТУС: I.14, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// ivector SubVector(const TArgVectorPredicate<long,ivector>& Predicate) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДВЕКТОРА ИЗ ЭЛЕМЕНТОВ ДАННОГО ВЕКТОРА, ЗНАЧЕНИЯ
//            КОТОРЫХ УДОВЛЕТВОРЯЮТ ОБЪЕКТУ-ПРЕДИКАТУ TArgVectorPredicate
//Каждый элемент исходного вектора передается перегруженному оператору вызова
//функции объекта Predicate. Если значение элемента вектора удовлетворяет усло-
//виям объекта-предиката Predicate, то данное значение заносится в список. По
//окончании просмотра всех элементов исходного вектора по элементам списка фор-
//мируется подвектор SubVector.
//Функция может возвратить подвектор нулевого размера в двух случаях, во-первых,
//если исходный вектор - это вектор нулевого размера, и, во-вторых, если ни одно
//из значений исходного вектора не удовлетворяет условиям объекта-предиката.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const TArgVectorPredicate<long,ivector>& Predicate - ссылка на объект-предикат,
//определяющий какие элементы исходного вектора будут размещаться в подвекторе.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ivector SubVector - подвектор исходного вектора элементы, значения которого
//удовлетворяют объекту-предикату Predicate.
//******************************************************************************
ivector TIntVector::SubVector(const TArgVectorPredicate<long,ivector>& Predicate)
const
{ivector SubVector;
 if (IsZeroSize()) return SubVector;//Вектор нулевого размера
 //*****************************************************************************
 //1. Формирование списка со значениями элементов, удовлетворяющим условию
 //   объекта-предиката Predicate
 //*****************************************************************************
 std::list<long> List;
 long value;
 for (ulong i = 0L; i < Size(); i++)
 {//Проверка значения элемента на соответствие условиям предиката Predicate
  value = data[i];
  if (Predicate(value)) List.push_back(value);
 }
 //*****************************************************************************
 //2. Переписываем значения из списка List в данный вектор
 //*****************************************************************************
 //Устанавливаем размер исходного вектора равного размеру списка
 SubVector.Resize(List.size()); SubVector.SetType(Type());
 //Цикл копирования значений элементов списка List в исходный вектор
 for (ulong i = 0L; i < SubVector.Size(); i++)
 {SubVector.Put(i,List.front()); List.pop_front();}
return SubVector;
}
//------------------------------------------------------------------------------
//Алгоритмы сортировки вектора
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.15, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// BubbleSort(bool direct = ASCENDING, ulong *permutations = NULL,
//            ulong *comparisons = NULL)
//НАЗНАЧЕНИЕ: МОДИФИЦИРОВАННАЯ ПУЗЫРЬКОВАЯ СОРТИРОВКА ПО ВОЗРАСТАНИЮ ИЛИ
//            ПО УБЫВАНИЮ ЭЛЕМЕНТОВ ВЕКТОРА
//Функция реализует алгоритм пузырьковой сортировки, в ходе которой за каждый
//цикл просмотра элементов вектора с первого элемента до граничного элемента
//Border в правой части вектора оказываются наибольшие или наименьшие элементы
//в зависимости от направления сортировки, задаваемого аргументом direct. При
//каждом последующем просмотре элементов вектора верхний предел просмотра умень-
//шается на единицу. Начальное значение Border = Size()-1. Если при очередном
//просмотре элементов вектора не произошло ни одной перестановки, то алгоритм
//завершает свою работу, так как данный факт является критерием того, что все
//элементы вектора упорядочены по возрастанию (ASCENDING) или по убыванию
//(DESCENDING). Алгоритм применяется к векторам с размерностью большей 1. При
//работе алгоритма положение элементов вектора могут изменяться. Они не изменяют-
//ся только для уже упорядоченного вектора. При работе алгоритма ведется подсчет
//числа перестановок и сравнений, которые можно передать через указатели внешней
//по отношению к BubbleSort функции. Функция возвращает false, если длина вектора
//меньше 2.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. bool direct - направление сортировки (по возрастанию или по убыванию);
//2. ulong *permutations (NULL) - количество перестановок в ходе сортировки;
//3. ulong *comparisons (NULL) - количество сравнений в ходе сортировки
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//******************************************************************************
bool TIntVector::BubbleSort(bool direct, ulong *permutations, ulong *comparisons)
{if (Size() < 2) return false;//Проверка на вектор допустимого размера
 ulong Border = Size()-1;
 ulong p = 0L, c = 0L;
 long temp;
 bool permut;
 bool end = false;
 //Тип сортировки
 if (direct == ASCENDING) //Сортировка по возрастанию
 {do
  {permut = false;
   for (ulong i = 0L; i < Border; i++)
   {c++;
    if (data[i] > data[i+1]) //Выполнить перестановку
    {temp = data[i+1]; data[i+1] = data[i]; data[i] = temp;
     permut = true; p++;
    }
   }
   if ((permut == false) || (--Border == 0)) end = true;
  } while (!end);
 }
 else //Сортировка по убыванию
 {do
  {permut = false;
   for (ulong i = 0L; i < Border; i++)
   {c++;
    if (data[i] < data[i+1]) //Выполнить перестановку
    {temp = data[i+1]; data[i+1] = data[i]; data[i] = temp;
     permut = true; p++;
    }
   }
   if ((permut == false) || (--Border == 0)) end = true;
  } while (!end);
 }
 if (permutations != NULL) *permutations = p;
 if (comparisons != NULL) *comparisons = c;
 return true;
}
//******************************************************************************
//СТАТУС: I.16, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool Find(const long& value, ulong* index = NULL, bool sort = UNSORTED,
//      ulong left = 0L, ulong right = MAX_SIZE, bool direct = FORWARD) const
//НАЗНАЧЕНИЕ: ПОИСК СРЕДИ ЭЛЕМЕНТОВ ВЕКТОРА В ЗАДАННОМ ИНТЕРВАЛЕ ЭЛЕМЕНТА
//            ВЕКТОРА С ОПРЕДЕЛЕННЫМ ЗНАЧЕНИЕМ
//Функция осуществляет поиск в интервале индексов вектора от left до right эле-
//мента вектора со значением равным value. В случае успеха функция возвращает
//значение true, а в переменную передаваемую в функцию через указатель index за-
//носится индекс элемента вектора с заданным значением value. Если элемент со
//значением value не найден в интервале от left до right, то функция возвращает
//false, а в переменную, переданную через указатель index заносится значение
//MAX_SIZE ("за пределами"). Аргумент sort указывает на отсортированность элемен-
//тов вектора. Если элементы вектора отсортированы, то поиск значения, как прави-
//ло, занимает меньше времени, чем в несортированном векторе. Ответственность за
//установку аргумента sort ложится на пользователя, так как если вектор не являет-
//ся отсортированны, а опция sort равна SORTED, может привести к неправильным
//результатам работы функции. Если sort == UNSORTED и вектор является отсортиро-
//ванным, то результат работы функции будет всегда правильным, но при отсутствии
//элемента с заданным значением value приведет к увеличению времени работы функ-
//ции. При sort == SORTED, функция автоматически настраивается на алгоритм поиска
//в отсортированном по возрастанию или по убыванию элементов векторе, путем срав-
//нения первого и последнего его значений:
//1) V[0] > V[size()-1] - поиск в отсортированном по убыванию векторе;
//2) V[0] < V[size()-1] - поиск в отсортированном по возрастанию векторе;
//По умолчанию аргумент sort == UNSORTED, что всегда гарантирует правильность
//работы функции с возможным ее замедлением в случае вектора с отсортированными
//элементами.
//Интервал поиска задается двумя аргументами left - нижняя граница и right -
//верхняя граница. Верхняя и нижняя границы индексов вектора входят в интервал
//поиска элемента вектора с заданным значением. По умолчанию left = 0, а right =
//MAX_SIZE (максимально возможная размерность вектора - 2^32-1). Такие установки
//приводят к поиску элемента со значением value по всему вектору. Функция прове-
//ряет корректность нижней и верхней границы интервала - left <= right < Size(),
//в противном случае функция возвращает false. Если вектор является вектором ну-
//левого размера, то функция также возвращает false.
//Функция предусматривает два направление поиска первого элемента вектора равно-
//го значению value, задаваемого аргументом direct:
//1) Поиск в прямом направлении (FORWARD) от left до right;
//2) Поиск в обратном направлении (BACKWARD) от right до left.
//По умолчанию задается прямое направление поиска - direct = FORWARD.
//Работа функции не приводит к изменению внутренней структуры вектора, в котором
//осуществляется поиск элемента с заданным значением.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const long& value - ссылка на значение элемента, по которому будет происхо-
//   дить поиск в векторе;
//2. ulong* index (NULL) - указатель на переменную, в которую будет заносится
//   индекс первого элемента вектора равного со значением value;
//3. bool sort (UNSORTED) - признак "отсортированности" элементов вектора;
//4. ulong left (0) - нижний индекс вектора, с которого будет происходить поиск;
//5. ulong right (MAX_SIZE ~ Size()-1) - верхний индекс вектора до которого будет
//   происходить поиск значения value, включая значение индекса right;
//6. bool direct (FORWARD) - направление поиска первого элемента вектора, совпа-
//   дающего со значением value.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак существования элемента со значением value в векторе.
//******************************************************************************
bool TIntVector::Find(const long& value, ulong* index, bool sort, ulong left,
                      ulong right, bool direct) const
{bool lSuccess = false;
 if (Size() == 0L) //Вектор нулевого размера
 {if (index != NULL) *index = MAX_SIZE;
  return lSuccess;
 }
 right = (right == MAX_SIZE) ? Size()-1 : right;
 //Проверка на корректность заданного интервала поиска
 if ((left > right) || (right >= Size()))
 {if (index != NULL) *index = MAX_SIZE;
  return lSuccess;
 }
 ulong pos = MAX_SIZE;
 //Поиск в неотсортированном векторе
 if (sort == UNSORTED)
 {if (direct == FORWARD) //Поиск в прямом направлении
  {for (ulong i = left; i <= right; i++)
   {if (data[i] == value) {lSuccess = true; pos = i; break;}
   }
  }
  else //Поиск в обратном направлении
  {for (ulong i = right; i <= left; i--)
   {if (data[i] == value) {lSuccess = true; pos = i; break;}
   }
  }
 }
 //Поиск в отсортированном векторе
 else
 {//Определение направления сортировки элементов вектора
  if (data[0] > data[Size()-1]) //Сортировка по убыванию
  {if (direct == FORWARD) //Поиск в прямом направлении
   {for (ulong i = left; i <= right; i++)
    {if (data[i] == value) {lSuccess = true; pos = i; break;}
     if (data[i] < value) break;
    }
   }
   else //Поиск в обратном направлении
   {for (ulong i = right; i <= left; i--)
    {if (data[i] == value) {lSuccess = true; pos = i; break;}
     if (data[i] > value) break;
    }
   }
  }
  else if (data[0] < data[Size()-1]) //Сортировка по возрастанию
  {if (direct == FORWARD) //Поиск в прямом направлении
   {for (ulong i = left; i <= right; i++)
    {if (data[i] == value) {lSuccess = true; pos = i; break;}
     if (data[i] > value) break;
    }
   }
   else //Поиск в обратном направлении
   {for (ulong i = right; i <= left; i--)
    {if (data[i] == value) {lSuccess = true; pos = i; break;}
     if (data[i] < value) break;
    }
   }
  }
  else //data[0] == data[Size()-1] - однородный вектор
  {if (direct == FORWARD) //Поиск в прямом направлении
    if (data[left] == value) {lSuccess = true; pos = left;}
   else //Поиск в обратном направлении
    if (data[right] == value) {lSuccess = true; pos = right;}
  }
 }
 if (index != NULL) *index = pos;
return lSuccess;
}
//******************************************************************************
//СТАТУС: I.17, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong Reverse(ulong left = 0L, ulong right = MAX_SIZE)
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ЭЛЕМЕНТОВ ВЕКТОРА В ЗАДАННОМ ИНТЕРВАЛЕ В ОБРАТНОМ
//            ПОРЯДКЕ
//Функция изменяет порядок следования элементов вектора в интервале от индекса
//со значением left до индекса со значением right (включая его) на обратный.
//Значения верхней и нижней границ интервала, в которой должна осуществляться
//перестановка должны удовлетворять следующим условиям:
// left <= right && right < Size(), в противном случае функция не выполняется.
//По умолчанию, функция осуществляет перестановку всех элементов вектора.
//Работа функции приводит к изменению внутренней структуры вектора, так как
//осуществляется перестановка элементов вектора в заданном интервале.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left (0) - нижний индекс вектора, с которого будет происходить
//   перестановка элементов вектора в обратном порядке;
//2. ulong right (MAX_SIZE ~ Size()-1) - верхний индекс вектора до которого будет
//   происходить перестановка элементов вектора в обратном порядке, включая зна-
//   чение индекса right.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong permut - количество перестановок
//******************************************************************************
ulong TIntVector::Reverse(ulong left, ulong right)
{ulong permut = 0L;//Количество перестановок
 right = (right == MAX_SIZE) ? Size()-1 : right;
 //Проверка на возможность или необходимость осуществления перестановки
 if ((Size() < 2) || (left >= right) || (right >= Size())) return permut;
 //Выполнение перестановки элементов вектора в обратном порядке
 long temp;
 while (left < right)
 {temp = data[left]; data[left] = data[right]; data[right] = temp;
  permut++; //Подсчет количества перестановок
  left++; right--; //Переход к другим индексам переставляемых элементов
 }
return permut;//Количество перестановок
}
//****************************************************************************************
//СТАТУС: I.18, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// ulong GetDataFromString(const string& source, bool unique = false,
//       const TArgVectorPredicate<long,ivector>* Predicate)
//НАЗНАЧЕНИЕ: Извлечение из строки source значений элементов вектора типа long в
//символьном виде, преобразовании их в тип long и записи их в данный вектор.
//Функция позволяет преобразовывать в значения элементов вектора как отдельные целые числа,
//так и интервалы целых чисел. Структура строки может быть представлена в следующем виде:
//<STRING> = {[<Long Value> || <Interval>]<Sep>...[<Long Value> || <Interval>]},
//<Long Value> = [<Sign>]<Digit>[<Digit>...<Digit>] - знаковое длинное целое;
//<Interval> = <LeftBracket><Left>[<,><Left+Delta>]<..><Right><RightBracket> - интервал
//чисел типа long ;
//<LeftBracket> = <([> - левая скобка;
//<RightBracket> = <)]> - правая скобка;
//<Left> = <Long Value> - значение нижней границы интервала;
//<Left+Delta> = <Long Value> - следующее значение интервала после Left. По значениям <Left>
//и <Left+Delta> определяется дискретность интервала. Если данная величина пропущена, то
//шаг равен 1;
//<..> - двоеточие - обязательный параметр, который должен предшествовать <Right>;
//<Right> - значение верхней границы интервала;
//<Sep> = <SPACE,TAB> - символы-разделители между символьными представлениями чисел типа <long>;
//<Sign> = <+-> - знак числа;
//<Digit> = <0123456789> - числа, из которых складываются значения типа long.
//Пример: <-1, -4, [0,1..10], 20, (11..20), -8, 12>.
//Интервалы могут включать или не включать свои границы. Круглые скобки <()> означают, что
//граница не входит в интервал, квадратные скобки <[] - граница входит в интервал. При любом
//шаге интервала, если <Right> принадлежит интервалу, данное значение всегда войдет в вектор.
//При отсутствии в строке закрывающейся скобки <RightBracket> функция завершает свою работу
//(в случае обнаружения предшествующей открывающейся скобки <LeftBracket>). Между <Left> и
//<Left+Delta> должна всегда следовать запятая, а перед <Right> двоеточие. Интервалы и от-
//дельные целые числа могут разделяться символами-разделителями <Sep>.
//В общем случае, за исключением специального синтаксиса, введенного для интервалов - обя-
//зательное наличие закрывающейся скобки при наличии открывающейся, наличие символа <,>
//между левой границей интервала и следующим значением интервала (в случае его указания),
//а также двоеточия <..> перед Right - функция не критична к присутствию символов отличных
//от <Sep>,<Digit>,<Sign>,<..>. Функция игнорирует символы, не относящиеся к вышеперечислен-
//ному множеству - алфавиту данной грамматики, не прерывая своей работы при их обнаружении.
//Функция прерывает свою работу в следующих случаях:
//1. Не обнаружено новых символов из множества <Sign>+<Digit> либо <LeftBracket>;
//2. После обнаружения символа из <LeftBracket> не обнаружено символа из <RightBracket> -
//   отсутствует правая скобка.
//При преобразовании интервалов в последовательность целых чисел должны выполняться следую-
//щие семантические правила:
//1. left < left+delta < right, т.е. между левой и правой границей должно располагаться
//   хотя бы одно целое число.
//Все успешно извлеченные из строки целые числа размещаются в списке list<long>. После за-
//вершения разбора строки source значения в порядке их считывания из строки переносятся в
//исходный вектор при этом размерность исходного вектора меняется и становится равной раз-
//меру списка. Если установлена опция unique, то функция предотвращает дублирование одина-
//ковых значений, извлеченных из строки. С этой целью по каждому новому считанному значению
//перед его размещением в списке ведется поиск среди размещенных там значений. Если данное
//значение отсутствует в списке, то оно добавляется в данный список, в противном случае -
//игнорируется.
//Функция принимает указатель на шаблонный объект-предикат Predicate. Если Predicate != NULL,
//то все считанные из строки source целые числа передаются в качестве аргумента перегружен-
//ному оператору вызова функции () объекта-предиката TArgVectorPredicate. В зависимости от
//текущего значения целого числа и функциональных свойств предиката оператор вызова функции
//возвращает логическое значение - true или false. Результат работы оператора вызова функции
//свидетельствует о том, что удовлетворяет или нет текущее целое значение условиям предика-
//та. Объект-предикат используется в качестве фильтра для отбора определенных целых значений
//в качестве элементов вектора из всей последовательности целых чисел, извлеченных из строки.
//Если строка source не содержит ни одного целого значения, то исходный вектор становится
//вектором нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& source - ссылка на строку с символьным представлением целых чисел в виде
//   последовательности отдельных значений и интервалов;
//2. bool unique (false) - разрешение или запрещение дублирования значений элементов вектора,
//   считываемых из содержимого строки source.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong count - количество считанных из строки str элементов вектора
//****************************************************************************************
ulong TIntVector::GetDataFromString(const string& source, bool unique,
                  const TArgVectorPredicate<long,ivector>* Predicate)
{ulong count = 0L;
 long ind_number, ind_interval, index;
 std::list<long> List;
 ivector Interval;
 std::list<long>::iterator Iterator;
 long value;
 bool AddElement;
 string str(source);//Копирование исходной строки
 string ends;
 const string Digit("0123456789");
 const string Sign("+-");
 const string LeftBracket("([");
 const string RightBracket(")]");
 const string DigSign("0123456789+-");
 //Цикл считывания из строки последовательности целых чисел и их интервалов
 do
 {//Проверка строки str на пустую строку
  if (str.empty()) break;
  index = string::npos;//NPOS=-1
  //Поиск первого символа из множества <Digit>+<Sign> в str
  ind_number = str.find_first_of(DigSign);
  if (ind_number != string::npos) index = ind_number;//NPOS=-1
  //Поиск первой левой скобки из множества <LeftBracket> в str
  ind_interval = str.find_first_of(LeftBracket);
  if (ind_interval != string::npos) //NPOS=-1
  {if (index != string::npos) //NPOS=-1
    index = (ind_number < ind_interval) ? ind_number : ind_interval;
   else index = ind_interval;
  }
  //Строка не содержит целых чисел и их интервалов
  if (index == string::npos) break;//Выход из цикла NPOS = -1
  str = str.substr(index);
  //Преобразование символьного представления целого числа в тип long
  if (index == ind_number)
  {if (StrToLong(value,str,ends))//Преобразование произошло успешно
   {//************************************************************************
    //Добавление нового значения к списку List
    //************************************************************************
    //1. Проверка на возможность включения значения value в список List
    if (Predicate == NULL) AddElement = true;
    else AddElement = (*Predicate)(value);
    //2. Проверка значения value на уникальность
    if ((unique == true) && (AddElement == true))
    {//Поиск value в списке List
     Iterator = std::find(List.begin(),List.end(),value);
     //Значение value в списке содержится
     if (Iterator != List.end()) AddElement = false;
    }
    //Добавить элемент в конец списка
    if (AddElement) {List.push_back(value); count++;}
    str = ends;
   }
   //Ошибка при преобразовании целого значения из строкового в тип long
   //Переход к следующему символу строки str
   else {if (str.length() > 1) str = str.substr(1);}
  }
  //Преобразование символьного представления интервала в список целых чисел
  else if (index == ind_interval)
  {//Поиск первой правой скобки из множества <RightBracket> в str
   ind_interval = str.find_first_of(RightBracket);
   //Правая скобка не найдена, выход из цикла
   if (ind_interval == string::npos) break; //NPOS = -1
   //Извлечение подстроки с символьным представлением интервала чисел
   ends = str.substr(0,ind_interval+1);
   //Извлечение подстроки из строки str, начинающейся за правой скобкой интервала
   str = str.substr(ind_interval+1);
   //Преобразование строкового представления интервала целых чисел в список
   //типа long
   Interval.StrIntervalToVector(ends);
   //Вектор не является вектором нулевого размера
   if (!Interval.IsZeroSize())
   {//Цикл считывания данных из Interval в List
    for (ulong i = 0L; i < Interval.Size(); i++)
    {value = Interval[i];
     //***********************************************************************
     //Добавление нового значения к списку List
     //***********************************************************************
     //1. Проверка на возможность включения значения value в список List
     if (Predicate == NULL) AddElement = true;
     else AddElement = (*Predicate)(value);
     //2. Проверка значения value на уникальность
     if ((unique == true) && (AddElement == true))
     {//Поиск value в списке List
      Iterator = std::find(List.begin(),List.end(),value);
      //Значение value в списке содержится
      if (Iterator != List.end()) AddElement = false;
     }
     //Добавить элемент в конец списка
     if (AddElement) {List.push_back(value); count++;}
    }//Конец цикла считывания данных из Interval в List
   }
  }
 } while (true);
 //Считывание данных из списка List в исходный вектор
 if (List.empty()) Resize(0L); //Список является пустым
 else //Список содержит данные
 {//Устанавливаем размер исходного вектора равного размеру списка
  Resize(List.size());
  //Цикл копирования значений элементов списка List в исходный вектор
  for (ulong i = 0L; i < Size(); i++)
  {data[i] = List.front(); List.pop_front();}
 }
return count;//Количество считанных из строки данных
}
//****************************************************************************************
//СТАТУС: I.21, TIntVector class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong StrIntervalToVector(const string& source)
//НАЗНАЧЕНИЕ: ПРЕОБРАЗОВАНИЕ СТРОКОВОГО ПРЕДСТАВЛЕНИЯ ИНТРЕВАЛА ЦЕЛЫХ ЧИСЕЛ
//            В ВЕКТОР ЗНАЧЕНИЙ ТИПА <LONG>
//Функция осуществляет извлечение из строки source значений элементов вектора
//типа long в символьном виде, преобразовании их в тип long и записи их в данный
//вектор. Функция преобразовывает в значения элементов вектора интервалы целых
//чисел. Символьная структура интервала целых чисел может быть представлена в
//следующем виде:
//<STRING> = <Interval>,
//<Interval> = <LeftBracket><Left>[<,><Left+Delta>]<..><Right><RightBracket> -
//интервал чисел типа long ;
//<LeftBracket> = <([> - левая скобка;
//<RightBracket> = <)]> - правая скобка;
//<Left> = <Long Value> - значение нижней границы интервала;
//<Left+Delta> = <Long Value> - следующее значение интервала после Left. По зна-
//чениям <Left> и <Left+Delta> определяется дискретность интервала. Если данная
//величина пропущена, то шаг равен 1;
//<..> - двоеточие - обязательный параметр, который должен предшествовать <Right>;
//<Right> - значение верхней границы интервала;
//<Sep> = <SPACE,TAB> - символы-разделители между символьными представлениями
//чисел типа <long>;
//<Long Value> = [<Sign>]<Digit>[<Digit>...<Digit>] - знаковое длинное целое;
//<Sign> = <+-> - знак числа;
//<Digit> = <0123456789> - числа, из которых складываются значения типа long.
//Примеры: [0,1..10], (11..20), (-10,1..10], [20..100) и т.д.
//Интервалы могут включать или не включать свои границы. Круглые скобки <()>
//означают, что граница не входит в интервал, квадратные скобки <[] - граница
//входит в интервал. При любом шаге интервала, если <Right> принадлежит интерва-
//лу, данное значение всегда войдет в вектор.
//При разборе строки source действуют следующие СИНТАКСИЧЕСКИЕ ПРАВИЛА:
//1. Первым символом в строке, содержащим интервал обязательно должна быть откры-
//   вающая скобка <LeftBracket>, а последним символом должна быть закрывающая
//   скобка <RightBracket>;
//2. Между <Left> и <Left+Delta> должна всегда следовать запятая;
//3. Перед <Right> должно следовать двоеточие;
//4. Допускается пропуск <Left+Delta>, в этом случае шаг по умолчанию равен 1.
//   Наличие значений правой и левой границ интервала обязательно.
//При преобразовании интервалов в последовательность целых чисел должны выпол-
//няться следующие СЕМАНТИЧЕСКИЕ ПРАВИЛА:
//1. left < left+delta < right, т.е. между левой и правой границей должно распо-
//   лагаться хотя бы одно целое число.
//При несоблюдении вышеперечисленных правил, функция возвращает count == 0, а
//исходный вектор становится вектором нулевого размера.
//Все успешно извлеченные из строки целые числа размещаются в списке list<long>.
//После завершения разбора строки source значения в порядке их считывания из
//строки переносятся в исходный вектор при этом размерность исходного вектора
//меняется и становится равной размеру списка. Если строка source не содержит ни
//одного целого значения, то исходный вектор становится вектором нулевого разме-
//ра и функция возвращает count == 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const string& source - ссылка на строку с символьным представлением интервала
//целых чисел;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ulong count - количество преобразованных из символьного представления интервала
//              целых чисел значений элементов вектора
//******************************************************************************
ulong TIntVector::StrIntervalToVector(const string& source)
{ulong count = 0L;
 Resize(0L);//Установка вектора в вектор нулевого размера
 string str = source;//Копирование исходной строки
 string ends;
 long index;
 //Нижняя, верхняя границы и дискретность интервала
 long left, right, delta;
 //Принадлежность значений границ интервала интервалу
 bool LeftBelong, RightBelong;
 std::list<long> List;
 long value;
 //const string Digit("0123456789");
 //const string Sign("+-");
 const string DigSign("0123456789+-");
 //*****************************************************************************
 //1. Устанавливаем принадлежность границ интервалу
 //*****************************************************************************
 //Установка принадлежности нижней границы интервала
 if (str[0] == '(') LeftBelong = false;
 else if (str[0] == '[') LeftBelong = true;
 //Первый символ строки не является символом из множества <LeftBracket>
 else return count;
 //-----------------------------------------------------------------------------
 //Установка принадлежности верхней границы интервала
 index = str.length()-1;
 if (str[index] == ')') RightBelong = false;
 else if (str[index] == ']') RightBelong = true;
 //Последний символ строки не является символом из множества <RightBracket>
 else return count;
 //*****************************************************************************
 //2. Устанавливаем нижнюю границу интервала - left
 //*****************************************************************************
 index = str.find_first_of(DigSign);
 if (index == string::npos) return count; //NPOS = -1
 str = str.substr(index);
 if (StrToLong(value,str,ends)) //Нижняя граница определена
 {left = value; str = ends;}
 else return count;
 //*****************************************************************************
 //3. Устанавливаем дискретность интервала
 //*****************************************************************************
 index = str.find_first_of(",");
 if (index == string::npos) delta = 1;//Установка шага интервала по умолчанию  NPOS = -1
 else
 {//Устанавливаем значение дискретности интервала
  index = str.find_first_of(DigSign);
  if (index == string::npos) return count;   //NPOS = -1
  str = str.substr(index);
  if (StrToLong(value,str,ends)) //Второе значение последовательности определено
  {delta = value - left; str = ends;}
  else return count;
 }
 //*****************************************************************************
 //4. Устанавливаем правую границу интервала
 //*****************************************************************************
 index = str.find_first_of("..");
 if (index == string::npos) return count; //NPOS = -1
 str = str.substr(index+2);
 index = str.find_first_of(DigSign);
 if (index == string::npos) return count;//NPOS = -1
 str = str.substr(index);
 if (StrToLong(value,str,ends)) right = value;//Верхняя граница определена
 else return count;
 //*****************************************************************************
 //5. Проверка значений left, right и delta на непротиворечивость
 //*****************************************************************************
 if (delta == 0) return count;
 if (right == left) return count;
 //Интервал должен быть ЗАМКНУТЫМ и СХОДЯЩИМСЯ к right
 if (labs(right - left) <= labs(right - (left + delta))) return count;
 //Между left & right всегда должно размещаться хотя бы одно значение
 if (delta > 0) //Шаг положительный
  if (left + delta >= right) return count;
 else if (delta < 0) //Шаг отрицательный
  if (left + delta <= right) return count;
 //*****************************************************************************
 //6. Записываем значения принадлежащие интервалу в список List
 //*****************************************************************************
 if (LeftBelong == false) value = left + delta;
 else value = left;
 do
 {List.push_back(value); count++;
  value += delta;
  if (((right > left) && (value >= right)) ||
      ((left > right) && (value <= right)))
  {if (RightBelong == true) {List.push_back(right); count++;}
   break;//Выход из цикла
  }
 } while (true);
 //*****************************************************************************
 //7. Переписываем значения из списка List в данный вектор
 //*****************************************************************************
 //Устанавливаем размер исходного вектора равного размеру списка
 Resize(List.size());
 //Цикл копирования значений элементов списка List в исходный вектор
 for (ulong i = 0L; i < Size(); i++)
 {data[i] = List.front(); List.pop_front();}
return count;
}
//******************************************************************************
//СТАТУС: I.20, TIntVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//ivector Assign(const ivector& V, ulong pos = 0L, ulong* counter = NULL) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ ЗНАЧЕНИЙ ЭЛЕМЕНТОВ ОДНОГО ВЕКТОРА ДРУГОМУ ВЕКТОРУ
//В качестве вектора-приемника используется исходный вектор, вектора-источника -
//вектор V, передаваемый по ссылке. Присваивание элементов исходным вектором
//начинается с индекса pos, по умолчанию pos == 0. Вектор-источник может иметь
//любую размерность. Функция присваивает значения элементов вектора V копии ис-
//ходного вектора, начиная с первого элемента вектора V, вплоть до последнего
//элемента вектора V или последнего элемента исходного вектора, в зависимости от
//соотношения начального индекса pos исходного вектора, с которого начинается
//присваивание, размеров вектора-источника и вектора-приемника. Значения элемен-
//тов исходного вектора и его структура не изменяются в результате работы данной
//функции, так как все необходимые операции присваивания осуществляются с копией
//вектора-источника, которая и является результатом работы функции.
//Функции передается необязательный указатель на переменную типа ulong - count.
//По умолчанию counter=NULL. В ходе работы функция подсчитывает кол-во элементов
//исходного вектора, которым присваивались значения элементов вектора V. Если
//указатель counter отличен от NULL, то по его адресу по окончании работы функ-
//ции передается количество элементов исходного вектора, принимавших участии в
//операции присваивания.
//Функция возвращает результирующий вектор нулевого размера в следующих исключи-
//тельных ситуациях:
//1. Исходный вектор - вектор нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Начальный индекс pos в исходном векторе, начиная с которого осуществляется
//   присваивание, превышает верхнюю границу для данного исходного вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& V - ссылка на вектор-источник, значения элементов которого
//   будут присваиваться элементам исходного вектора;
//2. ulong pos - начальный индекс элемента исходного вектора, с которого начнется
//   присваивание значений элементов вектора-источника V;
//3. ulong* counter (NULL) - указатель на счетчик, в который будет записано ко-
//   личество элементов исходного вектора, которым присваивались значения эле-
//   ментов вектора-источника V.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ivector result - результирующий вектор выполнения операции присваивания значе-
//                 ний элементов одного вектора другому вектору
//******************************************************************************
ivector TIntVector::Assign(const ivector& V, ulong pos, ulong* counter) const
{ulong count = 0L;
 ivector result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (pos >= Size()))
 { if (counter != NULL) *counter = count;
   return result;
 }
 result = *this;//Копирование исхоного вектора
 //Выполнение операции присваивания значений одного вектора другому вектору
 ulong index;
 for (ulong i = 0L; i < V.Size(); i++)
 {index = i+pos;
  if (index < result.Size()) {result[index] = V.Get(i); count++;}
  else break; //Выход из цикла
 }
 if (counter != NULL) *counter = count;
return result;
}

//----------------------------------------------------------------------------------------
//                    РЕАЛИЗАЦИЯ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ
//----------------------------------------------------------------------------------------
//****************************************************************************************
//СТАТУС: I.1; public TIntVector class overloading operator()
//OVERLOADING OPERATOR OF FUNCTION CALL
//НАИМЕНОВАНИЕ ФУНКЦИИ: long& operator() (ulong i)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЗКА ОПЕРАТОРА ВЫЗОВА ФУНКЦИИ класса TIntVector.
//Функция предоствляет доступ к i-му элементу вектора с проверкой корректности индекса, по
//которому располагается требуемый элемент вектора. Функция вызывается во всех функциях,
//кроме вызова в операторе присваивания и конструкторе копирования, т.к. в качестве аргумен-
//тов последних передается константный объект. Доступ к членам-данным константных объектов
//можно осуществлять только с использованием константных функций.
//ПРИМЕР ВЫЗОВА: V(3), где i=3 - индекс элемента целочисленного вектора. Нумерация элементов
//вектора начинается с 0. Если индекс элемента вектора некорректен, то возвращается его
//первый элемент.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint i - индекс элемента вектора
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: long& value - ссылка на a[i] компонент вектора
//****************************************************************************************
long& TIntVector::operator() (ulong i)
{if (Size() == 0L) return data[0];//Доступ к вектору нулевого размера
 //Проверка корректности индексов доступа к элементу вектора
 if (i >= Size()) return data[0];  //Индекс i выходит за границы вектора
 return data[i];
}
//****************************************************************************************
//СТАТУС: I.2; public TIntVector class overloading operator()
//OVERLOADING OPERATOR OF FUNCTION CALL
//НАИМЕНОВАНИЕ ФУНКЦИИ: const long operator() (ulong i) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЗКА ОПЕРАТОРА ВЫЗОВА ФУНКЦИИ для класса TIntVector.
//Функция предоставляет доступ к i-му элементу вектора с проверкой корректности индекса, по
//которому располагается требуемый элемент вектора. Функция вызывается в операторе присваи-
//вания и конструкторе копирования, т.к. в качестве их аргументов передается константный
//объект. Доступ к членам-данным константных объектов можно осуществлять только с использо-
//ванием константных функций.
//ПРИМЕР ВЫЗОВА: A(3), где i=3 - индекс целочисленного вектора. Нумерация элементов вектора
//начинается с 0. Если индекс элемента вектора некорректен, то возвращается его первый элемент.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint i - индекс элемента вектора
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: const long value - a[i] компонент вектора
//****************************************************************************************
const long TIntVector::operator() (ulong i) const
{if (Size() == 0L) return data[0];//Доступ к вектору нулевого размера
 //Проверка корректности индексов доступа к элементу вектора
 if (i >= Size()) return data[0]; //Индекс i выходит за границы вектора
 return data[i];
}
//****************************************************************************************
//СТАТУС: I.3; public TIntVector class overloading operator[]
//OVERLOADING THE SUBSCRIPT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: long& operator[] (ulong i)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЗКА ОПЕРАТОРА [] для класса TIntVector.
//Функция осуществляет доступ i-му элементу вектора. Проверяется корректность индекса по
//которому располагается требуемый элемент вектора. Функция вызывается во всех функциях,
//кроме вызова в операторе присваивания и конструкторе копирования, т.к. в качестве аргумен-
//тов последних передается константный объект. Доступ к членам-данным константных объектов
//можно осуществлять только с использованием константных функций.
//ПРИМЕР ВЫЗОВА: V[3], где i=3 - индекс элемента целочисленного вектора. Нумерация элемен-
//тов вектора начинается с 0. Если индекс элемента вектора некорректен, то возвращается его
//первый элемент.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint i - индекс элемента вектора
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: long& value - ссылка на a[i] компонент вектора
//****************************************************************************************
long& TIntVector::operator[] (ulong i)
{if (Size() == 0L) return data[0];//Доступ к вектору нулевого размера
 //Проверка корректности индексов доступа к элементу вектора
 if (i >= Size()) return data[0];  //Индекс i выходит за границы вектора
 return data[i];
}
//****************************************************************************************
//СТАТУС: I.4; public TIntVector class overloading operator[]
//OVERLOADING SUBSCRIPT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: const long operator[] (ulong i) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЗКА ОПЕРАТОРА [] для класса TIntVector
//Функция предназначена для доступа к i-му элементу вектора. Осуществляется проверка кор-
//ректности индекса по которому располагается требуемый элемент вектора. Функция вызывается
//в операторе присваивания и конструкторе копирования, т.к. в качестве их аргументов пере-
//дается константный объект. Доступ к членам-данным константных объектов можно осуществлять
//только с использованием константных функций.
//ПРИМЕР ВЫЗОВА: A[3], где i=3 - индекс целочисленного вектора. Нумерация элементов вектора
//начинается с 0. Если индекс элемента вектора некорректен, то возвращается его первый
//элемент.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong i - индекс элемента вектора
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: const long value - a[i] компонент вектора
//****************************************************************************************
const long TIntVector::operator[] (ulong i) const
{if (Size() == 0L) return data[0];//Доступ к вектору нулевого размера
 //Проверка корректности индексов доступа к элементу вектора
 if (i >= Size()) return data[0]; //Индекс i выходит за границы вектора
 return data[i];
}
//****************************************************************************************
//СТАТУС: I.5; public TIntVector class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: operator =(const TIntVector& V)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЗКА ОПЕРАТОРА ПРИСВАИВАНИЯ для класса TIntVector.
//Функция копирует свойства и элементы из одного целочисленного вектора в другой. Осуществ-
//ляется корректное копирование членов-указателей на данные копируемого класса в создавае-
//мый класс с целью недопущения ссылок указателей разных объектов класса на одно и то же
//место памяти.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TIntVector& V - ссылка на копируемый вектор.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TIntVector::operator =(const TIntVector& V)
{//Предотвращение попытки присваивания объекта самому себе
 if (this == &V) return;
 Resize(V.Size()); SetType(Type());//Установка свойств копирующего вектора
 //Копирование значений элементов вектора V
 for (ulong i = 0L; i < Size(); i++) data[i] = V.Get(i);
}
//****************************************************************************************
//СТАТУС: I.6;  TIntVector class friend overloading operator <<
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend ostream& operator <<(ostream& out, const TIntVector& V)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЗКА ОПЕРАТОРА ПОТОКОВОГО ВЫВОДА для класса TIntVector.
//Функция выводит в поток свойства вектора и ее элементы и возвращает ссылку на поток, что
//позволяет записывать операторы вывода в поток каскадно. Формат вывода значений элементов
//вектора: <x;>, где x - значениe элемента вектора.
//При выводе элементов вещественного вектора приняты следующие соглашения:
//1. Все элементы вектора имеют ширину вывода равную наибольшей символьной длине элемента
//   вектора, определяемый функцией MaxStrLen(...).
//2. Выводятся только отрицательные знаки чисел.
//3. Элементы вектор-строки выводятся в строку, а вектор-столбца - в столбец.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на объект потока вывода
//2. сonst TIntVector& V - ссылка на вектор, выводимый в поток.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ostream& out - ссылка на объект потока вывода.
//****************************************************************************************
ostream& operator <<(ostream& out, const TIntVector& V)
{string s;
 long flags = out.flags();
 V.Properties(s);//Получение свойств вектора V в виде строки
 //Вывод характеристик вектора
 out << s;
 if (V.Size() == 0L) return out;
 //Определение типа вектора: вектор-строка или вектор-столбец
 bool ColVector = V.IsColumn();
 //Определение максимальной символьной длины элемента вектора
 uint MaxLen = MaxStrLen(V);
 out.setf(ios::right);//Выравнивание по правому краю.
 //Вывод значений элементов целочисленного вектора V в поток
 for (ulong i = 0L; i < V.Size(); i++)
 {//Формирование символьного представления длинного целого числа
  out << setw(MaxLen) << V.Get(i) << ";";
  if ((V.Size()-i) > 1) out << " ";
  //Элементы вектора-столбца выводятся с новой строки
  if (ColVector == true) out << endl;
 }
 out.flags(flags);
return out;
}
//****************************************************************************************
//СТАТУС: I.7; public; TIntVector class overloading operator ==
//OVERLOADING COMPARISON OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ==(const TIntVector& V) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СРАВНЕНИЯ ДВУХ ВЕКТОРОВ.
//Функция перегружает оператор (==) для сравнения двух целочисленных векторов X(x1,...,xn)
//и Y(y1,...,yn). N-мерные вектора X = (x1,x2,...,xN) и Y = (y1,y2,...,yN) считаются РАВНЫМИ,
//если их соответствующие компоненты совпадают, т.е. если xi = yi для i = 1,2,...,n. Срав-
//нивать можно только векторы ОДНОГО ТИПА и ОДНОЙ РАЗМЕРНОСТИ. Если векторы равны, то воз-
//вращается true, в противном случае - false. Если векторы разных типов (вектор-строка и
//вектор-столбец) и разной размерности, то возвращается false.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TIntVector& V - ссылка на сравниваемый вектор
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool compare
//****************************************************************************************
bool TIntVector::operator ==(const TIntVector& V) const
{//Операция сравнения производится с вектором (векторами) нулевого размера
 if ((Size() == 0L) && (V.Size() == 0L)) return true;
 //Операция сравнения производится с векторами разной размерности
 if (Size() != V.Size()) return false;
 //Операция сравнения производится с векторами разных типов
 if (Type() != V.Type()) return false;
 //Покомпонентное сравнение векторов
 bool equal = true;
 for (ulong i = 0; i < Size(); i++)
  if (data[i] != V.Get(i))
  {equal = false;
   break; //Преждевременный выход из цикла сравнения компонент векторов
  }
 return equal;//Результат сравнения векторов
}
//****************************************************************************************
//СТАТУС: I.8; public; TIntVector class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator =(const long value)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЗКА ОПЕРАТОРА ПРИСВАИВАНИЯ ЭЛЕМЕНТАМ ВЕКТОРА ДЛИННОГО ЦЕЛОГО ЧИСЛА.
//Функция присваивает ВСЕМ компонентам вектора значение value. При попытке присваивания
//вектору нулевой размерности длинного целого числа возвращается false.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const long value - присваиваемое вектору значение
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//****************************************************************************************
bool TIntVector::operator =(const long value)
{if (Size() == 0L) return false;//Присваивание вектору нулевого размера
 //Цикл присваивания компонентам вектора значения value
 for (ulong i = 0; i < Size(); i++) data[i] = value;
 return true;
}
//****************************************************************************************
//СТАТУС: I.9; TIntVector class friend function
//OVERLOADING OPERATOR & -  A & B <=> A * B
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend ivector operator &(const ivector& A, const ivector& B)
//НАЗНАЧЕНИЕ: ОПЕРАЦИЯ ПЕРЕСЕЧЕНИЯ ДВУХ ВЕКТОРОВ ПО ПРАВИЛАМ АЛГЕБРЫ МНОЖЕСТВ
//Функция перегружает оператор & для реализации операции алгебры множеств - пересечение двух
//множеств (С = A*B <=> A & B). Под множествами рассматриваются векторы А и В. Результат
//операции пересечения двух множеств является множество C, которое содержит общие элементы
//для множеств A и B. Если множество A или B является ПУСТЫМ, то множество C также будет
//пустым. ПУСТОМУ МНОЖЕСТВУ соответствует вектор нулевого размера. Если множества A или B
//содержат несколько одинаковых элементов, по которым они пересекаются, то в C заносится
//только одно такое значение.
//ПРИМЕР: A = {1,2,3,10,20,21}, B = {2,5,6,10,21,30,40}, C = A & B = {2,10,21}.
//Результат работы функции - вектор C, представляющий результат пересечения множеств. В
//качестве промежуточного буфера, в котором происходит накопление элементов общих для A и B,
//используется класс list<long> из шаблонной библиотеки std.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& A - ссылка на вектор А, представляющий множество A;
//2. const ivector& B - ссылка на вектор B, представляющий множество B;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ivector C - результат операции пересечения двух множеств.
//****************************************************************************************
ivector operator &(const ivector& A, const ivector& B)
{ivector C;//Результат пересечения двух множеств
 //Проверка A и B на ПУСТЫЕ МНОЖЕСТВА
 if (A.IsZeroSize() || B.IsZeroSize()) return C;
 //Промежуточное накопление общих для A & B элементов
 std::list<long> IntersectSet;
 std::list<long>::iterator Iterator;
 //Цикл формирования списка элементов общих для A и B.
 for (ulong i = 0L; i < A.Size(); i++)
 {if (B.Find(A[i])) //Добавить в IntersectSet
  {//Поиск A[i] в списке IntersectSet
   Iterator = std::find(IntersectSet.begin(),IntersectSet.end(),A[i]);
   //Значение A[i] не найдено, добавление в список
   if (Iterator == IntersectSet.end()) IntersectSet.push_back(A[i]);
  }
 }
 //Передача значений в вектор C
 if (!IntersectSet.empty()) //Список содержит значения
 {IntersectSet.sort();//Сортируем элементы списка
  C.Resize(IntersectSet.size());
  for (ulong i = 0L; i < C.Size(); i++)
  {C.Put(i,IntersectSet.front());
   IntersectSet.pop_front();//Удаление элемента i из списка
  }
 }
return C; // C = A & B
}
//****************************************************************************************
//СТАТУС: I.10; TIntVector class friend function
//OVERLOADING OPERATOR && -  A && B <=> A * B
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend ivector operator &&(const ivector& A, const ivector& B)
//НАЗНАЧЕНИЕ: ОПЕРАЦИЯ ПЕРЕСЕЧЕНИЯ ДВУХ ВЕКТОРОВ ПО ПРАВИЛАМ АЛГЕБРЫ МНОЖЕСТВ
//Функция перегружает оператор & для реализации операции алгебры множеств - пересечение
//двух множеств (С = A*B <=> A & B). Под множествами рассматриваются векторы А и В. Резуль-
//тат операции пересечения двух множеств является множество C, которое содержит общие эле-
//менты для множеств A и B. Если множество A или B является ПУСТЫМ, то множество C также
//будет пустым. ПУСТОМУ МНОЖЕСТВУ соответствует вектор нулевого размера. Если в множествах
//A или B имеется несколько одинаковых элементов по которым они пересекаются, то в C зано-
//сятся все значения. Операция A && B НЕКОММУТАТИВНА, т.е. A && B !== B && A.
//ПРИМЕР: A = {1,2,2,3,10,20,21,21}, B = {2,5,6,10,21,30,40},
//        C = A && B = {2,2,10,21,21}.
//Результат работы функции - вектор C: результат пересечения двух множеств. Промежуточным
//буфером, в котором происходит накопление элементов общих для A и B, используется класс
//list<long> из шаблонной библиотеки std.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& A - ссылка на вектор А, представляющий множество A;
//2. const ivector& B - ссылка на вектор B, представляющий множество B;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ivector C - результат выполнения пересечения двух множеств.
//****************************************************************************************
ivector operator &&(const ivector& A, const ivector& B)
{ivector C;//Результат пересечения двух множеств
 //Проверка A и B на ПУСТЫЕ МНОЖЕСТВА
 if (A.IsZeroSize() || B.IsZeroSize()) return C;
 //Промежуточное накопление общих для A & B элементов
 std::list<long> IntersectSet;
 //Цикл формирования списка элементов общих для A и B.
 for (ulong i = 0L; i < A.Size(); i++)
 {if (B.Find(A[i])) IntersectSet.push_back(A[i]); //Добавить в IntersectSet
 }
 //Передача значений в вектор C
 if (!IntersectSet.empty()) //Список содержит значения
 {C.Resize(IntersectSet.size());
  for (ulong i = 0L; i < C.Size(); i++)
  {C.Put(i,IntersectSet.front());
   IntersectSet.pop_front();//Удаление элемента i из списка
  }
 }
return C; // C = A && B
}
//****************************************************************************************
//СТАТУС: I.11; TIntVector class friend function
//OVERLOADING OPERATOR | -  A | B <=> A + B <=> A U B
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend ivector operator |(const ivector& A, const ivector& B)
//НАЗНАЧЕНИЕ: ОПЕРАЦИЯ ОБЪЕДИНЕНИЯ ДВУХ ВЕКТОРОВ ПО ПРАВИЛАМ АЛГЕБРЫ МНОЖЕСТВ
//Функция перегружает оператор | для реализации операции алгебры множеств - объединения
//двух множеств (С = A + B <=> A | B). Под множествами рассматриваются векторы А и В.
//Результат операции объединения двух множеств является множество C, которое содержит эле-
//менты как множества A, так и B. Если множество A и B является ПУСТЫМ, то множество C также
//будет пустым. ПУСТОМУ МНОЖЕСТВУ соответствует вектор нулевого  размера. Если множества A
//и B содержат НЕСКОЛЬКО ОДИНАКОВЫХ ЗНАЧЕНИЙ элементов, по которым происходит объединение,
//в множество C заносится только ОДНО ИЗ НЕСКОЛЬКИХ ОДИНАКОВЫХ ЗНАЧЕНИЙ.
//ПРИМЕР: A = {1,2,3,10,20,21}, B = {2,5,6,10,21,30,40},
//        C = A | B = {1,2,3,5,6,10,20,21,30,40}.
//Результат работы функции - вектор C, представляющий результат объединения множеств. В
//качестве промежуточного буфера, в котором происходит накопление элементов объединения A
//и B, используется класс list<long> из шаблонной библиотеки std.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& A - ссылка на вектор А, представляющий множество A;
//2. const ivector& B - ссылка на вектор B, представляющий множество B;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ivector C - результат выполнения объединения двух множеств.
//****************************************************************************************
ivector operator |(const ivector& A, const ivector& B)
{ivector C;//Результат объединения двух множеств
 //Промежуточное накопление общих для A & B элементов
 std::list<long> UnionSet;
 std::list<long>::iterator Iterator;
 //Передача значений из A в UnionSet
 for (ulong i = 0L; i < A.Size(); i++)
 {//Поиск A[i] в списке UnionSet
  Iterator = std::find(UnionSet.begin(),UnionSet.end(),A[i]);
  //Значение A[i] не найдено, добавление в список
   if (Iterator == UnionSet.end()) UnionSet.push_back(A[i]);
 }
 //Передача значений из B в UnionSet
 for (ulong i = 0L; i < B.Size(); i++)
 {//Поиск B[i] в списке UnionSet
  Iterator = std::find(UnionSet.begin(),UnionSet.end(),B[i]);
  //Значение B[i] не найдено, добавление в список
   if (Iterator == UnionSet.end()) UnionSet.push_back(B[i]);
 }
 //Передача значений в вектор C
 if (!UnionSet.empty()) //Список содержит значения
 {UnionSet.sort();//Сортируем элементы списка
  C.Resize(UnionSet.size());
  for (ulong i = 0L; i < C.Size(); i++)
  {C.Put(i,UnionSet.front());
   UnionSet.pop_front();//Удаление элемента i из списка
  }
 }
return C; //C = A | B
}
//****************************************************************************************
//СТАТУС: I.12; TIntVector class friend function
//OVERLOADING OPERATOR || -  A || B <=> A + B <=> A U B
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend ivector operator |(const ivector& A, const ivector& B)
//НАЗНАЧЕНИЕ: ОПЕРАЦИЯ ОБЪЕДИНЕНИЯ ДВУХ ВЕКТОРОВ ПО ПРАВИЛАМ АЛГЕБРЫ МНОЖЕСТВ, ОПЕРАЦИЯ
//СЛИЯНИЯ ДВУХ ВЕКТОРОВ
//Функция перегружает оператор || для реализации операции алгебры множеств - объединение
//двух множеств (С = A + B <=> A || B). В качестве множеств рассматриваются значения эле-
//ментов векторов А и В. Результат операции пересечения двух множеств является множество C,
//которое содержит элементы как множества A, так и B. Если множество A и B является ПУСТЫМ,
//то множество C также будет пустым. ПУСТОМУ МНОЖЕСТВУ соответствует  вектор нулевого раз-
//мера. При объединении A и B, если данные множества содержат НЕСКОЛЬКО ОДИНАКОВЫХ ЗНАЧЕНИЙ
//элементов, по которым происходит объединение, в множество C заносятся ВСЕ ОДИНАКОВЫЕ
//ЗНАЧЕНИЯ.
//ПРИМЕР: A = {1,1,2,3,10,20,20,21}, B = {2,5,6,10,21,30,40},
//        C = A || B = {1,1,2,3,10,20,20,21,2,5,6,10,21,30,40}.
//Операция A || B НЕКОММУТАТИВНА, т.е. A || B != B || A.
//Результат работы функции - вектор C, представляющий результат объединения множеств. В
//качестве промежуточного буфера, в котором происходит накопление элементов объединения A
//и B, используется класс list<long> из шаблонной библиотеки std.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& A - ссылка на вектор А, представляющий множество A;
//2. const ivector& B - ссылка на вектор B, представляющий множество B;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ivector C - результат объединения двух множеств.
//****************************************************************************************
ivector operator ||(const ivector& A, const ivector& B)
{ivector C;//Результат объединения двух множеств
 //Промежуточное накопление общих для A & B элементов
 std::list<long> UnionSet;
 //Передача значений из A в UnionSet
 for (ulong i = 0L; i < A.Size(); i++) UnionSet.push_back(A[i]);
 //Передача значений из B в UnionSet
 for (ulong i = 0L; i < B.Size(); i++) UnionSet.push_back(B[i]);
 //Передача значений в вектор C
 if (!UnionSet.empty()) //Список содержит значения
 {C.Resize(UnionSet.size());
  for (ulong i = 0L; i < C.Size(); i++)
  {C.Put(i,UnionSet.front());
   UnionSet.pop_front();//Удаление элемента i из списка
  }
 }
return C; //C = A || B
}
//****************************************************************************************
//СТАТУС: I.13; TIntVector class friend function
//OVERLOADING OPERATOR ^ -  A ^ B <=> A - B
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend ivector operator ^(const ivector& A, const ivector& B)
//НАЗНАЧЕНИЕ: ОПЕРАЦИЯ РАЗНОСТИ ДВУХ ВЕКТОРОВ ПО ПРАВИЛАМ АЛГЕБРЫ МНОЖЕСТВ
//Функция перегружает оператор ^ с целью реализации операции алгебры множеств - разность
//двух множеств (С = A - B <=> A ^ B). В качестве множеств рассматриваются векторы А и В.
//Результатом операции разности двух множеств является множество C с элементами множества
//A, которые не принадлежат B. Если множество A - ПУСТОЕ, то множество C также будет ПУСТЫМ.
//ПУСТОМУ МНОЖЕСТВУ соответствует вектор нулевого размера. При выполнении операции разности
//A и B, если множество A содержит НЕСКОЛЬКО ОДИНАКОВЫХ ЗНАЧЕНИЙ элементов, отсутствующие
//в B, то в множество C заносится только ОДНО ИЗ НЕСКОЛЬКИХ ОДИНАКОВЫХ ЗНАЧЕНИЙ. Операция
//разности двух множеств НЕКОММУТАТИВНА.
//ПРИМЕР: A = {1,2,3,10,20,21}, B = {2,5,6,10,21,30,40},
//        C = A ^ B = {1,3,20}, C = B ^ A = {5,6,30,40}.
//Результат работы функции - вектор C, представляющий результат разности двух множеств. В
//качестве промежуточного буфера, в котором происходит накопление элементов разности A и B,
//используется класс list<long> из шаблонной библиотеки std.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& A - ссылка на вектор А, представляющий множество A;
//2. const ivector& B - ссылка на вектор B, представляющий множество B;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// ivector C - результат выполнения операции - разность двух множеств.
//****************************************************************************************
ivector operator ^(const ivector& A, const ivector& B)
{ivector C;//Результат объединения двух множеств
 //Проверка множества A на ПУСТОЕ МНОЖЕСТВО
 if (A.IsZeroSize()) return C;
 //Промежуточное накопление элементов разности между A & B
 std::list<long> DifferenceSet;
 std::list<long>::iterator Iterator;
 //Цикл накопления элементов разности множеств A & B в списке DifferenceSet
 for (ulong i = 0L; i < A.Size(); i++)
 {//Поиск A[i] в множестве B
  if (!B.Find(A[i])) //Элемент A[i] в множестве B не найден
  {//Поиск A[i] в списке DifferenceSet
   Iterator = std::find(DifferenceSet.begin(),DifferenceSet.end(),A[i]);
   //Значение A[i] не найдено, добавление в список
   if (Iterator == DifferenceSet.end()) DifferenceSet.push_back(A[i]);
  }
 }
 //Передача значений в вектор C из списка DifferenceSet
 if (!DifferenceSet.empty()) //Список содержит значения
 {DifferenceSet.sort();//Сортируем элементы списка
  C.Resize(DifferenceSet.size());
  for (ulong i = 0L; i < C.Size(); i++)
  {C.Put(i,DifferenceSet.front());
   DifferenceSet.pop_front();//Удаление элемента i из списка
  }
 }
return C; //C = A ^ B
}

//==============================================================================
// II. РЕАЛИЗАЦИЯ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TIntVector
//     PRIVATE MEMBER-FUNCTION OF TIntVector CLASS REALIZATION
//==============================================================================
//******************************************************************************
//СТАТУС: II.1., private TIntVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Initial()
//НАЗНАЧЕНИЕ: Начальная инициализация характеристик целочисленного вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TIntVector::Initial()
{//Начальная инициализация защищенных членов-данных класса
 type = V_ZEROSIZE;//Вещественный вектор нулевого размера
 size = 0L;        //Установка размерности вектора
 data = NULL;      //Установка указателя на элементы вектора в NULL
}
//******************************************************************************
//СТАТУС: II.2., private, TIntVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Create()
//НАЗНАЧЕНИЕ: Распределение оперативной памяти под элементы целочисленного вектора
//без инициализации. Количество элементов вектора определяется переменной size.
//Если size равна 0, то создается вектор нулевого размера. В случае нехватки па-
//мяти возвращается false. Элементы вектора хранятся в одномерном массиве data.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - признак работы функции
//******************************************************************************
bool TIntVector::Create()
{//Вектор нулевого размера
 if (Size() == 0) {Initial(); return true;}
 //Распределение памяти под элементы вектора и первоначальная их инициализация
 try
  { data = new long[Size()]; //Распределение памяти под элементы вектора
  }
  // ENTER THIS BLOCK ONLY IF xalloc IS THROWN.
  // YOU COULD REQUEST OTHER ACTIONS BEFORE TERMINATING
  catch (std::bad_alloc) {Initial(); return false;}//xalloc x
 return true;
}
//******************************************************************************
//СТАТУС: II.3., private, TIntVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Delete()
//НАЗНАЧЕНИЕ: Удаление из оперативной памяти элементов целочисленного вектора.
//После завершения работы функции получается вектор нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TIntVector::Delete()
{//Вектор нулевого размера
 if (data == NULL) {Initial(); return;}
 delete[] data; //Удаление элементов вектора
 Initial();
}

//==============================================================================
// III. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TIntVector
//      PROTECTED MEMBER-FUNCTION OF TIntVector CLASS REALIZATION
//==============================================================================
//******************************************************************************
//СТАТУС: III.1., protected, TIntVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsZeroSize() const
//НАЗНАЧЕНИЕ: Проверка целочисленного вектора на вектор нулевого размера. В случае
//удачи функция возвращает - true и false - в противном случае. Свойства вектора
//нулевого размера: size == 0 || data == NULL
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - вектор со всеми нулевыми элементами;
//                false - не нулевой вектор.
//******************************************************************************
bool TIntVector::IsZeroSize() const
{//Проверка на size == 0 & data == NULL
 return (Size() == 0L) ? true : false;
}
//******************************************************************************
//СТАТУС: III.2., protected, TIntVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsZero() const
//НАЗНАЧЕНИЕ: Проверка целочисленного вектора со всеми нулевыми элементами. В
//случае удачи функция возвращает - true и false - в противном случае. Свойства
//вектора со всеми нулевыми элементами:
//1. size != 0 - вектор должен быть не НУЛЕВОГО РАЗМЕРА;
//2. V[i] = 0 - ВСЕ элементы вектора должны быть равны НУЛЮ.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - вектор со всеми нулевыми элементами;
//                false - не нулевой вектор.
//******************************************************************************
bool TIntVector::IsZero() const
{bool lSuccess = false;
 if (IsZeroSize()) return lSuccess;//Вектор нулевого размера
 lSuccess = true;
 for (ulong i = 0; i < Size(); i++) //Цикл проверки свойства 2
 {if (data[i] == 0L) {lSuccess = false; break;} //Все элементы д.б. нулевыми
 }
return lSuccess;
}
//******************************************************************************
//СТАТУС: III.3., protected, TIntVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsScalar() const
//НАЗНАЧЕНИЕ: Проверка целочисленного вектора на СКАЛЯРНЫЙ ВЕКТОР. В случае удачи
//функция возвращает - true и false - в противном случае. Свойства скалярного
//вектора:
//1. size != 0 - вектор должен быть не НУЛЕВОГО РАЗМЕРА;
//2. V[i] = a - ВСЕ элементы вектора должны быть равны между собой и отличны от 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - true - вектор скалярный;
//                                       false - вектор не скалярный.
//******************************************************************************
bool TIntVector::IsScalar() const
{bool lSuccess = false;
 if (IsZeroSize()) return lSuccess;//Вектор нулевого размера
 //Цикл проверки свойства 2
 if (data[0] == 0L) return lSuccess;
 lSuccess = true;
 long a = data[0];
 for (ulong i = 1; i < Size(); i++)
 {if (data[i] != a) {lSuccess = false; break;} //Все элементы д.б. равными a
 }
return lSuccess;
}
//******************************************************************************
//СТАТУС: III.4., protected, TIntVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsUnit() const
//НАЗНАЧЕНИЕ: Проверка целочисленного вектора на ЕДИНИЧНЫЙ ВЕКТОР. В случае удачи
//функция возвращает - true и false - в противном случае. Свойства единичного
//вектора:
//1. size != 0 - вектор должен быть не НУЛЕВОГО РАЗМЕРА;
//2. V[i] = 1 - ВСЕ элементы вектора должны быть равны 1.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - true - вектор единичный;
//                                       false - вектор не единичный.
//******************************************************************************
bool TIntVector::IsUnit() const
{bool lSuccess = false;
 if (IsZeroSize()) return lSuccess;//Проверка на вектор нулевого размера
 lSuccess = true;
 for (ulong i = 0; i < Size(); i++) //Цикл проверки свойства 2
 {if (data[i] != 1L) {lSuccess = false; break;}//Все элементы д.б. равны 1
 }
return lSuccess;
}

//----------------------------------------------------------------------------------------
// III. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ФУНКЦИЙ КЛАССА TIntVector
//      КОНСОЛЬНОГО ВВОДА ЭЛЕМЕНТОВ ЦЕЛОЧИСЛЕННОГО ВЕКТОРА
//----------------------------------------------------------------------------------------
//****************************************************************************************
//СТАТУС: III.1., protected, TIntVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutVector(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ ЦЕЛОЧИСЛЕННОГО ВЕКТОРА
//Функция вводит элементы целочисленнного вектора. Формат ввода элементов вектора:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <vector name>;
//      TYPE: <vector type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>]: <long value>.
//Функция вводит целочисленные векторы TIntVector произвольных типов. При ввода элементов
//вектора проверяется корректность длинных целых чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование вектора;
//2. bool confirm (true) - опция подтверждения введеных данных каждого элемента вектора.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TIntVector::InPutVector(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемого вектора
 cout << endl;
 cout << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << "     " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода всех элементов целочисленного вектора
 for (ulong i = 0; i < Size(); i++)
 {cout << name << "[" << (i+1) << "]: ";
  data[i] = EditLong(confirm); //Ввод i-го элемента вектора
  ClrScr(x,y);//Очистка экрана
 }
 cout << "All elements of " << GetCompleteType(s) << " <" << name
      << "> are entered!" << endl;
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.2., protected, TIntVector class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutScalar(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ СКАЛЯРНОГО ВЕКТОРА
//Функция вводит элементы скалярного вектора. Формат ввода элементов вектора:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <vector name>;
//      TYPE: <vector type>; DIMENSION: <Size()>.
//----------------------------------------------------------------------------------------
//Value: <long value>.
//При вводе значений элементов вектора проверяется корректность длинных целых чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование целочисленного вектора;
//2. bool confirm - подтверждение введеных данных по каждому элементу вектора.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TIntVector::InPutScalar(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 long value;
 //----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемого вектора
 cout << endl;
 cout << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << "     " << Properties(s);
 cout << line << endl;
 //----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Обнуление элементов вектора
 for (ulong i = 0L; i < Size(); i++) data[i] = 0.0;
 //Ввод одного элемента скалярного вектора
 cout << "Element value: ";
 value = EditLong(confirm); //Ввод элемента вектора
 //Цикл присваивания элементам скалярного вектора значения value
 for (ulong i = 0L; i < Size(); i++) data[i] = value;
 ClrScr(x,y);//Очистка экрана
 cout << "All elements of " << GetCompleteType(s) << " <" << name
      << "> are entered!" << endl;
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}

//==============================================================================
//    РЕАЛИЗАЦИЯ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССУ TIntVector
//    REALIZATION of THE FRIEND FUNCTION TO TIntVector CLASS
//==============================================================================
//******************************************************************************
//СТАТУС: FRIEND FUNCTION to TIntVector class # 1
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend uint MaxStrLen(const TIntVector& V)
//НАЗНАЧЕНИЕ: Определение максимального символьного размера элемента целочислен-
//ного вектора V. Функция используется для рационального отображения элементов
//целочисленного вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TRealVector& V - ссылка на целочисленный вектор
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//uint MaxLen - максимальная символьная длина элемента вектора V
//******************************************************************************
uint MaxStrLen(const TIntVector& V)
{uint MaxLen = 0;
 if (V.IsZeroSize()) return MaxLen; //Вектор нулевого размера
 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 uint count;
 //Цикл считывания элементов целочисленного вектора
 for (ulong i = 0L; i < V.Size(); i++)
 {//Формирование символьного представления длинного целого числа
  text << V.Get(i) << ends;
  //Определение максимальной символьной длины элемента целочисленного вектора
  count = text.pcount()-1;
  if (count > MaxLen) MaxLen = count;
  text.seekp(0);
 }
return MaxLen;
}
//******************* Конец реализации класса TIntVector ***********************

//========================================================================================
//    РЕАЛИЗАЦИЯ СЕРВИСНЫХ ФУНКЦИЙ
//    REALIZATION of THE SERVICE FUNCTION
//========================================================================================
//****************************************************************************************
//СТАТУС: SERVICE FUNCTION # 1
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//void InPutPF_VECTOR(PF_VECTOR& Info, const char* Name = NULL);
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ПОЛЕЙ СТРУКТУРЫ PF_VECTOR.
//Функция осуществляет ввод характеристик для формирования вектора. После ввода характеристик
//осуществляется контроль введенных параметров и при необходимости можно повторно ввести
//данные. Введенные характеристики заносятся в структуру Info. Формат ввода следующий:
// ---------------------------------------------------------------------------------------
// MODE: DATA ENTRY for VECTOR BUILDING - <Name>.
// ---------------------------------------------------------------------------------------
// I. VECTOR TYPE:
//  1. Type: <string>;
// II. VECTOR DIMENSION:
//  1. Size:  <ulong value>;
//----------------------------------------------------------------------------------------
// Структурная схема выбора типа вектора:
// 1. Select vector type [1-2]:
//    1. Vector-row;
//    2. Vector-column;
// Структурная схема выбора подтипа вектора-строки (вектора-столбца):
// 1. Select row-vector (vector-column) subtype [1-10]:
//    1. Ordinary vector;
//    2. Unit vector;
//    3. Scalar vector;
//    4. Zero vector;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. PF_VECTOR& Info - ссылка на структуру с характеристиками формируемого вектора;
//2. const char* Name - наименование вектора
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void InPutPF_VECTOR(PF_VECTOR& Info, const char* Name)
{bool flag;
 char c;
 const string line(78,'-');

 STR_UINT ListVectorType[2] = {
  {1, "Row-vector"    },
  {0, "Column-vector" } };
 TB_STR_UINT TbVectorType = {2, ListVectorType};

 STR_UINT ListVectorSubType[4] = {
  {V_ORDINARY,"Ordinary vector" },
  {V_UNIT,    "Unit vector"     },
  {V_SCALAR,  "Scalar vector"   },
  {V_ZERO,    "Zero vector"     } };
 TB_STR_UINT TbVectorSubType = {4, ListVectorSubType};

 string head,t;
 uint type;
 clrscr(); //Очистка экрана
 if (Name == NULL) Name = "V";
 do //Начало цикла ввода данных
 {//---------------------------------------------------------------------------
  //Вывод заголовка
  cout << line << endl;
  cout << "MODE: DATA ENTRY for VECTOR BUILDING - <" << Name << ">."
       << endl;
  cout << line << endl;
  //---------------------------------------------------------------------------
  //Выбор типа вектора
  cout << "I. VECTOR TYPE:" << endl;
   head =  " Choice vector type: ";
   type = ConsoleChoice(TbVectorType, 1, head.c_str(), 2);
   if (type == 1) //Вектор-строка
   {head = " Choice row-vector subtype: "; Info.type = ROW; t = "-row";}
   else //Вектор-столбец
   {head = " Choice column-vector subtype: "; Info.type = COL; t = "-column";}
   type = ConsoleChoice(TbVectorSubType, V_ORDINARY, head.c_str(), 2);
   cout << " 1. Type: <" << GetName(TbVectorSubType, type) << t << ">;" << endl;
   Info.subtype = type;
  //---------------------------------------------------------------------------
  //Ввод размерности вектора
  cout << "II. VECTOR DIMENSION:" << endl;
   ulong size;
   uint x = wherex(), y = wherey();
   cout << " Enter vector size: "; cin >> size;
   ClrScr(x,y);//Очистка экрана
   Info.size = size;
   cout << " 1. Size: " << Info.size << ";" << endl;
   if (size == 0L) Info.subtype = V_ZEROSIZE;
   if (size == 1L) Info.subtype = V_NUMBER;
  //---------------------------------------------------------------------------
  cout << line << endl;
  //---------------------------------------------------------------------------
  //Подтверждение введенных данных
  x = wherex(); y = wherey();
  cout << "Please, confirm data entry [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y')
  {flag = true; ClrScr(x,y);
   cout << "All Datas are entered! Press any key...\a"; getch();
  }
  else flag = false;
  clrscr();
 } while (!flag); //Конец цикла ввода данных
}


