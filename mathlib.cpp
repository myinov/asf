//Mathlib.cpp
//Copyright (c) JohnSoft 2000-2002. All rights reserved. Borland C++ 5.02.
//Initial date: March,15,2000. Final date:
//Реализация математических классов общего назначения
#include "mathlib.h"
                 
//-----------------------------------------------------------------------------------
//Реализация класса TRandomGenerator - генератор псевдослучайной последовательности
//положительных целых равномерно распределенных чисел с задаваемым периодом от 2^20
//до 2^24 и возможностью получения СВ с равномерным распределением в других интервалах
//и СВ с другими законами распределения: экспоненциальным распределением, распределе-
//нием Релея, гауссовским (нормальным) распределением и другими видами распределения.
//Initial date: May,14,1999. Final date:
//Copyright (c) JohnSoft 1999-2002. All rights reserved. Borland C++ 5.02
//***********************************************************************************
//Таблица соответствий задаваемого пользователем периода последовательности
//рабочим установкам генератора - TB_RNG
//***********************************************************************************
RNG_SET ListSet[5] = {
 {T_1, 1048576L, 2045}, {T_2, 2097152L, 1021}, {T_4, 4194304L, 509},
 {T_8, 8388608L, 253},  {T_16, 16777216L, 125} };

TB_RNG Table = {5, ListSet};

//***********************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TRandomGenerator
//***********************************************************************************

//===================================================================================
// I. ОПИСАНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TRandomGenerator
//    PUBLIC MEMBER-FUNCTION OF TRandomGenerator CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1; public; class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetPerform(uint Period, uint InitValue = 0);
//НАЗНАЧЕНИЕ: Установка свойств генератора случайных чисел. Перед установкой новых
//характеристик объекта старые характеристики уничтожаются вызовом функции Initial().
//Функция может использоваться для инициализации характеристик после создания объекта
//класса TRandomGenerator конструктором по умолчанию, а также в процессе работы с
//данным объектом в случае необходимости изменения его параметров.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint Period - идентификатор периода последовательности (T_1, T_2, ..., T_16;
//2. uint InitValue - начальное значение случайной последовательности.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRandomGenerator::SetPerform(uint Period, uint InitValue)
{Initial(); //Начальная установка параметров датчика случайных чисел
 //----------------------------------------------------------------------------------
 SetPeriod(Period);//Установка рабочих параметров генератора по величине Period
 //----------------------------------------------------------------------------------
 //Установка начального значения последовательности
 if (InitValue == 0) Randomize();
 else SetInit(InitValue);
 Rn = Init;//Начальное значение последовательности
}
//***********************************************************************************
//СТАТУС: I.2; public; class member-function TRandomGenerator
//НАИМЕНОВАНИЕ ФУНКЦИИ: PF_RNG& GetPerform(PF_RNG &Info) const;
//НАЗНАЧЕНИЕ: Получение текущих свойств датчика случайных чисел. Характеристики
//объекта записываются в структуру PF_RNG.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//PF_RNG &Info - ссылка на структуру, в которую будут записываться текущие
//свойства объекта TRandomGenerator.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//PF_RNG &Info - ссылка на структуру с параметрами объекта TRandomGenerator
//***********************************************************************************
PF_RNG& TRandomGenerator::GetPerform(PF_RNG &Info) const
{//Запись текущих параметров датчика случайных чисел
 Info.M = GetPeriod();
 Info.J = GetFactor();
 Info.Rn = GetR();
 Info.Init = GetInit();
 Info.Count = GetCount();
return Info;
}
//***********************************************************************************
//СТАТУС: I.3; public member-function of class TRandomGenerator
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetPerform(string& s) const
//НАЗНАЧЕНИЕ: Формирование характеристики объекта TRandomGenerator в виде строки.
//Свойства объекта разделяются символом '\n'. Свойства генератора случайных чисел:
// ****************  Random Number Generator ****************************************
// 1. ALGORITHM: R(n+1) = (J*R(n)+1) mod M;
// 2. Period M: < value >;
// 3. Multiplier J: < value >;
// 4. Initial value: < value >;
// 5. Current random number: < value >;
// 6. RNG calls amount: < value >.
// **********************************************************************************
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строковый объект
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами RNG
//***********************************************************************************
string& TRandomGenerator::GetPerform(string& s) const
{PF_RNG Info;
 char buffer[80];
 ostrstream text (buffer, sizeof(buffer));
 string line(78,'*');
 line.append(1,'\n');
 s.resize(0);
 //Получение характеристик RNG
 GetPerform(Info);
 //----------------------------------------------------------------------------------
 //Формирование текущих характеристик RNG в виде символьной строки
 s.append(line);
 s.append("RANDOM-NUMBER GENERATOR:\n");
 //Алгоритм работы RNG
 s.append("1. Algorithm: R(n+1) = (J*R(n)+1) mod M;\n");
 //Период последовательности -  M
 s.append("2. Period M: ");
 text << Info.M << ";" << endl << ends;
 s.append(text.str()); text.seekp(0);
 //Множитель последовательности -  J
 s.append("3. Multiplier J: ");
 text << Info.J << ";" << endl << ends;
 s.append(text.str()); text.seekp(0);
 //Начальное значение последовательности - Init
 s.append("4. Initial value: ");
 text << Info.Init << ";" << endl << ends;
 s.append(text.str()); text.seekp(0);
 //Текущее случайное целое число - Rn
 s.append("5. Current random number: ");
 text << Info.Rn << ";" << endl << ends;
 s.append(text.str()); text.seekp(0);
 //Количество обращений к RNG - Count
 s.append("6. RNG calls amount: ");
 text << Info.Count << "." << endl << ends;
 s.append(text.str()); text.seekp(0);
 s.append(line);
return s;
}
//***********************************************************************************
//СТАТУС: I.4; public member-function of class TRandomGenerator
//НАИМЕНОВАНИЕ ФУНКЦИИ:  ulong GetPeriod() const;
//НАЗНАЧЕНИЕ: Получение периода последовательности
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong Period - период последовательности RNG
//***********************************************************************************
ulong TRandomGenerator::GetPeriod() const
{
 return Table.rec[Index].M;
}
//***********************************************************************************
//СТАТУС: I.5; public member-function of class TRandomGenerator
//НАИМЕНОВАНИЕ ФУНКЦИИ:  uint GetFactor() const;
//НАЗНАЧЕНИЕ: Получение множителя последовательности
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint Factor - множитель последовательности RNG
//***********************************************************************************
uint TRandomGenerator::GetFactor() const
{
 return Table.rec[Index].J;
}
//***********************************************************************************
//СТАТУС: I.6; public member-function of class TRandomGenerator
//НАИМЕНОВАНИЕ ФУНКЦИИ:  Randomize();
//НАЗНАЧЕНИЕ: Инициализация начального значения последовательности случайной величиной.
//Используется вызов стандартной функции rand() из библиотеки stdlib и осуществляется
//проверка, чтобы СВ была больше 1000.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRandomGenerator::Randomize()
{uint InitValue;
 randomize();
 do {InitValue = rand();} while (InitValue < 1000);
 SetInit(InitValue);
 Rn = InitValue;//Начальное значение последовательности
 Count = 0L;
}
//***********************************************************************************
//СТАТУС: I.7; public member-function of class TRandomGenerator
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong Rand();
//НАЗНАЧЕНИЕ: Функция возвращает целую положительную равномерно распределенную случай-
//ную величину и генерирует новое значение по формуле: R(n+1) = (J*R(n)+1)modM.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: R - равномерно распределенное целое положительное число
//***********************************************************************************
ulong TRandomGenerator::Rand()
{//ulong R = GetR();
 Rn = (GetFactor()*Rn+1) % GetPeriod();
 Count++;
 return Rn;
}
//***********************************************************************************
//СТАТУС: I.8; public member-function of class TRandomGenerator
//НАИМЕНОВАНИЕ ФУНКЦИИ: long Rand(long A, long B);
//НАЗНАЧЕНИЕ: Функция возвращает целую равномерно распределенную случайную величину
//в интервале от A до B, где A < B: R = Min + (Max-Min+1)%Rand()
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//long A - нижняя граница интервала;
//long B - верхняя граница интервала.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// long R - равномерно распределенное целое число в пределах от A до B.
//***********************************************************************************
long TRandomGenerator::Rand(long A, long B)
{long R, Left, Right;
 //Проверка условия A > B
 if (A < B) {Left = A; Right = B;}
 else if (A > B) {Left = B; Right = A;}
 else if (A == B) return A;
 R = Left + (Right-Left+1)%Rand();
 return R;
}

//***********************************************************************************
//СТАТУС: I.9; public member-function of class TRandomGenerator
//НАИМЕНОВАНИЕ ФУНКЦИИ: double Random();
//НАЗНАЧЕНИЕ: Функция возвращает равномерно распределенную случайную величину в
//интервале от 0 до 1.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// double R - равномерно распределенное число в пределах от 0 до 1.
//***********************************************************************************
double TRandomGenerator::Random()
{double R;
 R = ((double)Rand()+1.0)/((double)GetPeriod()+1.0);
 return R;
}
//***********************************************************************************
//СТАТУС: I.10; public member-function of class TRandomGenerator
//НАИМЕНОВАНИЕ ФУНКЦИИ: double Random(double A, double B);
//НАЗНАЧЕНИЕ: Функция возвращает равномерно распределенную случайную величину в интер-
//вале от A до B, где A < B.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//double A - нижняя граница интервала;
//double B - верхняя граница интервала.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// double R - равномерно распределенное число в пределах от A до B.
//***********************************************************************************
double TRandomGenerator::Random(double A, double B)
{double R, Left, Right;
 //Проверка условия A > B
 if (A < B) {Left = A; Right = B;}
 else if (A > B) {Left = B; Right = A;}
 else if (A == B) return A;
 R = Left + (Right-Left)*Random();
 return R;
}
//***********************************************************************************
//СТАТУС: I.11; public member-function of class TRandomGenerator
//НАИМЕНОВАНИЕ ФУНКЦИИ: double Gauss(double M = 0.0, double D = 1.0);
//НАЗНАЧЕНИЕ: Функция возвращает нормально распределенную случайную величину в интер-
//вале с математическим ожиданием M и дисперсией D. Для получения СВ, распределенной
//по гауссовскому закону, используется алгоритм Бокса-Маллера.
//Данный алгоритм посволяет по двум обращениям к генератору случайных чисел, формирую-
//щему равномерно распределенные числа x1 и x2 в пределах от 0 до 1, получить две слу-
//чайные величины Y1 & Y2, имеющие нормированное (M = 0, D = 1) нормальное распределе-
//ние:  Y1 = -2*ln(x1)*cos(2*PI*x2); Y2 = -2*ln(x1)*sin(2*PI*x2).
//Переход к нормальному распределению с произвольными мат. ожиданием M и дисперсией D
//производится посредством преобразования: Y' = M + Y*D.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//double M - математическое ожидание (по умолчанию M = 0);
//double D - дисперсия (по умолчанию D = 1).
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// double R - нормально распределенное число с мат. ожиданием M и дисперсией D.
//***********************************************************************************
double TRandomGenerator::Gauss(double M, double D)
{double R;
 R = -2.0*log(Random())*cos(6.28318530718*Random());
 R = M + R*D;
 return R;
}
//===================================================================================
// II. ОПИСАНИЕ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TRandomGenerator
//    PRIVATE MEMBER-FUNCTION OF TRandomGenerator CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: II.1; private; class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Initial();
//НАЗНАЧЕНИЕ: Начальная установка всех характеристик TRandomGenerator
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRandomGenerator::Initial()
{ Index = 0; Init = 0; Rn = 0; Count = 0;
}
//***********************************************************************************
//СТАТУС: II.2; private; class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetPeriod(uint Period)
//НАЗНАЧЕНИЕ: Функция устанавливает переменную Index, которая является индексом в таб-
//лице Table типа TB_RNG с параметрами генератора. Поиск необходимого индекса ведется
//по полю type структуры RNG_SET, являющейся записью в Table. Сравнение значения type
//осуществляется с аргументом Period. При совпадении значений осуществляется прекраще-
//ние поиска в Table и значение Index принимает индекс (номер) в этой записи в таблице.
//Если поиск окончился неудачно, то Index принимает значение равное 0, что соответст-
//вует периоду последовательности генератора равное 1 048 576.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//uint Period - идентификатор, соответствующий задаваемому периоду последовательности
//случайных чисел.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRandomGenerator::SetPeriod(uint Period)
{Index = 0;//Значение по умолчанию
 //Поиск в таблице Table по полю type
 for (uint i = 0; i < Table.size; i++)
 {if (Table.rec[i].type == Period) {Index = i; break;}
 }
}

//******************************************************************************
//             РЕАЛИЗАЦИЯ КЛАССА TEvenCloseInterval
//       РАВНОМЕРНЫЙ ЗАКРЫТЫЙ ИНТЕРВАЛ [left,left+delta...right]
//left - левая граница интервала;
//right - правая граница интервала;
//delta - шаг интервала
//******************************************************************************
//==============================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TEvenCloseInterval
//   PUBLIC MEMBER-FUNCTION OF TEvenCloseInterval CLASS
//==============================================================================
//*****************************************************************************
//СТАТУС: I.1; TEvenCloseInterval public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Set(double a, double b, double step = 0.1)
//НАЗНАЧЕНИЕ: Установка параметров равномерного закрытого интервала. Границы и
//шаг интервала должны удовлетворять следующим правилам:
//1) a <= b;
//2) step > 0.0;
//3) количество чисел принадлежащих интервалу не должно превышать 4294967295,
//   в противном случае, шаг интервала автоматически увеличивается в два раза
//   до тех пор, пока кол-во чисел внутри интервала не достигнет приемлемого
//   значения (от 1 до 4 294 967 295). Данное ограничение связано с тем, что
//   данный интервал можно преобразовывать в вектор вещественных чисел.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double a - левая граница закрытого интервала;
//2. double b - правая граница закрытого интервала;
//3. double step (0.1) - дискретность интервала.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TEvenCloseInterval::Set(double a, double b, double step)
{Delta = (step == 0.0) ? 0.1 : fabs(step);//Установка шага интервала
 //Установка границ интервала
 if (a < b) {Left = a; Right = b;} else {Left = b; Right = a;}
 do //Определяем количество чисел, принадлежащих интервалу
 {double size = ceil((Right-Left)/Delta)+1;
  if (size > 4294967295) Delta *= 2.0;//Увеличение шага интервала
  else {Count = size; break;}
 } while (true);
}
//****************************************************************************************
//СТАТУС: I.2; TEvenCloseInterval public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double Number(ulong n)
//НАЗНАЧЕНИЕ: Получение n-го числа, принадлежащего интервалу, 0 <= n < N. Если n > N, то
//функция возвращает наибольшее значение Right - правую границу интервала.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong n - порядковый номер числа в интервале вещественных чисел
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//double value - число, с порядковым номером n, принадлежащее интервалу
//****************************************************************************************
double TEvenCloseInterval::Number(ulong n) const
{return (n >= (Count-1)) ? Right : Left + Delta*n;
}
//*****************************************************************************
//СТАТУС: I.3; TEvenCloseInterval public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Copy(rvector& Data) const
//НАЗНАЧЕНИЕ: Преобразование интервала в вектор вещественных чисел.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//rvector& Data - ссылка на вектор вещественных чисел, в который будут помещены
//                числовые значения, принадлежащие интервалу.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TEvenCloseInterval::Copy(rvector& Data) const
{//Установка размера вектора равная количеству чисел в интервале
 Data.Resize(Count);
 //Копирование чисел, принадлежащих интервалу, в вещественный вектор
 for (ulong i = 0L; i < Data.Size(); i++) Data.Put(i,Number(i));
}
//****************************************************************************************
//СТАТУС: I.4; TEvenCloseInterval public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& Properties(string& s, const string& head, uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирование свойств интервала в виде строки. Информация заносится в строку
//s, передаваемую в функцию по ссылке, предыдущее содержимое строки s уничтожается. Формат
//вывода свойств интервала:
//<Even Close Interval | head: > <[Left,Left+Delta..Right] Size: <Count> >
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& head - ссылка на строку с заголовком объекта;
//3. uint indent (0) - начальное смещение строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//****************************************************************************************
string& TEvenCloseInterval::Properties(string& s, const string& head, uint indent) const
{char buffer[80]; ostrstream text (buffer, sizeof(buffer));
 //Формирование заголовка объекта
 string space(indent,' '); s = space;
 if (head.empty()) s.append("Even Close Interval"); else s.append(head);
 s.append(": ");
 //Формирование свойств интервала
 if (Count > 2)
  text << "[" << Left << ", " << (Left+Delta) << " .. " << Right << "] " << ends;
 else text << "[" << Left << " .. " << Right << "] " << ends;
 s.append(text.str()); text.seekp(0);
 text << "Size: " << Count << endl << ends;
 s.append(text.str()); text.seekp(0);
 return s;
}
//****************************************************************************************
//СТАТУС: I.5; TEvenCloseInterval public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Info(string& s) const
//НАЗНАЧЕНИЕ: Формирование свойств интервала в виде строки. Информация заносится в строку
//s, передаваемую ссылке, предыдущее содержимое строки s уничтожается. Формат вывода свойств
//интервала: < N: <Count> <[Left,Left+Delta..Right] >
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строковый объект;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//****************************************************************************************
string& TEvenCloseInterval::Info(string& s) const
{char buffer[80];
 ostrstream text (buffer, sizeof(buffer));
 //Формирование свойств интервала
 text << "N: " << this->Count << ends;
 s.assign(text.str()); text.seekp(0);
 if (this->Count > 2)
  text << " [" << Left << ", " << (Left+Delta) << " .. " << Right << "];" << ends;
 else text << " [" << Left << " .. " << Right << "];" << ends;
 s.append(text.str()); text.seekp(0);
 return s;
}

//****************************************************************************************
//СТАТУС: I.5; TEvenCloseInterval public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit(const string& head)
//НАЗНАЧЕНИЕ: Ввод параметров интервала с консоли. Формат ввода интервала:
//----------------------------------------------------------------------------------------
//< EVEN CLOSE INTERVAL || head.c_str() >: Input Properties
//< Even Close Interval Properties: [left,left+delta..right] Size: <Count> >
//  Left Bound: <double value>
//  Right Bound: <double value>
//  Interval Step: <double value>
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// string& head (string())- ссылка на строку с заголовком объекта;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TEvenCloseInterval::Edit(const string& head)
{//Рабочие переменные
 int y, row_start = wherey(); string s, h, line(78,'-'); bool flag; char c;
 double value;
 gotoxy(1,row_start); clreol();
 //Формирование заголовка объекта
 h = (head.empty()) ? string("Even Close Interval") : head;
 h.append(": < Input Properties >");
 do //Цикл ввода свойств равномерного закрытого интервала
 {cout << line << endl << h << endl;
  //---------------------------------------------------------------------------
  //Ввод значений границ и шага равномерного закрытого интервала
  //---------------------------------------------------------------------------
  y = wherey();
  cout << Properties(s,h,1) << line << endl;
  //Ввод левой границы интервала
  cout << "  Left Bound: "; cin >> value; Set(value,Right,Delta);
  do {gotoxy(1,wherey()-1); clreol();} while (y != wherey());//Очистка экрана
  cout << Properties(s,h,1) << line << endl;
  //Ввод правой границы интервала
  cout << "  Right Bound: "; cin >> value; Set(Left,value,Delta);
  do {gotoxy(1,wherey()-1); clreol();} while (y != wherey());
  cout << Properties(s,h,1) << line << endl;
  //Ввод дискретности (шага) интервала
  cout << "  Interval Step: "; cin >> value; Set(Left,Right,value);
  do {gotoxy(1,wherey()-1); clreol();} while (y != wherey());
  cout << Properties(s,h,1) << line << endl;
  //---------------------------------------------------------------------------
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  do {gotoxy(1,wherey()-1); clreol();} while (row_start != wherey());
 } while (flag);
 cout << Properties(s,h,1);
}
//****************************************************************************************
//СТАТУС: I.6; TEvenCloseInterval public member-function
//OVERLOADING ASSIGNMENT OPERATOR (=)
//НАИМЕНОВАНИЕ ФУНКЦИИ: TEvenCloseInterval& operator =(const TEvenCloseInterval& Gap)
//НАЗНАЧЕНИЕ:Перегрузка оператора присваивания (=) для класса TEvenCloseInterval
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//TEvenCloseInterval& Gap - ссылка на объект TEvenCloseInterval, параметры которого будут
//скопированы в данный интервал.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//TEvenCloseInterval& - ссылка на интервал, в который были скопированы свойства интервала Gap.
//****************************************************************************************
TEvenCloseInterval& TEvenCloseInterval::operator =(const TEvenCloseInterval& Gap)
{if (this == &Gap) return *this;
 Left = Gap.LeftBorder(); Right = Gap.RightBorder();
 Delta = Gap.Step(); Count = Gap.Size();
 return *this;
}
//****************************************************************************************
//СТАТУС: I.7; FRIEND function to TEvenCloseInterval class
//OVERLOAD THE STREAM INSERTION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend ostream& operator <<(ostream& out, const TEvenCloseInterval& Gap)
//НАЗНАЧЕНИЕ: Перегрузка операции потокового вывода (<<) свойств класса
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//TEvenCloseInterval& Gap - ссылка на объект TEvenCloseInterval, параметры
//которого будут скопированы в данный интервал.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//TEvenCloseInterval& - ссылка на интервал, в который были скопированы свойства
//интервала Gap.
//****************************************************************************************
ostream& operator <<(ostream& out, const TEvenCloseInterval& Gap)
{string s;
 return out << Gap.Info(s);
}

//****************************************************************************************
//                        РЕАЛИЗАЦИЯ КЛАССА TPoint_2D
//Класс описывает точку на плоскости, которая характеризуется двумя параметрами:
//1) x - координата по оси Ox;
//2) y - координата по оси Oy;
//Значения координат точки в классе TPoint_2D представляются типом double.
//****************************************************************************************
//========================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TPoint_2D
//    PUBLIC MEMBER-FUNCTION OF TPoint_2D CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TPoint_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(const char* s)
//НАЗНАЧЕНИЕ: Установка значений координат точки из строки s. Функция извлекает из строки
//s координаты x & y точки и в случае успеха устанавливает новые свойства объекта. Формат
//символьного представления свойств класса:
//[<WS>]<(><X>,[<WS>]<Y><)>, где (например, (1.5,-30.4) => x = 1.5, y = -30.4)
//X, Y - символьные представления вещ-х значений x & y координат точки.
//Функция возвращает false в случае отсутствия символьного представления координат точки в
//s или в случае обнаружения синтаксической ошибки при их извлечении из s.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const char* s - константный указатель на строку со значениями координатам точки
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - индикатор обновления свойств объекта из строки
//****************************************************************************************
bool TPoint_2D::Set(const char* s)
{bool lSuccess = false;
 TStrToDoubleArgs DArgs;//Объект извлечения из строки вещ-х аргументов в круглых скобках
 ulong pos = 0L;
 //Извлечение из строки s списка вещ-х чисел, заключенных в круглые скобки
 if (DArgs(s,pos) == 2) //Список должен содержать ровно 2 числа - X & Y
 {rvector params;
  DArgs.GetFirstChain(params);
  Set(params[0],params[1]);
  lSuccess = true;
 }
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.2; public member-function of class TPoint_2D
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Properties(string& s) const
//НАЗНАЧЕНИЕ: Формирование характеристик объекта TPoint_2D в символьном виде в строке s,
//передаваемой в функцию по ссылке. Свойства точки на плоскости представляются:
//----------------------------------------------------------------------------------------
// (x = <_x>, y = <_y>)
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строковый объект, в котором формируются свойства объекта
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами объекта.
//****************************************************************************************
string& TPoint_2D::Properties(string& s) const
{char buffer[41];
 ostrstream text(buffer, sizeof(buffer));
 text << "(x = " << GetX() << ", y = " << GetY() << ')' << ends;
 s.assign(text.str());
 return s;
}
//****************************************************************************************
//СТАТУС: I.3; public member-function of class TPoint_2D
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Brief(string& s) const
//НАЗНАЧЕНИЕ: Получение свойств объекта TPoint_2D в краткой форме в строке s, передаваемой
//в функцию по ссылке. Свойства точки на плоскости представляются:
//----------------------------------------------------------------------------------------
// (<_x>, <_y>)
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строку, в которой заносятся свойства объекта в кратком виде
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами объекта в кратком виде
//****************************************************************************************
string& TPoint_2D::Brief(string& s) const
{char buffer[41];
 ostrstream text(buffer, sizeof(buffer));
 text << '(' << GetX() << ',' << GetY() << ')' << ends;
 s.assign(text.str());
 return s;
}
//========================================================================================
// РЕАЛИЗАЦИЯ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ КЛАССА TPoint_2D
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TPoint_2D class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: void operator =(const TPoint_2D& Point)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ  класса TPoint_2D. Функция копирует
//свойства (координаты) одного объекта TPoint_2D в другой.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TPoint_2D& Point - ссылка на копируемый объект
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPoint_2D::operator =(const TPoint_2D& Point)
{//Предотвращение попытки присваивания объекта самому себе
 if (this == &Point) return;
 this->Set(Point.GetX(),Point.GetY());
}
//****************************************************************************************
//СТАТУС: I.2; public; TPoint_2D class overloading operator ==
//OVERLOADING COMPARE OPERATOR <EQUAL>
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ==(const TPoint_2D& Point) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СРАВНЕНИЯ объектов класса TPoint_2D. Функция сравнивает
//координаты двух объектов TPoint_2D. При равенстве их координат функция возвращает true,
//в противном случае - false.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TPoint_2D& Point - ссылка на сравниваемый объект
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lCompare - результат сравнения двух объектов
//****************************************************************************************
bool TPoint_2D::operator ==(const TPoint_2D& Point) const
{
 return ((GetX() == Point.GetX()) && (GetY() == Point.GetY())) ? true : false;
}
//****************************************************************************************
//СТАТУС: I.3; public; TPoint_2D class overloading operator <
//OVERLOADING COMPARE OPERATOR <LESS, SMALLER>
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator <(const TPoint_2D& Point) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СРАВНЕНИЯ объектов класса TPoint_2D. Функция сравнивает
//координаты двух объектов TPoint_2D. Сравнение производиться по вычислению их нормы.
//При this->norm() < Point.norm, функция возвращает true в противном случае - false.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TPoint_2D& Point - ссылка на сравниваемый объект
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lCompare - результат сравнения двух объектов
//****************************************************************************************
bool TPoint_2D::operator <(const TPoint_2D& Point) const
{
 return (this->norm() < Point.norm()) ? true : false;
}

//========================================================================================
//             РЕАЛИЗАЦИЯ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССА TPoint_2D
//========================================================================================
//****************************************************************************************
//СТАТУС: 1;  TPoint_2D class friend overloading operator <<
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend ostream& operator <<(ostream& out, const TPoint_2D& Point)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВЫВОДА класса TPoint_2D. Функция выводит в
//поток значения координат точки на плоскости в краткой форме. Возвращается ссылка на поток,
//что позволяет записывать в программе операторы вывода в поток каскадно.
//Формат вывода: (<_x>, <_y>)
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на объект потока вывода
//2. сonst TPoint_2D& Point - ссылка на объект, выводимый в поток.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ostream& out - ссылка на объект потока вывода.
//***********************-****************************************************************
ostream& operator <<(ostream& out, const TPoint_2D& Point)
{string s;
 Point.Brief(s);//Получение координат точки на плоскости в виде строки (в краткой форме)
 out << s;//Вывод характеристик объекта
 return out;
}
//****************************************************************************************
//СТАТУС: 2;  TPoint_2D class friend overloading operator >>
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool operator >>(istream& in, TPoint_2D& Point)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВВОДА класса TPoint_2D. Функция вводит
//через поток in координаты точки на плоскости. Формат ввода: (<_x>, <_y>).
//Функция возвращает true в случае успешного ввода свойств объекта Point и false - в проти-
//воположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. istream& in - ссылка на объект потока ввода;
//2. TPoint_2D& Point - ссылка на объект, свойства которого будут вводиться из потока in.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат ввода данных в объект из потока ввода
//***********************-****************************************************************
bool operator >>(istream& in, TPoint_2D& Point)
{char buf[41];
 in.ignore();
 in.getline(buf,sizeof(buf));
 return Point.Set(buf);
}
//****************************************************************************************
//СТАТУС: 3;  TPoint_2D class friend function
//INPUT TPoint_2D PROPERTIES by cin
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool Edit(TPoint_2D& Point)
//НАЗНАЧЕНИЕ: Редактирование свойств объекта класса TPoint_2D через стандартный поток ввода
//cin. Функция вводит значения координат точки Point, передаваемой по ссылке. Функция возв-
//ращает true - в случае изменения свойств объекта и false - в противоположном случае. После
//ввода новых свойств объекта осуществляется их отображение.
//Формат ввода координат точки на плоскости:
//----------------------------------------------------------------------------------------
//Point: <Edit>
// x: <d_value>, y: <d_value>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TPoint_2D& Point - ссылка на редактируемый объект
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lChanged - результат редактирования
//***********************-****************************************************************
bool Edit(TPoint_2D& Point)
{//Рабочие переменные
 TPoint_2D PrevPoint(Point);
 char buffer[20];
 ostrstream text(buffer, sizeof(buffer));
 double value;
 int y, row_start = wherey();
 char c;
 string s, line(78,'-');
 bool flag;
 gotoxy(1,row_start); clreol();

 do //Цикл ввода координат точки на плоскости
 {//--------------------------------------------------------------------------------------
  cout << line << endl;
  cout << "Point: < Edit >, PrevCoords: " << PrevPoint << endl;
  //--------------------------------------------------------------------------------------
  //1. Ввод значения координаты x
  //--------------------------------------------------------------------------------------
  s = " x: "; y = wherey();
  cout << " x: "; cin >> value; Point.SetX(value);
  text << Point.GetX() << ends;
  s.append(text.str()); text.seekp(0);
  ClrScr(1,y);//Очистка экрана
  cout << s << endl;
  //------------------------------------------------------------------------------------
  //2. Ввод значения координаты y
  //------------------------------------------------------------------------------------
  s.append(", y: ");
  cout << " y: "; cin >> value; Point.SetY(value);
  text << Point.GetY() << ends;
  s.append(text.str()); text.seekp(0);
  ClrScr(1,y);//Очистка экрана
  cout << s << endl;
  //-----------------------------------------------------------------------------------
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
 //Проверка на изменение свойств редактируемого объекта
 return (PrevPoint == Point) ? true : false;
}

//****************************************************************************************
//                    Реализация класса TNumSimulationOpts
//Класс описывает параметры необходимые для проведения численного моделирования с дискрет-
//ным неотрицательным временем. Данный класс описывается следующим образом:
//1. Time - общее время моделирования (Time > 0), положительное целочисленное значение;
//2. CheckPoint - список значений контрольных точек, в которых необходимо произвести
//   определенные действия (произвести измерения, запомнить результаты, уведомить пользо-
//   вателя и т.д.). Все значения контрольных точек должны принадлежать интервалу [0..Time]
//   и быть целочисленными значениями;
//3. UseSignal - использование полезного сигнала в ковариационной матрице входного
//   воздействия при расчете весовых коэффициентов пространственного фильтра (тип bool);
//4. enCalcTFOpts (перечислымый тип) - варианты вычисления передаточной функции фильтра:
//   a) TF_Disable - передаточная функция не вычисляется;
//   b) TF_ByFinRes - передаточная функция вычисляется в конце моделирования;
//   c) TF_ByCheckPts - передаточная функция вычисляется во всех контрольных точках
//5. TSettingsTF - установки расчета передаточных функций с одной угловой координатой:
//   a) Угловой сектор, в котором вычисляется передаточная функция;
//   b) Тип нормирования, вычисленных значений мощности передаточной функции.
//****************************************************************************************
//****************************************************************************************
//========================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TNumSimulationOpts
//    PUBLIC MEMBER-FUNCTION OF TNumSimulationOpts CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TNumSimulationOpts class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Reset()
//НАЗНАЧЕНИЕ: Начальная установка свойств класса. Все члены-данные класса "обнуляются".
//Класс не готов выдать данные для проведения численного моделирования.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TNumSimulationOpts::Reset()
{this->_Time = 0L;
 this->_CheckPoint.Clear();//Удаление ранее установленных контрольных точек
 this->_UseSignal = false;//Полезный сигнал не используется в расчетах
 this->_CalcTFOpts = TF_Disable;//Запрет на вычисление передаточной функции
 this->_TFSets.Reset();//Обнуление параметров, используемых при вычислении TF
}
//****************************************************************************************
//СТАТУС: I.2; public; TNumSimulationOpts class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetDefault()
//НАЗНАЧЕНИЕ: Установка свойств класса по умолчанию. Класс готов выдать данные для прове-
//дения численного моделирования:
//1. Time       = 1000 - длительность моделирования
//2. CheckPoint = [0,100 .. 1000] - контрольные точки
//3. UseSignal  = ON - полезный сигнал учитывается при настройке весов фильтра
//4. CalcTFOpts = TF_ByFinRes - вычислять передаточную функцию фильтра в конце моделирования
//5. TFSets     = {Sector = [-90.0, -89.9 .. 90.0]; NormType = Norm_10Lg; MinDB = -60.0 dB;
//                 GroupNorm = ON}
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TNumSimulationOpts::SetDefault()
{this->_Time = 1000;
 this->_CheckPoint.SetName("CheckPoints");
 this->_CheckPoint.Assign(0,1000,100);//Инициализация числами из интервала [0,100 .. 1000]
 this->_UseSignal = true;
 this->_CalcTFOpts = TF_ByFinRes;
 this->_TFSets.SetDefault();
}
//****************************************************************************************
//СТАТУС: I.3; public; TNumSimulationOpts class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong SetTime(ulong Tmax)
//НАЗНАЧЕНИЕ: Установка длительности моделирования. При Tmax == 0 происходит начальная
//установка свойств объекта класса в состояние "NOT READY".
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong Tmax - новая длительность моделирования
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong _Time - установленное время моделирования
//****************************************************************************************
ulong TNumSimulationOpts::SetTime(ulong Tmax)
{if (this->_Time == Tmax) return this->GetTime();
 if (Tmax == 0) this->Reset();
 else
 {this->_Time = Tmax;
  this->_CheckPoint.Assign(0,Tmax,Tmax/10);//Автоустановка новых контрольных точек
 }
 return this->GetTime();
}
//****************************************************************************************
//СТАТУС: I.4; public; TNumSimulationOpts class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetTime(string& s) const
//НАЗНАЧЕНИЕ: Символьное представление длительности моделирования в строке s, передаваемой
//по ссылке. Формат представления: <Time: <_Time>>.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - строка-приемник длительности моделирования
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку-получатель времени моделирования
//****************************************************************************************
string& TNumSimulationOpts::GetTime(string& s) const
{char buffer[41];
 ostrstream text(buffer, sizeof(buffer));
 text << "Time: " << this->GetTime() << ends;
 s.assign(text.str()); text.seekp(0);
 return s;
}
//****************************************************************************************
//СТАТУС: I.5; public; TNumSimulationOpts class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SetCheckPoint(ulong ChPoint, bool lAppend = false)
//НАЗНАЧЕНИЕ: Установка контрольной точки ChPoint. Опция lAppend равная true устанавливает
//режим добавления контрольной точки к ранее установленным, а false - режим замещения ранее
//установленных контрольных точек новым значением СhPoint. В случае добавления контрольной
//точки функция возвращает true, иначе false.
//P.S. Значение ChPoint должно принадлежать интервалу [0.._Time].
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong ChPoint - значение контрольной точки;
//2. bool lAppend (false) - режим установки новой контрольной точки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат установки новой контрольной точки
//****************************************************************************************
bool TNumSimulationOpts::SetCheckPoint(ulong ChPoint, bool lAppend)
{bool lSuccess = false;
 if (!this->IsReady() || (ChPoint > this->_Time)) return lSuccess;
 if (lAppend) lSuccess = this->_CheckPoint.Append(ChPoint);//Режим добавления
 else lSuccess = this->_CheckPoint.Assign(ChPoint);//Режим присваивания
 //Проверка на наличие контрольных точек и корректировка _CalcTFOpts при необходимости
 if ((this->GetCheckPoints() == 0) && (this->TF_GetCalcMode() == TF_ByCheckPts))
  this->TF_SetCalcMode(TF_ByFinRes);
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.6; public; TNumSimulationOpts class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong SetCheckPoints(const char* str, bool lAppend = false)
//НАЗНАЧЕНИЕ: Установка контрольных точек, передаваемых в строке str. Опция lAppend равная
//true устанавливает режим добавления контрольных точек к ранее установленным, а false -
//режим замещения ранее установленных контрольных точек новыми значениями. Функция возвра-
//щает число установленных контрольных точек.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const char* str - строка cо значениями контрольных точек;
//2. bool lAppend (false) - режим установки новых контрольных точек.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong count - число установленных контрольных точек
//****************************************************************************************
ulong TNumSimulationOpts::SetCheckPoints(const char* str, bool lAppend)
{if (!this->IsReady()) return 0;
 if (lAppend) this->_CheckPoint.Append(str);//Режим добавления
 //Режим замещения установленных контрольных точек
 else this->_CheckPoint.Assign(str);
 //Удаление контрольных точек вне интервала [0 .. _Time]
 this->_CheckPoint.RemoveOutSide(0,this->_Time);
 //Проверка на наличие контрольных точек и корректировка _CalcTFOpts при необходимости
 if ((this->GetCheckPoints() == 0) && (this->TF_GetCalcMode() == TF_ByCheckPts))
  this->TF_SetCalcMode(TF_ByFinRes);
 return this->GetCheckPoints();
}
//****************************************************************************************
//СТАТУС: I.7; public; TNumSimulationOpts class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetCheckPoints(string& s) const
//НАЗНАЧЕНИЕ: Символьное представление значений контрольных точек в строке s, передаваемой
//по ссылке. Формат представления: <Check Point: <Count> {<Check Point List>}>.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - строка-приемник контрольных точек
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку-получатель контрольных точек
//****************************************************************************************
string& TNumSimulationOpts::GetCheckPoints(string& s) const
{s.assign("Check Point: ");
 if (this->GetCheckPoints() == 0L) {s.append("0 {}"); return s;}
 string t;
 char buffer[21];
 ostrstream text(buffer, sizeof(buffer));
 text << this->GetCheckPoints() << " {" << ends;
 s.append(text.str()); text.seekp(0);
 //Получение списка контрольных точек с возможностью интервального представления
 this->_CheckPoint.DataToStr(t);
 s.append(t); s.append(1,'}');
 return s;
}
//****************************************************************************************
//СТАТУС: I.8; public; TNumSimulationOpts class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetUseSignal(string& s) const
//НАЗНАЧЕНИЕ: Символьное представление опции использования полезного сигнала при настройке
//весов адаптивного фильтра в строке s, передаваемой по ссылке. Формат представления:
//<Signal: <Enable | Disable>>.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - строка-приемник опции использования сигнала
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку-получатель опции использования сигнала
//****************************************************************************************
string& TNumSimulationOpts::GetUseSignal(string& s) const
{s.assign("Signal: ");
 if (this->GetUseSignal() == true) s.append("Enable");
 else s.append("Disable");
 return s;
}
//****************************************************************************************
//СТАТУС: I.9; public; TNumSimulationOpts class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: enCalcTFOpts TF_SetCalcMode(enCalcTFOpts Mode)
//НАЗНАЧЕНИЕ: Установка вариантов вычисления передаточной функции при проведении моделиро-
//вания. Функция возвращает установленное значение.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: enCalcTFOpts Mode - вариант вычисления TF.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: enCalcTFOpts _CalcTFOpts - установленный вариант вычисления TF
//****************************************************************************************
enCalcTFOpts TNumSimulationOpts::TF_SetCalcMode(enCalcTFOpts Mode)
{if (Mode == TF_ByCheckPts && this->GetCheckPoints() == 0) Mode = TF_ByFinRes;
 this->_CalcTFOpts = Mode;
 if (this->_CalcTFOpts  == TF_Disable) this->_TFSets.Reset();
 else
 {if (!this->_TFSets.IsReady()) this->_TFSets.SetDefault();
 }
 return this->TF_GetCalcMode();
}
//****************************************************************************************
//СТАТУС: I.10; public; TNumSimulationOpts class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& TF_GetCalcMode(string& s) const
//НАЗНАЧЕНИЕ: Символьное представление варианта вычисления TF в строке s, передаваемой по
//ссылке. Формат представления: <CalcMode: Disable | ByFinRes | ByCheckPts>.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - строка-приемник варианта вычисления TF
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку-получатель варианта вычисления TF
//****************************************************************************************
string& TNumSimulationOpts::TF_GetCalcMode(string& s) const
{s.assign("CalcMode: ");
 switch (this->TF_GetCalcMode())
 {case TF_Disable:
   s.append("Disable");
   break;
  case TF_ByFinRes:
   s.append("By Final Result");
   break;
  case TF_ByCheckPts:
   s.append("By Check Points");
   break;
 }
 return s;
}
//****************************************************************************************
//СТАТУС: I.11; public; TNumSimulationOpts class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong TF_SetSector(double StartAngle, double EndAngle, double Step)
//НАЗНАЧЕНИЕ: Установка сектора расчета передаточной функции. Функция возвращает общее число
//угловых координат в которых будет рассчитывается передаточна функция пространственного
//фильтра.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double StartAngle - начальный угол сектора расчета TF в градусах;
//2. double EndAngle - конечный угол сектора расчета TF в градусах;
//3. double Step - угловое приращение в градусах (дискретность сектора).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong count - число угловых координат, в которых вычисляется TF.
//****************************************************************************************
ulong TNumSimulationOpts::TF_SetSector(double StartAngle, double EndAngle, double Step)
{if (this->_CalcTFOpts != TF_Disable) this->_TFSets.SetSector(StartAngle,EndAngle,Step);
 return this->_TFSets.Count();
}
//****************************************************************************************
//СТАТУС: I.12; public; TNumSimulationOpts class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: enNormType TF_SetNormType(enNormType Type, double MindB = -60.0)
//НАЗНАЧЕНИЕ: Установка типа нормирования и минимального порогового значения при нормиро-
//вании в dB.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. enNormType Type - задаваемый тип нормирования;
//2. double MindB (-60.0) - минимальный порог при нормировании в dB.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: enNormType Type - установленный тип нормирования
//****************************************************************************************
enNormType TNumSimulationOpts::TF_SetNormType(enNormType Type, double MindB)
{if (this->_CalcTFOpts != TF_Disable)
 {if (Type == Norm_20Lg) Type = Norm_10Lg;//Только по мощности
  this->_TFSets.SetNormType(Type,MindB);
 }
 return this->_TFSets.GetNormType();
}
//****************************************************************************************
//СТАТУС: I.13; public; TNumSimulationOpts class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double TF_SetMinDB(double Min)
//НАЗНАЧЕНИЕ: Установка минимального порогового значения при нормировании в dB.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: double MindB - минимальный порог при нормировании в dB.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double MindB - установленный минимальный порог.
//****************************************************************************************
double TNumSimulationOpts::TF_SetMinDB(double Min)
{if (this->_CalcTFOpts != TF_Disable) this->_TFSets.SetMinDB(Min);
 return this->_TFSets.GetMindB();
}
//****************************************************************************************
//СТАТУС: I.14; TNumSimulationOpts public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& TF_Settings(string& s) const
//НАЗНАЧЕНИЕ: Формирование настроек вычисления передаточной функции в строке s, передаваемой
//по ссылке, в формате:
//<TF_Settings: <OFF> |
// CalcMode: Disable | ByFinRes | ByCheckPts>
// Sector [deg]: [<Start>,<Start+Delta>..<End>] Size: <Count>,
// NormType: <UnNormalized> || <Normalized [0..1]> || <dB Normalized, MindB: <value>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строку-приемник настроек вычисления TF.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку опций вычисления TF.
//****************************************************************************************
string& TNumSimulationOpts::TF_Settings(string& s) const
{s.assign("TF_Settings: ");
 if (this->TF_GetCalcMode() != TF_Disable)
 {string sCalcMode, sSector, sNormType;
  this->TF_GetCalcMode(sCalcMode);
  this->_TFSets.Sector(sSector);
  this->_TFSets.NormType(sNormType);
  s.append(sCalcMode);
  s.append(",\n"); s.append(sSector);
  s.append(", "); s.append(sNormType);
 }
 else s.append("OFF");
 return s;
}
//****************************************************************************************
//СТАТУС: I.15, public, TNumSimulationOpts class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Info(string& s, uint width = 80) const
//НАЗНАЧЕНИЕ: Формирование характеристик объекта в строке s, передаваемой по ссылке.
//Свойства объекта представляются в виде:
//----------------------------------------------------------------------------------------
//Numeric Simulation Options: <ON> | <OFF>
// 1. Time: <_Time>;
// 2. Signal: <Enable | Disable>;
// 3. Check Points: <N> {<Check Points List>};
// 4. TF Settings: <OFF> | <CalcMode: Disable | ByFinRes | ByCheckPts>,
//    Sector [deg]: [<Start>,<Start+Delta>..<End>] Size: <Count>,
//    NormType: <UnNormalized> || <Normalized [0..1]> || <dB Normalized, MindB: <r_val>>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект, в котором формируются свойства опций
//   моделирования;
//2. uint width (80) - максимальная ширина строки при многострочном выводе свойств.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами объекта.
//****************************************************************************************
string& TNumSimulationOpts::Info(string& s, uint width) const
{string t;
 t.assign("Numeric Simulation Options: ");
 if (this->IsReady()) t.append("< ON >;\n");
 else t.append("< OFF >;\n");
 //Время моделирования
 this->GetTime(s); t.append(" 1. "); t.append(s); t.append(1,'\n');
 //Использование полезного сигнала при настройке весов адаптивного фильтра
 this->GetUseSignal(s); t.append(" 2. "); t.append(s); t.append(1,'\n');
 //Получаем информацию о контрольных точках
 this->GetCheckPoints(s); t.append(" 3. "); t.append(s); t.append(1,'\n');
 //Получаем опции при вычислении передаточной функции
 this->TF_Settings(s); t.append(" 4. "); t.append(s); t.append(1,'\n');
 //Разбиваем строку t на подстроки с максимальной шириной не более width
 MultiLineFormat(s,t,width,NULL);
 return s;
}
//****************************************************************************************
//СТАТУС: I.16; public; TNumSimulationOpts class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsCheckPoint(ulong time) const
//НАЗНАЧЕНИЕ: Функция проверяет значение time на его принадлежность контрольной точке.
//Функция возвращает true в случае совпадения time с установленной контрольной точкой и
//false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong time - дискретное значение времени моделирования;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// bool lBelong - признак совпадения time с установленной контрольной точкой
//****************************************************************************************
bool TNumSimulationOpts::IsCheckPoint(ulong time) const
{return ((!this->IsReady()) || (time > _Time)) ? false : _CheckPoint.Find(time);
}

//========================================================================================
//            РЕАЛИЗАЦИЯ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССА TNumSimulationOpts
//========================================================================================
//****************************************************************************************
//СТАТУС: 1;  TNumSimulationOpts class friend overloading operator <<
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend ostream& operator <<(ostream& out, const TNumSimulationOpts& Obj)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВЫВОДА класса TNumSimulationOpts.
//Функция выводит в поток свойства класса, используемые для численного моделирования адап-
//тивного пространственного фильтра с ОСНОВНЫМ каналом. Функция возвращает ссылку на поток,
//что позволяет записывать в программе операторы вывода в поток каскадно. Формат вывода:
//----------------------------------------------------------------------------------------
//Numeric Simulation Options: <ON> | <OFF>
// 1. Time: <_Time>;
// 2. Signal: <Enable | Disable>;
// 3. Check Points: <N> {<Check Points List>};
// 4. TF Settings: <OFF> | <CalcMode: Disable | ByFinRes | ByCheckPts>,
//    Sector [deg]: [<Start>,<Start+Delta>..<End>] Size: <Count>,
//    NormType: <UnNormalized> || <Normalized [0..1]> || <dB Normalized, MindB: <r_val>;>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на объект потока вывода
//2. сonst TNumSimulationOpts& Obj - ссылка на объект, выводимый в поток.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ostream& out - ссылка на объект потока вывода.
//***********************-****************************************************************
ostream& operator <<(ostream& out, const TNumSimulationOpts& Obj)
{string s;
 Obj.Info(s,80);//Получение свойств объекта
 out << s;//Вывод характеристик объекта
 return out;
}
//****************************************************************************************
//СТАТУС: 2;  TNumSimulationOpts class friend function
//INPUT TNumSimulationOpts PROPERTIES by cin
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend void Edit(TNumSimulationOpts& Obj)
//НАЗНАЧЕНИЕ: Редактирование свойств объекта класса TNumSimulationOpts через стандартный
//поток ввода cin. Функция редактирует свойства Obj, передаваемого по ссылке.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TNumSimulationOpts& Obj - ссылка на редактируемый объект
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void Edit(TNumSimulationOpts& Obj)
{STR_UINT Option[5] = {
  {1, "Edit < Simulation Time >" },
  {2, "Edit < Using Signal >" },
  {3, "Edit < Check Points >" },
  {4, "Edit < Settings TF >" },
  {5, "Exit" } };
 TB_STR_UINT Menu = {5, Option};
 string head = " Choice menu option [1-5]: ";
 //Рабочие переменные
 int y_start = wherey();
 int y;
 string line(78,'-');
 const string sPressKey = "Press any key...";
 const string sZeroTime = "TIPS: First of all You have to set Time > 0 !!!";
 const string s = "Numeric Simulation Options: < Edit >";
 string t;
 bool flag = true;

 gotoxy(1,y_start); clreol();
 do
 {cout << line << endl << s << endl;
  y = wherey();
  cout << line << endl << Obj << line << endl;
  uint choice = ConsoleChoice(Menu,1,head.c_str(),2);
  switch (choice)
  {case 1: //Редактирование времени моделирования
    ClrScr(1,y);//Очистка экрана
    Obj.Edit_Time();
    break;
   case 2: //Редактирование использования полезного сигнала
    if (Obj.IsReady()) {ClrScr(1,y); Obj.Edit_UseSignal();}
    else {cout << sZeroTime << endl << sPressKey; getch();}
    break;
   case 3: //Редактирование контрольных точек
    if (Obj.IsReady()) {ClrScr(1,y); Obj.Edit_CheckPoints();}
    else {cout << sZeroTime << endl << sPressKey; getch();}
    break;
   case 4: //Редактирование настроек при расчете передаточной функции
    if (Obj.IsReady()) {ClrScr(1,y); Obj.Edit_TFSettings();}
    else {cout << sZeroTime << endl << sPressKey; getch();}
    break;
   case 5: //Выход из режима редактирования
    flag = false; break;
  }
  ClrScr(1,y_start);//Очистка экрана
  //clrscr();
 } while (flag);
}

//========================================================================================
// II. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TNumSimulationOpts
//     PROTECTED MEMBER-FUNCTION OF TNumSimulationOpts CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: II.1; TNumSimulationOpts protected member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit_Time()
//НАЗНАЧЕНИЕ: Редактирование времени моделирования:
//----------------------------------------------------------------------------------------
//< Edit < Simulation Time >
//< Time [T > 0]: <ivalue> >
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TNumSimulationOpts::Edit_Time()
{//Рабочие переменные
 int y, row_start = wherey();
 string s, h, line(79,'-');
 string sZeroTime("WARNING! All Simulation Options will be RESET !!!");
 char c;
 ulong value;
 gotoxy(1,row_start); clreol();
 //Формирование заголовка
 h.assign("Edit < Simulation Time >");
 do //Цикл ввода времени моделирования
 {cout << line << endl << this->Info(s,80) << line << endl;//Свойства объекта
  cout << h << endl << line << endl;
  //Ввод времени моделирования
  y = wherey();
  cout << "Time [T > 0]: "; cin >> value;
  ClrScr(1,y);//Очистка экрана
  if (value == 0)
  {cout << sZeroTime << endl;
   cout << "Would you like to ignore T == 0? [y/n]: "; cin >> c;
   ClrScr(1,y);//Очистка экрана
   if (c != 'Y' && c != 'y') this->SetTime(value);
  }
  else this->SetTime(value);//Установка нового времени моделирования
  ClrScr(1,row_start);//Очистка экрана
  cout << line << endl << "New => Simulation Time: " << this->GetTime() << endl;
  cout << line << endl << this->Info(s,80) << line << endl;//Свойства объекта
  //---------------------------------------------------------------------------
  //Подтверждение введенных данных
  cout << "Would you like to exit? [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') break;//Выход из цикла редактирования
  ClrScr(1,row_start);//Очистка экрана
 } while (true);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: II.2; TNumSimulationOpts protected member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit_UseSignal()
//НАЗНАЧЕНИЕ: Ввод опции использования полезного сигнала при настройке фильтра:
//----------------------------------------------------------------------------------------
//< Edit < Using Signal >
//< Use Signal: <Enable | Disable>>
//< Would you like to use SIGNAL during Filter Tuning ? [y/n]: <y/n> >
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TNumSimulationOpts::Edit_UseSignal()
{//Рабочие переменные
 int y, row_start = wherey();
 string s, line(79,'-');
 string h("Edit < Using SIGNAL >");
 string sRequest("Would you like to use SIGNAL during Filter Tuning ? [y/n]: ");
 bool flag;
 char c;
 bool value;
 gotoxy(1,row_start); clreol();
 do //Цикл ввода времени моделирования
 {cout << line << endl << this->Info(s,80) << line << endl;//Свойства объекта
  cout << h << endl << line << endl ;
  y = wherey();
  //Запрос на использование ПОЛЕЗНОГО СИГНАЛА
  cout << sRequest; cin >> c;
  ClrScr(1,y);//Очистка экрана
  value = (c == 'Y' || c == 'y') ? true : false;
  this->SetUseSignal(value);
  ClrScr(1,row_start);//Очистка экрана
  cout << line << endl << "New => " << this->GetUseSignal(s) << endl;
  cout << line << endl << this->Info(s,80) << line << endl;//Свойства объекта
  //--------------------------------------------------------------------------------
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  flag = (c == 'Y' || c == 'y') ? false : true;//Повторный ввод данных
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: II.3; TNumSimulationOpts protected member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: Edit_CheckPoints()
//НАЗНАЧЕНИЕ: Ввод значений контрольных точек:
//----------------------------------------------------------------------------------------
//< Edit < Check Points >, Prev: <Check Points List>
//< > i1 i2 ... ik
//< Confirm input ...
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TNumSimulationOpts::Edit_CheckPoints()
{//Рабочие переменные
 int y, row_start = wherey();
 char c;
 string s, t, msg;
 string line(78,'-');
 string h("Edit <Check Points> InputForm: <i1 i2 ... in;>");
 bool flag, lAppend = false;
 gotoxy(1,row_start); clreol();

 do //Цикл ввода значений контрольных точек
 {//--------------------------------------------------------------------------------------
  cout << line << endl << this->Info(s,80) << line << endl;//Свойства объекта
  cout << h << endl << line << endl;
  //--------------------------------------------------------------------------------------
  //Запрос на редактирование с предупреждающим сообщением
  //--------------------------------------------------------------------------------------
  msg.clear();
  if (this->GetCheckPoints() != 0)
   msg.assign("Would you like to DELETE old values !? [y/n]: ");
  if (!msg.empty())
  {y = wherey();
   cin.ignore();
   cout << msg; cin >> c;
   lAppend = (c == 'Y' || c == 'y') ? false : true;
   ClrScr(1,y);//Очистка экрана
  }
  //--------------------------------------------------------------------------------------
  //Ввод новых значений
  //--------------------------------------------------------------------------------------
  cout << "> "; cin.ignore(); getline(cin,s,';');
  this->SetCheckPoints(s.c_str(),lAppend);
  ClrScr(1,row_start);//Очистка экрана
  //Формирование значений, хранящихся в контейнере, после ввода новых элементов
  s.assign("New => "); this->GetCheckPoints(t); s.append(t); MultiLineFormat(t,s,80);
  cout << line << endl << t << endl;
  cout << line << endl << this->Info(s,80) << line << endl;//Свойства объекта
  //--------------------------------------------------------------------------------------
  //Подтверждение введенных данных
  cout << "Would you like to exit? [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: II.4; TNumSimulationOpts protected member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit_TFSettings()
//НАЗНАЧЕНИЕ: Ввод опций для вычисления передаточной функции адаптивного пространственного
//фильтра по одной угловой координате:
//----------------------------------------------------------------------------------------
//< Edit < Params For Calculating One Angle-Coordinate Transfer Function >
//<Sector [deg]: [<Start>,<Start+Delta>..<End>] Size: <Count>,
// NormType: <UnNormalized> || <Normalized [0..1]> || <dB Normalized, MindB: <value>;>
//  1. Edit <Calculation Mode> --> Edit_TFCalcMode
//  2. Edit <Sector>           --> EditSector()
//  3. Edit <NormType>         --> Edit_TFNormType()
//  4. Exit
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TNumSimulationOpts::Edit_TFSettings()
{//Рабочие переменные
 STR_UINT EditOpts[4] = {
 {1, "Edit < Calculation Mode >"},
 {2, "Edit < Sector >"},
 {3, "Edit < NormType >"},
 {4, "Exit"} };
 TB_STR_UINT EditMenu = {4, EditOpts};
 int row_start = wherey();
 int choice;
 bool flag = true;
 string s, line(78,'-');
 string h("Edit < SETTINGs to Calculate Adaptive Space Filter Transfer Function >");

 string sWarn("WARNING ! This option is inaccessible now.");
 string sTip("TIP: First of all You should cancel <Disable> [option # 1] !!!");
 string sPressKey("Press any key ...");

 gotoxy(1,row_start); clreol();
 do //Цикл редактирования свойств настроек для вычисления TF
 {cout << line << endl << h << endl;
  cout << this->TF_Settings(s) << endl << line << endl;
  //Выбор типа нормировки
  s = "Choose option [1..4]: ";
  choice = ConsoleChoice(EditMenu,4,s.c_str(),1);
  switch (choice)
  {case 1:
    ClrScr(1,row_start);
    this->Edit_TFCalcMode();
    break;
   case 2:
    if (this->TF_IsReady()) this->_TFSets.EditSector();
    else {cout << sWarn << endl << sTip << endl << sPressKey; getch();}
    break;
   case 3:
    if (this->TF_IsReady()) {ClrScr(1,row_start); this->Edit_TFNormType();}
    else {cout << sWarn << endl << sTip << endl << sPressKey; getch();}
    break;
   case 4: flag = false; break;
  }
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: I.5; TNumSimulationOpts public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit_TFCalcMode()
//НАЗНАЧЕНИЕ: Установка вариантов расчета передаточной функции. Формат редактирования:
//----------------------------------------------------------------------------------------
//< Edit < TF Calculation Mode >
//< Mode: <TF_Disable> || <TF_ByFinRes> || <TF_ByCheckPts> >
//  1. DISABLE Calculating TF
//  2. Calculate TF at the END of Simulation
//  3. Calculate TF at CHECK POINTS
//  Choose mode [1..3]: <i_value>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TNumSimulationOpts::Edit_TFCalcMode()
{//Рабочие переменные
 STR_UINT ModeOption[3] = {
 {1, "DISABLE Calculating TF"},
 {2, "Calculate TF at the END of Simulation"},
 {3, "Calculate TF at CHECK POINTS"} };
 TB_STR_UINT CalcModeMenu = {3, ModeOption};

 int y, row_start = wherey(),choice;
 string s, line(78,'-');
 string h("Edit < TF Calculation Mode >");
 string sPressKey("Press any key ...");
 bool flag;
 char c;
 enCalcTFOpts TFCalcMode;
 gotoxy(1,row_start); clreol();
 do //Цикл ввода варианта расчета TF
 {cout << line << endl << this->Info(s,80) << line << endl;//Свойства объекта
  cout << h << endl << line << endl;
  //--------------------------------------------------------------------------------------
  //Выбор варианта расчета передаточной функции
  //--------------------------------------------------------------------------------------
  y = wherey();
  s = "Choose mode [1..3]: ";
  choice = ConsoleChoice(CalcModeMenu,3,s.c_str(),2);
  switch (choice)
  {case 1: TFCalcMode = TF_Disable; break;
   case 2: TFCalcMode = TF_ByFinRes; break;
   case 3: TFCalcMode = TF_ByCheckPts; break;
   default: TFCalcMode = TF_ByFinRes;
  }
  ClrScr(1,y);//Очистка экрана
  if (this->TF_GetCalcMode() == TFCalcMode)
  {cout << "WARNING! This TF Calculation Choice has been already selected !!!" << endl;
   cout << "TIP: You should choose different mode. " << endl << sPressKey << endl; getch();
  }
  else if (TFCalcMode == TF_Disable)
  {cout << "WARNING! You've choosen <DISABLE TF> and calculating TF will be impossible." << endl;
   cout << "Do you confirm this choice ? [y/n]: "; cin >> c;
   if (c == 'Y' || c == 'y') this->TF_SetCalcMode(TFCalcMode);
   ClrScr(1,y);//Очистка экрана
  }
  else if ((TFCalcMode == TF_ByCheckPts) && (this->GetCheckPoints() == 0))
  {cout << "WARNING! You don't choose <CalcTF at CHECK POINTS> just now." << endl;
   cout << "TIP: First of all You've to set Check Points values." << endl << sPressKey << endl;
   getch();
  }
  else this->TF_SetCalcMode(TFCalcMode);
  ClrScr(1,row_start);//Очистка экрана
  cout << line << endl << "New => " << this->TF_GetCalcMode(s) << endl;
  cout << line << endl << this->Info(s,80) << line << endl;//Свойства объекта
  //--------------------------------------------------------------------------------------
  //Подтверждение введенных данных
  cout << "Would you like to exit? [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: I.6; TNumSimulationOpts public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit_TFNormType()
//НАЗНАЧЕНИЕ: Редактирование типа нормировки. Формат редактирования:
//----------------------------------------------------------------------------------------
//< Edit < NormType >
//< NormType: <UnNormalized> || <Normalized [0..1]> || <dB Normalized, MindB: <value> >
//  1. UnNormalized
//  2. Normalized [0..1]
//  3. Normalized [Decibel]
//  Choose normalization option [1..3]: <i_value>
//  IF (value == 3) Minimal Level in Db [MindB < 0]: <r_value>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TNumSimulationOpts::Edit_TFNormType()
{//Рабочие переменные
 STR_UINT NormOption[3] = {
 {1, "UnNormalized"},
 {2, "Normalized [0..1]"},
 {3, "Normalized [dB]"} };
 TB_STR_UINT NormMenu = {3, NormOption};

 int y, row_start = wherey(),choice;
 string s, line(78,'-');
 string h("Edit < Normalization Type >");
 bool flag;
 char c;
 double value;
 gotoxy(1,row_start); clreol();
 do //Цикл ввода типа нормирования
 {cout << line << endl << this->Info(s,80) << line << endl;//Свойства объекта
  cout << h << endl << line << endl;
  //--------------------------------------------------------------------------------------
  //Выбор типа нормирования
  //--------------------------------------------------------------------------------------
  y = wherey();
  //Выбор типа нормировки
  s = "Choose normalization option [1..3]: ";
  choice = ConsoleChoice(NormMenu,3,s.c_str(),2);
  switch (choice)
  {case 1: this->TF_SetNormType(UnNormalized,this->_TFSets.GetMindB()); break;
   case 2: this->TF_SetNormType(Normalized,this->_TFSets.GetMindB()); break;
   case 3: this->TF_SetNormType(Norm_10Lg,this->_TFSets.GetMindB()); break;
  }
  ClrScr(1,y);//Очистка экрана
  //Ввод минимального значения в децибелах (MinDb < 0)
  if (this->_TFSets.GetNormType() == Norm_10Lg)
  {cout << "Now => NormType: " << this->_TFSets.NormType(s) << endl << line << endl;
   cout << " Minimal Level in dB [MindB < 0]: "; cin >> value;
   this->TF_SetMinDB(value);
  }
  ClrScr(1,row_start);//Очистка экрана
  cout << line << endl << "New => " << _TFSets.NormType(s) << endl << line << endl;
  cout << line << endl << this->Info(s,80) << line << endl;//Свойства объекта
  //--------------------------------------------------------------------------------------
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}


//****************************************************************************************
// РЕАЛИЗАЦИЯ класса TNumSimulationParams - характеристики численного моделирования
//Класс описывает параметры необходимые для проведения численного моделирования с дискрет-
//ным неотрицательным временем. Данный класс описывается следующим образом:
//1. Time - общее время моделирования (Time > 0), положительное целочисленное значение;
//2. CheckPoints - список значений контрольных точек, в которых необходимо произвести
//   определенные действия (произвести измерения, запомнить результаты, уведомить пользо-
//   вателя и т.д.). Все значения контрольных точек должны принадлежать интервалу [0..Time]
//   и быть целочисленными значениями.
//****************************************************************************************
//========================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TNumSimulationParams
//    PUBLIC MEMBER-FUNCTION OF TNumSimulationParams CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TNumSimulationParams class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SetCheckPointMode(enCheckPointOpts NewOption, ulong Param=0L)
//НАЗНАЧЕНИЕ: Функция устанавливает новый вариант задания контрольных точек на интервале
//моделирования в соответствии со значением NewOption. Функция возвращает true при измене-
//нии варианта задания контрольных точек и false в противоположном случае. Значение Param
//используется в случае NewOption = cpEvenSample (Param задает шаг расстановки контрольных
//точек, начиная с начала time = 0). Выбор варианта cpCustom является недопустимым.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. enCheckPointOpts NewOption - вариант установки контрольных точек при моделировании;
//2. ulong Param (0L) - дополнительный параметр при установке нового варианта NewOption.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - флаг установки нового варианта расстановки контрольных точек
//****************************************************************************************
bool TNumSimulationParams::SetCheckPointMode(enCheckPointOpts NewOption, ulong Param)
{bool lSuccess = false;
 if ((NewOption == cpEmpty) || (NewOption == cpBounds))
 {if (GetCheckPointMode() != NewOption) {_CheckPoint.clear(); lSuccess = true;}
 }
 else if (NewOption == cpEvenSample)
 {if ((Param != 0L) && (Param < GetDuration())) //Проверка шага расстановки CheckPoints
  {if (GetCheckPointMode() != NewOption)
   {_CheckPoint.clear(); _CheckPoint.push_back(Param); lSuccess = true;}
   else if ((GetCheckPointMode() == NewOption) && (_CheckPoint.front() != Param))
   {_CheckPoint[0] = Param; lSuccess = true;}
  }
 }
 if (lSuccess) _Mode = NewOption;
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.2; public; TNumSimulationParams class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong Set(ulong Duration)
//НАЗНАЧЕНИЕ: Функция устанавливает новое значение длительности моделирования. Функция
//возвращает установленное время моделирования.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong Duration - значение длительности моделирования;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// ulong Duration - установленное значение длительности моделирования;
//****************************************************************************************
ulong TNumSimulationParams::Set(ulong Duration)
{if (Duration != GetDuration())
 {_Time = Duration;
  _HndlDurationChange();//Обработчик изменения интервала моделирования
 }
 return this->GetDuration();
}
//****************************************************************************************
//СТАТУС: I.3; public; TNumSimulationParams class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong GetCheckPointsNumber() const
//НАЗНАЧЕНИЕ: Функция определяет количество установленных контрольных точек.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong Count - количество установленных контрольных точек;
//****************************************************************************************
ulong TNumSimulationParams::GetCheckPointsNumber() const
{ulong Count = 0L;
 if (GetCheckPointMode() == cpBounds) Count = 2;
 else if (GetCheckPointMode() == cpCustom) Count = _CheckPoint.size();
 else if (GetCheckPointMode() == cpEvenSample)
 {ulong step = _CheckPoint.front();
  Count = GetDuration() / step;
  Count = (GetDuration() % step) ? Count+1 :Count+2;
 }
 return Count;
}
//****************************************************************************************
//СТАТУС: I.4; public; TNumSimulationParams class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong Set(const string& sCheckPoints, bool lStrict = true);
//НАЗНАЧЕНИЕ: Функция устанавливает новые значения контрольных точек. Контрольные точки
//представляются в символьном виде строкой sCheckPoints. Опция lStrict определяет возмож-
//ность изменения интервала моделирования при установке новых значений контрольных точек
//(при lStrict == false). По умолчанию lStrict == true интервал моделирования не меняется
//и при установке новых контрольных точек осуществляется их фильтрация на принадлежность
//интервалу существующему интервалу моделирования. Функция возвращает кол-во установленных
//контрольных точек.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& sCheckPoints - ссылка на строку с символьным представлением значений
//   новых контрольных точек;
//2. bool lStrict (true) - условия установки новых контрольных точек с проверкой на
//   принадлежность существующему интервалу моделирования или его коррекции в соответствии
//   с наибольшим значением контрольной точки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong Count - количество установленных контрольных точек;
//****************************************************************************************
ulong TNumSimulationParams::Set(const string& sCheckPoints, bool lStrict)
{ivector IntVals;
 _CheckPoint.clear();//Удаление предыдущих значений контрольных точек

 if (lStrict == true) //Интервал моделирования изменен не будет
 {if (this->GetDuration() == 0L) return GetCheckPointsNumber();
  TBelongClosedInterval<long,ivector> Pred(0,GetDuration());
  IntVals.GetDataFromString(sCheckPoints,true,&Pred);
 }
 else //Интервал моделирования может быть изменен в большую сторону
 {TGreaterOrEqual<long,ivector> Pred(0);
  IntVals.GetDataFromString(sCheckPoints,true,&Pred);
 }
 //Анализ полученных значений
 if (IntVals.IsZeroSize()) SetCheckPointMode(cpEmpty);//Контрольные точки отсутствуют
 else
 {IntVals.BubbleSort(ASCENDING);//Сортировка по возрастанию
  ulong szIntVals = IntVals.Size();
  bool lCustom = true;
  //Изменение интервала моделирования в сторону увеличения (lStrict == false)
  if ((!lStrict) && ((ulong)IntVals[szIntVals-1] > GetDuration()))
   _Time = (ulong) IntVals[szIntVals-1];

  //Контрольные точки на границах интервала
  if ((szIntVals == 2) && (IntVals[0] == 0L) && ((ulong)IntVals[1] == GetDuration()))
  {lCustom = false; SetCheckPointMode(cpBounds);}
  //Проверка на равномерный интервал размещения контрольных точек: [0,d,2d .. nd,last]
  else if ((szIntVals > 2) && (IntVals[0] == 0L))
  {long Step = IntVals[1];
   ulong LastIndex = ((ulong)IntVals[szIntVals-1] == GetDuration()) ? szIntVals-1 : szIntVals;
   bool lEvenSample = true;
   //Цикл по элементам вектора
   for (ulong i = 2; i < LastIndex; i++)
   {if (IntVals.Get(i)-IntVals.Get(i-1) != Step) {lEvenSample = false; break;}
   }
   if (lEvenSample) //Устанавливаем режим cpEvenSample
   {SetCheckPointMode(cpEvenSample,Step); lCustom = false;}
  }
  //Установка режима lCustom с импортированием контрольных точек в _CheckPoint
  if (lCustom == true)
  {_Mode = cpCustom;
   for (ulong i = 0L; i < szIntVals; i++) _CheckPoint.push_back((ulong) IntVals.Get(i));
  }
 }

 return GetCheckPointsNumber();
}
//****************************************************************************************
//СТАТУС: I.5; public; TNumSimulationParams class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong Set(const char* sCheckPoints, bool lStrict = true);
//НАЗНАЧЕНИЕ: Функция устанавливает новые значения контрольных точек. Контрольные точки
//представляются в символьном виде строкой sCheckPoints. Опция lStrict определяет возмож-
//ность изменения интервала моделирования при установке новых значений контрольных точек
//(при lStrict == false). По умолчанию lStrict == true интервал моделирования не меняется
//и при установке новых контрольных точек осуществляется их фильтрация на принадлежность
//интервалу существующему интервалу моделирования. Функция возвращает кол-во установленных
//контрольных точек.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const char* sCheckPoints - указатель на строку с символьным представлением значений
//   новых контрольных точек;
//2. bool lStrict (true) - условия установки новых контрольных точек с проверкой на
//   принадлежность существующему интервалу моделирования или его коррекции в соответствии
//   с наибольшим значением контрольной точки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// ulong Count - количество установленных контрольных точек;
//****************************************************************************************
ulong TNumSimulationParams::Set(const char* sCheckPoints, bool lStrict)
{string str(sCheckPoints);
 return Set(str,lStrict);
}
//****************************************************************************************
//СТАТУС: I.6; public; TNumSimulationParams class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong Set(ulong Duration, const string& sCheckPoints)
//НАЗНАЧЕНИЕ: Функция устанавливает новые значения длительности моделирования и контрольных
//точек. Контрольные точки представляются в символьном виде строкой sCheckPoints. Функция
//возвращает количество установленных контрольных точек.
//P.S. Значения контрольных точек, извлекаемых из строки, проверяются на уникальность и
//принадлежность вновь установленному интервалу моделирования с длительностью Duration.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong Duration - длительность моделирования;
//2. const string& sCheckPoints - ссылка на строку с символьным представлением значений
//   новых контрольных точек.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// ulong Count - количество установленных контрольных точек;
//****************************************************************************************
ulong TNumSimulationParams::Set(ulong Duration, const string& sCheckPoints)
{this->Set(Duration);//Установка длительности моделирования
 return this->Set(sCheckPoints,true);//Установка новых контрольных точек
}
//****************************************************************************************
//СТАТУС: I.7; public; TNumSimulationParams class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong Set(ulong Duration, const char* sCheckPoints)
//НАЗНАЧЕНИЕ: Функция устанавливает новые значения длительности моделирования и контрольных
//точек. Контрольные точки представляются в символьном виде строкой sCheckPoints. Функция
//возвращает количество установленных контрольных точек.
//P.S. Значения контрольных точек, извлекаемых из строки, проверяются на уникальность и
//принадлежность вновь установленному интервалу моделирования с длительностью Duration.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong Duration - длительность моделирования;
//2. const char* sCheckPoints - ссылка на строку с символьным представлением значений
//   новых контрольных точек.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// ulong Count - количество установленных контрольных точек;
//****************************************************************************************
ulong TNumSimulationParams::Set(ulong Duration, const char* sCheckPoints)
{this->Set(Duration);//Установка длительности моделирования
 return this->Set(sCheckPoints,true);//Установка новых контрольных точек
}
//****************************************************************************************
//СТАТУС: I.8; public; TNumSimulationParams class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsCheckPoint(ulong time) const
//НАЗНАЧЕНИЕ: Функция проверяет значение time на его принадлежность контрольной точке.
//Функция возвращает true в случае совпадения time с установленной контрольной точкой и
//false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong time - дискретное значение времени моделирования;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// bool lBelong - признак совпадения time с установленной контрольной точкой
//****************************************************************************************
bool TNumSimulationParams::IsCheckPoint(ulong time) const
{bool lBelong = false;
 if (time > GetDuration()) return lBelong;
 //Проверка на принадлежность выполняется в зависимости от режима установки
 //контрольных точек
 if (GetCheckPointMode() == cpBounds)
 {if ((time == 0L) || (time == GetDuration())) lBelong = true;
 }
 else if (GetCheckPointMode() == cpEvenSample)
 {if ((time == 0L) || (time == GetDuration())) lBelong = true;
  if (!lBelong)
   lBelong = (time % _CheckPoint.front() == 0) ? true : false;
 }
 else if (GetCheckPointMode() == cpCustom)
 {//Поиск значения time в отсортированном списке контрольных точек
  ulong ivalue;
  for (ulong i = 0L; i < _CheckPoint.size(); i++)
  {ivalue = _CheckPoint[i];
   if (ivalue == time) {lBelong = true; break;}
   if (ivalue > time) break;
  }
 }
 return lBelong;
}
//****************************************************************************************
//СТАТУС: I.9; public; TNumSimulationParams class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong GetCheckPoints(string& s) const
//НАЗНАЧЕНИЕ: Функция формирует в строке s, передаваемую по ссылке, значения контрольных
//точек в зависимости от выбранного варианта их установки. Функция возвращает количество
//установленных контрольных точек.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строку;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong Count - количество установленных контрольных точек
//****************************************************************************************
ulong TNumSimulationParams::GetCheckPoints(string& s) const
{s.clear();//Очистка строки
 char buffer[41];
 ostrstream text(buffer, sizeof(buffer));
 //Контрольные точки не установлены
 if (GetCheckPointMode() == cpEmpty) s.assign("Empty");
 //Контрольные точки заданы на границах интервала моделирования
 else if (GetCheckPointMode() == cpBounds)
 {text << "0 " << GetDuration() << ends;
  s.assign(text.str()); text.seekp(0);
 }
 //Контрольные точки выбираются равномерно на интервале моделирования
 else if (GetCheckPointMode() == cpEvenSample)
 {text << "[0, " << _CheckPoint.front() << " ... " << GetDuration() << ']' << ends;
  s.assign(text.str()); text.seekp(0);
 }
 //Контрольные точки выбираются произвольно на интервале моделирования
 else if (GetCheckPointMode() == cpCustom)
 {deque<ulong>::const_iterator I = _CheckPoint.begin();
  //Цикл формирования свойств источников излучения
  while (I != _CheckPoint.end())
  {text << (*I) << ends;
   s.append(text.str()); text.seekp(0);
   if (++I != _CheckPoint.end()) s.append(1,' ');
  }
 }
 return this->GetCheckPointsNumber();
}
//****************************************************************************************
//СТАТУС: I.10; public; TNumSimulationParams class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//ulong GetCheckPoints(string& s, ulong MaxWidth, const char* sfx = NULL) const
//НАЗНАЧЕНИЕ: Многострочный форматированный вывод значений контрольных точек в строку s,
//передаваемую по ссылке в зависимости от выбранного варианта их установки. Для всех режи-
//мов, кроме cpCustom, информация по значениям контрольных точек выводится в ОДНУ строку.
//Для варианта cpCustom ширина одной строки ограничивается значением MaxWidth, но при этом
//в каждой строке должно быть размещено как минимум одно значение. Каждая строка начинается
//со строки sfx (при sfx != NULL).
//Функция возвращает количество строк, в которых разместились значения установленных
//контрольных точек.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку-приемник значений контрольных точек;
//2. ulong MaxWidth (80) - максимальная ширина каждой строки;
//3. const char* sfx (NULL) - начало каждой новой строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ulong Lines - количество строк, в которых разместились значения контрольных точек
//****************************************************************************************
ulong TNumSimulationParams::GetCheckPoints(string& s, ulong MaxWidth, const char* sfx) const
{ulong Lines = 0L;
 s.clear();//Очистка строки
 if (GetCheckPointMode() != cpCustom)
 {Lines = 1;
  string t;
  GetCheckPoints(t);
  if (sfx != NULL) s.assign(sfx);
  s.append(t);
 }
 else //Контрольные точки выбираются произвольно на интервале моделирования
 {bool lFirst = true;//Первый элемент в строке
  bool lNewLine = false;//Переход на новую строку
  ulong CurLen;//Текущая длина строки
  ulong SfxLen = (sfx == NULL) ? 0 : strlen(sfx);
  deque<ulong>::const_iterator I = _CheckPoint.begin();
  deque<ulong>::const_iterator EndIter = _CheckPoint.end();
  char buffer[21];
  ostrstream text(buffer, sizeof(buffer));
  string t;
  //Цикл по значениям контрольных точек
  while (I != EndIter)
  {if (!lNewLine) {text << (*I) << ends; t.assign(text.str()); text.seekp(0);}
   if (lFirst) //Первая контрольная точка в строке
   {Lines++;
    lFirst = false;
    lNewLine = false;
    if (SfxLen != 0) s.append(sfx);
    s.append(t);
    CurLen = SfxLen+t.length();
   }
   else //Контрольная точка не первая в строке
   {//Проверка на возможность размещения значения контрольной точки в текущей строке
    CurLen += t.length() + 1;
    if (CurLen <= MaxWidth || MaxWidth == 0L)
    {s.append(1,' ');
     s.append(t);
    }
    else //Переход на новую строку
    {s.append(1,'\n');
     lFirst = true;
     lNewLine = true;
    }
   }
   if (!lNewLine) ++I;
  }//Конец цикла по контрольным точкам
 }//Обработка варианта резмещения cpCustom
 return Lines;
}
//****************************************************************************************
//СТАТУС: I.11; public member-function of class TNumSimulationParams
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Properties(string& s, ulong MaxWidth = 80L) const
//НАЗНАЧЕНИЕ: Формирование характеристик объекта в строке s, передаваемой в функцию по
//ссылке. Свойства представляются в виде:
//----------------------------------------------------------------------------------------
// Tsim: <_Time>, CheckPoints: <N>
// t1 t2 ... tn
// N - кол-во контрольных точек;
// t1, t2 ... tn - значения контрольных точек;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект, в котором формируются свойства объекта
//2. ulong MaxWidth (80) - максимальная ширина строки при выводе значений контрольных точек
//   в режиме cpCustom (при MaxWidth = 0 все значения выводятся в одну строку)
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами объекта.
//****************************************************************************************
string& TNumSimulationParams::Properties(string& s, ulong MaxWidth) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 string t;
 ulong ChPointNumber = GetCheckPointsNumber();
 text << "Tsim: " << GetDuration() << ", CheckPoints: " << ChPointNumber << ends;
 s.assign(text.str()); text.seekp(0);
 //Вывод значений контрольных точек
 ulong Lines = GetCheckPoints(t,MaxWidth);
 if ((Lines == 1) && (t.length() < 45))
 {text << " {" << t.c_str() << "};\n" << ends;
  s.append(text.str()); text.seekp(0);
 }
 else {s.append(1,'\n'); s.append(t); s.append(1,'\n');}
 return s;
}
//****************************************************************************************
//СТАТУС: I.12; public member-function of class TNumSimulationParams
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Brief(string &s, ulong MaxWidth = 80L) const
//НАЗНАЧЕНИЕ: Формирование характеристик объекта в строке s, передаваемой в функцию по
//ссылке, в краткой форме. Свойства представляются в виде:
//----------------------------------------------------------------------------------------
// Tsim: <_Time>, ChPoints: <N> [{t1 t2 ... tn}]
// N - кол-во контрольных точек;
// t1, t2 ... tn - значения контрольных точек;
//Значения контрольных точек для режима cpCustom выводятся в случае, когда они могут быть
//размещены в строке длиной до MaxWidth вместе с первоначально выводимой информацией.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект, в котором формируются свойства объекта
//2. ulong MaxWidth (80) - максимальная ширина строки при выводе значений контрольных точек
//   в режиме cpCustom (при MaxWidth = 0 все значения выводятся в одну строку)
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами объекта.
//****************************************************************************************
string& TNumSimulationParams::Brief(string& s, ulong MaxWidth) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 string t;
 ulong ChPointNumber = GetCheckPointsNumber();
 text << "Tsim: " << GetDuration() << ", ChPoints: " << ChPointNumber << ends;
 s.assign(text.str()); text.seekp(0);
 //Вывод значений контрольных точек
 GetCheckPoints(t);
 if (GetCheckPointMode() != cpCustom)
 {text << " {" << t.c_str() << "};\n" << ends;
  s.append(text.str()); text.seekp(0);
 }
 else //Для режима cpCustom
 {if (t.length() <= MaxWidth-s.length()-4)
  {text << " {" << t.c_str() << "};\n" << ends;
   s.append(text.str()); text.seekp(0);
  }
  else s.append(" {Custom mode};\n");
 }
 return s;
}
//========================================================================================
// РЕАЛИЗАЦИЯ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ КЛАССА TNumSimulationParams
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TNumSimulationParams class overloading operator ==
//OVERLOADING COMPARE OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ==(const long& time) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СРАВНЕНИЯ класса TNumSimulationParams. Функция
//проверяет принадлежность значения time контрольной точке. Возвращается true, если time
//совпадает со значением контрольной точки и false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const long& time - ссылка на сравниваемое значение.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат сравнения значения time со значением
//контрольной точки.
//****************************************************************************************
bool TNumSimulationParams::operator ==(const long& time) const
{
 return this->IsCheckPoint(time);
}
//========================================================================================
//             РЕАЛИЗАЦИЯ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССА TNumSimulationParams
//========================================================================================
//****************************************************************************************
//СТАТУС: 1;  TNumSimulationParams class friend overloading operator <<
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// ostream& operator <<(ostream& out, const TNumSimulationParams& Object)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВЫВОДА класса TNumSimulationParams. Функция
//выводит в поток свойства объекта в виде:
//----------------------------------------------------------------------------------------
// Tsim: <_Time>, CheckPoints: <N>
// t1 t2 ... tn
// N - кол-во контрольных точек;
// t1, t2 ... tn - значения контрольных точек;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на объект потока вывода
//2. сonst TNumSimulationParams& Object - ссылка на объект, выводимый в поток.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ostream& out - ссылка на объект потока вывода.
//***********************-****************************************************************
ostream& operator <<(ostream& out, const TNumSimulationParams& Object)
{string s;
 Object.Properties(s,78);
 out << s;//Вывод характеристик объекта
 return out;
}
//****************************************************************************************
//СТАТУС: 2;  TNumSimulationParams class friend function
//INPUT TNumSimulationParams PROPERTIES by cin
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend long Edit(TNumSimulationParams& Object)
//НАЗНАЧЕНИЕ: Редактирование свойств объекта класса TNumSimulationParams, передаваемый по
//ссылке через стандартный поток ввода cin. Возвращается количество контрольных точек.
//После редактирования происходит отображение свойств объекта. Формат ввода контрольных
//точек:
//----------------------------------------------------------------------------------------
//Check Points: <Edit>
// t1 t2 t3 ... tn;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TNumSimulationParams& Object - ссылка на редактируемый объект;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: long Count - количество контрольных точек после редактирования
//****************************************************************************************
long Edit(TNumSimulationParams& Object)
{//Рабочие переменные
 int y, row_start = wherey();
 char c;
 string s, line(78,'-');
 bool flag, lClear;
 gotoxy(1,row_start); clreol();

 do //Цикл ввода контрольных точек
 {//--------------------------------------------------------------------------------------
  cout << line << endl;
  cout << "Check Points: < Edit > InputForm: <T1 T2 T3 ... Tn;>, Prev:" << endl;
  Object.Properties(s,79);
  cout << s << endl;
  cout << line << endl;
  //--------------------------------------------------------------------------------------
  //Запрос на удаление ранее введенных контрольных точек
  //--------------------------------------------------------------------------------------
  y = wherey();
  if (Object.GetCheckPointsNumber() > 0)
  {cout << "WARNING ! Check Points will be LOST ! Continue !? [y/n]: "; cin >> c;
   lClear = (c == 'Y' || c == 'y') ? true : false;
   if (!lClear) break;
  }
  ClrScr(1,y);//Очистка экрана
  //--------------------------------------------------------------------------------------
  //Ввод значений контрольных точек
  //--------------------------------------------------------------------------------------
  y = wherey();
  cout << "> ";
  cin.ignore();
  getline(cin,s,';');
  Object.Set(s,false);
  ClrScr(1,y);//Очистка экрана
  cout << "New Check Points:" << endl;
  cout << Object;
  //--------------------------------------------------------------------------------------
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
 return Object.GetCheckPointsNumber();//Кол-во контрольных точек после редактирования
}
//========================================================================================
// II. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TNumSimulationParams
//     PROTECTED MEMBER-FUNCTION OF TNumSimulationParams CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: II.1; protected; TNumSimulationParams class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void _Init()
//НАЗНАЧЕНИЕ: Начальная установка характеристик TNumSimulationParams
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TNumSimulationParams::_Init()
{ _Time = 0L;//Дискретное положительное общее время моделирования
  _CheckPoint.clear();//Отсортированный список контрольных точек
  _Mode = cpEmpty;//Вариант установки контрольных точек
}
//****************************************************************************************
//СТАТУС: II.2; protected; TNumSimulationParams class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void _HndlDurationChange()
//НАЗНАЧЕНИЕ: Обработчик события изменения длительности интервала моделирования. Функция
//проверяет и при необходимости корректирует варианты расстановки и значения контрольных
//точек, установленных на интервале моделирования.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TNumSimulationParams::_HndlDurationChange()
{if (GetDuration() == 0L) SetCheckPointMode(cpEmpty);
 else
 {if (GetCheckPointMode() == cpEmpty) SetCheckPointMode(cpBounds);
  else if ((GetCheckPointMode() == cpEvenSample) && (GetDuration() < _CheckPoint.front()))
   SetCheckPointMode(cpBounds);
  else if (GetCheckPointMode() == cpCustom)
  {//Удаление контрольных точек, которые не принадлежат интервалу моделирования
   if (_CheckPoint.back() > GetDuration())
   {while (_CheckPoint.back() > GetDuration()) _CheckPoint.pop_back();
    if (_CheckPoint.empty()) SetCheckPointMode(cpBounds);
    else if ((_CheckPoint.size() == 2) && (_CheckPoint[0] == 0) &&
             (_CheckPoint[1] == GetDuration())) SetCheckPointMode(cpBounds);
   }
  }
 }

}

//****************************************************************************************
//                              РЕАЛИЗАЦИЯ КЛАССА TSettingsTF
//            ПАРАМЕТРЫ РАСЧЕТА ПЕРЕДАТОЧНЫХ ФУНКЦИЙ C ОДНОЙ УГЛОВОЙ КООРДИНАТОЙ
//1) TEvenCloseInterval Sector - угловой сектор, в котором рассчитывается передаточная
//   функция: [a,a+delta .. b] в градусах, где  a - начальный угол, b - конечный угол и
//   delta - шаг интервала (дискретность отсчетов);
//2) enNormType NormType - тип нормирования значений:
//   a) UnNormalized - без нормирования;
//   b) Normalized - нормировка в пределах [0..1];
//   c) NormalizedDB - нормирование в децибелах;
//3) double MinDB - минимальный порог в dB при нормировке в децибелах;
//4) bool GroupNorm - опция групповой или индивидуальной нормировки при вычислении переда-
//   точных функций нескольких каналов.
//****************************************************************************************
//========================================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TSettingsTF
//   PUBLIC MEMBER-FUNCTION OF TSettingsTF CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; TSettingsTF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Sector(string& s) const
//НАЗНАЧЕНИЕ: Формирование углового сектора в строке s, передаваемой по ссылке, в формате:
// <Sector [deg]: [<Start>,<Start+Delta>..<End>] Size: <Count>>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строку-приемник параметров сектора;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку со свойствами сектора
//****************************************************************************************
string& TSettingsTF::Sector(string& s) const
{char buffer[40];
 ostrstream text (buffer, sizeof(buffer));
 //Формирование заголовка
 s.assign("Sector [deg]: ");
 text << Count() << ' ' << ends;
 s.append(text.str()); text.seekp(0);
 //Формирование свойств интервала
 if (Count() == 0) {s.append("{ }"); return s;}
 else if (Count() > 2)
  text << "[" << Start() << ", " << (Start()+Step()) << " .. " << End() << "]" << ends;
 else text << "[" << Start() << " .. " << End() << "]" << ends;
 s.append(text.str()); text.seekp(0);
 return s;
}
//****************************************************************************************
//СТАТУС: I.2; TSettingsTF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& NormType(string& s) const
//НАЗНАЧЕНИЕ: Формирование типа нормирования в строке s, передаваемой по ссылке, в формате:
// <NormType: <UnNormalized> || <Normalized [0..1]> || <dB Normalized, MindB: <value>>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строку-приемник типа нормирования;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с типом нормирования
//****************************************************************************************
string& TSettingsTF::NormType(string& s) const
{char buffer[40];
 ostrstream text (buffer, sizeof(buffer));
 bool lShowThreshold = false;
 //Формирование заголовка
 //s.assign("NormType: ");
 //Формирование типа нормирования
 switch (this->GetNormType())
 {case UnNormalized:
   s.assign("UnNormalized");
   break;
  case Normalized:
   s.assign("Normalized [0..1]");
   break;
  case Norm_10Lg:
   s.assign("Norm As 10Lg, ");
   lShowThreshold = true;
   break;
  case Norm_20Lg:
   s.assign("Norm As 20Lg, ");
   lShowThreshold = true;
   break;
  default:
   s.assign("Normalized ???");
 }
 //Пороговое значение при нормировании в dB
 if (lShowThreshold)
 {text << "Min: " << this->GetMindB() << " dB" << ends;
  s.append(text.str()); text.seekp(0);
 }
 return s;
}
//****************************************************************************************
//СТАТУС: I.3; TSettingsTF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GroupNorm(string& s) const
//НАЗНАЧЕНИЕ: Формирование значения опции нормирования в строке s, передаваемой по ссылке,
//в формате: <GroupNorm: ON | OFF>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строку-приемник типа нормирования;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с типом нормирования
//****************************************************************************************
string& TSettingsTF::GroupNorm(string& s) const
{//Признак группового или индивидуального нормирования
 s.assign("GroupNorm: ");
 if (this->GetGroupNorm()) s.append("ON");
 else s.append("OFF");
 return s;
}
//****************************************************************************************
//СТАТУС: I.4; TSettingsTF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& About(string& s) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта в строке s, передаваемой по ссылке, в формате:
//<Sector [deg]: [<Start>,<Start+Delta>..<End>] Size: <Count>,
// NormType: <UnNormalized> || <Normalized [0..1]> || <dB Normalized, MindB: <value>,
// GroupNorm: <ON || OFF>;>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строку-приемник свойств объекта;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку со свойствами объекта класса
//****************************************************************************************
string& TSettingsTF::About(string& s) const
{string t;
 this->Sector(s);
 this->NormType(t);
 s.append(", ");
 s.append(t);
 if (this->GetNormType() != UnNormalized)
 {this->GroupNorm(t); s.append(", "); s.append(t);}
 s.append(";");
 return s;
}
//****************************************************************************************
//СТАТУС: I.5; TSettingsTF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditSector()
//НАЗНАЧЕНИЕ: Редактирование углового сектора объекта. Формат редактирования сектора:
//----------------------------------------------------------------------------------------
//< Edit < Sector [deg] >
//< Sector: [Start,Start+Step..End] size: <Count> >
//  1. Start Angle [deg]: <double value>
//  2. End Angle [deg]: <double value>
//  3. Step [deg]: <double value>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TSettingsTF::EditSector()
{//Рабочие переменные
 int y, row_start = wherey();
 string s, h, line(78,'-');
 bool flag;
 char c;
 double value;
 gotoxy(1,row_start); clreol();
 //Формирование заголовка
 h.assign("Edit < Sector [deg]>");
 do //Цикл ввода свойств равномерного закрытого интервала
 {cout << line << endl << h << endl;
  //--------------------------------------------------------------------------------------
  //Ввод начального, конечного углов сектора и шага изменения углов в секторе
  //--------------------------------------------------------------------------------------
  y = wherey();
  cout << this->Sector(s) << endl << line << endl;
  //Ввод начального угла сектора
  cout << " 1. Start Angle [deg]: "; cin >> value;
  this->SetSector(value,this->End(),this->Step());
  ClrScr(1,y);//Очистка экрана
  cout << this->Sector(s) << endl << line << endl;
  //Ввод конечного угла сектора
  cout << " 2. End Angle [deg]: "; cin >> value;
  this->SetSector(this->Start(),value,this->Step());
  ClrScr(1,y);//Очистка экрана
  cout << this->Sector(s) << endl << line << endl;
  //Ввод шага изменения углов в секторе
  cout << " 3. Step [deg]: "; cin >> value;
  this->SetSector(this->Start(),this->End(),value);
  ClrScr(1,y);//Очистка экрана
  cout << this->Sector(s) << endl << line << endl;
  //---------------------------------------------------------------------------
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: I.6; TSettingsTF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditNormType()
//НАЗНАЧЕНИЕ: Редактирование типа нормировки. Формат редактирования:
//----------------------------------------------------------------------------------------
//< Edit < NormType >
//< NormType: <UnNormalized> || <Normalized [0..1]> || <dB Normalized, MindB: <value> >
//  1. UnNormalized
//  2. Normalized [0..1]
//  3. Normalized [Decibel]
//  Choose normalization option [1..3]: <i_value>
//  IF (value == 3) Minimal Level in Db [MindB < 0]: <r_value>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TSettingsTF::EditNormType()
{//Рабочие переменные
 STR_UINT NormOption[4] = {
 {1, "UnNormalized"},
 {2, "Normalized [0..1]"},
 {3, "Norm As 10Lg  [dB]"},
 {4, "Norm As 20Lg  [dB]"} };
 TB_STR_UINT NormMenu = {4, NormOption};

 int y, row_start = wherey(),choice;
 string s, h, line(78,'-');
 bool flag;
 char c;
 double value;
 gotoxy(1,row_start); clreol();
 //Формирование заголовка
 h.assign("Edit < Normalization Type >");
 do //Цикл ввода свойств равномерного закрытого интервала
 {cout << line << endl << h << endl;
  //--------------------------------------------------------------------------------------
  //Выбор типа нормирования
  //--------------------------------------------------------------------------------------
  y = wherey();
  cout << " NormType: " << this->NormType(s) << endl << line << endl;
  //Выбор типа нормировки
  s = "Choose normalization option [1..5]: ";
  choice = ConsoleChoice(NormMenu, 3, s.c_str(), 2);
  switch (choice)
  {case 1: this->SetNormType(UnNormalized,this->GetMindB()); break;
   case 2: this->SetNormType(Normalized,this->GetMindB()); break;
   case 3: this->SetNormType(Norm_10Lg,this->GetMindB()); break;
   case 4: this->SetNormType(Norm_20Lg,this->GetMindB()); break;
  }
  ClrScr(1,y);//Очистка экрана
  cout << " NormType: " << this->NormType(s) << endl << line << endl;
  //Ввод минимального значения в децибелах (MinDb < 0)
  switch (this->GetNormType())
  {case Norm_10Lg:
   case Norm_20Lg:
    cout << " Minimal Level in dB [MindB < 0]: "; cin >> value;
    this->SetMinDB(value);
    ClrScr(1,y);//Очистка экрана
    cout << " NormType: " << this->NormType(s) << endl << line << endl;;
    break;
  }
  //--------------------------------------------------------------------------------------
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: I.7; TSettingsTF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditGroupNorm()
//НАЗНАЧЕНИЕ: Редактирование опции групповой нормировки. Формат редактирования:
//----------------------------------------------------------------------------------------
//< Edit < GroupNorm >
//< GroupNorm: <ON> || <OFF> >
//  1. Group Normalization
//  2. Individual Normalization
//  Choose normalization option [1..2]: <i_value>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TSettingsTF::EditGroupNorm()
{//Рабочие переменные
 STR_UINT GroupNormOption[2] = {
 {1, "Group Normalization"},
 {2, "Individual Normalization"} };
 TB_STR_UINT GroupNormMenu = {2, GroupNormOption};

 int y, row_start = wherey(),choice;
 string s, h, line(78,'-');
 bool flag;
 char c;
 double value;
 gotoxy(1,row_start); clreol();
 //Формирование заголовка
 h.assign("Edit < Group Normalization Option >");
 do //Цикл ввода значений GroupNorm
 {cout << line << endl << h << endl;
  //--------------------------------------------------------------------------------------
  //Выбор типа нормирования
  //--------------------------------------------------------------------------------------
  y = wherey();
  cout << " " << this->GroupNorm(s) << endl << line << endl;
  //Выбор типа нормировки
  s = "Choose GroupNorm option [1..5]: ";
  choice = ConsoleChoice(GroupNormMenu, 1, s.c_str(), 2);
  switch (choice)
  {case 1: this->SetGroupNorm(true); break;
   case 2: this->SetGroupNorm(false); break;
  }
  ClrScr(1,y);//Очистка экрана
  cout << " " << this->GroupNorm(s) << endl << line << endl;
  //--------------------------------------------------------------------------------------
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: I.8; FRIEND function to TSettingsTF class
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend void Edit(TSettingsTF& Obj)
//НАЗНАЧЕНИЕ: Редактирование параметров расчета передаточной функции с одной угловой
//координатой:
//----------------------------------------------------------------------------------------
//< Edit < Params For Calculating One Angle-Coordinate Transfer Function >
//<Sector [deg]: [<Start>,<Start+Delta>..<End>] Size: <Count>,
// NormType: <UnNormalized> || <Normalized [0..1]> || <dB Normalized, MindB: <value>;>
//  1. Edit <Sector>    --> EditSector()
//  2. Edit <NormType>  --> EditNormType()
//  3. Edit <GroupNorm> --> EditGroupNorm()
//  4. Exit
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void Edit(TSettingsTF& Obj)
{//Рабочие переменные
 STR_UINT EditOpts[4] = {
 {1, "Edit < Sector >"},
 {2, "Edit < NormType >"},
 {3, "Edit < GroupNorm >"},
 {4, "Exit"} };
 TB_STR_UINT EditMenu = {4, EditOpts};
 int row_start = wherey();
 int choice;
 bool flag = true;
 string s, line(78,'-');
 string h("Edit < Params For Calculating One Angle-Coordinate Transfer Function >");

 gotoxy(1,row_start); clreol();
 do //Цикл редактирования свойств объекта
 {cout << line << endl << h << endl;
  cout << Obj << endl << line << endl;
  //Выбор типа нормировки
  s = "Choose option [1..4]: ";
  choice = ConsoleChoice(EditMenu,4,s.c_str(),1);
  switch (choice)
  {case 1: Obj.EditSector(); break;
   case 2: Obj.EditNormType(); break;
   case 3: Obj.EditGroupNorm(); break;
   case 4: flag = false; break;
  }
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: I.9; TSettingsTF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool MakeReport(rmatrix& Out, const rvector& In) const
//НАЗНАЧЕНИЕ: Нормирование вектора входных данных In в соответствии с установленным типом
//нормирования NormType с последующим размещением результатов в матрице Out в формате:
//Out[][0] - значения углов, принадлежащих угловому сектору Sector;
//Out[][1] - нормированные значения из вектора In
//Для успешного выполнения функции должны выполняться следующие условия:
//1. Размерность вектора In должна соответствовать кол-ву отсчетных значений в секторе;
//2. Все значения в векторе In должны быть неотрицательными.
//В случае успеха возвращается true и в матрице Out формируется таблица значений углов,
//принадлежащих сектору Sector и нормированных значений передаточной функции из In, которые
//соответствуют данным угловым координатам. В случае невыполнения вышеуказанных условий
//возвращается false и матрица Out нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& Out - ссылка на матрицу-приемник результатов работы функции;
//2. const rvector& In - ссылка на вектор с входными данными.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат формирования табличных данных в Out
//****************************************************************************************
bool TSettingsTF::MakeReport(rmatrix& Out, const rvector& In) const
{double Max, Min, r_val;
 double Factor = 1.0;
 double Angle;
 //Проверка возможности формирования отчета в Out
 if (In.Size() != this->Count()) {Out.Set(0,false); return false;}
 //Вычисление максимального и минимального значений
 In.MaxMin(Max,Min);
 if (Min < 0.0) {Out.Set(0,false); return false;}
 //Задаем матрицу Out необходимой размерности: In.Size() x 2
 Out.Set(In.Size(),2,false);
 if (this->GetNormType() == Norm_10Lg) Factor = 10.0;
 else if(this->GetNormType() == Norm_20Lg) Factor = 20.0;

 //Формируем отчет
 for (ulong i = 0; i < Out.Rows(); i++)
 {Angle = this->Number(i);
  if (fabs(Angle) < 1e-10) Angle = 0.0; 
  Out.Put(i,0,Angle);
  r_val = In.Get(i);
  //Проводим нормирование (при необходимости)
  switch (this->GetNormType())
  {case Normalized: //Нормирование в пределах [0..1]
    if (Max != 0.0) r_val = r_val/Max;
    break;
   case Norm_10Lg: //Нормирование 10*Log10(x)
   case Norm_20Lg: //Нормирование 20*Log10(x)
    if (r_val != 0.0)
    {r_val = Factor*log10(r_val);
     if (r_val < this->GetMindB()) r_val = this->GetMindB();
    }
    else r_val = this->GetMindB();
    break;
  }
  Out.Put(i,1,r_val);
 }
 return true;
}
//****************************************************************************************
//СТАТУС: I.10; TSettingsTF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool MakeReport(rmatrix& Out, const rmatrix& In) const
//НАЗНАЧЕНИЕ: Формирование отчета по входным данным матрицы In в матрице Out. Первый стол-
//бец матрицы Out содержит угловые значения, в которых вычислялась передаточная функция.
//Допускается индивидуальная или групповая нормировка данных матрицы In в соответствии с
//установками объекта класса TSettingsTF. Индивидуальная нормировка значений матрицы In
//проводится по столбцам.
//Для успешного выполнения функции должны выполняться следующие условия:
//1. Число строк матрицы In должна соответствовать кол-ву отсчетных значений в секторе;
//2. Все значения в матрице In должны быть неотрицательными.
//В случае успеха возвращается true и в матрице Out формируется таблица значений углов,
//принадлежащих сектору Sector и нормированных значений передаточной функции из In, которые
//соответствуют данным угловым координатам. В случае невыполнения вышеуказанных условий
//возвращается false и матрица Out нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& Out - ссылка на матрицу-приемник результатов работы функции;
//2. const rmatrix& In - ссылка на матрицу с входными данными.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат формирования табличных данных в Out
//****************************************************************************************
bool TSettingsTF::MakeReport(rmatrix& Out, const rmatrix& In) const
{double Max, Min;
 double Angle;
 //Проверка возможности формирования отчета в Out
 if (In.Rows() != this->Count()) {Out.Set(0,false); return false;}
 //Вычисление максимального и минимального значений
 In.MaxMin(Max,Min);
 if (Min < 0.0) {Out.Set(0,false); return false;}
 //Задаем матрицу Out необходимой размерности: In.Size() x 2
 Out.Set(In.Rows(),In.Cols()+1,false);
 rmatrix NormIn(In);

 if (this->IsNormalize())
 {bool lGroup = this->GetGroupNorm();
  bool lSuccess;
  if (this->IsNormDB()) //Нормирование в децибелах
  {bool lPower = (this->GetNormType() == Norm_10Lg) ? true : false;
   if (lGroup) lSuccess = In.NormalizeToDB(NormIn,lPower,this->GetMindB());
   else lSuccess = In.NormalizeColsToDB(NormIn,lPower,this->GetMindB());
  }
  else //Нормирование в интервале [0..1]
  {if (lGroup) lSuccess = In.Normalize(NormIn,FIRST_NORM);//Групповое нормирование
   else //Индивидуальное нормирование
    lSuccess = In.NormalizeCols(NormIn,FIRST_NORM);
  }
  if (lSuccess == false) {Out.Set(0,false); return false;}
 }
 //---------------------------------------------------------------------------------
 //Формируем отчет
 //---------------------------------------------------------------------------------
 for (ulong i = 0L; i < Out.Rows(); i++)
  for (ulong j = 0L; j < Out.Cols(); j++)
  {if (j == 0)
   {Angle = this->Number(i);
    if (fabs(Angle) < 1.0e-10) Angle = 0.0;//Округление до нуля
    Out.Put(i,j,Angle);
   }
   else Out.Put(i,j,NormIn.Get(i,j-1));
  }
 return true;
}
//****************************************************************************************
//СТАТУС: I.11; TSettingsTF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetDefault()
//НАЗНАЧЕНИЕ: Установка параметров по умолчанию для объекта класса TSettingsTF:
//1. Sector    = [-90.0, -89.9 .. +90.0];
//2. NormType  = Norm_10Lg
//3. MinDB     = -60.0 dB
//4. GroupNorm = ON
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TSettingsTF::SetDefault()
{this->SetSector(-90.0,90.0,0.1);
 this->SetNormType(Norm_10Lg,-60.0);
 this->SetGroupNorm(true);
}

//========================================================================================
// РЕАЛИЗАЦИЯ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ КЛАССА TSettingsTF
// OVERLOADING OPERATORS FOR TSettingsTF CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; TSettingsTF public member-function
//OVERLOADING ASSIGNMENT OPERATOR (=)
//НАИМЕНОВАНИЕ ФУНКЦИИ: TSettingsTF& operator =(const TSettingsTF& Obj)
//НАЗНАЧЕНИЕ: Перегрузка оператора присваивания (=) для класса TSettingsTF.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//TSettingsTF& Obj - ссылка на объект класса TSettingsTF, свойства которого копируются в
//данный объект (this) класса TSettingsTF.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//TSettingsTF& this - ссылка на объект, в который были скопированы свойства Obj.
//****************************************************************************************
TSettingsTF& TSettingsTF::operator =(const TSettingsTF& Obj)
{if (this == &Obj) return *this;
 this->SetSector(Obj.Start(),Obj.End(),Obj.Step());
 this->SetNormType(Obj.GetNormType(),Obj.GetMindB());
 this->SetGroupNorm(Obj.GetGroupNorm());
 return *this;
}
//****************************************************************************************
//СТАТУС: I.2; FRIEND function to TSettingsTF class
//OVERLOAD THE STREAM INSERTION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend ostream& operator <<(ostream& out, const TSettingsTF& Obj)
//НАЗНАЧЕНИЕ: Перегрузка операции потокового вывода (<<) свойств класса TSettingsTF.
//Функция передает в поток out свойства объекта Obj в символьном виде и возвращает ссылку
//на данный поток для возможности каскадного применения оператора <<.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на поток, в который передаются свойства объекта Obj;
//2. TSettingsTF& Obj - ссылка на объект-источник, свойства которого копируются в поток.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ostream& out - ссылка на поток, с переданными свойствами объекта класса TSettingsTF
//****************************************************************************************
ostream& operator <<(ostream& out, const TSettingsTF& Obj)
{string s;
 return out << Obj.About(s);
}

//****************************************************************************************
//               РЕАЛИЗАЦИЯ КЛАССА TDoubleSet -- КОНТЕЙНЕР ВЕЩЕСТВЕННЫХ ЧИСЕЛ
//Класс реализует интерфейс по хранению, получению, модификации, редактированию чисел типа
//double. Контейнером для хранения выступает класс std::set, который допускает хранение
//только уникальных значений и их автоматическую сортировку по выбранному пользователем
//критерия (по умолчанию - по возрастанию).
//****************************************************************************************
//========================================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TDoubleSet
//   PUBLIC MEMBER-FUNCTION OF TDoubleSet CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; TDoubleSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// ulong Append(const string& s, const TArgVectorPredicate<double,rvector>* Predicate = NULL)
//Извлечение из строки s вещественных чисел и добавление их в контейнер _Set. Функция
//возвращает количество элементов в контейнере после их извлечения из строки s и добавления
//в контейнер _Set.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1) string& s - ссылка на строку c вещественными числами;
//2) const TArgVectorPredicate<double,rvector>* Predicate - указатель на объект-предикат,
//   согласно которому осуществляется добавление, извлеченных из строки чисел в контейнер.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong size - кол-во вещественных чисел в контейнере после их
//извлечения из строки s и добавления в контейнер
//****************************************************************************************
ulong TDoubleSet::Append(const string& s, const TArgVectorPredicate<double,rvector>* Predicate)
{rvector V;
 //Извлечение из строки s вещ-х чисел с их размещением в векторе V (заносятся только
 //уникальные значения)
 V.GetDataFromString(s,true,Predicate);
 //Добавление вещественных чисел из вектора V в контейнер _Set
 for (ulong i = 0L; i < V.Size(); i++) this->Append(V.Get(i));
 return this->Size();
}
//****************************************************************************************
//СТАТУС: I.2; TDoubleSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong GetData(rvector& V) const
//Копирование вещественных чисел из контейнера _Set в вектор V.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: rvector& V - ссылка на вектор-приемник чисел из контейнера;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong Count - кол-во значений, размещенных в векторе V
//****************************************************************************************
ulong TDoubleSet::GetData(rvector& V) const
{V.Resize(this->Size(),false);
 if (V.IsZeroSize()) return V.Size();
 DblSet::const_iterator I = _Set.begin();
 //Копирование чисел из контейнера в вектор V
 for (ulong i = 0; i < V.Size(); i++)
 {V.Put(i,*I);
  ++I;
 }
 return V.Size();
}
//****************************************************************************************
//СТАТУС: I.3; TDoubleSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetData(string& t) const
//Копирование вещественных чисел из контейнера _Set в строку t.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& t - ссылка на строку-приемник чисел из контейнера;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& t - ссылка на строку-приемник чисел из контейнера после
//их размещения в ней
//****************************************************************************************
string& TDoubleSet::GetData(string& t) const
{t.clear();//Предварительная очистка строку
 if (this->IsEmpty()) return t;
 char buffer[20];
 ostrstream text (buffer, sizeof(buffer));
 DblSet::const_iterator I = _Set.begin();
 DblSet::const_iterator End = _Set.end();
 //Цикл размещения в строке t чисел из контейнера
 do
 {text << *I << ends;//Символьное представление вещественного числа из контейнера
  t.append(text.str());
  text.seekp(0);
  ++I;
  if (I != End) t.append(1,' ');
  else break;
 } while (true);
 return t;
}
//****************************************************************************************
//СТАТУС: I.4; TDoubleSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: const string& SetName(const string& NewName)
//Переименование контейнера с данными. Функция возвращет новое имя контейнера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const string& NewName - ссылка на строку с новым именем контейнера;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: const string& Name - ссылка на строку с новым именем контейнера
//****************************************************************************************
const string& TDoubleSet::SetName(const string& NewName)
{long start = -1;
 long end;
 char c;
 //Поиск первого непробельного символа слева
 for (ulong i = 0; i < NewName.size(); i++)
 {c = NewName[i];
  if ((c != ' ') && (c != '\t') && (c != '\n')) {start = i; break;}
 }
 if (start != -1) //Непробельный символ слева найден
 {//Поиск первого непробельного символа справа
  end = NewName.size()-1;
  for (long i = end; i > start; i--)
  {c = NewName[i];
   if ((c != ' ') && (c != '\t') && (c != '\n')) {end = i; break;}
  }
  _Name.assign(NewName,start,end-start+1);
 }
 else _Name.assign("DoubleSet");

 return _Name;
}
//****************************************************************************************
//СТАТУС: I.5; TDoubleSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& About(string& t, bool lBriefly) const
//Формирование свойств объекта в строке t, передаваемой в функцию по ссылке. Опция lBriefly
//задает ограничение на максимальный размер строки t. При lBriefly = true длина строки t
//не должна превышать 80, в противном случае длина не ограничивается. Формат вывода:
// <DataSet Name>: <Set size> {<r_val1> <r_val2> .. <rval_n>} - ПОЛНАЯ ФОРМА
// <DataSet Name>: <Set size> {<r_val1> ... <rval_n>} - СОКРАЩЕННАЯ ФОРМА
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& t - ссылка на строку-приемник свойств объекта в символьном виде;
//2. bool lBriefly - опция представления свойств объекта (полная или сокращенная форма).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& t - ссылка на строку со свойствами объекта
//****************************************************************************************
string& TDoubleSet::About(string& t, bool lBriefly) const
{char buffer[40];
 ostrstream text (buffer, sizeof(buffer));
 string values;
 ulong LenStr;

 t.clear();//Предварительная очистка строки
 t.assign(this->Name());
 text << ": " << this->Size() << " {" << ends;
 t.append(text.str());
 text.seekp(0);
 if (this->Size() == 0) //Контейнер пустой
 {t.append(1,'}'); return t;}
 //Формирование в строке values значений хранящихся в контейнере
 this->GetData(values);
 LenStr = t.size() + values.size() + 1;//Определение длины результирующей строки t

 if ((lBriefly == true) && (LenStr > 80)) //Краткая форма
 {DblSet::const_iterator First = _Set.begin();
  DblSet::const_reverse_iterator Last  = _Set.rbegin();
  text << *First << " ... " << *Last << ends;
  t.append(text.str());
  text.seekp(0);
 }
 else t.append(values);//Полная форма
 t.append(1,'}');
 return t;
}
//****************************************************************************************
//СТАТУС: I.6; TDoubleSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& About(string& t,  uint width, const char* pfx = NULL) const
//Формирование свойств объекта в строке t, передаваемой в функцию по ссылке. Строка t фор-
//матируется на подстроки шириной не более width символов и каждая подстрока может предва-
//ряться строкой pfx. Формат вывода:
// <DataSet Name>: <Set size> vals {<r_val1> <r_val2> .. <rval_n>}
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& t - ссылка на строку-приемник свойств объекта в символьном виде;
//2. uint width - максимальная ширина каждой строки;
//3. const char* pfx (NULL) - начало каждой новой строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& t - ссылка на строку со свойствами объекта
//****************************************************************************************
string& TDoubleSet::About(string& t,  uint width, const char* pfx) const
{string s;
 this->About(s,false);
 MultiLineFormat(t,s,width,pfx);
 return t;
}
//****************************************************************************************
//СТАТУС: I.7; TDoubleSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& AboutData(string& t) const
//Формирование в строке t, передаваемой по ссылке информации о данных, хранящихся в кон-
//тейнере. Форма предствления: <Size> {<_Set>}
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const string& t - ссылка на строку-приемник сведений о данных контейнера;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& t - ссылка на строку с данными контейнера
//****************************************************************************************
string& TDoubleSet::AboutData(string& t) const
{ulong szSet = this->Size();
 if (szSet == 0) {t.assign("0 {};"); return t;}
 char buffer[21];
 ostrstream text(buffer, sizeof(buffer));
 string s;
 this->GetData(s);
 text << szSet << " {" << ends; t.assign(text.str()); text.seekp(0);
 t.append(s); t.append("};");
 return t;
}
//****************************************************************************************
//СТАТУС: I.8; TDoubleSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Range(string& t) const
//Формирование в строке t информации о диапазоне (интервале) хранимых в контейнере значений
//и размере контейнера в формате:
//1. Size = 0 - пустой контейнер => {};
//2. Size < 4 - перечисляются все значения контейнера => {X1[,X2,X3]};
//3. Size > 3 => {Xmin..Xmax,Size}.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const string& t - ссылка на строку-приемник сведений о данных контейнера;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& t - ссылка на строку с данными контейнера
//****************************************************************************************
string& TDoubleSet::Range(string& t) const
{//Объявление переменных
 ulong szSet = this->Size();//число значений в контейнере
 //Формирование в строке t сведений о диапазоне значений контейнера и его размерах
 if (szSet == 0) t.assign("{}");
 else if (szSet < 4)
 {string s;
  this->GetData(s);
  t.assign(1,'{'); t.append(s); t.append(1,'}');
 }
 else //szSet >= 4
 {char buffer[81];
  ostrstream text(buffer, sizeof(buffer));
  DblSet::const_iterator First = _Set.begin();
  DblSet::const_reverse_iterator Last  = _Set.rbegin();
  text << '{' << *First << ".." << *Last << ',' << szSet << '}' << ends;
  t.assign(text.str());
  text.seekp(0);
 }
 return t;
}
//****************************************************************************************
//СТАТУС: I.9; TDoubleSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong Range(double& Min, double& Max) const
//Определение максимального и минимального значений, хранящихся в контейнере, а также раз-
//меров контейнера. Функция возвращает размеры контейнера. В переменные Min и Max, переда-
//ваемые в функцию по ссылке, в зависимости от размеров контейнера записываются следующие
//результаты:
//1. Size = 0 - пустой контейнер => Min = Max = 0;
//2. Size = 1 - Min = Max = X;
//3. Size > 1 - Min = Xmin, Max = Xmax.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double& Min - ссылка на переменную-приемник минимального значения контейнера;
//2. double& Max - ссылка на переменную-приемник максимального значения контейнера;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong szSet - размерность контейнера
//****************************************************************************************
ulong TDoubleSet::Range(double& Min, double& Max) const
{//Объявление переменных
 ulong szSet = this->Size();//размерность контейнера
 //Формирование в строке t сведений о диапазоне значений контейнера и его размерах
 if (szSet == 0) {Min = Max = 0.0;}
 else if (szSet == 1)
 {DblSet::const_iterator First = _Set.begin();
  Min = Max = *First;
 }
 else //szSet > 1
 {DblSet::const_iterator First = _Set.begin();
  DblSet::const_reverse_iterator Last  = _Set.rbegin();
  Min = *First;
  Max = *Last;
 }
 return szSet;
}
//****************************************************************************************
//СТАТУС: I.10; TDoubleSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditName()
//НАЗНАЧЕНИЕ: Редактирование наименования набора данных. Формат редактирования:
//----------------------------------------------------------------------------------------
//< Edit < DoubleSet name >
//< Name: <Old_name> >
//> New_name
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TDoubleSet::EditName()
{//Рабочие переменные
 int y, row_start = wherey();
 string s, h, line(78,'-');
 bool flag;
 char c;
 double value;
 gotoxy(1,row_start); clreol();
 //Формирование заголовка
 h.assign("Edit < DoubleSet name >");
 do //Цикл редактирования наименования набора данных
 {cout << line << endl << h << endl;
  y = wherey();
  cout << this->Name() << endl << line << endl;
  cout << "> ";
  cin.ignore();
  getline(cin,s,'\n');
  this->SetName(s);
  ClrScr(1,y);
  cout << this->Name() << endl << line << endl;
  //--------------------------------------------------------------------------------------
  //Подтверждение введенных данных
  //--------------------------------------------------------------------------------------
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
}
//****************************************************************************************
//СТАТУС: I.11; TDoubleSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// void EditData(const TArgVectorPredicate<double,rvector>* Predicate = NULL)
//НАЗНАЧЕНИЕ: Консольное редактирование элементов контейнера с подтверждением ввода.
//Формат ввода:
// Edit < DoubleSet vals > InPutForm: <d1 d2 ... dn;>, Prev:
// {Property DoubleSet before edit}
// [Warning message, input request]
// > d1 d2 ...
// {request to confirm input data}
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// const TArgVectorPredicate<double,rvector>* Predicate - указатель на объект-предикат,
// согласно правилам которого введенные значения добавляются в контейнер
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TDoubleSet::EditData(const TArgVectorPredicate<double,rvector>* Predicate)
{//Рабочие переменные
 int y, row_start = wherey();
 char c;
 string s, t, msg;
 string line(78,'-');
 bool flag, lClear = true;
 char buffer[40];
 ostrstream text(buffer, sizeof(buffer));

 gotoxy(1,row_start); clreol();

 do //Цикл ввода вещественных чисел
 {//--------------------------------------------------------------------------------------
  cout << line << endl;
  cout << "Edit <" << this->Name() << "> InputForm: <d1 d2 ... dn;>, Total: " << this->Size()
       << endl;
  this->GetData(t); MultiLineFormat(s,t,80); t.clear();
  cout << this->GetData(s) << endl;
  cout << line << endl;
  //--------------------------------------------------------------------------------------
  //Запрос на редактирование с предупреждающим сообщением
  //--------------------------------------------------------------------------------------
  msg.clear();
  if (!this->IsEmpty()) msg.assign("Would you like to DELETE old values !? [y/n]: ");
  if (!msg.empty())
  {y = wherey();
   cin.ignore();
   cout << msg; cin >> c;
   lClear = (c == 'Y' || c == 'y') ? true : false;
   ClrScr(1,y);//Очистка экрана
  }
  //--------------------------------------------------------------------------------------
  //Ввод новых значений
  //--------------------------------------------------------------------------------------
  y = wherey();
  cout << "> ";
  cin.ignore();
  getline(cin,s,';');
  if (lClear) this->Assign(s,Predicate);
  else this->Append(s,Predicate);
  ClrScr(1,y);//Очистка экрана
  //Формирование значений, хранящихся в контейнере, после ввода новых элементов
  this->GetData(s);
  text << "New: " << this->Size() << " {" << ends;
  t.assign(text.str()); text.seekp(0);
  t.append(s); t.append(1,'}');
  MultiLineFormat(s,t,80); t.clear();
  cout << s << endl;
  //--------------------------------------------------------------------------------------
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: I.12; TDoubleSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void RemoveData()
//НАЗНАЧЕНИЕ: Удаление из контейнера значений, введенных пользователем
//Формат ввода:
// Remove from < DoubleSet.Name > InPutForm: <d1 d2 ... dn;>, Total: <DoubleSet.size()>
// {Property DoubleSet before edit}
// [Warning message, input request]
// > d1 d2 ...
// {request to confirm input data}
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TDoubleSet::RemoveData()
{//Рабочие переменные
 int y, row_start = wherey();
 char c;
 string s, t;
 string line(78,'-');
 bool flag, lClearAll;
 char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 rvector RemovingData;
 ulong count;//Счетчик удаленных значений

 gotoxy(1,row_start); clreol();
 do //Цикл ввода чисел, подлежащих удалению
 {//--------------------------------------------------------------------------------------
  cout << line << endl;
  cout << "Remove from <" << this->Name() << "> DelVals: <d1 d2 ... dn;>, Total: "
       << this->Size() << endl;
  this->GetData(t); MultiLineFormat(s,t,80); t.clear();
  cout << this->GetData(s) << endl;
  cout << line << endl;
  if (this->IsEmpty()) //Контейнер пустой
  {cout << "DoubleSet is EMPTY!!! Removing data is impossible." << endl;
   cout << "Press any key..."; getch();
   break;
  }
  //--------------------------------------------------------------------------------------
  //Запрос на удаление с предупреждающим сообщением
  //--------------------------------------------------------------------------------------
  y = wherey();
  cout << "Would you like to DELETE ALL DATA !? [y/n]: ";
  cin.ignore(); cin >> c;
  lClearAll = (c == 'Y' || c == 'y') ? true : false;
  ClrScr(1,y);//Очистка экрана
  if (lClearAll) //Удаление всех значений
  {this->Clear();
   cout << "ALL DATA from " << this->Name() << " has been removed !!!";
   cout << "Press any key..."; getch();
   break;
  }
  //--------------------------------------------------------------------------------------
  //Ввод значений, которые должны быть удалены из контейнера
  //--------------------------------------------------------------------------------------
  count = 0;
  y = wherey();
  cout << "> ";
  cin.ignore();
  getline(cin,s,';');
  RemovingData.GetDataFromString(s,true);
  //Цикл удаления из контейнера значений, введенных пользователем
  for (ulong i = 0L; i < RemovingData.Size(); i++)
  {if (this->Remove(RemovingData.Get(i))) count++;
  }
  ClrScr(1,y);//Очистка экрана
  if (count) cout << count << " elements from DoubleSet has been deleted." << endl;
  else cout << "None elements from DoubleSet has been deleted." << endl;
  cout << line << endl;
  //Вывод значений оставшихся в контейнере после операции удаления
  this->GetData(s);
  text << "New: " << this->Size() << " {" << ends;
  t.assign(text.str()); text.seekp(0);
  t.append(s); t.append(1,'}');
  MultiLineFormat(s,t,80); t.clear();
  cout << s << endl;
  //--------------------------------------------------------------------------------------
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Would you like to go on removing values? [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = true;
  else //Повторный ввод данных
  {flag = false;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: I.13; FRIEND function to TDoubleSet class
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend void Edit(TDoubleSet& Obj,const TArgVectorPredicate<double,rvector>* Predicate = NULL)
//НАЗНАЧЕНИЕ: Редактирование свойств контейнера вещественных чисел:
//----------------------------------------------------------------------------------------
//< Edit < DoubleSet >
//{Property DoubleSet before edit}
//  1. Edit <Name>    --> EditName()
//  2. Edit <DataSet> --> EditData(Predicate)
//  3. Remove data    --> RemoveData();
//  3. Exit
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1) TDoubleSet& Obj - ссылка на редактируемый объект типа TDoubleSet;
//2) const TArgVectorPredicate<double,rvector>* Predicate - указатель на объект-предикат,
//   согласно правилам которого введенные значения добавляются в контейнер
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void Edit(TDoubleSet& Obj, const TArgVectorPredicate<double,rvector>* Predicate)
{//Рабочие переменные
 STR_UINT EditOpts[4] = {
 {1, "Edit < Name >"},
 {2, "Edit < DataSet >"},
 {3, "Remove data"},
 {4, "Exit"} };
 TB_STR_UINT EditMenu = {4, EditOpts};
 int row_start = wherey();
 int choice;
 bool flag = true;
 string s, line(78,'-');
 string h("Edit < DoubleSet >");

 gotoxy(1,row_start); clreol();
 do //Цикл редактирования свойств объекта
 {cout << line << endl << h << endl;
  cout << Obj.About(s,80) << endl << line << endl;
  s = "Choose option [1..3]: ";
  choice = ConsoleChoice(EditMenu,3,s.c_str(),1);
  switch (choice)
  {case 1: Obj.EditName(); break;
   case 2: Obj.EditData(Predicate); break;
   case 3: Obj.RemoveData(); break;
   case 4: flag = false; break;
  }
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: I.14; TDoubleSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Find(double rvalue) const
//Поиск элемента в контейнере со значением rvalue.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: double rval - значение искомого элемента
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lFind - результат поиска
//****************************************************************************************
bool TDoubleSet::Find(double rvalue) const
{if (this->IsEmpty()) return false;
 DblSet::const_iterator p = _Set.find(rvalue);
 return (p != _Set.end()) ? true : false;
}
//****************************************************************************************
//СТАТУС: I.15; TDoubleSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong RemoveOutSide(double min, double max)
//Удаление из контейнера всех значений не принадлежащих интервалу [min..max]. Функция воз-
//вращает число удаленных элементов.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double min - минимальное значение (нижний предел), принадлежащие допустимому интервалу;
//2. double max - максимальное значение (верхний предел), принадлежащие допустимому интервалу;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong Count - кол-во значений, удаленных из контейнера
//****************************************************************************************
ulong TDoubleSet::RemoveOutSide(double min, double max)
{if (this->IsEmpty()) return 0;
 if (max < min) {double t = max; max = min; min = t;}
 bool lFind = false;
 ulong PrevSize = this->Size();
 DblSet::const_iterator I = _Set.begin();
 DblSet::const_iterator First;
 //Поиск и удаление элементов, значения которых меньше min
 while (I != _Set.end())
 {if (*I < min && !lFind) {lFind = true; First = I;}
  if (*I >= min) break;
  I++;
 }
 if (lFind) _Set.erase(First,I);
 //Поиск и удаление элементов, значения которых больше max
 lFind = false;
 I = _Set.begin();
 while (I != _Set.end())
 {if (*I > max) {lFind = true; break;}
  I++;
 }
 if (lFind) _Set.erase(I,_Set.end());

 return PrevSize-this->Size();//Количество удаленных элементов
}
//****************************************************************************************
//СТАТУС: I.16; TDoubleSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// ulong Filtering(const TArgVectorPredicate<double,rvector>* Predicate)
//Удаление из контейнера значений, не удовлетворяющих предикату Predicate. Функция возвра-
//щает число удаленных элементов.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const TArgVectorPredicate<double,rvector>* Predicate - указатель на класс-предикат,
//согласно работе которого элементы контейнера исключаются или остаются в контейнере.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong Count - кол-во значений, удаленных из контейнера
//****************************************************************************************
ulong TDoubleSet::Filtering(const TArgVectorPredicate<double,rvector>* Predicate)
{if (this->IsEmpty() || Predicate == NULL) return 0;
 double dval, temp;
 bool lSuccess, lEnd;
 ulong PrevSize = this->Size();
 DblSet::const_iterator I = _Set.begin();
 //Поиск и удаление элементов, значения которых не удовлетворяют предикату
 while (true)
 {dval = *I;
  lSuccess = (*Predicate)(dval);//Проверка на соответствие значения элемента предикату
  I++;//Переход к следующему элементу контейнера
  lEnd = (I == _Set.end()) ? true : false;//Определение достижения конца контейнера
  if (!lSuccess) //Удаление элемента dval из контейнера
  {if (!lEnd) temp = *I;
   _Set.erase(dval);//Удаляем элемент, не удовлетворяющий предикату
   //Переходим к следующему элементу после удаленного значения
   if (!lEnd) I = _Set.find(temp);
  }
  if (lEnd) break;//Выход из цикла
 }
 return PrevSize-this->Size();//Количество удаленных элементов
}

//========================================================================================
// РЕАЛИЗАЦИЯ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ КЛАССА TDoubleSet
// OVERLOADING OPERATORS FOR TDoubleSet CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; TDoubleSet public member-function
//OVERLOADING ASSIGNMENT OPERATOR (=)
//НАИМЕНОВАНИЕ ФУНКЦИИ: TDoubleSet& operator =(const TDoubleSet& Obj)
//НАЗНАЧЕНИЕ: Перегрузка оператора присваивания (=) для класса TDoubleSet
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//TDoubleSet& Obj - ссылка на объект класса TDoubleSet, свойства которого копируются в
//данный объект (this) класса TDoubleSet.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//TDoubleSet& this - ссылка на объект, в который были скопированы свойства Obj.
//****************************************************************************************
TDoubleSet& TDoubleSet::operator =(const TDoubleSet& Obj)
{if (this == &Obj) return *this;
 this->SetName(Obj.Name());//Копирование имени контейнера
 //Копирование данных
 this->Clear();
 DblSet::const_iterator begin;
 DblSet::const_iterator end;
 if (Obj.GetIters(begin,end)) _Set.insert(begin,end);
 return *this;
}
//****************************************************************************************
//СТАТУС: I.2; FRIEND function to TDoubleSet class
//OVERLOAD THE STREAM INSERTION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend ostream& operator <<(ostream& out, const TDoubleSet& Obj)
//НАЗНАЧЕНИЕ: Перегрузка операции потокового вывода (<<) свойств класса TDoubleSet.
//Функция передает в поток out свойства объекта Obj в символьном виде и возвращает ссылку
//на данный поток для возможности каскадного применения оператора <<.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на поток, в который передаются свойства объекта Obj;
//2. TDoubleSet& Obj - ссылка на объект-источник, свойства которого копируются в поток.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ostream& out - ссылка на поток, с переданными свойствами объекта класса TDoubleSet
//****************************************************************************************
ostream& operator <<(ostream& out, const TDoubleSet& Obj)
{string s;
 return out << Obj.About(s,true);
}

//****************************************************************************************
//               РЕАЛИЗАЦИЯ КЛАССА TLongSet -- КОНТЕЙНЕР ВЕЩЕСТВЕННЫХ ЧИСЕЛ
//Класс реализует интерфейс по хранению, получению, модификации, редактированию чисел типа
//long. Контейнером для хранения выступает класс std::set, допускающий хранение только
//уникальных значений и их автоматическую сортировку по выбранному пользователем критерия
//(по умолчанию - по возрастанию).
//****************************************************************************************
//========================================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TLongSet
//   PUBLIC MEMBER-FUNCTION OF TLongSet CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// ulong Append(const string& s, const TArgVectorPredicate<long,ivector>* Predicate)
//Извлечение из строки s целых чисел и добавление их в контейнер _Set. Функция возвращает
//размер контейнера после извлечения из s и добавления в контейнер _Set целых чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1) string& s - ссылка на строку c целыми числами;
//2) const TArgVectorPredicate<long,ivector>* Predicate - указатель на объект-предикат,
//   согласно которому осуществляется добавление, извлеченных из строки чисел в контейнер.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong size - размер контейнера после извлечения из s и добавления
//в контейнер целых чисел
//****************************************************************************************
ulong TLongSet::Append(const string& s, const TArgVectorPredicate<long,ivector>* Predicate)
{ivector V;
 //Извлечение из строки s целых чисел с их размещением в векторе V (заносятся только
 //уникальные значения)
 V.GetDataFromString(s,true,Predicate);
 //Добавление целых чисел из вектора V в контейнер _Set
 for (ulong i = 0L; i < V.Size(); i++) this->Append(V.Get(i));
 return this->Size();
}
//****************************************************************************************
//СТАТУС: I.2; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong GetData(ivector& V) const
//Копирование целых чисел из контейнера _Set в вектор V.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ivector& V - ссылка на вектор-приемник чисел из контейнера;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong Count - кол-во значений, размещенных в векторе V
//****************************************************************************************
ulong TLongSet::GetData(ivector& V) const
{V.Resize(this->Size(),false);
 if (V.IsZeroSize()) return V.Size();
 LongSet::const_iterator I = _Set.begin();
 //Копирование чисел из контейнера в вектор V
 for (ulong i = 0; i < V.Size(); i++)
 {V.Put(i,*I);
  ++I;
 }
 return V.Size();
}
//****************************************************************************************
//СТАТУС: I.3; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetData(string& t) const
//Копирование целых чисел из контейнера _Set в строку t.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& t - ссылка на строку-приемник чисел из контейнера;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& t - ссылка на строку-приемник чисел из контейнера после
//их размещения в ней
//****************************************************************************************
string& TLongSet::GetData(string& t) const
{t.clear();//Предварительная очистка строки
 if (this->IsEmpty()) return t;
 char buffer[20];
 ostrstream text (buffer, sizeof(buffer));
 LongSet::const_iterator I = _Set.begin();
 LongSet::const_iterator End = _Set.end();
 //Цикл размещения в строке t чисел из контейнера
 do
 {text << *I << ends;//Символьное представление целого числа из контейнера
  t.append(text.str());
  text.seekp(0);
  ++I;
  if (I != End) t.append(1,' ');
  else break;
 } while (true);
 return t;
}
//****************************************************************************************
//СТАТУС: I.4; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong DataToStr(string& t) const
//Копирование данных из контейнера _Set в строку t с выделением интервалов. Для процедуры
//выделения интервалов из последовательности целых чисел, хранящихся в контейнере, приме-
//няется класс TLongValsToStr. Результат работы функции присваивается строке t, передавае-
//мой по ссылке. Функция возвращает количество чисел, переданных контейнером в строку t.
//В случае пустого контейнера, функция возвращает 0 и строку t нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& t - ссылка на строку-приемник чисел из контейнера;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong szSet - количество чисел контейнера, преобразованных в строку
//****************************************************************************************
ulong TLongSet::DataToStr(string& t) const
{TLongValsToStr LValsToStr;
 LongSet::const_iterator I = _Set.begin();
 LongSet::const_iterator End = _Set.end();
 //Цикл размещения в строке t чисел из контейнера с выделением интервалов
 LValsToStr.Start();
 while (I != End) {LValsToStr.Add(*I); ++I;};
 LValsToStr.Stop();
 return LValsToStr.GetResult(t);
}
//****************************************************************************************
//СТАТУС: I.5; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: const string& SetName(const string& NewName)
//Переименование контейнера с данными. Функция возвращет новое имя контейнера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const string& NewName - ссылка на строку с новым именем контейнера;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: const string& Name - ссылка на строку с новым именем контейнера
//****************************************************************************************
const string& TLongSet::SetName(const string& NewName)
{long start = -1;
 long end;
 char c;
 //Поиск первого непробельного символа слева
 for (ulong i = 0; i < NewName.size(); i++)
 {c = NewName[i];
  if ((c != ' ') && (c != '\t') && (c != '\n')) {start = i; break;}
 }
 if (start != -1) //Непробельный символ слева найден
 {//Поиск первого непробельного символа справа
  end = NewName.size()-1;
  for (long i = end; i > start; i--)
  {c = NewName[i];
   if ((c != ' ') && (c != '\t') && (c != '\n')) {end = i; break;}
  }
  _Name.assign(NewName,start,end-start+1);
 }
 else _Name.assign("LongSet");

 return _Name;
}
//****************************************************************************************
//СТАТУС: I.6; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& About(string& t, bool lBriefly) const
//Формирование свойств объекта в строке t, передаваемой в функцию по ссылке. Опция lBriefly
//задает ограничение на максимальный размер строки t. При lBriefly = true длина строки t
//не должна превышать 80, в противном случае длина не ограничивается. Формат вывода:
// <DataSet Name>: <Set size> {<i_val1> <i_val2> .. <ival_n>} - ПОЛНАЯ ФОРМА
// <DataSet Name>: <Set size> {<i_val1> ... <ival_n>} - СОКРАЩЕННАЯ ФОРМА
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& t - ссылка на строку-приемник свойств объекта в символьном виде;
//2. bool lBriefly - опция представления свойств объекта (полная или сокращенная форма).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& t - ссылка на строку со свойствами объекта
//****************************************************************************************
string& TLongSet::About(string& t, bool lBriefly) const
{char buffer[40];
 ostrstream text (buffer, sizeof(buffer));
 string values;
 ulong LenStr;

 t.clear();//Предварительная очистка строки
 t.assign(this->Name());
 text << ": " << this->Size() << " {" << ends;
 t.append(text.str());
 text.seekp(0);
 if (this->Size() == 0) //Контейнер пустой
 {t.append(1,'}'); return t;}
 //Формирование в строке values значений хранящихся в контейнере
 this->GetData(values);
 LenStr = t.size() + values.size() + 1;//Определение длины результирующей строки t

 if ((lBriefly == true) && (LenStr > 80)) //Краткая форма
 {LongSet::const_iterator First = _Set.begin();
  LongSet::const_reverse_iterator Last  = _Set.rbegin();
  text << *First << " ... " << *Last << ends;
  t.append(text.str());
  text.seekp(0);
 }
 else t.append(values);//Полная форма
 t.append(1,'}');
 return t;
}
//****************************************************************************************
//СТАТУС: I.7; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& About(string& t,  uint width, const char* pfx = NULL) const
//Формирование свойств объекта в строке t, передаваемой в функцию по ссылке. Строка t фор-
//матируется на подстроки шириной не более width символов и каждая подстрока может предва-
//ряться строкой pfx. Формат вывода:
// <DataSet Name>: <Set size> vals {<i_val1> <i_val2> .. <ival_n>}
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& t - ссылка на строку-приемник свойств объекта в символьном виде;
//2. uint width - максимальная ширина каждой строки;
//3. const char* pfx (NULL) - начало каждой новой строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& t - ссылка на строку со свойствами объекта
//****************************************************************************************
string& TLongSet::About(string& t,  uint width, const char* pfx) const
{string s;
 this->About(s,false);
 MultiLineFormat(t,s,width,pfx);
 return t;
}
//****************************************************************************************
//СТАТУС: I.8; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& AboutData(string& t) const
////Формирование в строке t, передаваемой по ссылке информации о данных, хранящихся в кон-
//тейнере, с возможностью объединения их в интервалы. Форма предствления: <Size> {<_Set>}
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const string& t - ссылка на строку-приемник сведений о данных контейнера;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& t - ссылка на строку с данными контейнера
//****************************************************************************************
string& TLongSet::AboutData(string& t) const
{if (this->IsEmpty()) {t.assign("0 {};"); return t;}
 char buffer[21];
 ostrstream text(buffer, sizeof(buffer));
 string s;
 ulong szSet = this->DataToStr(s);
 text << szSet << " {" << ends; t.assign(text.str()); text.seekp(0);
 t.append(s); t.append("};");
 return t;
}
//****************************************************************************************
//СТАТУС: I.9; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Range(string& t) const
//Формирование в строке t информации о диапазоне (интервале) хранимых в контейнере значений
//и размере контейнера в формате:
//1. Size = 0 - пустой контейнер => {};
//2. Size < 4 - перечисляются все значения контейнера => {X1[,X2,X3]};
//3. Size > 3 => {Xmin..Xmax,Size}.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const string& t - ссылка на строку-приемник сведений о данных контейнера;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& t - ссылка на строку с данными контейнера
//****************************************************************************************
string& TLongSet::Range(string& t) const
{//Объявление переменных
 ulong szSet = this->Size();//число значений в контейнере
 //Формирование в строке t сведений о диапазоне значений контейнера и его размерах
 if (szSet == 0) t.assign("{}");
 else if (szSet < 4)
 {string s;
  this->GetData(s);
  t.assign(1,'{'); t.append(s); t.append(1,'}');
 }
 else //szSet >= 4
 {char buffer[81];
  ostrstream text(buffer, sizeof(buffer));
  LongSet::const_iterator First = _Set.begin();
  LongSet::const_reverse_iterator Last  = _Set.rbegin();
  text << '{' << *First << ".." << *Last << ',' << szSet << '}' << ends;
  t.assign(text.str());
  text.seekp(0);
 }
 return t;
}
//****************************************************************************************
//СТАТУС: I.10; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong Range(long& Min, long& Max) const
//Определение максимального и минимального значений, хранящихся в контейнере, а также раз-
//меров контейнера. Функция возвращает размеры контейнера. В переменные Min и Max, переда-
//ваемые в функцию по ссылке, в зависимости от размеров контейнера записываются следующие
//результаты:
//1. Size = 0 - пустой контейнер => Min = Max = 0;
//2. Size = 1 - Min = Max = X;
//3. Size > 1 - Min = Xmin, Max = Xmax.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. long& Min - ссылка на переменную-приемник минимального значения контейнера;
//2. long& Max - ссылка на переменную-приемник максимального значения контейнера;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong szSet - размерность контейнера
//****************************************************************************************
ulong TLongSet::Range(long& Min, long& Max) const
{//Объявление переменных
 ulong szSet = this->Size();//размерность контейнера
 //Формирование в строке t сведений о диапазоне значений контейнера и его размерах
 if (szSet == 0) {Min = Max = 0L;}
 else if (szSet == 1)
 {LongSet::const_iterator First = _Set.begin();
  Min = Max = *First;
 }
 else //szSet > 1
 {LongSet::const_iterator First = _Set.begin();
  LongSet::const_reverse_iterator Last  = _Set.rbegin();
  Min = *First;
  Max = *Last;
 }
 return szSet;
}
//****************************************************************************************
//СТАТУС: I.11; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditName()
//НАЗНАЧЕНИЕ: Редактирование наименования набора данных. Формат редактирования:
//----------------------------------------------------------------------------------------
//< Edit < LongSet name >
//< Name: <Old_name> >
//> New_name
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TLongSet::EditName()
{//Рабочие переменные
 int y, row_start = wherey();
 string s, h, line(78,'-');
 bool flag;
 char c;
 double value;
 gotoxy(1,row_start); clreol();
 //Формирование заголовка
 h.assign("Edit < LongSet name >");
 do //Цикл редактирования наименования набора данных
 {cout << line << endl << h << endl;
  y = wherey();
  cout << this->Name() << endl << line << endl;
  cout << "> ";
  cin.ignore();
  getline(cin,s,'\n');
  this->SetName(s);
  ClrScr(1,y);
  cout << this->Name() << endl << line << endl;
  //--------------------------------------------------------------------------------------
  //Подтверждение введенных данных
  //--------------------------------------------------------------------------------------
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
}
//****************************************************************************************
//СТАТУС: I.12; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditData(const TArgVectorPredicate<long,ivector> *Predicate)
//НАЗНАЧЕНИЕ: Консольное редактирование элементов контейнера с подтверждением ввода.
//Формат ввода:
// Edit < LongSet vals > InPutForm: <i1 i2 ... in;>, Prev:
// {Property LongSet before edit}
// [Warning message, input request]
// > i1 i2 ...
// {request to confirm input data}
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const TArgVectorPredicate<long,ivector> *Predicate - указатель на объект-предикат,
//согласно которому осуществляется добавление, извлеченных из строки чисел в контейнер.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TLongSet::EditData(const TArgVectorPredicate<long,ivector> *Predicate)
{//Рабочие переменные
 int y, row_start = wherey();
 char c;
 string s, t, msg;
 string line(78,'-');
 bool flag, lClear = true;
 char buffer[40];
 ostrstream text(buffer, sizeof(buffer));

 gotoxy(1,row_start); clreol();

 do //Цикл ввода целых чисел типа long
 {//--------------------------------------------------------------------------------------
  cout << line << endl;
  cout << "Edit <LongSet vals> InputForm: <i1 i2 ... in;>, Prev: " << this->Size()
       << " vals" << endl;
  this->GetData(t); MultiLineFormat(s,t,80); t.clear();
  cout << this->GetData(s) << endl;
  cout << line << endl;
  //--------------------------------------------------------------------------------------
  //Запрос на редактирование с предупреждающим сообщением
  //--------------------------------------------------------------------------------------
  msg.clear();
  if (!this->IsEmpty()) msg.assign("Would you like to DELETE old values !? [y/n]: ");
  if (!msg.empty())
  {y = wherey();
   cin.ignore();
   cout << msg; cin >> c;
   lClear = (c == 'Y' || c == 'y') ? true : false;
   ClrScr(1,y);//Очистка экрана
  }
  //--------------------------------------------------------------------------------------
  //Ввод новых значений
  //--------------------------------------------------------------------------------------
  y = wherey();
  cout << "> ";
  cin.ignore();
  getline(cin,s,';');
  if (lClear) this->Assign(s,Predicate);
  else this->Append(s,Predicate);
  ClrScr(1,y);//Очистка экрана
  //Формирование значений, хранящихся в контейнере, после ввода новых элементов
  this->GetData(s);
  text << "New: " << this->Size() << " {" << ends;
  t.assign(text.str()); text.seekp(0);
  t.append(s); t.append(1,'}');
  MultiLineFormat(s,t,80); t.clear();
  cout << s << endl;
  //--------------------------------------------------------------------------------------
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: I.13; FRIEND function to TLongSet class
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend void Edit(TLongSet& Obj,const TArgVectorPredicate<long,ivector> *Predicate=NULL)
//НАЗНАЧЕНИЕ: Редактирование свойств контейнера целых чисел:
//----------------------------------------------------------------------------------------
//< Edit < LongSet >
//{Property LongSet before edit}
//  1. Edit <Name>   --> EditName()
//  2. Edit <DataSet> --> EditData(Predicate)
//  3. Exit
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TDoubleSet& Obj - ссылка на контейнер с редактируемыми данными;
//2. const TArgVectorPredicate<long,ivector> *Predicate - указатель на объект-предикат,
//   согласно которому осуществляется добавление, извлеченных из строки чисел в контейнер.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void Edit(TLongSet& Obj, const TArgVectorPredicate<long,ivector> *Predicate)
{//Рабочие переменные
 STR_UINT EditOpts[3] = {
 {1, "Edit < Name >"},
 {2, "Edit < DataSet >"},
 {3, "Exit"} };
 TB_STR_UINT EditMenu = {3, EditOpts};
 int row_start = wherey();
 int choice;
 bool flag = true;
 string s, line(78,'-');
 string h("Edit < LongSet >");

 gotoxy(1,row_start); clreol();
 do //Цикл редактирования свойств объекта
 {cout << line << endl << h << endl;
  cout << Obj.About(s,80) << endl << line << endl;
  s = "Choose option [1..3]: ";
  choice = ConsoleChoice(EditMenu,3,s.c_str(),1);
  switch (choice)
  {case 1: Obj.EditName(); break;
   case 2: Obj.EditData(Predicate); break;
   case 3: flag = false; break;
  }
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: I.13a; FRIEND function to TLongSet class
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend void EditData(TLongSet& Obj, string& head,
//                      const TArgVectorPredicate<long,ivector> *Predicate = NULL)
//НАЗНАЧЕНИЕ: Редактирование данных, хранящихся в контейнере. Формат ввода:
// Edit < LongSet vals > InPutForm: <i1 i2 ... in;>, Prev:
// {Property LongSet before edit}
// [Warning message, input request]
// > i1 i2 ...
// {request to confirm input data}
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TLongSet& Obj - ссылка на контейнер с редактируемыми данными;
//2. string& head - строка-заголовок;
//3. const TArgVectorPredicate<long,ivector> *Predicate - указатель на объект-предикат,
//   согласно которому осуществляется добавление, извлеченных из строки чисел в контейнер.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void EditData(TLongSet& Obj,string& head,const TArgVectorPredicate<long,ivector> *Predicate)
{//Рабочие переменные
 int y, row_start = wherey();
 char c;
 string s, t, msg;
 string line(78,'-');
 bool flag, lClear = true;
 char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 gotoxy(1,row_start); clreol();

 do //Цикл ввода целых чисел типа long
 {//--------------------------------------------------------------------------------------
  if (head.empty()) s.assign("Edit <LongSet vals> InputForm: <i1 i2 ... in;>");
  else s.assign(head);
  s.append(" Prev: ");
  Obj.AboutData(t); s.append(t); MultiLineFormat(t,s,80);
  cout << line << endl;
  cout << t << endl;
  cout << line << endl;
  //--------------------------------------------------------------------------------------
  //Запрос на редактирование с предупреждающим сообщением
  //--------------------------------------------------------------------------------------
  msg.clear();
  if (!Obj.IsEmpty()) msg.assign("Would you like to DELETE old values !? [y/n]: ");
  if (!msg.empty())
  {y = wherey();
   cin.ignore();
   cout << msg; cin >> c;
   lClear = (c == 'Y' || c == 'y') ? true : false;
   ClrScr(1,y);//Очистка экрана
  }
  //--------------------------------------------------------------------------------------
  //Ввод новых значений
  //--------------------------------------------------------------------------------------
  y = wherey();
  cout << "> ";
  cin.ignore();
  getline(cin,s,';');
  if (lClear) Obj.Assign(s,Predicate);
  else Obj.Append(s,Predicate);
  ClrScr(1,y);//Очистка экрана
  //Формирование значений, хранящихся в контейнере, после ввода новых элементов
  s.assign("New: ");
  Obj.AboutData(t); s.append(t); MultiLineFormat(t,s,80);
  cout << t << endl;
  //--------------------------------------------------------------------------------------
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: I.14; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong RemoveOutSide(long min, long max)
//Удаление из контейнера всех значений не принадлежащих интервалу [min..max]. Функция воз-
//вращает число удаленных элементов.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. long min - минимальное значение (нижний предел), принадлежащие допустимому интервалу;
//2. long max - максимальное значение (верхний предел), принадлежащие допустимому интервалу;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong Count - кол-во значений, удаленных из контейнера
//****************************************************************************************
ulong TLongSet::RemoveOutSide(long min, long max)
{if (this->IsEmpty()) return 0;
 if (max < min) {long t = max; max = min; min = t;}
 bool lFind = false;
 ulong PrevSize = this->Size();
 LongSet::const_iterator I = _Set.begin();
 LongSet::const_iterator First;
 //Поиск и удаление элементов, значения которых меньше min
 while (I != _Set.end())
 {if (*I < min && !lFind) {lFind = true; First = I;}
  if (*I >= min) break;
  I++;
 }
 if (lFind) _Set.erase(_Set.begin(),I);
 //Поиск и удаление элементов, значения которых больше max
 lFind = false;
 I = _Set.begin();
 while (I != _Set.end())
 {if (*I > max) {lFind = true; break;}
  I++;
 }
 if (lFind) _Set.erase(I,_Set.end());

 return PrevSize-this->Size();//Количество удаленных элементов
}
//****************************************************************************************
//СТАТУС: I.15; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetFirst(long& ival) const
//Получение значения первого элемента контейнера с записью его в ival, передаваемую по
//ссылке. Функция возвращает признак выполнения операции: для пустого контейнера функция
//возвращает false и величине ival присваивается -1, в противном случае, она возвращает
//true и величине ival присваивается значение первого элемента контейнера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: long& ival - ссылка на переменную, которой будет присвоено зна-
//чение первого элемента контейнера;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции
//****************************************************************************************
bool TLongSet::GetFirst(long& ival) const
{if (this->IsEmpty()) {ival = -1; return false;}
 LongSet::const_iterator First = _Set.begin();
 ival = *First;
 return true;
}
//****************************************************************************************
//СТАТУС: I.16; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetLast(long& ival) const
//Получение значения последнего элемента контейнера с записью его в ival, передаваемую по
//ссылке. Функция возвращает признак выполнения операции: для пустого контейнера функция
//возвращает false и величине ival присваивается -1, в противном случае, она возвращает
//true и величине ival присваивается значение последнего элемента контейнера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: long& ival - ссылка на переменную, которой будет присвоено значе-
//ние последнего элемента контейнера;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции
//****************************************************************************************
bool TLongSet::GetLast(long& ival) const
{if (this->IsEmpty()) {ival = -1; return false;}
 LongSet::const_reverse_iterator Last  = _Set.rbegin();
 ival = *Last;
 return true;
}
//****************************************************************************************
//СТАТУС: I.17; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Find(long ival) const
//Поиск элемента в контейнере со значением ival.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: long ival - значение искомого элемента
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lFind - результат поиска
//****************************************************************************************
bool TLongSet::Find(long ival) const
{if (this->IsEmpty()) return false;
 LongSet::const_iterator p = _Set.find(ival);
 return (p != _Set.end()) ? true : false;
}
//****************************************************************************************
//СТАТУС: I.18; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// ulong Assign(long min, long max, const TLongSet& Derating, ulong max_count = 0)
//Присваивание контейнеру значений из интервала [min..max] количеством не более max_count
//с исключением значений, принадлежащих множеству Derating. При max_count == 0 ограничения
//на размер исходного контейнера (this) не задаются. Функция возвращает размер контейнера
//(this) после выполнения операции присваивания. До выполнения операции прежние значения
//удаляются из контейнера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. long min - нижняя граница интервала;
//2. long max - верхняя граница интервала;
//3. const TLongSet& Derating - ссылка на контейнер с числами, которые не должны быть
//   присвоены исходному контейнеру;
//4. ulong max_count [0] - максимальный размер исходного контейнера.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// ulong ival - размер контейнера после выполнения операции присваивания
//****************************************************************************************
ulong TLongSet::Assign(long min, long max, const TLongSet& Derating, ulong max_count)
{this->Clear();//Очистка контейнера
 if (min > max) {long t = max; max = min; min = t;}
 //Присвоение контейнеру значений из интервала [min..max] с учетом ограничений на допустимые
 //значения, задаваемые множеством Derating, и максимальным числом присваиваемых значений -
 //max_count
 //LongSet::const_iterator p;
 for (long i = min; i <= max; i++)
 {if (!Derating.Find(i)) this->Append(i);
  if (max_count != 0 && this->Size() == max_count) break;
 }
 return this->Size();
}
//****************************************************************************************
//СТАТУС: I.19; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong Assign(long min, long max, const TLongSet& StrongRestrict,
//                                   const TLongSet& WeakRestrict, ulong max_count = 0)
//Присваивание контейнеру значений из интервала [min..max] количеством не более max_count
//с учетом сильных и слабых ограничений, задаваемых контейнерами StrongRestrict и WeakRestict
//соответственно.
//Контейнер StringRestrict содержит значения, которые не должны быть присвоены исходному
//контейнеру при их принадлежности допустимому интервалу [min..max].
//Контейнер WeakRestrict содержит значения, присутствие которых в исходном контейнере не-
//желательно, но допустимо при их принадлежности допустимому интервалу [min..max]. Слабые
//ограничения учитываются только в том случае, когда max_count != 0.
//При max_count == 0 ограничения на размер исходного контейнера (this) не задаются. Функция
//возвращает размер контейнера (this) после выполнения операции присваивания. До выполнения
//операции прежние значения удаляются из контейнера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. long min - нижняя граница интервала;
//2. long max - верхняя граница интервала;
//3. const TLongSet& StrongRestict - контейнер с недопустимыми значениями;
//4. const TLongSet& WeakRestict - контейнер с нежелательными значениями, но допустимыми
//   значениями;
//5. ulong max_count [0] - максимальный размер исходного контейнера.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// ulong ival - размер контейнера после выполнения операции присваивания
//****************************************************************************************
ulong TLongSet::Assign(long min, long max, const TLongSet& StrongRestrict,
                       const TLongSet& WeakRestrict, ulong max_count)
{this->Clear();//Очистка контейнера
 if (min > max) {long t = max; max = min; min = t;}
 ulong amount = max - min;
 if ((max_count == 0) || (max_count >= amount) || WeakRestrict.IsEmpty())
  return this->Assign(min,max,StrongRestrict);

 for (long i = min; i <= max; i++)
 {if (!StrongRestrict.Find(i) && !WeakRestrict.Find(i)) this->Append(i);
  if (this->Size() == max_count) break;
 }
 //Выбор недостающих значений из WeakRestrict
 if (this->Size() < max_count)
 {LongSet::const_iterator p, end;
  if (WeakRestrict.GetIters(p,end))
  {long i;
   while (p != end)
   {i = *p;
    if ((i >= min) && (i <= max)) this->Append(i);
    if (this->Size() == max_count) break;
    ++p;
   }
  }
 }
 return this->Size();
}
//****************************************************************************************
//СТАТУС: I.20; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong AssignData(const TLongSet& LSet)
//Присваивание контейнеру значений из контейнера LSet, передаваемого по ссылке, с предвари-
//тельной очисткой контейнера this. Функция возвращает размер контейнера (this) после выпол-
//нения операции присваивания.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TLongSet& LSet - ссылка на контейнер-источник данных.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong ival - новый размер контейнера после выполнения функции.
//****************************************************************************************
ulong TLongSet::AssignData(const TLongSet& LSet)
{if (this == &LSet) return this->Size();
 this->Clear();//Очистка контейнера
 //Копирование данных
 LongSet::const_iterator begin;
 LongSet::const_iterator end;
 if (LSet.GetIters(begin,end)) _Set.insert(begin,end);
 return this->Size();
}
//****************************************************************************************
//СТАТУС: I.21; TLongSet public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong Assign(long min, long max, long delta = 1)
//Присваивание контейнеру чисел из интервала [min,min+delta .. max]. Значения min & max
//всегда включаются в контейнер. Функция возвращает новый размер контейнера.
//P.S. Присваивание контейнеру чисел из интервала всегда начинатся с нижней границы интер-
//вала независимо от знака приращения delta. При значении min > max осуществляется их
//перестановка, так чтобы верхняя граница интервала была больше нижней границы.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. long min - нижняя граница интервала;
//2. long max - верхняя граница интервала;
//3. long delta - приращение.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong ival - новый размер контейнера после выполнения функции.
//****************************************************************************************
ulong TLongSet::Assign(long min, long max, long delta)
{if (min == max) {this->Assign(min); return this->Size();}
 this->Clear();//Очистка контейнера
 long temp;
 if (delta == 0) delta = 1;
 if (delta < 0) delta *= -1;
 if (max < min) {temp = min; min = max; max = temp;}

 temp = min;
 while (temp < max) {this->_Set.insert(temp); temp += delta;}
 this->_Set.insert(max);

 return this->Size();
}

//========================================================================================
// РЕАЛИЗАЦИЯ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ КЛАССА TLongSet
// OVERLOADING OPERATORS FOR TLongSet CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; TLongSet public member-function
//OVERLOADING ASSIGNMENT OPERATOR (=)
//НАИМЕНОВАНИЕ ФУНКЦИИ: TLongSet& operator =(const TLongSet& Obj)
//НАЗНАЧЕНИЕ: Перегрузка оператора присваивания (=) для класса TLongSet
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//TLongSet& Obj - ссылка на объект класса TLongSet, свойства которого копируются в данный
//объект (this) класса TLongSet.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//TLongSet& this - ссылка на объект, в который были скопированы свойства Obj.
//****************************************************************************************
TLongSet& TLongSet::operator =(const TLongSet& Obj)
{if (this == &Obj) return *this;
 this->SetName(Obj.Name());//Копирование имени контейнера
 //Копирование данных
 this->Clear();
 LongSet::const_iterator begin;
 LongSet::const_iterator end;
 if (Obj.GetIters(begin,end)) _Set.insert(begin,end);
 return *this;
}
//****************************************************************************************
//СТАТУС: I.1; FRIEND function to TLongSet class
//OVERLOADING COMPARE OPERATOR (==)
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool operator ==(const TLongSet& A, const TLongSet& B)
//НАЗНАЧЕНИЕ: Перегрузка оператора сравнения (==) для класса TLongSet. Функция возвращает
//true, если данные хранящиеся в контейнерах идентичны и false в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TLongSet& A - ссылка на объект класса TLongSet, сравниваемый с объектом B;
//2. const TLongSet& B - ссылка на объект класса TLongSet, сравниваемый с объектом A;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lEqual - признак сравнения двух объектов класса TLongSet.
//****************************************************************************************
bool operator ==(const TLongSet& A, const TLongSet& B)
{if (&A == &B) return true;
 //Сравнение размеров контейнеров
 if (A.Size() != B.Size()) return false;
 if (A.IsEmpty() && B.IsEmpty()) return true;
 //Поэлементное сравнение данных, хранящихся в контейнерах
 bool lEqual = true;
 long ival;
 LongSet::const_iterator p, end;
 A.GetIters(p,end);
 while (p != end)
 {ival = *p;
  if (B.Find(ival) == false) {lEqual = false; break;}
  ++p;
 }
 return lEqual;
}
//****************************************************************************************
//СТАТУС: I.3; FRIEND function to TLongSet class
//OVERLOAD THE STREAM INSERTION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend ostream& operator <<(ostream& out, const TLongSet& Obj)
//НАЗНАЧЕНИЕ: Перегрузка операции потокового вывода (<<) свойств класса TLongSet.
//Функция передает в поток out свойства объекта Obj в символьном виде и возвращает ссылку
//на данный поток для возможности каскадного применения оператора <<.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на поток, в который передаются свойства объекта Obj;
//2. TLongSet& Obj - ссылка на объект-источник, свойства которого копируются в поток.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ostream& out - ссылка на поток, с переданными свойствами объекта класса TLongSet
//****************************************************************************************
ostream& operator <<(ostream& out, const TLongSet& Obj)
{string s;
 return out << Obj.About(s,true);
}


//========================================================================================
// РЕАЛИЗАЦИЯ ФУНКЦИЙ, ОБЪЯВЛЕННЫХ В ЗАГОЛОВОЧНОМ ФАЙЛЕ mathlib.h
//========================================================================================
//****************************************************************************************
//СТАТУС: 1; Extremum Seeking
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// long ExtremumSeeking(deque<TPoint_2D>& ExtrPoints, const rmatrix& F, FuncExtremum Extr)
//НАЗНАЧЕНИЕ: Поиск экстремумов функции, представленной в табличном виде матрицей F, пере-
//даваемой по ссылке. Матрица F должна состоять из двух столбцов и не менее чем из трех
//строк. В первом столбце хранятся значения аргументов функции, а во втором - значения
//функции. При невыполнении данных требований функция возвращает -1.
//Значение Extr позволяет определять MAX, MIN или MAX & MIN экстремумы вместе. Найденные
//экстремальные точки заносятся в контейнер ExtrPoints. Функция возвращает кол-во найденных
//экстремумов в матрице F (значения аргументов в F должны располагаться по возрастанию).
//Проверка точек на экстремум проводится последовательно для всех точек функции, за исклю-
//чением первой и последней точек - граничных точек. Алгоритм определения экстремума:
//1) MAX: F(i-1) < F(i) > F(i+1); 2) MIN: F(i-1) > F(i) < F(i+1).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1) deque<TPoint_2D>& ExtrPoints - ссылка на контейнер, в котором будут размещаться
//   найденные экстремальные точки;
//2) const rmatrix& F - ссылка на матрицу с табличным представлением исследуемой функции;
//3) FuncExtremum Extr - опция, определяющая экстремумы какого типа предстоит искать.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: long Number - кол-во найденных экстремумов
//***********************-****************************************************************
long ExtremumSeeking(deque<TPoint_2D>& ExtrPoints, const rmatrix& F, FuncExtremum Extr)
{ExtrPoints.clear();//Очищаем контейнер
 //Проверка матрицы F на корректность
 if (F.Cols() != 2 || F.Rows() < 3) return -1L;
 //------------------------------------------------------------------------------------
 TPoint_2D Point;//Поиск экстремумов функции
 double x,y;
 FuncExtremum PointKind;

 for(ulong i = 2; i < F.Rows(); i++)
 {PointKind = NoneExtr;
  y = F.Get(i-1,1);
  x = F.Get(i-1,0);
  //Проверка на максимум
  if ((F.Get(i-2,1) < y) && (y > F.Get(i,1))) {Point.Set(x,y); PointKind = MaxExtr;}
  //Проверка на минимум
  else if ((F.Get(i-2,1) > y) && (y < F.Get(i,1))) {Point.Set(x,y); PointKind = MinExtr;}
  //Точка относится к числу экстремальных
  if (PointKind != NoneExtr)
  {if (Extr == MaxMinExtr) ExtrPoints.push_back(Point);
   else if (Extr == PointKind) ExtrPoints.push_back(Point);
  }
 }//Конец цикла
 return ExtrPoints.size();
}
//****************************************************************************************
//СТАТУС: 2;  MULTILINE OUTPUT TPoint_2D objects in string
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//ulong MultiLineFormat(string& s, const deque<TPoint_2D>& Points, ulong MaxWidth = 80,
//      const char* sfx = NULL)
//НАЗНАЧЕНИЕ: Многострочный форматированный вывод точек TPoint_2D, размещенных в контейнере
//Points в строку s, передаваемую по ссылке. Ширина строки определяется переменной MaxWidth.
//Каждая новая строка начинается со строки sfx. Разбивка на строки предполагает размещение
//в каждой строке строки sfx и как минимум одной точки в краткой форме - (x,y) - независимо
//от величины MaxWidth.
//Функция возвращает количество строк Lines, в которых разместились все источники излучения
//при ширине каждой строки - MaxWidth. Функция возвращает 0, если контейнер Jams не содержит
//источников излучения.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку с характеристиками источников излучения из Jams;
//2. const deque<TPoint_2D>& Points - ссылка на контейнер с точками;
//3. ulong MaxWidth (80) - максимальная ширина каждой строки;
//4. const char* sfx (NULL) - начало каждой новой строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ulong Lines - количество строк, в которых разместились источники излучения из Jams.
//****************************************************************************************
ulong MultiLineFormat(string& s, const deque<TPoint_2D>& Points, ulong MaxWidth, const char* sfx)
{ulong Lines = 0;
 s.resize(0);
 if (Points.size() == 0) return Lines;
 string t;
 bool lFirst = true;//Первый элемент в строке
 bool lNewLine = false;//Переход на новую строку
 ulong CurLen;//Текущая длина строки
 ulong SfxLen = (sfx == NULL) ? 0 : strlen(sfx);
 deque<TPoint_2D>::const_iterator I = Points.begin();
 deque<TPoint_2D>::const_iterator EndIter = Points.end();
 //Цикл по всем источникам излучения
 while (I != EndIter)
 {if (!lNewLine) I->Brief(t);
  if (lFirst) //Первый источник излучения в строке
  {Lines++;
   lFirst = false;
   lNewLine = false;
   if (SfxLen != 0) s.append(sfx);
   s.append(t);
   CurLen = SfxLen+t.length();
  }
  else //Источник излучения не первый в строке
  {//Проверка на возможность размещения источника излучения в текущей строке
   CurLen += t.length() + 1;
   if (CurLen <= MaxWidth)
   {s.append(1,' ');
    s.append(t);
   }
   else //Переход на новую строку
   {s.append(1,'\n');
    lFirst = true;
    lNewLine = true;
   }
  }
  if (!lNewLine) ++I;
 }//Конец цикла по источникам излучения

 return Lines;
}
//****************************************************************************************
//СТАТУС: 3;  String MULTILINE FORMAT
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong MultiLineFormat(string& t, const string& s, uint width = 80,
//                            const char* pfx = NULL);
//НАЗНАЧЕНИЕ: Разбиение строки s на подстроки длиной не более width с возможностью вставки
//в начало каждой подстроки строки pfx. Разбитая на подстроки строка s сохраняется в t и
//функция возвращает число подстрок, на которые была разбита строка.
//Функция возвращает Lines == 0 и пустую строку t в следующих случаях:
//1) s - пустая строка;
//2) Len(pfx) >= width.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& t - ссылка на результирующую строку;
//2. string& s - ссылка на исходную строку;
//3. uint width (80) - максимальная ширина каждой строки;
//4. const char* pfx (NULL) - начало каждой новой строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ulong Lines - количество строк, в которых разместились источники излучения из Jams.
//****************************************************************************************
ulong MultiLineFormat(string& t, const string& s, uint width, const char* pfx)
{ulong Lines = 0;
 ulong LenPfx = (pfx == NULL) ? 0 : strlen(pfx);
 t.clear();//Обнуление результирующей строки
 //Проверка на возможность разбиения строки s на подстроки
 if (s.empty() || (LenPfx >= width)) return Lines;
 //Разбиение строки на подстроки
 uint Width = width - LenPfx;
 uint start = 0;
 uint end = (Width < s.size()) ? Width-1 : s.size();
 int LastSpace = -1;
 bool lNewLine = false;
 char c;

 do
 {for (uint i = start; i < end; i++)
  {c = s[i];
   if (c == '\n') {lNewLine = true; end = i; break;}
   if ((c == ' ') || (c == '\t')) LastSpace = i;
  }
  //Формируем начало каждой строки
  Lines++;//Увеличиваем счетчик строк
  if (LenPfx != 0) t.append(pfx);//Добавляем префиксную строку pfx

  if (lNewLine) //Формирование новой подстроки при обнаружении символа '\n'
  {lNewLine = false;
   t.append(s,start,end-start+1);
   start = end+1;
  }
  //Проверка на последную подстроку
  else if (end == s.size())
  {t.append(s,start,end-start);
   break;//Выход из цикла
  }
  //Формирование новой подстроки по последнему из интеравала [start..end) пробельному
  //символу - ' ' or '\t'
  else if (LastSpace != -1)
  {t.append(s,start,LastSpace-start);
   t.append(1,'\n');
   start = LastSpace+1;
   LastSpace = -1;
  }
  //Принудительное формирование новой подстроки после символа s[end-1]
  else
  {t.append(s,start,end-start);
   t.append(1,'\n');
   start = end;
  }
  if (start >= s.size()) break;//Достигнут конец строки s
  //Устанавливаем правую границу нового интервала
  end = start+Width;
  if (end > s.size()) end = s.size();

 } while (true);

 return Lines;
}
//****************************************************************************************
//СТАТУС: 4;  BUILD X & Y ARRAYS FOR MathCAD 3D-Surface as (X,Y,Z)
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool MathCad_AxesXY(rmatrix& X, rmatrix& Y, const rvector& sX, const rvector& sY)
//НАЗНАЧЕНИЕ: Построение массивов чисел в матрицах X & Y для отображения значений числовых
//осей X & Y, соответствующим действительным их значениям, при построении 3D-поверхностей
//в пакете MathCAD в форме (X,Y,Z). Векторы sX & sY, передаваемые по ссылке, содержат
//значения по осям X и Y.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& X - ссылка на матрицу, в которой формируется числовой массив для оси X
//2. rmatrix& Y - ссылка на матрицу, в которой формируется числовой массив для оси Y
//3. const rvector& sX - ссылка на вектор значений по оси X
//4. const rvector& sY - ссылка на вектор значений по оси Y
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения функции
//****************************************************************************************
bool MathCad_AxesXY(rmatrix& X, rmatrix& Y, const rvector& sX, const rvector& sY)
{if (sX.IsZeroSize() || sY.IsZeroSize())
 {X.Set(0L,false); Y.Set(0L,false);
  return false;
 }
 //Создание числовых массивов X & Y необходимой размерности
 X.Set(sX.Size(),sY.Size(),false);
 Y.Set(sX.Size(),sY.Size(),false);
 //Инициализация числовых массивов X & Y в соответствии со значениями для x & y
 for (ulong i = 0L; i < X.Rows(); i++)
  for (ulong j = 0L; j < X.Cols(); j++)
  {X.Put(i,j,sX.Get(i));
   Y.Put(i,j,sY.Get(j));
  }

 return true;
}
//****************************************************************************************
//СТАТУС: 5;  BUILD X & Y ARRAYS FOR MathCAD 3D-Surface as (X,Y,Z)
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool MathCad_AxesXY(rmatrix& X, rmatrix& Y, const TDoubleSet& sX, const TDoubleSet& sY)
//НАЗНАЧЕНИЕ: Построение массивов чисел в матрицах X & Y для отображения значений числовых
//осей X & Y, соответствующим действительным их значениям, при построении 3D-поверхностей
//в пакете MathCAD в форме (X,Y,Z). Контейнеры sX & sY, передаваемые по ссылке, содержат
//значения по осям X и Y.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& X - ссылка на матрицу, в которой формируется числовой массив для оси X
//2. rmatrix& Y - ссылка на матрицу, в которой формируется числовой массив для оси Y
//3. const TDoubleSet& sX - ссылка на контейнер значений по оси X
//4. const TDoubleSet& sY - ссылка на контейнер значений по оси Y
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения функции
//****************************************************************************************
bool MathCad_AxesXY(rmatrix& X, rmatrix& Y, const TDoubleSet& sX, const TDoubleSet& sY)
{if (sX.IsEmpty() || sY.IsEmpty()) {X.Set(0L,false); Y.Set(0L,false); return false;}
 //Создание числовых массивов X & Y необходимой размерности
 X.Set(sX.Size(),sY.Size(),false);
 Y.Set(sX.Size(),sY.Size(),false);
 //Инициализация числовых массивов X & Y в соответствии со значениями для x & y
 DblSet::const_iterator Iter_X, Iter_Y, EIter_X, EIter_Y, BIter_Y;
 sX.GetIters(Iter_X, EIter_X);
 sY.GetIters(Iter_Y, EIter_Y);
 BIter_Y = Iter_Y;
 //Двойной цикл
 for (ulong i = 0L; i < X.Rows(); i++)
 {for (ulong j = 0L; j < X.Cols(); j++)
  {X.Put(i,j,*Iter_X);
   Y.Put(i,j,*Iter_Y);
   ++Iter_Y;
  }
  Iter_Y = BIter_Y;
  ++Iter_X;
 }
 return true;
}
//****************************************************************************************
//СТАТУС: 6;  BUILD X & Y ARRAYS FOR MathCAD 3D-Surface as (X,Y,Z)
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool MathCad_AxesXY(imatrix& X, rmatrix& Y, const TLongSet& sX, const TDoubleSet& sY)
//НАЗНАЧЕНИЕ: Построение массивов чисел в матрицах X & Y для отображения значений числовых
//осей X & Y, соответствующим действительным их значениям, при построении 3D-поверхностей
//в пакете MathCAD в форме (X,Y,Z). Контейнеры sX & sY, передаваемые по ссылке, содержат
//значения по осям X и Y.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& X - ссылка на матрицу, в которой формируется числовой массив для оси X
//2. rmatrix& Y - ссылка на матрицу, в которой формируется числовой массив для оси Y
//3. const TLongSet& sX - ссылка на контейнер значений по оси X
//4. const TDoubleSet& sY - ссылка на контейнер значений по оси Y
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения функции
//****************************************************************************************
bool MathCad_AxesXY(imatrix& X, rmatrix& Y, const TLongSet& sX, const TDoubleSet& sY)
{if (sX.IsEmpty() || sY.IsEmpty()) {X.Set(0L,false); Y.Set(0L,false); return false;}
 //Создание числовых массивов X & Y необходимой размерности
 X.Set(sX.Size(),sY.Size(),false);
 Y.Set(sX.Size(),sY.Size(),false);
 //Инициализация числовых массивов X & Y в соответствии со значениями для x & y
 LongSet::const_iterator Iter_X, EIter_X;
 DblSet::const_iterator Iter_Y, EIter_Y, BIter_Y;
 sX.GetIters(Iter_X, EIter_X);
 sY.GetIters(Iter_Y, EIter_Y);
 BIter_Y = Iter_Y;
 //Двойной цикл
 for (ulong i = 0L; i < X.Rows(); i++)
 {for (ulong j = 0L; j < X.Cols(); j++)
  {X.Put(i,j,*Iter_X);
   Y.Put(i,j,*Iter_Y);
   ++Iter_Y;
  }
  Iter_Y = BIter_Y;
  ++Iter_X;
 }
 return true;
}
//****************************************************************************************
//СТАТУС: 7;  Prime Numbers Factoring By Division
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool PrimeFactoringByDivision(ulong n, ULongMap& PrimeNumColl)
//НАЗНАЧЕНИЕ: Разложение на простые множители числа n (n>1) при помощи деления. В контейнер
//PrimeNumColl, передаваемый по ссылке, заносятся значения простых множителей и их число
//(от 1 и более), на которые число n раскладывается. Если число n простое, то контейнер
//будет содержать только значение n в количестве равном 1, и функция возвратит true. В
//противном случае функция возвращает false (n - составное число) и контейнер будет содер-
//жать либо разные простые числа либо одно значение простого числа в количестве большем 1
//либо комбинацию вышеперечисленных вариантов.
//Алгоритм (Д. Кнут Искусство программирования для ЭВМ, т. 2): По данному положительному
//целому n данный алгоритм находит простые множители p1 <= p2 <= ... <= pt. В этом методе
//используется вспомогательная последовательность "пробных делителей": 2 = d0 < d1 < d2 <
//d3 < ..., которая включает в себя все простые числа <= sqrt(n) (а если это удобно, может
//содержать и числа, не являющиеся простыми). Последоватеьность чисел d должна содержать по
//крайней мере один член dk > sqrt(n).
//Последовательность пробных делителей d0, d1, d2 ..., используемую в алгоритме можно просто
//считать последовательностью чисел 2 3 5 7 11 13 17 19 23 25 29 31 35 ..., члены которой
//кроме первых трех, получаются попеременным увеличением на два и четыре. Эта последователь-
//ность содержит все числа, не являющиеся кратными двух и трех; при этом она содержит числа,
//как 25 35 49 и т.д., заведомо не простые, тем не менее алгоритм будет давать правильный
//ответ. Если из списка убрать числа 30m[+-]5, m >=1, изгоняя тем самым как "ложные" простые
//числа все кратные пяти, то можно сэкономить 20% времени выполнения. Исключение кратных
//семи сократит список еще на 14% и т.д.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong n - целое положительное число, разлагаемое на простые множители;
//2. ULongMap& PrimeNumsColl - ссылка на контейнер, в который заносятся значения простых
//   множителей и их количество для n.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lPrime - простое (true) или составное (false) число n
//****************************************************************************************
bool PrimeFactoringByDivision(ulong n, ULongMap& PrimeNumColl)
{bool lPrime = true;
 //Очистка контейнера
 PrimeNumColl.clear();
 if (n == 1) {PrimeNumColl.insert(std::make_pair(n,1)); return lPrime;}
 //Простой алгоритм разложения
 ulong t = 0;//Счетчик простых множителей числа n
 ulong k = 0;
 ulong q,r;
 ulong dk = 2;
 ulong D[4] = {2,3,5,7};
 ULongMap::iterator pos;
 bool lIncByTwo = false;
 //Основной цикл
 while (n != 1) //A2 - Проверка на окончание работы алгоритма при n == 1
 {//A3 - Разделить
  q = n/dk;//Частное от деления на dk
  r = n%dk;//Остаток от деления на dk
  //A4 - Остаток нуль (r == 0) ?
  if (r == 0)
  {//A5 - Множитель найден
   ++t;
   //Добавляем значение dk в контейнер простых чисел или увеличиваем значение счетчика
   //на единицу, если dk уже присутствует в контейнере
   pos = PrimeNumColl.find(dk);//Поиск dk в контейнере
   if (pos == PrimeNumColl.end()) //Добавляем новое значение dk
    PrimeNumColl.insert(std::make_pair(dk,1));
   else //Увеличиваем кол-во значений dk на единицу
    pos->second = pos->second+1;
   n = q;//Присваиваем n частное от деления n на dk
  }
  else //Остаток от деления r != 0
  {//A6 - Малое частное?
   if (q > dk) //Выбор нового "пробного делителя" dk
   {k++;
    if (k < 4) dk = D[k];
    else
    {dk = (lIncByTwo == true) ? dk+2 : dk+4;
     lIncByTwo = !lIncByTwo;
    }
   }
   else
   {//A7 - n - простое число [закончить алгоритм]
    ++t;
    //Добавляем значение n в контейнер
    pos = PrimeNumColl.find(n);//Поиск n в контейнере
    if (pos == PrimeNumColl.end()) //Добавляем значение n
     PrimeNumColl.insert(std::make_pair(n,1));
    else //Увеличиваем кол-во значений n на единицу
     pos->second = pos->second+1;
    break;//Выход из цикла
   }
  }
 }//Конец цикла
 lPrime = (t > 1) ? false : true;

 return lPrime;
}
//****************************************************************************************
//СТАТУС: 8;  Making Statistical Series
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool StatisticalSeries(const rmatrix& A, rmatrix& Res,
//                      double Left = 0, double Right = 0, ulong Intervals = 10)
//НАЗНАЧЕНИЕ: Построение статистического ряда по данным вещественной матрицы A.
//Ряд формируется в матрице Res, состоящей из 4 столбцов. Первые два столбца определяют
//значения левой и правой границ отрезков ряда - [Xi..Xi+1), третий столбец содержит счетчик
//значений Mi данных A, которые попадают в отрезок [Xi..Xi+1), четвертый столбец содержит
//значение частоты Pi в процентах для отрезка [Xi..Xi+1): Pi = Mi/N, N - число данных матри-
//цы A. Число строк Res будет определятся количеством интервалов Intervals, на которые будет
//разбит отрезок [Left..Right], а также его расположением относительно всего диапазона зна-
//чений [Min..Max] для данных матрицы A, где Min - минимальное, а Max - максимальное значе-
//ния матрицы A. Возможны следующие варианты разбиения статистического ряда на отрезки:
//1. В случае, когда отрезок [Left..Right] не принадлежит интервалу [Min..Max], а также
//   когда значения Left и Right равны между собой, за исходный интервал берется [Min..Max],
//   который разбивается на равные отрезки, определяемые значением Intervals;
//2. В случае когда отрезок [Left..Right] полностью лежит внутри интервала [Min..Max] обра-
//   зуются еще два отрезка [Min..Left) и [Right..Max] произвольной длины, а отрезок [Left..Right]
//   разбивается на подинтервалы равной длины, определяемые значением Intervals;
//Функция возвращает true в случае успешного построения статистического ряда по данным A и
//false - в противном случае. Функция возвращает false в случае матрицы A нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& A - ссылка на вещественную матрицу A, по данным которой строится ряд;
//2. rmatrix& Res - ссылка на результирующую матрицу с характеристиками статистического ряда,
//   построенными для матрицы A;
//3. double Left(0) - левая граница значений ряда, разбиваемая на равные подинтервалы;
//4. double Right(0) - правая граница значений ряда, разбиваемая на равные подинтервалы;
//5. ulong Intervals(10) - число интервалов, на которые разбивается отрезок [Left..Right].
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат построения статистического ряда по
//данным матрицы A.
//****************************************************************************************
bool StatisticalSeries(const rmatrix& A, rmatrix& Res, double Left, double Right,
     ulong Intervals)
{//Объявление переменных
 double dval;
 double delta;
 double Min, Max;
 double N = A.Rows()*A.Cols();//Число элементов матрицы
 bool lIsSmallerLeft = false;
 bool lIsBiggerRight = false;
 ulong Rows;
 ulong FirstIndex, LastIndex;
 ulong index;
 //Проверка значения Intervals на корректность
 if (Intervals == 0) Intervals = 10;

 //Шаг 1. Анализ матрицы A на матрицу нулевого размера - статистический ряд не м.б. построен
 if (N == 0) {Res.Set(0,0,false); return false;}
 //Шаг 2. Определение Min и Max значений матрицы A
 A.MaxMin(Max,Min);
 if (Max == Min) //Все значения матрицы A равные
 {Res.Set(1,4,Min); Res.Put(0,2,N); Res.Put(0,3,100.0); return true;}
 //Шаг 3. Анализ значений Left и Right
 if (Left == Right) {Left = Min; Right = Max;}
 else
 {//Обмен значений Left и Right с целью выполнения условия Right > Left
  if (Left > Right) {dval = Left; Left = Right; Right = dval;}
  //Анализ размещения интервала [Left..Right] на интервале [Min..Max]
  if ((Right <= Min) || (Left >= Max)) // [Left..Right] лежит вне интервала [Min..Max]
  {Left = Min; Right = Max;}
  else //Продолжаем анализ...
  {//Расчет допустимого интервала между Left и Min или Right и Max, когда их можно объединять
   double tol = (Right-Left)/(100.0*Intervals);
   //Имеется интервал левее [Left..Right] => [Min..Left)
   if (Left > Min)
   {if (fabs(Left-Min) < tol) Left = Min;
    else lIsSmallerLeft = true;
   }
   //Имеется интервал правее [Left..Right) => [Right..Max]
   if (Right < Max)
   {if (fabs(Max-Right) < tol) Right = Max;
    else lIsBiggerRight = true;
   }
  }
 }
 //Шаг 4. Определение числа строк матрицы Res
 Rows = Intervals;
 if (lIsSmallerLeft) Rows++;
 if (lIsBiggerRight) Rows++;
 //Создаем матрицу Res необходимой размерности для размещения элементов статистического
 //ряда, строящегося по данным матрицы A
 Res.Set(Rows,4,0.0);
 //Шаг 5. Расчет шага интервала delta и инициализация 1 и 2 столбцов матрицы Res
 delta = (Right-Left)/Intervals;
 if (lIsSmallerLeft) {FirstIndex = 1; Res.Put(0,0,Min); Res.Put(0,1,Left);}
 else FirstIndex = 0;

 if (lIsBiggerRight)
 {LastIndex = Rows-1; Res.Put(LastIndex,0,Right); Res.Put(LastIndex,1,Max);}
 else LastIndex = Rows;
 //Инициализация 1 и 2 столбцов матрицы Res - левая и правая границы отрезков, на которые
 //разбит статистический ряд
 dval = Left;
 for (ulong i = FirstIndex; i < LastIndex; i++)
 {Res.Put(i,0,dval); dval += delta; Res.Put(i,1,dval);}

 //Шаг 6. Подсчет числа значений выборки из матрицы A, попадающих в интервалы, на которые
 //разбит статистический ряд
 ulong y,y1;
 y = wherey();
 cout << "Statistical Series Building..." << endl;
 y1 = wherey();

 for (ulong i = 0; i < A.Rows(); i++)
 {cout << "Row " << (i+1) << " from " << A.Rows();
  for (ulong j = 0; j < A.Cols(); j++)
  {dval = A.Get(i,j);
   if (lIsSmallerLeft && (dval < Left)) Res.Put(0,2,Res.Get(0,2)+1);
   else if (lIsBiggerRight && (dval >= Right)) Res.Put(LastIndex,2,Res.Get(LastIndex,2)+1);
   else if (dval == Right) Res.Put(Rows-1,2,Res.Get(Rows-1,2)+1);
   else //Определение номера подинтервала на отрезке [Left..Right]
   {index = (dval-Left)/delta;//Целая часть от деления
    if (lIsSmallerLeft) index++;
    Res.Put(index,2,Res.Get(index,2)+1);
   }
  }
  ClrScr(1,y1);//Очистка экрана
 }
 ClrScr(1,y);//Очистка экрана
 //Шаг 7. Расчет частоты попадания значений в интервалы, на которые разбит статистический
 //ряд, в процентах.
 for (ulong i = 0; i < Res.Rows(); i++) Res.Put(i,3,(100.0*Res.Get(i,2))/N);
 return true;
}
//****************************************************************************************
//СТАТУС: 9; Calculating Relative Errors and making Statistical Series
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool RelativeError(const rmatrix& S, const rmatrix& X, rmatrix& Res, double Left = 0,
//                    double Right = 0, ulong Intervals = 10);
//НАЗНАЧЕНИЕ: Вычисление относительной погрешности отклонения значений из матрицы X от ве-
//личин из эталонной матрицы S с построением статистического ряда по данным из матрицы RelErr
//в матрице Res (RelErr - матрица значений относительных погрешностей, построенная по данным
//из матриц S и X, с размерностью равной размерности матриц S и X). Относительная погреш-
//ность выражается в процентах и рассчитывается для каждого элемента матрицы X следующим
//образом: RelErr(i,j) = |(S[i,j]-X[i,j])/S[i,j]|*100%.
//Матрица Res описывает статистический ряд матрицы RelErr и состоит из 4-х столбцов.
//Столбцы 1 и 2 определяют левую и правую границы отрезков, на которые разбивается интервал
//всех значений относительной погрешности - [REi..REi+1), столбец 3 содержит счетчик значе-
//ний Mi данных RelErr, принадлежащих [REi..REi+1), столбец 4 содержит значение частоты
//попадания Pi (в %) в [REi..REi+1): Pi = Mi/N, N - число данных матрицы RelErr.
//Число строк Res определяется числом интервалов Intervals, на которые будет разбит отрезок
//[Left..Right], а также его расположением относительно всего диапазона значений относительных
//погрешностей [Min..Max] для данных матрицы RelErr, где Min - минимальное, а Max - макси-
//мальное значения относительных погрешностей.
//Возможны следующие варианты разбиения статистического ряда на отрезки:
//1. В случае, когда отрезок [Left..Right] не принадлежит интервалу [Min..Max], а также
//   когда значения Left и Right равны между собой, за исходный интервал берется [Min..Max],
//   который разбивается на равные отрезки, определяемые значением Intervals;
//2. В случае когда отрезок [Left..Right] полностью лежит внутри интервала [Min..Max] обра-
//   зуются еще два отрезка [Min..Left) и [Right..Max] произвольной длины, а отрезок [Left..Right]
//   разбивается на подинтервалы равной длины, определяемые значением Intervals;
//Функция возвращает true в случае успешного расчета относит-х погрешностей и построения
//статистического ряда по данным матриц S, X и false - в противном случае. Функция возвращает
//false в случае матриц нулевого размера или несовпадения размерностей матриц S и X.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& S - ссылка на эталонную матрицу значений;
//2. const rmatrix& X - ссылка на вещественную матрицу X, для значений которой вычисляется
//   относительная погрешность и строится матрица RelErr;
//3. rmatrix& Res - ссылка на матрицу, содержащую статистический ряд, построенными по матрице
//   отностиельных погрешностей RelErr;
//4. double Left(0) - левая граница значений ряда, разбиваемая на равные подинтервалы;
//5. double Right(0) - правая граница значений ряда, разбиваемая на равные подинтервалы;
//6. ulong Intervals(10) - число интервалов, на которые разбивается отрезок [Left..Right].
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат вычисления построения статистического
//ряда по данным матрицы RelErr.
//****************************************************************************************
bool RelativeError(const rmatrix& S, const rmatrix& X, rmatrix& Res, double Left,
                   double Right, ulong Intervals)
{//Объявление переменных
 rmatrix RelErr;//Матрица значений относительных дисперсий
 double dval;
 //Проверка на возможность проведения вычислений
 if (X.IsZeroSize() || S.IsZeroSize()) {Res.Set(0,0,false); return false;}
 if (!IsEqualSize(S,X)) {Res.Set(0,0,false); return false;}
 //Расчет матрицы относительных погрешностей RelErr
 RelErr.Set(S.Rows(),S.Cols(),0.0);
 if (RelErr.IsZeroSize()) {Res.Set(0,0,false); return false;}
 //Цикл расчета относительных погрешностей значений матрицы X относительно значений S,
 //выраженную в процентах
 for (ulong i = 0L; i < RelErr.Rows(); i++)
  for (ulong j = 0L; j < RelErr.Cols(); j++)
  {dval = fabs((S.Get(i,j)-X.Get(i,j))/S.Get(i,j));
   dval = dval*100.0;
   RelErr.Put(i,j,dval);
  }
 //Проверка значений Left, Right и Interval на корректность
 if (Intervals == 0) Intervals = 10;
 if (Left < 0) Left = 0;
 if (Right <= 0) Right = 100;
 if (Left > Right) {dval = Left; Left = Right; Right = dval;}
 //Построение статистического ряда по данным RelErr в матрице Res
 return StatisticalSeries(RelErr,Res,Left,Right,Intervals);
}


