//Parsing.cpp
//Copyright (c) JohnSoft 2001-2005. All rights reserved. Borland C++ 5.02, C++ Builder 6
//Initial date: October,2,2001. Final date:
//Реализация классов синтаксического анализа / грамматического разбора
#include "parsing.h"

const char Digit[] = "0123456789";
const char Sign[]  = "-+";
const char Space[] = " \t";
const char DecPoint[] = ".";
const char Exp[]   = "eE";

//****************************************************************************************
//Функция возвращает указатель на первый символ в строке s, которого нет в строке symbols.
//Если символов отличных от символов строки symbols не найдено, то функция возвращает
//указатель на символ завершения строки '\0'.
//****************************************************************************************
const char* SkipSymbols(const char* s, const char* symbols)
{if (s == NULL) return NULL;
 const char* pStr = s;
 if (symbols == NULL) return pStr;
 while ((*pStr != '\0') && (strchr(symbols,*pStr))) pStr++;
 return pStr;
}
//****************************************************************************************
//Импорт из строки s аргумента типа double с предшествующим ему обязательным идентификато-
//ром из набора IdentColl и символом-разделителем из строки Sep. Синтаксис разбора:
//<IDENT>[ws]<SEP>[ws]<DOUBLE_VALUE>
//Функция возвращает true при успешном считывании аргумента типа double из строки s с задан-
//ным идентификатором, значение вещественного числа передается через аргумент value. В слу-
//чае отсутствия имени идентификатора в строке s или коллекции IdentColl, неудачного разбора
//функция возвращает false и переменной value присваивается 0.
//****************************************************************************************
bool ImportDoubleArg(double& value, const char* s, const StringSet& IdentColl, const char* Sep)
{value = 0.0;
 //Проверка на возможность синтаксического разбора
 if (s == NULL || strlen(s) == 0 || IdentColl.empty()) return false;
 //Подготовка к синтаксическому разбору
 if (Sep == NULL) Sep = ":=";
 char ws[] = " \t";//Пробельные символы
 const char* p = NULL;//Индикатор обнаружения лексемы в строке s
 StringSet::const_iterator pos = IdentColl.begin();
 //--------------------------------------------------------------------------------------
 //Поиск идентификатора вещественного числа в строке s по именам из коллекции IdentColl
 while(pos != IdentColl.end())
 {p = strstr(s,pos->c_str());
  if (p != NULL)
  {p += strlen(pos->c_str());
   break;//Идентификатор найден
  }
  ++pos;
 }
 if (p == NULL) return false;
 //--------------------------------------------------------------------------------------
 //Поиск символа-разделителя с пропуском пробельных символов в строке Sep
 const char* ptr = NULL;
 while (*p != '\0')
 {if ((*p == ws[0]) || (*p == ws[1])) ++p;//Пробельный символ
  else {ptr = strchr(Sep,*p); ++p; break;}//Поиск символа-разделителя в строке Sep
 }
 if ((ptr == NULL) || (*p == '\0')) return false;
 //--------------------------------------------------------------------------------------
 //Извлечение вещественного числа из строки s с позиции p
 TStrToDouble stod;
 ulong offset;
 bool lSuccess = stod(p,offset,value);
 if (!lSuccess) value = 0.0;
 return lSuccess;
}

//****************************************************************************************
//Импорт из строки имени файла, заключенного между маркерами с игнорированием начальных
//и конечных пробельных символов. Формат: [ws]<StartMarker>[ws]<FileName>[ws]<EndMarker>.
//В случае безошибочного разбора имя файла записывается в строку fname и возвращается true
//Запрещенные символы: "/\\:*?\"<>|"
//****************************************************************************************
bool ImportFileName(string& fname, const char* s, char StartMarker, char EndMarker)
{char IllegalChars[] = "/*?<>|";//Запрещенные символы в имени файла
 char ws[] = " \t";
 const char* p;

 fname.clear();//Очистка строки
 //Пропускаем начальные пробельные символы перед StartMarker
 p = SkipSymbols(s,ws);
 if (*p == StartMarker) //После пробелов должен следовать МАРКЕР НАЧАЛА
 {p = SkipSymbols(++p,ws);
  if (p == NULL) return false;
  //Поиск МАРКЕРА КОНЦА
  s = strchr(p,EndMarker);
  if (s == NULL) return false;//МАРКЕР КОНЦА не найден
  const char* temp = s;
  //Пропускаем конечные пробельные символы
  --temp;
  while (temp != p)
  {if (strchr(ws,*temp)) --temp;//Пробельный символ найден
   else break;
  }

  //Извлекаем имя файла, заключенное между двух маркеров
  while (p <= temp)
  {//Проверка символа на принадлежность к запрещенным символам
   if (strchr(IllegalChars,*p)) {fname.clear(); break;}
   fname.append(1,*p);
   ++p;
  }
 }
 return !fname.empty();
}


//****************************************************************************************
//                             РЕАЛИЗАЦИЯ КЛАССА TLongValsToStr
//Преобразование последовательности целых чисел в их строковое представление с распознава-
//нием цепочек, образующих арифметическую прогрессию, и представлением их в строковом виде
//как интервалов вида: [begin, begin+d .. end].
//****************************************************************************************

//========================================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TLongValsToStr
//   PUBLIC MEMBER-FUNCTION OF TLongValsToStr CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; TLongValsToStr public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Start()
//НАЗНАЧЕНИЕ: Установка объекта класса в начальное состояние WAIT. В данном состоянии все
//внутренние параметры объекта обнуляются. Объект находится в состоянии готовности к приему
//и обработке очередной последовательности целых чисел. Предыдущие результаты работы унич-
//тожаются.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TLongValsToStr::Start()
{_State = WAIT;//Номер текущего состояния
 _Buf.clear();//Строка с результатами преобразования
 _Count = 0L;//Число целых чисел, переданных классу
 _Intervals = 0L;//Количество обнаруженных интервалов
 _Vals_in_Interval = 0L;//Количество чисел в текущем интервале
 _begin = 0;//Начальное значение интервала
 _end = 0;//Конечное значение интервала
 _d = 0;//Приращение в текущей арифметической прогрессии
}
//****************************************************************************************
//СТАТУС: I.2; TLongValsToStr public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong Stop()
//НАЗНАЧЕНИЕ: Установка объекта класса в конечное состояние IDLE. В данном состоянии все
//внутренние параметры объекта сохраняются и пользователь может считать их значения. Авто-
//мат в этом состоянии прекращает дальнейшую обработку новых чисел и завершает формирование
//результирующей строки. При нахождении автомата в состоянии WAIT перевод в состояние IDLE
//игнорируется. Функция возвращает число обработанных чисел с момента установки последнего
//состояния WAIT.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong Count - число обработанных классом целых чисел
//****************************************************************************************
ulong TLongValsToStr::Stop()
{if (_State == WAIT) return this->GetValCount();
 //Завершение формирования результирующей строки в зависимости от текущего состояния
 //конечного автомата
 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 //if (this->GetValCount()) _Buf.append(1,' ');
 if (!_Buf.empty() && this->GetValCount()) _Buf.append(1,' ');

 if (_State == FIRST) text << _begin << ends;

 else if (_State == SECOND) text << _begin << ' ' << _end << ends;

 else if (_State == INTERVAL)
 {if (_d == 1) text << '[' << _begin << " .. " << _end << ']' << ends;
  else text << '[' << _begin << ", " << (_begin + _d) << " .. " << _end << ']' << ends;
 }
 _Buf.append(text.str()); text.seekp(0);

 //Переход в состояние IDLE
 _State = IDLE;
 return this->GetValCount();
}
//****************************************************************************************
//СТАТУС: I.3; TLongValsToStr public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Add(long value)
//НАЗНАЧЕНИЕ: Передача очередного целого числа на вход автомата для его последующого преоб-
//разования в зависимости от текущего состояния объекта класса и значения value. В состоя-
//нии IDLE автомат больше не обрабатывает числа и функция возвращает false, в остальных
//состояниях функция возвращает true. Данная функция является основной функцией объекта.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: long value - очередное число передаваемое автомату на обработку
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат обработки очередного числа автоматом
//****************************************************************************************
bool TLongValsToStr::Add(long value)
{if (_State == IDLE) return false;//Игнорируем число
 //Обработка числа value в зависимости от состояния автомата
 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));

 if (_State == WAIT)
 {this->_begin = value;
  _State = FIRST;
 }
 else if (_State == FIRST)
 {_d = value - _begin;
  if (_d == 0)
  {if (this->GetValCount()) _Buf.append(1,' ');
   text << value << ends;
   _Buf.append(text.str()); text.seekp(0);
  }
  else {_end = value; _State = SECOND;}
 }
 else if (_State == SECOND)
 {if (value - _end == _d) {_end = value; _State = INTERVAL; _Vals_in_Interval = 3;}
  else
  {if (this->GetValCount()) _Buf.append(1,' ');
   text << _begin << ends;
   _Buf.append(text.str()); text.seekp(0);
   _begin = _end; _end = value; _d = _end - _begin;
   if (_d == 0) //Числа равные
   {text << ' ' << _end << ends;
    _Buf.append(text.str()); text.seekp(0);
    _end = 0;  _State = FIRST;
   }
  }
 }
 else if (_State == INTERVAL)
 {if (value - _end == _d) {_Vals_in_Interval++; _end = value;}
  else //Формируем строковое представление интервала
  {if (!_Buf.empty() && this->GetValCount()) _Buf.append(1,' ');
   if (_d == 1)
    text << '[' << _begin << " .. " << _end << ']' << ends;
   else
    text << '[' << _begin << ", " << (_begin + _d) << " .. " << _end << ']' << ends;
   _Buf.append(text.str()); text.seekp(0);
   _Intervals++;//Увеличиваем счетчик интервалов
   //Переходим в состояние FIRST
   _begin = value; _Vals_in_Interval = 0; _end = 0; _d = 0; _State = FIRST;
  }
 }

 //Увеличение счетчика обработанных значений
 this->_Count++;
 return true;
}

//****************************************************************************************
// РЕАЛИЗАЦИЯ КЛАССА TStrToDoubleArgs - ИЗВЛЕЧЕНИЕ ИЗ СТРОКИ СПИСКА(ОВ) АРГУМЕНТОВ из
// ВЕЩЕСТВЕННЫХ ЧИСЕЛ, ЗАКЛЮЧЕННЫХ В СКОБКИ
//****************************************************************************************

//========================================================================================
//  РЕАЛИЗАЦИЯ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TStrToDoubleArgs
//  TStrToDoubleArgs CLASS CONSTRUCTORs & DESTRUCTOR REALIZATION
//========================================================================================
//****************************************************************************************
//СТАТУС: 1; public TStrToDoubleArgs constructor by default
//НАИМЕНОВАНИЕ ФУНКЦИИ: TStrToDoubleArgs()
//НАЗНАЧЕНИЕ: Конструктор по умолчанию класса TStrToDoubleArgs создает объект класса по
//умолчанию: LBR: '(', RBR: ')', DELIM: ',', WS: " \t\n"
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
TStrToDoubleArgs::TStrToDoubleArgs()
{Init();
 SetTables();
 SetWS(" \t\n");
}
//****************************************************************************************
//СТАТУС: 2; public TStrToDoubleArgs constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TStrToDoubleArgs(char LBr, char RBr, char Delim, const char* ws)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TStrToDoubleArgs создает объект класса с
//установкой LBR, RBR, DELIM и WS.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. char LBr - символ левой скобки;
//2. char RBr - символ правой скобки;
//3. char Delim - символ-разделитель соседних чисел;
//4. const char* ws - указатель на строку с допустимыми пробельными символами.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
TStrToDoubleArgs::TStrToDoubleArgs(char LBr, char RBr, char Delim, const char* ws)
{Init();
 SetTables();
 //Установка символов для LBR, RBR, DELIM и WS
 SetBeginMarker(LBr); SetEndMarker(RBr); SetDelim(Delim); SetWS(ws);
}

//========================================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TStrToDoubleArgs
//   PUBLIC MEMBER-FUNCTION OF TStrToDouble CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; TStrToDoubleArgs public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetStandByMode(bool lClear = true)
//НАЗНАЧЕНИЕ: Установка класса в режим "ОЖИДАНИЕ" (SleepMode, WaitingMode).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//bool lClear (true) - опция очистки списков аргументов, извлеченных из строк ранее
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TStrToDoubleArgs::SetStandByMode(bool lClear)
{pStr = NULL;//указатель на начало строки
 pCur = NULL;//указатель на текущий обрабатываемый символ

 TokenClass = tOther;//класс литеры (символа)
 TokenValue = 0;     //значение (идентификатор) литеры в классе

 lIdentLBr = true;//опция распознавания маркера начала списка (левой скобки)
 lIdentNumber = false;//опция распознавания вещественных чисел
 lIdentDelim = false;//опция распознавания символа-разделителя между двумя числами
 lIdentRBr = false;//опция распознавания маркера конца списка (правой скобки)

 State = StandByMode;//текущее состояния - режим ожидания
 MsgNumber = 0;//порядковый номер сообщения состояния объекта класса

 if (lClear) ClearList();//Очистка списков вещ-х чисел (аргументов), извлеченных ранее
}
//****************************************************************************************
//СТАТУС: I.2; TStrToDoubleArgs public member-function
//OVERLOAD OPERATOR of CALL FUNCTION
//НАИМЕНОВАНИЕ ФУНКЦИИ: long operator ()(const char* s, ulong& pos, bool lClear = true)
//НАЗНАЧЕНИЕ: Функция извлекает из строки s, начиная с позиции pos от ее начала, список
//аргументов вещественных чисел, заключенных в скобки, сохраняет их в конце списка Data и
//записывает в конец списка Info кол-во извлеченных аргументов (в случае отсутствия ошибок
//в строке). При наличии синтаксических ошибок в строке, а также при отсутствии аргументов,
//заключенных в скобки, функция возвращает -1. При успешном обнаружении и извлечении чисел,
//заключенных в скобки, функция возвращает кол-во извлеченных вещ-х чисел. В переменную pos,
//передаваемую по ссылке, по окончании работы функция вернет позицию символа от начала
//строки, на котором она завершила свою работу (tOther, tWS, tEOS).
//Строка s, передаваемая в функцию, в ходе ее работы не изменяется. Опция lClear позволяет
//удалять или сохранять ранее извлеченные списки аргументов, заключенных в скобках. При
//lClear = true результаты предыдущих сессий не сохраняются.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const char* s - константный указатель на анализируемую строку s;
//2. ulong& pos - ссылка на позицию в строке s, с которой начинается работа функции;
//3. bool lClear - опция сохранения/уничтожения списков чисел, считанных ранее.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//long Count - количество вещественных чисел, извлеченных из строки s, в данной сессии
//****************************************************************************************
long TStrToDoubleArgs::operator ()(const char* s, ulong& pos, bool lClear)
{SetStandByMode();//Начальная установка всех параметров объекта
 if (lClear) ClearList();//Очистка списков вещ-х чисел, извлеченных ранее
 long Count = -1L;
 if ((s != NULL) && (sizeof(s) > pos))
 {pStr = pCur = s+pos;//Получение указателя на строку s
  Count = Extract();//Извлечение из строки вещественных чисел
  pos = pCur - pStr;
 }
 return Count;//Количество извлеченных из строки вещественных чисел за данную сессию
}
//****************************************************************************************
//СТАТУС: I.3; TStrToDoubleArgs public member-function
//OVERLOAD OPERATOR of CALL FUNCTION
//НАИМЕНОВАНИЕ ФУНКЦИИ: long operator ()(const char* s, bool lClear = true)
//НАЗНАЧЕНИЕ: Функция извлекает из строки s ВСЕ списки аргументов вещественных чисел, зак-
//люченных в скобки, сохраняет их в списке Data и записывает в список Info кол-во извлечен-
//ных аргументов (в случае отсутствия ошибок в строке) по каждому списку.
//При отсутствии в строке s аргументов, заключенных в скобки, функция возвращает 0. При
//обнаружении синтаксических ошибок в s, разбор строки прекращается и функция возвращает
//количество списков, извлеченных из строки без ошибок.
//При успешном обнаружении и извлечении списков чисел, заключенных в скобки, возвращается
//кол-во извлеченных списков из строки s.
//Строка s, передаваемая в функцию, в ходе ее работы не изменяется. Опция lClear позволяет
//удалять или сохранять ранее извлеченные списки аргументов, заключенных в скобках. При
//lClear = true результаты предыдущих сессий не сохраняются.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const char* s - константный указатель на анализируемую строку s;
//2. bool lClear - опция сохранения/уничтожения списков чисел, считанных ранее.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//long Count - количество списков вещ-х чисел, извлеченных из строки s, в данной сессии
//****************************************************************************************
long TStrToDoubleArgs::operator ()(const char* s, bool lClear)
{SetStandByMode(); //Начальная установка всех параметров объекта
 if (lClear) ClearList();//Очистка списка вещественных чисел, извлеченных ранее
 long PrevSeries = Series();//Кол-во списков, извлеченных ранее
 if (s != NULL)
 {bool lProceed;
  pStr = pCur = s;//Получение указателя на строку s
  do
  {Extract();//Извлечение вещественных чисел, заключенных между скобками
   lProceed = (IsError() || IsEOS()) ? false : true;
  } while (lProceed);
 }
 return Series()-PrevSeries;//Количество списков вещ-х чисел, считанных из строки s
}
//****************************************************************************************
//СТАТУС: I.4;  TStrToDoubleArgs public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: long GetAllChains(rvector& V) const
//НАЗНАЧЕНИЕ: Функция передает в вектор V типа TRealVector, передаваемый по ссылке все ве-
//щественные числа, которые хранятся в объекте класса TStrToDoubleArgs.
//Функция изменяет размер и данные вектора V и возвращает вектор V нулевого размера, если
//список пустой. Функция возвращает размерность вектора V после операции присваивания.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//TRealVector& V - ссылка на вектор, в который помещаются числа из TStrToDoubleArgs
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: long szVector - размер вектора V после операции присваивания
//****************************************************************************************
long TStrToDoubleArgs::GetAllChains(rvector& V) const
{//Создаем вектор V одинакового с Data размера
 V.Resize(TotalCount());
 if (!V.IsZeroSize())//Копирование вещественных чисел из TStrToDoubleArgs в V
 {list<double>::const_iterator p = Data.begin();
  for (ulong i = 0L; i < V.Size(); i++) {V.Put(i,*p); ++p;}
 }
 return V.Size();
}
//****************************************************************************************
//СТАТУС: I.5;  TStrToDoubleArgs public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: long GetLastChain(rvector& V) const
//НАЗНАЧЕНИЕ: Функция присваивает вектору V типа TRealVector, передаваемому по ссылке,
//последний извлеченный список вещ-х чисел, который хранится в Data.
//Функция возвращает -1, если список Data пустой, в противном случае возвращается кол-во
//вещ-х чисел, составляющих последний список (от нуля и выше). Функция изменяет вектора V
//и возвращает вектор V нулевого размера, если список аргументов пустой или Data пустой.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//TRealVector& V - ссылка на вектор, в который помещается последний извлеченный список
//вещ-х чисел, заключенных в скобки
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//long result - результат присваивания -1 (данных нет) или размерность V
//****************************************************************************************
long TStrToDoubleArgs::GetLastChain(rvector& V) const
{long result = -1L;
 if (TotalCount() > 0) //Проверка списка Data
 {//Устанавливаем размер V равным размеру последнего списка вещ-х чисел
  result = Info.back();
  V.Resize(result);
  if (!V.IsZeroSize())//Копирование последнего списка вещ-х чисел в вектор V
  {list<double>::const_reverse_iterator p = Data.rbegin();
   for (ulong i = V.Size()-1; i <= 0; i--) {V.Put(i,*p); ++p;}
  }
 }
 else V.Resize(0L);
 return result;
}
//****************************************************************************************
//СТАТУС: I.6;  TStrToDoubleArgs public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: long GetFirstChain(rvector& V) const
//НАЗНАЧЕНИЕ: Функция присваивает вектору V типа TRealVector, передаваемому по ссылке,
//первый извлеченный список вещ-х чисел, который хранится в Data.
//Функция возвращает -1, если список Data пустой, в противном случае возвращается кол-во
//вещ-х чисел, составляющих первый список (от нуля и выше). Функция изменяет вектора V
//и возвращает вектор V нулевого размера, если список аргументов пустой или Data пустой.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//TRealVector& V - ссылка на вектор, в который помещается первый извлеченный список вещ-х
//чисел, заключенных в скобки
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//long result - результат присваивания -1 (данных нет) или размерность V
//****************************************************************************************
long TStrToDoubleArgs::GetFirstChain(rvector& V) const
{long result = -1L;
 if (TotalCount() > 0) //Проверка списка Data
 {//Устанавливаем размер V равным размеру последнего списка вещ-х чисел
  result = Info.front();
  V.Resize(result);
  if (!V.IsZeroSize())//Копирование последнего списка вещ-х чисел в вектор V
  {list<double>::const_iterator p = Data.begin();
   for (ulong i = 0; i < V.Size(); i++) {V.Put(i,*p); ++p;}
  }
 }
 else V.Resize(0L);
 return result;
}
//****************************************************************************************
//СТАТУС: I.7;  TStrToDoubleArgs public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: long GetAllChains(list<double>& d_list, long arg_num) const
//НАЗНАЧЕНИЕ: Функция передает в список d_list, передаваемый по ссылке, все значения спис-
//ков аргументов вещественных чисел с числом аргументов в списке равном arg_num, которые
//хранятся в объекте класса TStrToDoubleArgs.
//Функция изменяет размер и данные списка d_list, предварительно опустошая его, и возвра-
//щает количество списков аргументов с длиной arg_num. При arg_num == 0 функция просто
//подсчитывает кол-во списков без аргументов, предварительно очищая список d_list.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//list<double>& d_list - ссылка на контейнер, в который помещаются аргументы из списков
// с числом аргументов arg_num;
//long arg_num - число аргументов в списке (критерий отбора списков аргументов)
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: long list_num - кол-во списков с длиной равной arg_num
//****************************************************************************************
long TStrToDoubleArgs::GetAllChains(list<double>& d_list, long arg_num) const
{int list_num = 0;
 d_list.clear();//Очищаем список
 list<int>::const_iterator pInfo = Info.begin();
 list<double>::const_iterator pData = Data.begin();

 while (pInfo != Info.end())
 {if (*pInfo == arg_num)
  {for (long i = 0; i < arg_num; i++) d_list.push_back(*pData++);
   list_num++;
  }
  else for (long i = 0; i < *pInfo; i++) ++pData;
  ++pInfo;
 }
 return list_num;
}


//========================================================================================
//II. РЕАЛИЗАЦИЯ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TStrToDoubleArgs
//    PRIVATE MEMBER-FUNCTION OF TStrToDoubleArgs CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: II.1; TStrToDoubleArgs private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Init()
//НАЗНАЧЕНИЕ: Начальная установка свойств класса.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TStrToDoubleArgs::Init()
{MsgTable.clear();//очистка списка сообщений о состояниях объекта
 ModeTitles.clear();//очистка списка названий состояний объекта

 SetBeginMarker('(');//Установка маркера начала списка аргументов - левая скобка
 SetEndMarker(')');//Установка маркера конца списка аргументов - правая скобка
 SetDelim(',');//Установка символа-разделителя соседних чисел
 sWS.clear();//Очистка списка пробельных символов

 //Установка объекта в режим "ОЖИДАНИЕ" с очисткой списков Data & Info
 SetStandByMode(true);
}
//****************************************************************************************
//СТАТУС: II.2; TStrToDoubleArgs private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void ClearList()
//НАЗНАЧЕНИЕ: Очистка списков со списками вещественных аргументов в скобках Data и Info -
//количество аргументов в каждом из извлеченных из строк(и) списков.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TStrToDoubleArgs::ClearList() {Data.clear(); Info.clear();}
//****************************************************************************************
//СТАТУС: II.3; TStrToDoubleArgs private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetTables()
//НАЗНАЧЕНИЕ:Создание таблицы указателей на функции-обработчики состояний класса, таблиц
//наименований состояний объекта и строковых сообщений
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TStrToDoubleArgs::SetTables()
{//---------------------------------------------------------------------------------------
 //Установка указателей на функции-обработчики состояний
 Table[IdleMode]   = &TStrToDoubleArgs::HndlIdleMode;  //0
 Table[LBrMode]    = &TStrToDoubleArgs::HndlLBrMode;   //1
 Table[NumberMode] = &TStrToDoubleArgs::HndlNumberMode;//2
 Table[DelimMode]  = &TStrToDoubleArgs::HndlDelimMode; //3
 Table[RBrMode]    = &TStrToDoubleArgs::HndlRBrMode;   //4
 //---------------------------------------------------------------------------------------
 //Создание таблицы наименований состояний объекта класса
 ModeTitles.push_back("State:<IDLE>");
 ModeTitles.push_back("State:<LEFT BRACKET>");
 ModeTitles.push_back("State:<NUMBER>");
 ModeTitles.push_back("State:<DELIMETER>");
 ModeTitles.push_back("State:<RIGHT BRACKET>");
 ModeTitles.push_back("State:<ERROR>");
 ModeTitles.push_back("State:<STANDBY>");
 //---------------------------------------------------------------------------------------
 //Создание таблицы строковых сообщений
 MsgTable.push_back("Ready to begin.");//MsgNumber = 0
 MsgTable.push_back("Ready to proceed.");//MsgNumber = 1
 MsgTable.push_back("Success: Reached End-Of-List Marker.");//MsgNumber = 2
 MsgTable.push_back("Failure: Reached EOS Marker. Real args not found.");//MsgNumber = 3
 MsgTable.push_back("Error: Found EOS after L_BR. Expected R_BR or NUMBER.");//MsgNumber = 4
 //MsgNumber = 5 (for ErrorMode)
 MsgTable.push_back("Found illegal char. Expected L_BR");
 //MsgNumber = 6 (for ErrorMode)
 MsgTable.push_back("Found illegal char. Expected NUMBER or R_BR.");
 //MsgNumber = 7 (for ErrorMode)
 MsgTable.push_back("Found illegal char. Expected DELIM or R_BR.");
 //MsgNumber = 8 (for ErrorMode)
 MsgTable.push_back("Found EOS after NUMBER. Expected DELIM or R_BR");
 //MsgNumber = 9 (for ErrorMode)
 MsgTable.push_back("Found EOS after DELIM. Expected NUMBER");
 //MsgNumber = 10 (for ErrorMode)
 MsgTable.push_back("Found illegal char after DELIM. Expected NUMBER");

}
//****************************************************************************************
//СТАТУС: II.4; TStrToDoubleArgs private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetIdleMode()
//НАЗНАЧЕНИЕ: Установка класса в режим "НАЧАЛЬНОЕ СОСТОЯНИЕ" (IdleMode).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TStrToDoubleArgs::SetIdleMode()
{TokenClass = tOther;//класс литеры (символа)
 TokenValue = 0;     //значение (идентификатор) литеры в классе

 lIdentLBr = true;//опция распознавания маркера начала списка (левой скобки)
 lIdentNumber = false;//опция распознавания вещественных чисел
 lIdentDelim = false;//опция распознавания символа-разделителя между двумя числами
 lIdentRBr = false;//опция распознавания маркера конца списка (правой скобки)

 State = IdleMode;//текущее состояния - начальное состояние
 MsgNumber = 0;//порядковый номер сообщения состояния объекта класса
}
//****************************************************************************************
//СТАТУС: II.5; TStrToDoubleArgs private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: long Extract()
//НАЗНАЧЕНИЕ: Функция извлекает из строки ОДИН список вещественных чисел, заключенных в
//скобки и переводит их в двоичное представление типа double. Функция возвращает количество
//чисел, извлеченных из строки, за текущую сессию. Если в строке скобок не обнаружено или
//произошла синтаксическая ошибка при разборе строки, то функция возвращает -1. Кроме того,
//в случае ошибки при считывании извлеченные числа удаляются из списка Data. При обнаруже-
//нии скобок (левой и правой) функция возвращает кол-во извлеченных между ними вещ-х чисел.
//Допускаются пустые скобки - отсутствие аргументов между ними, в этом случае функция возв-
//ратит 0.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//long Count - количество чисел в скобках, извлеченных из строки за текущую сессию
//****************************************************************************************
long TStrToDoubleArgs::Extract()
{long Count = TotalCount();//Определение кол-ва чисел хранящихся в списке
 SetIdleMode();//Установка начального состояния системы
 do //Цикл извлечения из строки вещественных чисел
 {LexicalBlock();
 } while ((this->*Table[State])());
 //Анализ состояния класса после разбора
 if (GetMode() == IdleMode) Count = -1;
 else
 {Count = TotalCount()-Count;//Количество чисел, извлеченных из строки за текущую сессию
  if (GetMode() == ErrorMode) //Success !!!
  {while (Count-- > 0) Data.pop_back();//Удаление извлеченных вещ-х чисел из Data
   Count = -1;
  }
  else if (GetMode() == RBrMode) //Success !!!
   Info.push_back(Count);//Заносим кол-во считанных в скобках вещ-х аргументов
 }
 return Count;
}
//****************************************************************************************
//СТАТУС: II.6; TStrToDoubleArgs private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void LexicalBlock()
//НАЗНАЧЕНИЕ: Лексический анализ символов, поступающих на вход системы распознавания и
//преобразования строки числа типа double. Функция классифицирует входные символы, ставя им
//в соответствие КЛАСС (TokenClass) и значение в классе (TokenValue). Значения членов-данных
//класса TokenClass и TokenValue используют для дальнейшего извлечения из потока символов
//чисел или для завершения процесса преобразования.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TStrToDoubleArgs::LexicalBlock()
{//Проверка на символ конца строки - EOS (End-Of-String)
 if (*pCur == '\0') {TokenClass = tEOS; TokenValue = 0; return;}
 //Проверка на принадлежность классу <BEGINMARKER CLASS> - LEFT BRACKET
 if (lIdentLBr)
 {if (*pCur == cLBr)
  {TokenClass = tBeginMarker;
   TokenValue = 0;
   return;
  }
 }
 //Проверка на наличие в строке вещественного числа и его извлечение <NUMBER CLASS>
 if (lIdentNumber)
 {ulong pos = 0L;
  if (stod(pCur,pos))
  {pCur+=pos;
   TokenClass = tNumber;
   TokenValue = stod.IsInteger() ? 1 : 0;
   return;
  }
 }
 //Проверка на принадлежность классу <DELIMETER CLASS>
 if (lIdentDelim)
 {if (*pCur == cDelimeter)
  {TokenClass = tDelim;
   TokenValue = 0;
   return;
  }
 }
 //Проверка на принадлежность классу <ENDMARKER CLASS> - RIGHT BRACKET
 if (lIdentRBr)
 {if (*pCur == cRBr)
  {TokenClass = tEndMarker;
   TokenValue = 0;
   return;
  }
 }
 //Проверка на принадлежность классу <WHITESPACE CLASS>
 long pos = sWS.find(*pCur);
 if (pos != string::npos)
 {TokenClass = tWS;
  TokenValue = pos;
  return;
 }
 //Лексический блок не смог распознать текущий символ
 TokenClass = tOther; TokenValue = 0;
}
//****************************************************************************************
//СТАТУС: II.7; TStrToDoubleArgs private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlIdleMode()
//НАЗНАЧЕНИЕ: Обработчик состояния IdleMode - "НАЧАЛЬНОЕ СОСТОЯНИЕ". Функция возвращает
//true в случае возможности продолжения извлечения из строки вещественных чисел и false -
//в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//****************************************************************************************
bool TStrToDoubleArgs::HndlIdleMode()
{bool lProceed;
 //Синтаксический анализ: Текущее СОСТОЯНИЕ - Входная ЛЕКСЕМА
 if (TokenClass == tWS) //Лексема принадлежит классу WHITESPACE
 {MsgNumber = 1;
  pCur++;
  lProceed = true;
 }
 else if (TokenClass == tBeginMarker) //Лексема принадлежит классу BEGIN MARKER
 {MsgNumber = 1;
  pCur++;
  State = LBrMode;//Устанавливаем новое состояние - "BEGIN MARKER"
  //Установка опций распознавания классов лексем
  lIdentLBr = false;//опция распознавания маркера начала списка (левой скобки)
  lIdentNumber = true;//опция распознавания вещественных чисел
  lIdentDelim = false;//опция распознавания символа-разделителя между двумя числами
  lIdentRBr = true;//опция распознавания маркера конца списка (правой скобки)

  lProceed = true;
 }
 else if (TokenClass == tEOS) //Лексема принадлежит классу EOS (End-Of-String)
 {MsgNumber = 3;
  lProceed = false;
 }
 else if (TokenClass == tOther) //Лексема не распознана <OTHER CLASS>
 {MsgNumber = 5;
  State = ErrorMode;//Устанавливаем новое состояние - "ERROR"
  lProceed = false;
 }
 return lProceed;
}
//****************************************************************************************
//СТАТУС: II.8; TStrToDoubleArgs private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlLBrMode()
//НАЗНАЧЕНИЕ: Обработчик состояния LBrMode - "МАРКЕР НАЧАЛА СПИСКА". Функция возвращает
//true в случае возможности продолжения извлечения из строки вещественных чисел и false -
//в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//****************************************************************************************
bool TStrToDoubleArgs::HndlLBrMode()
{bool lProceed;
 //Синтаксический анализ: Текущее СОСТОЯНИЕ - Входная ЛЕКСЕМА
 if (TokenClass == tWS) //Лексема принадлежит классу WHITESPACE
 {MsgNumber = 1;
  pCur++;
  lProceed = true;
 }
 else if (TokenClass == tNumber) //Лексема принадлежит классу NUMBER
 {MsgNumber = 1;
  State = NumberMode;//Устанавливаем новое состояние - "NUMBER"
  Data.push_back(stod.GetValue());//Добавляем вещественное число в список
  //Установка опций распознавания классов лексем
  lIdentLBr = false;//опция распознавания маркера начала списка (левой скобки)
  lIdentNumber = false;//опция распознавания вещественных чисел
  lIdentDelim = true;//опция распознавания символа-разделителя между двумя числами
  lIdentRBr = true;//опция распознавания маркера конца списка (правой скобки)

  lProceed = true;
 }
 else if (TokenClass == tEndMarker) //Лексема принадлежит классу END MARKER
 {MsgNumber = 1;
  pCur++;
  State = RBrMode;//Устанавливаем новое состояние - "END MARKER"
  //Установка опций распознавания классов лексем
  lIdentLBr = false;//опция распознавания маркера начала списка (левой скобки)
  lIdentNumber = false;//опция распознавания вещественных чисел
  lIdentDelim = false;//опция распознавания символа-разделителя между двумя числами
  lIdentRBr = false;//опция распознавания маркера конца списка (правой скобки)

  lProceed = true;
 }
 else if (TokenClass == tEOS) //Лексема принадлежит классу EOS (End-Of-String)
 {MsgNumber = 4;
  State = ErrorMode;//Устанавливаем новое состояние - "ERROR"
  lProceed = false;
 }
 else if (TokenClass == tOther) //Лексема не распознана <OTHER CLASS>
 {MsgNumber = 6;
  State = ErrorMode;//Устанавливаем новое состояние - "ERROR"
  lProceed = false;
 }
 return lProceed;
}
//****************************************************************************************
//СТАТУС: II.9; TStrToDoubleArgs private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlNumberMode()
//НАЗНАЧЕНИЕ: Обработчик состояния NumberMode - "ВЕЩЕСТВЕННОЕ ЧИСЛО". Функция возвращает
//true в случае возможности продолжения извлечения из строки вещественных чисел и false -
//в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//****************************************************************************************
bool TStrToDoubleArgs::HndlNumberMode()
{bool lProceed;
 //Синтаксический анализ: Текущее СОСТОЯНИЕ - Входная ЛЕКСЕМА
 if (TokenClass == tWS) //Лексема принадлежит классу WHITESPACE
 {MsgNumber = 1;
  pCur++;
  lProceed = true;
 }
 else if (TokenClass == tDelim) //Лексема принадлежит классу DELIMETER
 {MsgNumber = 1;
  pCur++;
  State = DelimMode;//Устанавливаем новое состояние - "DELIM"
  //Установка опций распознавания классов лексем
  lIdentLBr = false;//опция распознавания маркера начала списка (левой скобки)
  lIdentNumber = true;//опция распознавания вещественных чисел
  lIdentDelim = false;//опция распознавания символа-разделителя между двумя числами
  lIdentRBr = false;//опция распознавания маркера конца списка (правой скобки)

  lProceed = true;
 }
 else if (TokenClass == tEndMarker) //Лексема принадлежит классу END MARKER
 {MsgNumber = 1;
  pCur++;
  State = RBrMode;//Устанавливаем новое состояние - "END MARKER"
  //Установка опций распознавания классов лексем
  lIdentLBr = false;//опция распознавания маркера начала списка (левой скобки)
  lIdentNumber = false;//опция распознавания вещественных чисел
  lIdentDelim = false;//опция распознавания символа-разделителя между двумя числами
  lIdentRBr = false;//опция распознавания маркера конца списка (правой скобки)

  lProceed = true;
 }
 else if (TokenClass == tEOS) //Лексема принадлежит классу EOS (End-Of-String)
 {MsgNumber = 8;
  State = ErrorMode;//Устанавливаем новое состояние - "ERROR"
  lProceed = false;
 }
 else if (TokenClass == tOther) //Лексема не распознана <OTHER CLASS>
 {MsgNumber = 7;
  State = ErrorMode;//Устанавливаем новое состояние - "ERROR"
  lProceed = false;
 }
 return lProceed;
}
//****************************************************************************************
//СТАТУС: II.10; TStrToDoubleArgs private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlDelimMode()
//НАЗНАЧЕНИЕ: Обработчик состояния DelimMode - "СИМВОЛ-РАЗДЕЛИТЕЛЬ". Функция возвращает
//true в случае возможности продолжения извлечения из строки вещественных чисел и false -
//в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//****************************************************************************************
bool TStrToDoubleArgs::HndlDelimMode()
{bool lProceed;
 //Синтаксический анализ: Текущее СОСТОЯНИЕ - Входная ЛЕКСЕМА
 if (TokenClass == tWS) //Лексема принадлежит классу WHITESPACE
 {MsgNumber = 1;
  pCur++;
  lProceed = true;
 }
 else if (TokenClass == tNumber) //Лексема принадлежит классу NUMBER
 {MsgNumber = 1;
  State = NumberMode;//Устанавливаем новое состояние - "NUMBER"
  Data.push_back(stod.GetValue());//Добавляем вещественное число в список
  //Установка опций распознавания классов лексем
  lIdentLBr = false;//опция распознавания маркера начала списка (левой скобки)
  lIdentNumber = false;//опция распознавания вещественных чисел
  lIdentDelim = true;//опция распознавания символа-разделителя между двумя числами
  lIdentRBr = true;//опция распознавания маркера конца списка (правой скобки)

  lProceed = true;
 }
 else if (TokenClass == tEOS) //Лексема принадлежит классу EOS (End-Of-String)
 {MsgNumber = 9;
  State = ErrorMode;//Устанавливаем новое состояние - "ERROR"
  lProceed = false;
 }
 else if (TokenClass == tOther) //Лексема не распознана <OTHER CLASS>
 {MsgNumber = 10;
  State = ErrorMode;//Устанавливаем новое состояние - "ERROR"
  lProceed = false;
 }
 return lProceed;
}
//****************************************************************************************
//СТАТУС: II.11; TStrToDoubleArgs private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlRBrMode()
//НАЗНАЧЕНИЕ: Обработчик состояния RBrMode - "МАРКЕР КОНЦА СПИСКА". Функция возвращает
//<FALSE>, так как это УСПЕШНОЕ ЗАВЕРШАЮЩЕЕ состояние. После достижения данного состояния
//объект класса может приступить к извлечению из строки новых вещ-х аргументов в скобках.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//****************************************************************************************
bool TStrToDoubleArgs::HndlRBrMode()
{MsgNumber = 2;
 return false;
}

//****************************************************************************************
//     РЕАЛИЗАЦИЯ КЛАССА TStrToDoubleList - ИЗВЛЕЧЕНИЕ ИЗ СТРОКИ ВЕЩЕСТВЕННЫХ ЧИСЕЛ
//Объект класса получает строку символов, осуществляет  поиск в строке последовательности
//символов, представляющих вещественные числа, преобразует их в значения типа double и раз-
//мещает их в списке. Класс работает во взаимодействии с TStrToDouble и способен обнаружи-
//вать синтаксические ошибки в символьном представлении списка чисел с выдачей сообщений по
//каждой ошибке. Класс может использоваться для извлечения последовательности строк с
//вещественными числами типа double из одной строки. Класс может хранить извлеченные числа
//вплоть до следующей сессии по извлечению из строки последовательности чисел. В ходе рабо-
//ты объект класса не изменяет содержимого строк и хранит указатели на первый и последний
//символы строки, с которых начался и закончился процесс извлечения вещественных чисел из
//строки. Класс заканчивает работу на первой лексеме, которая не удовлетворяет синтаксичес-
//ким правилам или не является допустимой с формированием сообщения.
//****************************************************************************************
//========================================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TStrToDoubleList
//   PUBLIC MEMBER-FUNCTION OF TStrToDouble CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; TStrToDoubleList public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// ulong operator ()(const string& s, ulong& pos, bool lClearList = true)
//НАЗНАЧЕНИЕ: Перегруженный оператор вызова функции поиска в строке s, передаваемой по
//ссылке, начиная с позиции pos от начала строки, символьного представления вещественных
//чисел и их преобразования в случае успеха в вещественные числа. Функция возвращает коли-
//чество чисел, которые удалось извлечь из строки s за данную сессию. В pos, передаваемой
//по ссылке, функция возвращает позицию символа от начала строки на котором функция завер-
//шила свою работу (tOther, tEndMarker, tEOS).
//Функция не изменяет строку s. Опция lClearList позволяет удалять или накапливать числа,
//извлеченные в ходе предыдущих сессий (значение true, установленное по умолчанию, не сох-
//раняет результаты предыдущих сессий).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& s - константная ссылка на анализируемую строку s;
//2. ulong& pos - ссылка на позицию в строке s, с которой начинается работа функции;
//3. bool lClearList - опция сохранения/уничтожения чисел, считанных ранее.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ulong Count - количество вещественных чисел, извлеченных из строки, в данной сессии
//****************************************************************************************
ulong TStrToDoubleList::operator ()(const string& s, ulong& pos, bool lClearList)
{SetStandByMode(); //Начальная установка всех параметров объекта
 if (lClearList) ClearList();//Очистка списка вещественных чисел
 ulong Count = 0L;
 if (pos < s.length())
 {//Получение указателя на строку s с учетом начального смещения pos
  pStr = pCur = s.c_str()+pos;
  Count = Extract();//Извлечение из строки вещественных чисел
  pos = pCur-pStr;
 }
 return Count;//Количество извлеченных из строки вещественных чисел за данную сессию
}
//***********************************************************************************
//СТАТУС: I.2; TStrToDoubleList public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//ulong operator ()(const char* s, ulong& pos, bool lClearList = true)
//НАЗНАЧЕНИЕ: Перегруженный оператор вызова функции предназначен для поиска в строке
//s, символьного представления вещественных чисел и их преобразований в числа типа
//double. Функция возвращает количество вещественных чисел, извлеченных из строки, за
//данную (последнюю сессию). В pos, функция возвращает индекс символа строки s, на ко-
//тором завершается преобразование строки в список вещественных чисел double. Функ-
//ция не изменяет строку s. Опция lClearList позволяет удалять или накапливать числа,
//извлеченные в ходе предыдущих сессий (значение true, установленное по умолчанию, не
//сохраняет результаты предыдущих сессий).
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const char* s - константная ссылка на анализируемую строку;
//2. ulong& pos - индекс символа в строке s, на котором завершается разбор;
//3. bool lClearList - опция сохранения/уничтожения чисел, считанных ранее.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ulong Count - количество вещественных чисел, извлеченных из строки в данной сессии
//***********************************************************************************
ulong TStrToDoubleList::operator ()(const char* s, ulong& pos, bool lClearList)
{SetStandByMode();//Начальная установка всех параметров объекта
 if (lClearList) ClearList();//Очистка списка вещественных чисел
 ulong Count = 0L;
 pos = 0;
 if (s != NULL)
 {pStr = pCur = s;//Получение указателя на строку s
  Count = Extract();//Извлечение из строки вещественных чисел
  pos = pCur - s;
 }
 return Count;//Количество извлеченных из строки вещественных чисел за данную сессию
}
//****************************************************************************************
//СТАТУС: I.3; TStrToDoubleList public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// ulong StrToMultiList(const string& s, ulong& pos, bool lClearList = true)
//НАЗНАЧЕНИЕ: Функция извлекает из строки s, передаваемой по ссылке, начиная с позиции pos
//от начала строки, списки вещественных чисел, которые разделены символами конца списка.
//Функция позволяет за один вызов считать двумерный массив чисел. Функция возвращает коли-
//чество списков с числами, которые удалось извлечь из строки s за сессию. В pos, переда-
//ваемой по ссылке, функция возвращает позицию символа от начала строки на котором функция
//завершила свою работу (tOther, tEndMarker, tEOS).
//Функция не изменяет строку s. Опция lClearList позволяет удалять или накапливать числа,
//извлеченные в ходе предыдущих сессий (значение true, установленное по умолчанию, не сох-
//раняет результаты предыдущих сессий).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& s - константная ссылка на анализируемую строку s;
//2. ulong& pos - ссылка на позицию в строке s, с которой начинается работа функции;
//3. bool lClearList - опция сохранения/уничтожения чисел, считанных ранее.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ulong ListCount - количество списков вещественных чисел, извлеченных из строки s за
//данную сессию
//****************************************************************************************
ulong TStrToDoubleList::StrToMultiList(const string& s, ulong& pos, bool lClearList)
{SetStandByMode(); //Начальная установка всех параметров объекта
 if (lClearList) ClearList();//Очистка списка вещественных чисел
 ulong ListCount = 0L;
 if (pos < s.length())
 {//Получение указателя на строку s с учетом начального смещения pos
  pStr = pCur = s.c_str()+pos;
  bool lProceed;
  do
  {ulong Count = Extract();//Извлечение из строки вещественных чисел
   if (Count) ListCount++;
   if ((State != ErrorMode) && (TokenClass == tEndMarker))
   {pCur++; lProceed = true;}
   else lProceed = false;
  } while (lProceed);
  pos = pCur-pStr;
 }
 return ListCount;//Количество списков вещественных чисел, считанных за данную сессию
}
//****************************************************************************************
//СТАТУС: I.4; TStrToDoubleList public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//ulong StrToMultiList(const char* s, ulong& pos, bool lClearList = true)
//НАЗНАЧЕНИЕ: Функция извлекает из строки s, передаваемой по ссылке, списки вещественных
//чисел, которые разделены символами конца списка. Функция позволяет за один вызов считать
//двумерный массив чисел. Функция возвращает количество списков с числами, которые удалось
//извлечь из строки s за сессию. В pos, передаваемой по ссылке, функция возвращает позицию
//символа от начала строки на котором она завершила свою работу.
//Функция не изменяет строку s. Опция lClearList позволяет удалять или накапливать числа,
//извлеченные в ходе предыдущих сессий (значение true, установленное по умолчанию, не сох-
//раняет результаты предыдущих сессий).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const char* s - константная ссылка на анализируемую строку;
//2. ulong& pos - индекс символа в строке s, на котором завершается разбор;
//3. bool lClearList - опция сохранения/уничтожения чисел, считанных ранее.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ulong ListCount - количество списков вещественных чисел, извлеченных из строки s за
//данную сессию
//****************************************************************************************
ulong TStrToDoubleList::StrToMultiList(const char* s, ulong& pos, bool lClearList)
{SetStandByMode();//Начальная установка всех параметров объекта
 if (lClearList) ClearList();//Очистка списка вещественных чисел
 ulong ListCount = 0L;
 pos = 0;
 if (s != NULL)
 {pStr = pCur = s;//Получение указателя на строку s
  bool lProceed;
  do
  {ulong Count = Extract();//Извлечение из строки вещественных чисел
   if (Count) ListCount++;
   if ((State != ErrorMode) && (TokenClass == tEndMarker))
   {pCur++; lProceed = true;}
   else lProceed = false;
  } while (lProceed);
  pos = pCur - s;
 }
 return ListCount;//Количество списков вещественных чисел, считанных за данную сессию
}
//****************************************************************************************
//СТАТУС: I.5; TStrToDoubleList public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetStandByMode()
//НАЗНАЧЕНИЕ: Установка класса в режим "ОЖИДАНИЕ" (SleepMode, WaitingMode).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TStrToDoubleList::SetStandByMode()
{pStr = NULL;//указатель на начало строки
 pCur = NULL;//указатель на текущий обрабатываемый символ

 TokenClass = tOther;//класс литеры (символа)
 TokenValue = 0;     //значение (идентификатор) литеры в классе

 lIdentNumber = true;//опция распознавания вещественных чисел
 lIdentDelim = false;//опция распознавания символа-разделителя между двумя числами
 lIdentEndMarker = false;//опция распознавания маркера конца

 State = StandByMode;//текущее состояния - режим ожидания
 MsgNumber = 0;//порядковый номер сообщения состояния объекта класса
}
//****************************************************************************************
//СТАТУС: I.6;  TStrToDoubleList public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong GetData(rvector& V) const;
//НАЗНАЧЕНИЕ: Функция присваивает объекту класса TRealVector список всех вещественных чисел,
//извлеченных из строк(и), которые хранятся в объекте класса TStrToDoubleList.
//Функция в ходе работы изменяет размер и данные вектора V и возвращает вектор V нулевого
//размера, если список пустой. Объект TStrToDoubleList не изменяется функцией. Функция
//возвращает размерность вектора V после операции присваивания.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//TRealVector& V - ссылка на вектор, в который помещаются числа из TStrToDoubleList
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong szVector - размер вектора V после операции присваивания
//****************************************************************************************
ulong TStrToDoubleList::GetData(rvector& V) const
{//Создаем вектор V одинакового с Data размера
 V.Resize(TotalCount());
 if (!V.IsZeroSize())//Копирование вещественных чисел из TStrToDoubleList в V
 {std::list<double>::const_iterator p = Data.begin();
  for (ulong i = 0L; i < V.Size(); i++) {V.Put(i,*p); p++;}
 }
 return V.Size();
}
//****************************************************************************************
//СТАТУС: I.7;  TStrToDoubleList public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong GetData(rmatrix& A, double DefValue = 0.0) const;
//НАЗНАЧЕНИЕ: Функция присваивает объекту класса TRealMatrix список всех вещественных
//чисел, извлеченных из строк(и), которые хранятся в объекте класса TStrToDoubleList.
//Если в объекте класса TStrToDoubleList хранятся числа, извлеченные в течении несколь-
//ких сессий (из нескольких строк или за несколько раз), то каждая группа таких чисел
//помещается в соотвестствующую строку матрицы. Количество строк матрицы A будет равна
//числу сессий, количество столбцов матрицы будет определяться длиной наибольшего спис-
//ка (если таких строк несколько). Так как кол-во чисел, извлеченных в разных сессиях
//может быть разным, то остальным числам в строках, длина которых меньше длины наиболь-
//шей извлеченной строки, будет присваиваться величина DefValue (по умолчанию ноль).
//Функция в ходе работы изменяет размерность и данные матрицы A и возвращает кол-во
//строк матрицы A. Если объект не содержит чисел, то конструируется матрица нулевого
//размера. Объект TStrToDoubleList не изменяется функцией.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//TRealMatrix& A - ссылка на матрицу, в который помещаются числа из TStrToDoubleList
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ulong nLines - кол-во строк матрицы A (кол-во считанных строк объектом DList)
//***********************************************************************************
ulong TStrToDoubleList::GetData(rmatrix& A, double DefValue) const
{//Проверка на наличие в объекте считанных вещественных чисел
 if (TotalCount() == 0) {A.Set(0L,0L,false); return 0L;}
 int rows = ListCount();//Кол-во строк матрицы A
 //Определяем кол-во столбцов матрицы по длине списка наибольшего размера
 std::list<int>::const_iterator p = Lines.begin();
 std::list<int>::const_iterator stop = Lines.end();
 int cols = *p;
 while (p != stop) {if (cols < *p) cols = *p; p++;}
 //Создаем матрицу A новой размерности без начальной инициализации
 A.Set(rows,cols,false);
 //Инициализируем элементы матрицы значениями из TStrToDoubleList
 p = Lines.begin();
 std::list<double>::const_iterator pData = Data.begin();
 int LenCurLine;
 for (int i = 0L; i < rows; i++)
 {LenCurLine = *p; //p++;
  if (p != Lines.end()) p++;
  for (int j = 0L; j < cols; j++)
  {if (LenCurLine > j) {A.Put(i,j,*pData); if (pData != Data.end()) pData++;}
   else A.Put(i,j,DefValue);
  }
 }
 return rows;
}

//========================================================================================
//II. РЕАЛИЗАЦИЯ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TStrToDoubleList
//    PRIVATE MEMBER-FUNCTION OF TStrToDoubleList CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: II.1; TStrToDoubleList private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Init()
//НАЗНАЧЕНИЕ: Начальная установка свойств класса.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TStrToDoubleList::Init()
{ClearList();//очистка списка считанных вещественных чисел и списка сессий
 MsgTable.resize(0);//очистка списка сообщений о состояниях объекта
 ModeTitles.resize(0);//очистка списка названий состояний объекта
 sDelimeter.resize(0);//строка символов-разделителей
 sEndMarker.resize(0);//строка символов маркера конца блока
 //Установка объекта в режим "ОЖИДАНИЕ"
 SetStandByMode();
}
//****************************************************************************************
//СТАТУС: II.2; TStrToDoubleList private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetTables()
//НАЗНАЧЕНИЕ:Создание таблицы указателей на функции-обработчики состояний класса, таблиц
//наименований состояний объекта и строковых сообщений
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TStrToDoubleList::SetTables()
{//---------------------------------------------------------------------------------------
 //Установка указателей на функции-обработчики состояний
 Table[IdleMode]   = &TStrToDoubleList::HndlIdleMode;  //0
 Table[NumberMode] = &TStrToDoubleList::HndlNumberMode;//1
 Table[DelimMode]  = &TStrToDoubleList::HndlDelimMode; //2
 //---------------------------------------------------------------------------------------
 //Создание таблицы наименований состояний объекта класса
 ModeTitles.push_back("State:<IDLE>");
 ModeTitles.push_back("State:<NUMBER>");
 ModeTitles.push_back("State:<DELIMETER>");
 ModeTitles.push_back("State:<ERROR>");
 ModeTitles.push_back("State:<STANDBY>");
 //---------------------------------------------------------------------------------------
 //Создание таблицы строковых сообщений
 MsgTable.push_back("Ready to begin.");//MsgNumber = 0
 MsgTable.push_back("Ready to proceed.");//MsgNumber = 1
 MsgTable.push_back("Success: Reached End-Of-Data Marker.");//MsgNumber = 2
 MsgTable.push_back("Success: Reached End-Of-String Marker.");//MsgNumber = 3
 MsgTable.push_back("Failure: Reached End-Of-String Marker.");//MsgNumber = 4
 //MsgNumber = 5 (for ErrorMode)
 MsgTable.push_back("Found unrecognized token. Expected NUMBER.");
 //MsgNumber = 6 (for ErrorMode)
 MsgTable.push_back("Found unrecognized token. Expected DELIM or ENDMARKER.");
 //MsgNumber = 7 (for ErrorMode)
 MsgTable.push_back("Found two DELIM together. Expected NUMBER");
 //MsgNumber = 8 (for ErrorMode)
 MsgTable.push_back("Found EOS after DELIM. Expected NUMBER");
 //MsgNumber = 9 (for ErrorMode)
 MsgTable.push_back("Found ENDMARKER after DELIM. Expected NUMBER");
}
//****************************************************************************************
//СТАТУС: II.3; TStrToDoubleList private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong Extract()
//НАЗНАЧЕНИЕ: Функция извлекает из строки последовательность вещественных чисел и переводит
//их в двоичное представление типа double. Функция возвращает количество чисел, извлеченных
//из строки, за текущую сессию.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ulong Count - количество чисел, извлеченных из строки за текущую сессию
//****************************************************************************************
ulong TStrToDoubleList::Extract()
{ulong Count = TotalCount();//Определение кол-ва чисел хранящихся в списке
 SetIdleMode();//Установка начального состояния системы
 do //Цикл извлечения из строки вещественных чисел
 {LexicalBlock();
 } while ((this->*Table[State])());
 //Определение количества чисел, извлеченных из строки за текущую сессию
 Count = TotalCount()-Count;
 //Добавить в список Lines еще одну ненулевую сессию
 if (Count > 0L) Lines.push_back(Count);
 return Count;
}
//****************************************************************************************
//СТАТУС: II.4; TStrToDoubleList private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void LexicalBlock()
//НАЗНАЧЕНИЕ: Лексический анализ символов, поступающих на вход системы распознавания и
//преобразования строки числа типа double. Функция классифицирует входные символы, ставя им
//в соответствие КЛАСС (TokenClass) и значение в классе (TokenValue). Значения членов-данных
//класса TokenClass и TokenValue используют для дальнейшего извлечения из потока символов
//чисел или для завершения процесса преобразования.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TStrToDoubleList::LexicalBlock()
{//Проверка на символ конца строки - EOS (End-Of-String)
 if (*pCur == '\0') {TokenClass = tEOS; TokenValue = 0; return;}
 //Проверка на наличие в строке вещественного числа и его извлечение <NUMBER CLASS>
 if (lIdentNumber)
 {ulong pos = 0L;
  if (stod(pCur,pos))
  {pCur+=pos;
   TokenClass = tNumber;
   TokenValue = stod.IsInteger() ? 1 : 0;
   return;
  }
 }
 //Проверка на принадлежность классу <ENDMARKER CLASS>
 if ((lIdentEndMarker) && (sEndMarker.length() != 0))
 {ulong pos = sEndMarker.find(*pCur);
  if (pos < sEndMarker.length())
  {TokenClass = tEndMarker;
   TokenValue = pos;
   return;
  }
 }
 //Проверка на принадлежность классу <DELIMETER CLASS>
 if (lIdentDelim)
 {ulong pos = sDelimeter.find(*pCur);
  if (pos < sDelimeter.length())
  {TokenClass = tDelim;
   TokenValue = pos;
   return;
  }
 }
 //Лексический блок не смог распознать текущий символ
 TokenClass = tOther; TokenValue = 0;
}
//****************************************************************************************
//СТАТУС: II.5; TStrToDoubleList private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlIdleMode()
//НАЗНАЧЕНИЕ:Обработчик состояния IdleMode - "НАЧАЛЬНОЕ СОСТОЯНИЕ". Функция возвращает
//true в случае возможности продолжения извлечения из строки вещественных чисел и false -
//в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//****************************************************************************************
bool TStrToDoubleList::HndlIdleMode()
{//Лексема принадлежит классу NUMBER
 if (TokenClass == tNumber)
 {MsgNumber = 1;
  State = NumberMode;//Устанавливаем новое состояние - "NUMBER"
  Data.push_back(stod.GetValue());//Добавляем вещественное число в список
  //Установка опций распознавания классов лексем
  lIdentNumber = false;
  lIdentDelim = true;
  lIdentEndMarker = true;
  return true;
 }
 //Лексема принадлежит классу EOS (End-Of-String)
 if (TokenClass == tEOS)
 {MsgNumber = 4;
  return false;
 }
 //Лексема не распознана <OTHER CLASS>
 MsgNumber = 5;
 State = ErrorMode;//Устанавливаем новое состояние - "ERROR"
 return false;
}
//***********************************************************************************
//СТАТУС: II.6; TStrToDoubleList private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlNumberMode()
//НАЗНАЧЕНИЕ: Обработчик состояния NumberMode - "ЧИСЛО". Функция возвращает true в
//случае возможности продолжения извлечения из строки вещественных чисело и false - в
//противоположном случае.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//***********************************************************************************
bool TStrToDoubleList::HndlNumberMode()
{//Лексема принадлежит классу DELIMETER
 if (TokenClass == tDelim)
 {MsgNumber = 1;
  State = DelimMode;//Устанавливаем новое состояние - "DELIMETER"
  pCur++;
  //Установка опций распознавания классов лексем
  lIdentNumber = true;
  lIdentDelim = true;
  lIdentEndMarker = true;
  return true;
 }
 //Лексема принадлежит классу ENDMARKER
 if (TokenClass == tEndMarker)
 {MsgNumber = 2;
  //pCur++;
  return false;
 }
 //Лексема принадлежит классу EOS (End-Of-String)
 if (TokenClass == tEOS)
 {MsgNumber = 3;
  return false;
 }
 //Лексема не распознана <OTHER CLASS>
 MsgNumber = 6;
 State = ErrorMode;//Устанавливаем новое состояние - "ERROR"
 return false;
}
//***********************************************************************************
//СТАТУС: II.7; TStrToDoubleList private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlDelimMode()
//НАЗНАЧЕНИЕ:Обработчик состояния DelimMode - "РАЗДЕЛИТЕЛЬ". Функция возвращает true
//в случае возможности продолжения извлечения из строки вещественных чисело и false -
//в противоположном случае.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//***********************************************************************************
bool TStrToDoubleList::HndlDelimMode()
{//Лексема принадлежит классу NUMBER
 if (TokenClass == tNumber)
 {MsgNumber = 1;
  State = NumberMode;//Устанавливаем новое состояние - "NUMBER"
  Data.push_back(stod.GetValue());//Добавляем вещественное число в список
  //Установка опций распознавания классов лексем
  lIdentNumber = false;
  lIdentDelim = true;
  lIdentEndMarker = true;
  return true;
 }
 //Лексема принадлежит классу DELIMETER
 if (TokenClass == tDelim)
 {MsgNumber = 7; State = ErrorMode;
  return false;
 }
 //Лексема принадлежит классу EOS (End-Of-String)
 if (TokenClass == tEOS)
 {const char* p = pCur-1;//Получение указателя на предыдущий символ
  if ((*p == ' ') || (*p == '\t')) MsgNumber = 3;
  else {MsgNumber = 8; State = ErrorMode;}
  return false;
 }
 //Лексема принадлежит классу ENDMARKER
 if (TokenClass == tEndMarker)
 {const char* p = pCur-1;//Получение указателя на предыдущий символ
  if ((*p == ' ') || (*p == '\t')) MsgNumber = 2;
  else {MsgNumber = 9; State = ErrorMode;}
  return false;
 }
 //Лексема не распознана <OTHER CLASS>
 MsgNumber = 5;
 State = ErrorMode;//Устанавливаем новое состояние - "ERROR"
 return false;
}
//****************************************************************************************
//СТАТУС: II.8; TStrToDoubleList private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetIdleMode()
//НАЗНАЧЕНИЕ: Установка класса в режим "НАЧАЛЬНОЕ СОСТОЯНИЕ" (IdleMode).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TStrToDoubleList::SetIdleMode()
{TokenClass = tOther;//класс литеры (символа)
 TokenValue = 0;     //значение (идентификатор) литеры в классе

 lIdentNumber = true;//опция распознавания вещественных чисел
 lIdentDelim = false;//опция распознавания символа-разделителя между двумя числами
 lIdentEndMarker = false;//опция распознавания маркера конца

 State = IdleMode;//текущее состояния - начальное состояние
 MsgNumber = 0;//порядковый номер сообщения состояния объекта класса
}


//***********************************************************************************
//РЕАЛИЗАЦИЯ КЛАССА TStrToDouble - ПРЕОБРАЗОВАНИЕ СТРОКИ СИМВОЛОВ В ВЕЩЕСТВЕННОЕ ЧИСЛО
//Объект класса получает строку символов, осуществляет  поиск в строке последователь-
//ности символов, представляющих вещественное число, и преобразует их в значение типа
//double. Класс обнаруживает ошибки в символьном представлении вещественного числа и
//приспособлен для извлечения последовательности чисел типа double из одной строки.
//***********************************************************************************
//===================================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TStrToDouble
//   PUBLIC MEMBER-FUNCTION OF TStrToDouble CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1; TStrToDouble public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ()(const string& s, ulong& pos, double& value)
//НАЗНАЧЕНИЕ: Перегруженный оператор вызова функции предназначен для поиска в строке
//s, передаваемой по ссылке, начиная с позиции pos от начала строки, символьного пред-
//ставления вещественного числа и его преобразования в случае успеха в вещественное
//число. Функция возвращает true, если в строке s удалось найти и извлечь без ошибок
//вещественное число и false - в случае неудачи (в строке нет чисел либо при преобра-
//зовании числа из символьного в двоичное представление обнаружена синтаксическая
//ошибка). Результат преобразования передается через переменную value. В pos, переда-
//ваемой по ссылке, функция возвращает позицию символа от начала строки, который уже
//не является символьным представлением вещественного числа. В процессе работы функция
//не изменяет содержимого строки s.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& s - константная ссылка на анализируемую строку s;
//2. ulong& pos - ссылка на позицию в строке s, с которой начинается работа функции;
//3. double& value - значение вещественного числа, извлеченного из строки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак извлечения из строки вещественного числа
//***********************************************************************************
bool TStrToDouble::operator ()(const string& s, ulong& pos, double& value)
{Init(); //Начальная установка всех параметров объекта
 if (pos >= s.length()) {value = Value; return lSuccess;}
 //Получение указателя на строку s с учетом начального смещения pos
 pStr = pCur = s.c_str()+pos;
 Extract();//Извлечение из строки вещественного числа
 pos = pCur-pStr; value = Value;
 return lSuccess;
}
//***********************************************************************************
//СТАТУС: I.2; TStrToDouble public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ()(const string& s, ulong& pos)
//НАЗНАЧЕНИЕ: Перегруженный оператор вызова функции предназначен для поиска в строке
//s, передаваемой по ссылке, начиная с позиции pos от начала строки, символьного пред-
//ставления вещественного числа и его преобразования в случае успеха в вещественное
//число. Функция возвращает true, если в строке s удалось найти и извлечь без ошибок
//вещественное число и false - в случае неудачи (в строке нет чисел либо при преобра-
//зовании числа из символьного в двоичное представление обнаружена синтаксическая
//ошибка). Извлеченное число сохраняется в члене-данном класса Value. В pos, переда-
//ваемой по ссылке, функция возвращает позицию символа от начала строки, который уже
//не является символьным представлением вещественного числа. В процессе работы функция
//не изменяет содержимого строки s.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& s - константная ссылка на анализируемую строку s;
//2. ulong& pos - ссылка на позицию в строке s, с которой начинается работа функции;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак извлечения из строки вещественного числа
//***********************************************************************************
bool TStrToDouble::operator ()(const string& s, ulong& pos)
{Init(); //Начальная установка всех параметров объекта
 if (pos < s.length())
 {//Получение указателя на строку s с учетом начального смещения pos
  pStr = pCur = s.c_str()+pos;
  Extract();//Извлечение из строки вещественного числа
  pos = pCur-pStr;
 }
 return lSuccess;
}
//***********************************************************************************
//СТАТУС: I.3; TStrToDouble public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ()(const char* s, ulong& pos, double& value)
//НАЗНАЧЕНИЕ: Перегруженный оператор вызова функции предназначен для поиска в строке
//s, символьного представления вещественного числа и его преобразования число типа
//double. Функция возвращает true, если в строке s удалось найти и извлечь без ошибок
//вещественное число и false - в случае неудачи (в строке нет чисел либо при преобра-
//зовании числа из символьного в двоичное представление обнаружена синтаксическая
//ошибка). Результат преобразования передается через переменную value. В pos, функция
//возвращает индекс первого символа, на котором завершается преобразование строки
//в число double. Функция не изменяет содержимого строки s.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const char* s - константная ссылка на анализируемую строку s;
//2. ulong& pos - индекс символа строки s, на котором завершается преобразование
//3. double& value - результат преобразования строки в число.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак извлечения из строки вещественного числа
//***********************************************************************************
bool TStrToDouble::operator ()(const char* s, ulong& pos, double& value)
{Init(); //Начальная установка всех параметров объекта
 if (s == NULL) {pos = 0L; value = Value; return lSuccess;}
 pStr = pCur = s;//Получение указателя на строку s
 Extract();//Извлечение из строки вещественного числа
 pos = pCur - s; value = Value;
 return lSuccess;
}
//***********************************************************************************
//СТАТУС: I.4; TStrToDouble public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ()(const char* s, ulong& pos)
//НАЗНАЧЕНИЕ: Перегруженный оператор вызова функции предназначен для поиска в строке
//s, символьного представления вещественного числа и его преобразования число типа
//double. Функция возвращает true, если в строке s удалось найти и извлечь без ошибок
//вещественное число и false - в случае неудачи (в строке нет чисел либо при преобра-
//зовании числа из символьного в двоичное представление обнаружена синтаксическая
//ошибка). Извлеченное число сохраняется в члене-данном класса Value. В s, функция
//возвращает указатель на первый символ, на котором завершается преобразование строки
//в число double. Функция не изменяет содержимого строки s.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const char* s - константная ссылка на анализируемую строку s;
//2. ulong& pos - индекс символа строки s, на котором завершается преобразование.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак извлечения из строки вещественного числа
//***********************************************************************************
bool TStrToDouble::operator ()(const char* s, ulong& pos)
{Init(); //Начальная установка всех параметров объекта
 pos = 0L;
 if (s != NULL)
 {pStr = pCur = s;//Получение указателя на строку s
  Extract();//Извлечение из строки вещественного числа
  pos = pCur-s;
 }
 return lSuccess;
}

//===================================================================================
//II. РЕАЛИЗАЦИЯ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TStrToDouble
//    PRIVATE MEMBER-FUNCTION OF TStrToDouble CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: II.1; TStrToDouble private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Init()
//НАЗНАЧЕНИЕ: Начальная установка свойств класса.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TStrToDouble::Init()
{Value = 0.0;          //значение вещественного числа, извлеченного из строки
 Exponent = 0;         //значение порядка числа
 DigAfterPoint = 0;    //счетчик количества цифр после десятичной точки
 Digits = 0;           //счетчик количества цифр до и после запятой
 DigExpPart = 0;       //счетчик количества цифр в порядке числа
 RightZeros = 0;       //счетчик правых нулей в числе
 lNonZeroValue = false;//индикатор ненулевого значения числа
 lNonZeroExp   = false;//индикатор ненулевого значения порядка числа

 lSuccess = false;//индикатор извлечения из строки числа

 lSignNum = true;   //знак числа (положительный по умолчанию)
 lIsSignNum = false;//наличие знака числа в явном виде
 lSignExp = true;   //знак порядка (положительный по умолчанию)
 lIsSignExp = false;//наличие знака порядка числа в явном виде

 pStr = NULL;//указатель на начало строки
 pCur = NULL;//указатель на текущий обрабатываемый символ

 TokenClass = dtEmpty;//класс литеры (символа)
 TokenValue = 0;      //значение (идентификатор) литеры в классе

 lIdentSign = true; //опция распознавания символов знака числа <-+>
 lIdentPoint = true;//опция распознавания символа десятичной точки <.>
 lIdentExp = false; //опция распознавания символа порядка числа <eE>

 State = dmIdle;//текущее состояния
}
//***********************************************************************************
//СТАТУС: II.2; TStrToDouble private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetHndlModeTable()
//НАЗНАЧЕНИЕ:Инициализация таблицы указателей на функции-обработчики состояний класса
//адресами функций-обработчиков.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TStrToDouble::SetHndlModeTable()
{Table[dmIdle]    = &TStrToDouble::HndlIdleMode;    //1
 Table[dmSign]    = &TStrToDouble::HndlSignMode;    //2
 Table[dmInteger] = &TStrToDouble::HndlIntegerMode; //3
 Table[dmPoint]   = &TStrToDouble::HndlPointMode;   //4
 Table[dmReal]    = &TStrToDouble::HndlRealMode;    //5
 Table[dmExp]     = &TStrToDouble::HndlExpMode;     //6
 Table[dmExpSign] = &TStrToDouble::HndlExpSignMode; //7
 Table[dmExpVal]  = &TStrToDouble::HndlExpValMode;  //8
}
//***********************************************************************************
//СТАТУС: II.3; TStrToDouble private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Extract()
//НАЗНАЧЕНИЕ:Функция извлекает из строки символьное представление вещественного числа
//и переводит его в двоичное представление типа double. В случае успешного поиска в
//строке символьного представления вещественного числа и его преобразования функция
//возвращает true, в противном случае - false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак преобразования последовательности символов в тип double
//***********************************************************************************
bool TStrToDouble::Extract()
{//Пропуск начальных пробельных символов
 pCur = SkipSymbols(pStr,Space);
 //Все символы в исходной строке пробельные, достигнут конец строки
 if (*pCur == '\0') {TokenClass = dtEOS; return lSuccess;}
 //Цикл преобразования строки символов в вещественное число
 do
 {LexicalBlock();
  if ((this->*Table[State])()) pCur++;
  else break;
 } while (true);
 return lSuccess;
}
//***********************************************************************************
//СТАТУС: II.4; TStrToDouble private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void LexicalBlock()
//НАЗНАЧЕНИЕ: Функция осуществляет лексический анализ символов, поступающих на вход
//системы распознавания и преобразования строки символов в число типа double. Функция
//классифицирует текущий символ, ставя ему в соответствие КЛАСС (TokenClass) и значе-
//ние в классе (TokenValue). Значения членов-данных класса TokenClass и TokenValue
//используют для дальнейшего преобразования потока символов в число или для завершения
//процесса преобразования.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TStrToDouble::LexicalBlock()
{//Проверка на конец строки
 if (*pCur == '\0') {TokenClass = dtEOS; TokenValue = 0; return;}
 const char* p;
 //Проверка на принадлежность классу DIGIT
 p = strchr(Digit,*pCur);
 if (p) {TokenClass = dtDigit; TokenValue = p-Digit; return;}
 //Проверка на принадлежность классу SIGN
 if (lIdentSign)
 {p = strchr(Sign,*pCur);
  if (p) {TokenClass = dtSign; TokenValue = p-Sign; return;}
 }
 //Проверка на принадлежность классу POINT
 if (lIdentPoint)
 {p = strchr(DecPoint,*pCur);
  if (p) {TokenClass = dtPoint; TokenValue = p-DecPoint; return;}
 }
 //Проверка на принадлежность классу EXP
 if (lIdentExp)
 {p = strchr(Exp,*pCur);
  if (p) {TokenClass = dtExp; TokenValue = p-Exp; return;}
 }
 //Лексический блок не смог распознать текущий символ
 TokenClass = dtOther; TokenValue = 0;
}
//***********************************************************************************
//СТАТУС: II.5; TStrToDouble private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlIdleMode()
//НАЗНАЧЕНИЕ: Обработчик состояния dmIdle - "НАЧАЛЬНОЕ СОСТОЯНИЕ". Функция возвращает
//true в случае возможности продолжения преобразования строки символов в вещественное
//число и false - в противоположном случае.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//***********************************************************************************
bool TStrToDouble::HndlIdleMode()
{bool lProceed = true;
 //Текущий символ принадлежит классу SIGN
 if (TokenClass == dtSign)
 {State = dmSign;//Устанавливаем новое состояние - "ЗНАК ЧИСЛА"
  lIsSignNum = true;//Знак числа присутствует явно
  lSignNum = (TokenValue == 0) ? false : true;
  //Установка опций распознавания классов лексем
  lIdentSign = false;
  return lProceed;
 }
 //Текущий символ принадлежит классу DIGIT
 if (TokenClass == dtDigit)
 {State = dmInteger;//Устанавливаем новое состояние - "ЦИФРЫ ДО ЗАПЯТОЙ"
  Digits++;//Увеличиваем счетчик количества цифр числа
  if (TokenValue != 0) {lNonZeroValue = true; Value = TokenValue;}
  //Установка опций распознавания классов лексем
  lIdentSign = false;
  lIdentExp = true;
  return lProceed;
 }
 //Текущий символ принадлежит классу POINT
 if (TokenClass == dtPoint)
 {State = dmPoint;//Устанавливаем новое состояние - "ДЕСЯТИЧНАЯ ТОЧКА"
  //Установка опций распознавания классов лексем
  lIdentSign  = false;
  lIdentPoint = false;
  return lProceed;
 }
 //Недопустимый символ для состояния dmIdle - выход
 lProceed = false;
 return lProceed;
}
//***********************************************************************************
//СТАТУС: II.6; TStrToDouble private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlSignMode()
//НАЗНАЧЕНИЕ: Обработчик состояния dmSign - "ЗНАК ЧИСЛА". Функция возвращает true в
//случае возможности продолжения преобразования строки символов в вещественное число
//и false - в противоположном случае.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//***********************************************************************************
bool TStrToDouble::HndlSignMode()
{bool lProceed = true;
 //Текущий символ принадлежит классу DIGIT
 if (TokenClass == dtDigit)
 {State = dmInteger;//Устанавливаем новое состояние - "ЦИФРЫ ДО ЗАПЯТОЙ"
  Digits++;//Увеличиваем счетчик количества цифр числа
  if (TokenValue != 0) {lNonZeroValue = true; Value = TokenValue;}
  //Установка опций распознавания классов лексем
  lIdentExp = true;
  return lProceed;
 }
 //Текущий символ принадлежит классу POINT
 if (TokenClass == dtPoint)
 {State = dmPoint;//Устанавливаем новое состояние - "ДЕСЯТИЧНАЯ ТОЧКА"
  //Установка опций распознавания классов лексем
  lIdentPoint = false;
  return lProceed;
 }
 //Недопустимый символ для состояния dmSign - выход
 lProceed = false; State = dmError;
 pCur--; TokenClass == dtSign;
 return lProceed;
}
//***********************************************************************************
//СТАТУС: II.7; TStrToDouble private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlIntegerMode()
//НАЗНАЧЕНИЕ: Обработчик состояния dmInteger - "ЦИФРЫ ДО ЗАПЯТОЙ". Функция возвращает
//true в случае возможности продолжения преобразования строки символов в вещественное
//число и false - в противоположном случае.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//***********************************************************************************
bool TStrToDouble::HndlIntegerMode()
{bool lProceed = true;
 //Текущий символ принадлежит классу DIGIT
 if (TokenClass == dtDigit)
 {Digits++;//Увеличиваем счетчик количества цифр числа
  AddDigitToValue();//Добавление цифры к value
  //Установка опций распознавания классов лексем
  lIdentExp = true;
  return lProceed;
 }
 //Текущий символ принадлежит классу POINT
 if (TokenClass == dtPoint)
 {State = dmReal;//Устанавливаем новое состояние - "ЦИФРЫ ПОСЛЕ ЗАПЯТОЙ"
  //Установка опций распознавания классов лексем
  lIdentPoint = true;//lIdentPoint = false;
  return lProceed;
 }
 //Текущий символ принадлежит классу EXP
 if (TokenClass == dtExp)
 {State = dmExp;//Устанавливаем новое состояние - "ПОРЯДОК ЧИСЛА"
  //Установка опций распознавания классов лексем
  lIdentPoint = false;
  lIdentSign  = true;
  lIdentExp   = false;
  return lProceed;
 }
 //Недопустимый символ для состояния dmInteger - завершение преобразования строки
 lProceed = false; lSuccess = true;
 if ((lNonZeroValue) && (lIsSignNum) && (lSignNum == false)) Value = -Value;
 return lProceed;
}
//***********************************************************************************
//СТАТУС: II.8; TStrToDouble private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlPointMode()
//НАЗНАЧЕНИЕ: Обработчик состояния dmInteger - "ДЕСЯТИЧНАЯ ТОЧКА". Функция возвращает
//true в случае возможности продолжения преобразования строки символов в вещественное
//число и false - в противоположном случае.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//***********************************************************************************
bool TStrToDouble::HndlPointMode()
{bool lProceed = true;
 //Текущий символ принадлежит классу DIGIT
 if (TokenClass == dtDigit)
 {State = dmReal;//Устанавливаем новое состояние - "ЦИФРЫ ПОСЛЕ ЗАПЯТОЙ"
  Digits++;//Увеличиваем счетчик количества цифр числа
  DigAfterPoint++;//Увеличиваем счетчик количества цифр числа после десятичной точки
  AddDigitToValue();//Добавление цифры к value
  //Установка опций распознавания классов лексем
  lIdentExp = true;
  return lProceed;
 }
 //Недопустимый символ для состояния dmPoint - завершение преобразования строки
 lProceed = false; State = dmError;
 pCur--; TokenClass = dtPoint;
 if (lIsSignNum) {pCur--; TokenClass = dtSign; lIsSignNum = false; lSignNum = true;}
 return lProceed;
}
//***********************************************************************************
//СТАТУС: II.9; TStrToDouble private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlRealMode()
//НАЗНАЧЕНИЕ: Обработчик состояния dmReal - "ЦИФРЫ ПОСЛЕ ЗАПЯТОЙ". Функция возвращает
//true в случае возможности продолжения преобразования строки символов в вещественное
//число и false - в противоположном случае.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//***********************************************************************************
bool TStrToDouble::HndlRealMode()
{bool lProceed = true;
 //Текущий символ принадлежит классу DIGIT
 if (TokenClass == dtDigit)
 {Digits++;//Увеличиваем счетчик количества цифр числа
  DigAfterPoint++;//Увеличиваем счетчик количества цифр числа после десятичной точки
  AddDigitToValue();//Добавление цифры к value
  //Установка опций распознавания классов лексем - без изменений
  return lProceed;
 }
 //Текущий символ принадлежит классу EXP
 if (TokenClass == dtExp)
 {State = dmExp;//Устанавливаем новое состояние - "ПОРЯДОК ЧИСЛА"
  //Установка опций распознавания классов лексем
  lIdentSign  = true;
  lIdentExp   = false;
  return lProceed;
 }
 //Недопустимый символ для состояния dmReal - завершение преобразования строки
 lProceed = false; lSuccess = true;
 CompleteConversion();//Завершение преобразования строки в число
 return lProceed;
}
//***********************************************************************************
//СТАТУС: II.10; TStrToDouble private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlExpMode()
//НАЗНАЧЕНИЕ: Обработчик состояния dmExp - "ПОРЯДОК ЧИСЛА". Функция возвращает true в
//случае возможности продолжения преобразования строки символов в вещественное число
//и false - в противоположном случае.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//***********************************************************************************
bool TStrToDouble::HndlExpMode()
{bool lProceed = true;
 //Текущий символ принадлежит классу SIGN
 if (TokenClass == dtSign)
 {State = dmExpSign;//Устанавливаем новое состояние - "ЗНАК ПОРЯДКА ЧИСЛА"
  lIsSignExp = true;//Знак порядка числа присутствует явно
  lSignExp = (TokenValue == 0) ? false : true;
  //Установка опций распознавания классов лексем
  lIdentSign = false;
  return lProceed;
 }
 //Текущий символ принадлежит классу DIGIT
 if (TokenClass == dtDigit)
 {State = dmExpVal;//Устанавливаем новое состояние - "ЗНАЧЕНИЕ ПОРЯДКА ЧИСЛА"
  DigExpPart++;//Увеличиваем счетчик количества цифр порядка числа
  if (TokenValue != 0) {lNonZeroExp = true; Exponent = TokenValue;}
  //Установка опций распознавания классов лексем
  lIdentSign = false;
  return lProceed;
 }
 //Недопустимый символ для состояния dmExp - завершение преобразования строки
 //с ошибкой
 lProceed = false; State = dmError; lSuccess = true;
 CompleteConversion();//Завершение преобразования строки в число
 pCur--; TokenClass = dtExp;
 return lProceed;
}
//***********************************************************************************
//СТАТУС: II.11; TStrToDouble private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlExpSignMode()
//НАЗНАЧЕНИЕ: Обработчик состояния dmExpSign - "ЗНАК ПОРЯДКА ЧИСЛА". Функция возвра-
//щает true в случае продолжения преобразования строки символов в вещественное число
//и false - в противоположном случае.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//***********************************************************************************
bool TStrToDouble::HndlExpSignMode()
{bool lProceed = true;
 //Текущий символ принадлежит классу DIGIT
 if (TokenClass == dtDigit)
 {State = dmExpVal;//Устанавливаем новое состояние - "ЗНАЧЕНИЕ ПОРЯДКА ЧИСЛА"
  DigExpPart++;//Увеличиваем счетчик количества цифр порядка числа
  if (TokenValue != 0) {lNonZeroExp = true; Exponent = TokenValue;}
  //Установка опций распознавания классов лексем - без изменений
  return lProceed;
 }
 //Недопустимый символ для состояния dmExpSign - завершение преобразования строки
 //с ошибкой
 lProceed = false; State = dmError; lSuccess = true;
 CompleteConversion();//Завершение преобразования строки в число
 pCur-=2; TokenClass = dtExp; lIsSignExp = false; lSignExp = true;
 return lProceed;
}
//***********************************************************************************
//СТАТУС: II.12; TStrToDouble private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HndlExpValMode()
//НАЗНАЧЕНИЕ: Обработчик состояния dmExpVal - "ЗНАЧЕНИЕ ПОРЯДКА ЧИСЛА". Функция возвра-
//щает true в случае продолжения преобразования строки символов в вещественное число
//и false - в противоположном случае.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lProceed - признак дальнейшего преобразования строки в число
//***********************************************************************************
bool TStrToDouble::HndlExpValMode()
{bool lProceed = true;
 //Текущий символ принадлежит классу DIGIT
 if (TokenClass == dtDigit)
 {DigExpPart++;//Увеличиваем счетчик количества цифр порядка числа
  if (lNonZeroExp) //Цифра отличная от нуля в порядке числа уже была
  {if (TokenValue != 0) Exponent = Exponent*10+TokenValue;
   else Exponent *= 10;
  }
  else //Цифры отличной от нуля еще не было
  {if (TokenValue != 0) {lNonZeroExp = true; Exponent = TokenValue;}
  }
  //Установка опций распознавания классов лексем - без изменений
  return lProceed;
 }
 //Недопустимый символ для состояния dmExpVal - завершение преобразования строки
 //в вещественное число без ошибки
 lProceed = false; lSuccess = true;
 if (lNonZeroValue)
 {if ((lNonZeroExp) && (lIsSignExp) && (lSignExp == false)) Exponent = -Exponent;
  int remainder = Exponent - DigAfterPoint;
  double multiplier = 10.0;
  if (remainder < 0) {remainder = abs(remainder); multiplier = 0.1;}
  for (int i = 0; i < remainder; i++) Value *= multiplier;
  if ((lIsSignNum) && (lSignNum == false)) Value = -Value;
 }
 return lProceed;
}
//***********************************************************************************
//СТАТУС: II.13; TStrToDouble private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void AddDigitToValue()
//НАЗНАЧЕНИЕ: Функция добавляет ЦИФРУ, извлеченную из строки, к значению value. Функ-
//ция используется в следующих обработчиках состояний: HndlIntegerMode, HndlPointMode,
//HndlRealMode 
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TStrToDouble::AddDigitToValue()
{if (lNonZeroValue) //Цифра отличная от нуля уже была
 {if (TokenValue != 0) {Value = Value*10.0+TokenValue; RightZeros = 0;}
  else {Value *= 10.0; RightZeros++;}
 }
 //Цифры отличной от нуля еще не было
 else if (TokenValue != 0) {lNonZeroValue = true; Value = TokenValue;}
}
//***********************************************************************************
//СТАТУС: II.14; TStrToDouble private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void CompleteConversion()
//НАЗНАЧЕНИЕ: Функция завершает преобразование строки в вещественное число. Функция
//используется в следующих обработчиках состояний: HndlRealMode, HndlExpMode и
//HndlExpSignMode. Функция вызывается при появлении недопустимого символа для автомата
//преобразования строки в вещественное число.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TStrToDouble::CompleteConversion()
{if (lNonZeroValue)
 {for (uchar i = 0; i < DigAfterPoint; i++) Value *= 0.1;
  if ((lIsSignNum) && (lSignNum == false)) Value = -Value;
 }
}

/*
//***********************************************************************************
//      РЕАЛИЗАЦИЯ ШАБЛОННОГО КЛАССА template <class T> TStrToReal<T> -
//            ПРЕОБРАЗОВАНИЕ СТРОКИ СИМВОЛОВ В ВЕЩЕСТВЕННОЕ ЧИСЛО
//Объект класса получает строку символов, осуществляет  поиск в строке последователь-
//ности символов, представляющих вещественное число, и преобразует их в значения типа
//float, double или long double. Класс реализован как шаблонный, вместо <class T>
//пользователь должен указать один из трех вышеуказанных  типов представления вещест-
//венных символов. Класс обнаруживает ошибки в символьном представлении вещественного
//числа и приспособлен для извлечения последовательности чисел из одной строки.
//***********************************************************************************
//===================================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TStrToReal
//   PUBLIC MEMBER-FUNCTION OF TStrToReal CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1; TStrToReal public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ()(const string& s, ulong& pos, T& value)
//НАЗНАЧЕНИЕ: Перегруженный оператор вызова функции предназначен для поиска в строке
//s, передаваемой по ссылке, начиная с позиции pos от начала строки, символьного пред-
//ставления вещественного числа и его преобразования в случае успеха в вещественное
//число. Функция возвращает true, если в строке s удалось найти и извлечь без ошибок
//вещественное число и false - в случае неудачи (в строке нет чисел либо при преобра-
//зовании числа из символьного в двоичное представление обнаружена синтаксическая
//ошибка). Результат преобразования передается через переменную value типа <T>. В pos,
//передаваемой по ссылке, функция возвращает позицию символа от начала строки, который
//уже не является символьным представлением вещественного числа. В процессе работы
//функция не изменяет содержимого строки s.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& s - константная ссылка на анализируемую строку s;
//2. ulong& pos - ссылка на позицию в строке s, с которой начинается работа функции;
//3. T& value - значение вещественного числа, полученного в результате работы функции.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак извлечения из строки вещественного числа
//***********************************************************************************
template <class T>
bool TStrToReal<T>::operator ()(const string& s, ulong& pos, T& value)
{Init(); //Начальная установка всех параметров объекта
 if (pos >= s.length()) {lSignNum = lSignExp = false; return lSuccess;}
 //Получение указателя на строку s, ее размера и начального смещения
 pStr = s.c_str(); szStr = s.length(); nPos = pos;
 //Извлечение из строки вещественного числа
 bool lSuccess = Extract();
 pos = nPos; value = Value;
 return lSuccess;
}
//***********************************************************************************
//СТАТУС: I.2; TStrToReal public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ()(const char* s, ulong& pos, T& value)
//НАЗНАЧЕНИЕ: Перегруженный оператор вызова функции предназначен для поиска в строке
//s, передаваемой по ссылке, начиная с позиции pos от начала строки, символьного пред-
//ставления вещественного числа и его преобразования в случае успеха в вещественное
//число. Функция возвращает true, если в строке s удалось найти и извлечь без ошибок
//вещественное число и false - в случае неудачи (в строке нет чисел либо при преобра-
//зовании числа из символьного в двоичное представление обнаружена синтаксическая
//ошибка). Результат преобразования передается через переменную value типа <T>. В pos,
//передаваемой по ссылке, функция возвращает позицию символа от начала строки, который
//уже не является символьным представлением вещественного числа. В процессе работы
//функция не изменяет содержимого строки s.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const char* s - константная ссылка на анализируемую строку s;
//2. ulong& pos - ссылка на позицию в строке s, с которой начинается работа функции;
//3. T& value - значение вещественного числа, полученного в результате работы функции.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак извлечения из строки вещественного числа
//***********************************************************************************
template <class T>
bool TStrToReal<T>::operator ()(const char* s, ulong& pos, T& value)
{Init(); //Начальная установка всех параметров объекта
 if (s == NULL) {lSignNum = lSignExp = false; return lSuccess;}
 //Получение указателя на строку s, ее размера и начального смещения
 pStr = s; szStr = strlen(pStr); nPos = pos;
 //Извлечение из строки вещественного числа
 bool lSuccess = Extract();
 pos = nPos; value = Value;
 return lSuccess;
}


//===================================================================================
//II. РЕАЛИЗАЦИЯ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TStrToReal
//    PRIVATE MEMBER-FUNCTION OF TStrToReal CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: II.1; TStrToReal private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Init()
//НАЗНАЧЕНИЕ: Начальная установка свойств класса.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
template <class T>
void TStrToReal<T>::Init()
{Value = 0.0;      //значение вещественного числа, извлеченного из строки
 Exponent = 0;     //значение порядка числа
 DigAfterPoint = 0;//счетчик количества цифр после десятичной точки
 Digits = 0;       //счетчик количества цифр до и после запятой
 DigExpPart = 0;   //счетчик количества цифр в порядке числа

 lSuccess = false;//индикатор извлечения из строки числа
 lError = false;  //индикатор обнаружения ошибки в символьном представлении числа

 lSignNum = true;   //знак числа
 lIsSignNum = false;//наличие знака числа в явном виде
 lSignExp = true;   //знак порядка
 lIsSignExp = false;//наличие знака порядка числа в явном виде

 pStr = NULL;//указатель на начало строки
 szStr = 0L; //длина строки
 nPos = 0L;  //указатель на текущий обрабатываемый символ в строке

 TokenClass = dtEmpty;//класс литеры (символа)
 TokenValue = 0;      //значение (идентификатор) литеры в классе

 lIdentSpace = true;//опция распознавания пробельных символов
 lIdentSign = true; //опция распознавания символов знака числа <-+>
 lIdentPoint = true;//опция распознавания символа десятичной точки <.>
 lIdentExp = false; //опция распознавания символа порядка числа <eE>

 State = dmIdle;//текущее состояния
}
//***********************************************************************************
//СТАТУС: II.2; TStrToReal<T> private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetHndlModeTable()
//НАЗНАЧЕНИЕ:Инициализация таблицы указателей на функции-обработчики состояний класса
//адресами функций-обработчиков.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
template <class T>
void TStrToReal<T>::SetHndlModeTable()
{Table[dmIdle]    = &TStrToReal<T>::HndlIdleMode;    //1
 Table[dmSign]    = &TStrToReal<T>::HndlSignMode;    //2
 Table[dmInteger] = &TStrToReal<T>::HndlIntegerMode; //3
 Table[dmPoint]   = &TStrToReal<T>::HndlPointMode;   //4
 Table[dmReal]    = &TStrToReal<T>::HndlRealMode;    //5
 Table[dmExp]     = &TStrToReal<T>::HndlExpMode;     //6
 Table[dmExpSign] = &TStrToReal<T>::HndlExpSignMode; //7
 Table[dmExpVal]  = &TStrToReal<T>::HndlExpValMode;  //8
}
//***********************************************************************************
//СТАТУС: II.3; TStrToReal<T> private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Extract()
//НАЗНАЧЕНИЕ:Функция извлекает из строки символьное представление вещественного числа
//и переводит его в двоичное представление типа <T> (тип float, double или long double).
//В случае успешного поиска в строке символьного представления вещественного числа и
//его преобразования функция возвращает true, в противном случае - false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак преобразования последовательности символов в вещ. число
//***********************************************************************************
template <class T>
bool TStrToReal<T>::Extract()
{//Пропуск начальных пробельных символов
 const char* p = SkipSymbols(pStr,Space,nPos);
 //Все символы в исходной строке пробельные, достигнут конец строки
 if (p == NULL)
 {TokenClass = dtEOS; nPos = szStr; lSignNum = lSignExp = false; return lSuccess;}
 //Строка содержит непробельные символы, устанавливаем указатель nPos в новую позицию
 nPos = p-pStr;
 //Цикл преобразования строки символов в вещественное число
 do {LexicalBlock();} while ((*Table[State])());
 return lSuccess;
}
*/


//***********************************************************************************
//             РЕАЛИЗАЦИЯ КЛАССА TPairBrackets - ПАРНЫЕ СКОБКИ
//Left  - позиция левой скобки в строке;
//Right - позиция правой скобки в строке;
//Level - уровень вложенности парных скобок
//***********************************************************************************
//===================================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TPairBrackets
//   PUBLIC MEMBER-FUNCTION OF TPairBrackets CLASS
//===================================================================================
//*****************************************************************************
//СТАТУС: I.1; TPairBrackets public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(ulong left, ulong right, ulong level)
//НАЗНАЧЕНИЕ: Установка свойств класса. Left <= Right, в противном случае,
//Left = Right = 0 && Level = 0, функция возвращает false.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left - позиция левой скобки в строке;
//2. ulong right - позиция правой скобки в строке;
//3. ulong level - уровень вложенности пары скобок
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак завершения работы функции
//*****************************************************************************
bool TPairBrackets::Set(ulong left, ulong right, ulong level)
{if (left > right) {_Left = _Right = _Level = 0L; return false;}
 _Left = left; _Right = right; _Level = level;
 return true;
}
//****************************************************************************************
//СТАТУС: I.2; TPairBrackets public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& Properties(string& s, string& head, uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта класса в строке s, передаваемую в функцию по
//ссылке. Формат вывода свойств интервала: <head: > <[Left,Right] Level: Level()>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& head - ссылка на строку с заголовком объекта;
//3. uint indent (0) - начальное смещение строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//****************************************************************************************
string& TPairBrackets::Properties(string& s, string& head, uint indent) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 //Формирование заголовка объекта
 string space(indent,' ');
 s.assign(space);
 if (!head.empty()) s.append(head);//head.is_null()
 else s.append("TPairBrackets");
 s.append(": ");
 //Формирование свойств класса
 text << "[" << Left() << "," << Right() << "] " << ends;
 s.append(text.str()); text.seekp(0);
 text << "Level: " << Level() << endl << ends;
 s.append(text.str()); text.seekp(0);
 return s;
}
//******************************************************************************
//СТАТУС: I.3; TPairBrackets public member-function
//OVERLOADING ASSIGNMENT OPERATOR (=)
//НАИМЕНОВАНИЕ ФУНКЦИИ: TPairBrackets& operator =(const TPairBrackets& Brackets)
//НАЗНАЧЕНИЕ:Перегрузка оператора присваивания (=) для класса TPairBrackets
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//TPairBrackets& Brackets - константная ссылка на объект TPairBrackets, свойства
//которого будут скопированы в данный объект.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//TPairBrackets& - ссылка на объект, в который были скопированы свойства объекта
//TPairBrackets& Brackets.
//******************************************************************************
TPairBrackets& TPairBrackets::operator =(const TPairBrackets& Brackets)
{if (this == &Brackets) return *this;
 Set(Brackets.Left(),Brackets.Right(),Brackets.Level());
 return *this;
}
//******************************************************************************
//СТАТУС: I.4; TPairBrackets public member-function
//OVERLOADING COMPARISON OPERATOR (==)
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ==(const TPairBrackets& Brackets) const
//НАЗНАЧЕНИЕ:Перегрузка оператора сравнения (==) для класса TPairBrackets.
//Два объекта класса TPairBrackets равны между собой, если значения их уровней
//вложенности совпадают.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TPairBrackets& Brackets - константная ссылка на сравни-
//ваемый объект TPairBrackets.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lResult - булевый результат сравнения на равенство
//объектов типа TPairBrackets
//******************************************************************************
bool TPairBrackets::operator ==(const TPairBrackets& Brackets) const
{if (this == &Brackets) return true;
 return (Level() == Brackets.Level()) ? true : false;
}
//******************************************************************************
//СТАТУС: I.5; TPairBrackets public member-function
//OVERLOADING SMALLER OPERATOR (<)
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator <(const TPairBrackets& Brackets) const
//НАЗНАЧЕНИЕ:Перегрузка оператора "меньше" (<) для класса TPairBrackets.
//Исходный объект считается меньше объекта, передаваемого по ссылке, если уровень
//вложенности исходного объекта меньше уровня вложенности объекта, передаваемого
//по ссылке.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TPairBrackets& Brackets - константная ссылка на сравни-
//ваемый объект TPairBrackets.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lResult - булевый результат сравнения на "меньше"
//исходного объекта с объектом Brackets
//******************************************************************************
bool TPairBrackets::operator <(const TPairBrackets& Brackets) const
{if (this == &Brackets) return false;
 return (Level() < Brackets.Level()) ? true : false;
}
//******************************************************************************
//СТАТУС: I.6; TPairBrackets public member-function
//OVERLOADING LARGER OPERATOR (>)
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator >(const TPairBrackets& Brackets) const
//НАЗНАЧЕНИЕ:Перегрузка оператора "больше" (>) для класса TPairBrackets.
//Исходный объект считается больше объекта, передаваемого по ссылке, если уровень
//вложенности исходного объекта больше уровня вложенности объекта, передаваемого
//по ссылке.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TPairBrackets& Brackets - константная ссылка на сравни-
//ваемый объект TPairBrackets.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lResult - булевый результат сравнения на "больше"
//исходного объекта с объектом Brackets
//******************************************************************************
bool TPairBrackets::operator >(const TPairBrackets& Brackets) const
{if (this == &Brackets) return false;
 return (Level() > Brackets.Level()) ? true : false;
}

//****************************************************************************************
//СТАТУС: # 1; Friend function to TPairBrackets class
//OVERLOAD THE STREAM INSERTION OPERATOR (<<)
//НАИМЕНОВАНИЕ ФУНКЦИИ: ostream& operator <<(ostream& out, const TPairBrackets& Brackets)
//НАЗНАЧЕНИЕ: Перегрузка операции потокового вывода свойств объекта класса TPairBrackets.
//Свойства объекта выводятся в символьном виде в поток out. Функция возвращает ссылку на
//поток out, что позволяет каскадно записывать операторы вывода в поток.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на поток-приемник свойств объекта Brackets;
//2. const TPairBrackets& Brackets - ссылка на объект класса, свойства которого выводятся
//   в поток out.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ostream& operator - ссылка на поток out
//****************************************************************************************
ostream& operator <<(ostream& out, const TPairBrackets& Brackets)
{string s;
 string head("TPairBrackets");
 return out << Brackets.Properties(s,head);
}


