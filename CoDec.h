//----------------------------------------------------------------------------------------
//CoDec.h
//Copyright (c) JohnSoft 2006. All rights reserved. Builder C++ 6.0
//Initial date: September,12,2006. Final date:
//Объявление классов, реализующие функциональные преобразователи значений сигналов.
#ifndef CoDecH
#define CoDecH

#include "const.h"
#pragma hdrstop

#include "parsing.h"

//****************************************************************************************
//Предварительное объявление имен классов и функций
//****************************************************************************************
//Объявление функционального преобразователя значений сигнала с двусторонним ограничением
//по максимуму и минимуму уровней мощности и амплитуд
class TFuncGen_DSClipper;
//Производные (конкретные) классы от TFuncGen_DSClipper
class TFuncGen_DSC_LinLaw;
class TFuncGen_DSC_DecLinLaw;
class TFuncGen_DSC_SqrtLaw;
class TFuncGen_DSC_ExpLaw;
class TFuncGen_DSC_DecExpLaw;
class TFuncGen_DSC_SinLaw;
class TFuncGen_DSC_CosLaw;
class TFuncGen_DSC_HyperbolicLaw;


//****************************************************************************************
//Объявление абстрактного (базового) класса TFuncGen_DSClipper
//Copyright (c) JohnSoft 2006. All rights reserved.
//Initial date: September,12,2006; Final date:
//Класс реализует два взаимообратных функциональных преобразования значений сигналов с
//ограничением по максимальным и минимальным значениям входных и выходных значений:
//1. ПРЯМОЕ ПРЕОБРАЗОВАНИЕ:   P(U) = k*F(U) + c (модуляция, кодирование)
//2. ОБРАТНОЕ ПРЕОБРАЗОВАНИЕ: U(P) = InvF((P-c)/k) (демодуляция, декодирование)
//Условно вариант # 1 считается преобразованием уровня сигнала в значение мощности по
//закону F(U), таким образом, что при изменении уровней сигнала в интервале [Umin..Umax]
//мощность будет изменяться в пределах от [Pmin..Pmax]. Коэффициенты k и c в зависимости
//от типа функции кодирования рассчитываются следующим образом:
//1) Функция кодирования - монотонно-возрастающая (с увеличением U увеличивается P)
//   k = (Pmax - Pmin)/(F(Umax) - F(Umin)), c = Pmax - k*F(Umax);
//1) Функция кодирования - монотонно-убывающая (с увеличением U уменьшается P)
//   k = (Pmax - Pmin)/(F(Umin) - F(Umax)), c = Pmin - k*F(Umax).
//Значения Pmax, Pmin определяют пороги (максимальный и минимальный) по мощности, Umin и
//Umax задают минимальный и максимальный пороги по входным напряжениям. Должны выполняться
//следующие соотношения: Pmax > Pmin >= 0, Umax > Umin >= 0.
//Пороговый ограничитель по уровню сигнала U (модуляция) в зависимости от типа функции
//кодирования работает следующим образом:
//1) Функция кодирования - монотонно-возрастающая (с увеличением U увеличивается P):
//   a) для всех U < Umin => P = Pmin; b) для всех U > Umax => P = Pmax.
//2) Функция кодирования - монотонно-убывающая (с увеличением U уменьшается P):
//   a) для всех U < Umin => P = Pmax; b) для всех U > Umax => P = Pmin.
//Пороговый ограничитель по мощности (демодуляция) в зависимости от типа функции декодиро-
//вания работает следующим образом:
//1) Функция декодирования - монотонно-возрастающая (с увеличением P увеличивается U):
//   a) для всех P < Pmin => U = Umin; b) для всех P > Pmax => U = Umax.
//2) Функция декодирования - монотонно-убывающая (с увеличением P уменьшается U):
//   a) для всех P < Pmin => U = Umax; b) для всех P > Pmax => U = Umin.
//Вариант # 2 можно считать преобразованием мощности входного сигнала в выходное значение
//уровня сигнала по закону InvF(U), где InvF(U) - обратная F(U) функция. В этом случае при
//изменении входных мощностей в интервале [Pmin..Pmax] уровень демодулированного сигнала
//будет изменяться в пределах от Umin до Umax.
//Функциональные преобразователи F(x) и InvF(x) реализуются классами производными от данного
//абстрактного класса TFuncGen_DSClipper.
//****************************************************************************************
class TFuncGen_DSClipper {
//-----------------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ДАННЫХ КЛАССА TFuncGen_DSClipper
//-----------------------------------------------------------------------------------
protected:
 double _Umin;//Минимальный пороговый уровень сигнала
 double _Umax;//Максимальный пороговый уровень сигнала
 double _Pmin;//Минимальный  уровень мощности сигнала
 double _Pmax;//Максимальный уровень мощности сигнала
 //Коэффициенты функционального преобразователя P(U) = k*F(U) + c
 double k;//
 double c;//
 //Тип функции кодирования-декодирования - монотонно возрастающая или убывающая
 enIncDecFunc _FuncType;

//-----------------------------------------------------------------------------------
// I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TFuncGen_DSClipper
//-----------------------------------------------------------------------------------
public:
//***********************************************************************************
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TFuncGen_DSClipper
//***********************************************************************************
 //Конструктор по умолчанию
 TFuncGen_DSClipper() {_SetDefault();};
 //Конструктор с аргументами
 TFuncGen_DSClipper(const char* str) {_SetDefault(); _SetThresholds(str);};
 TFuncGen_DSClipper(double Umin, double Umax, double Pmin, double Pmax)
 {_SetDefault(); _SetThresholds(Umin,Umax,Pmin,Pmax);};

 //Объявление конструктора копирования
 //TFuncGen_DSClipper(const TFuncGen_DSClipper& Obj) {*this = Obj;};

 //Объявление деструктора класса
 virtual ~TFuncGen_DSClipper() {_Reset();};
//---------------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TFuncGen_DSClipper
//---------------------------------------------------------------------------------------
 //Получение установленных пороговых значений напряжений
 void GetThreshold_U(double& Umin, double& Umax) const {Umin = _Umin; Umax = _Umax;};
 //Получение установленных пороговых значений мощности
 void GetThreshold_P(double& Pmin, double& Pmax) const {Pmin = _Pmin; Pmax = _Pmax;};
 double GetPmin() const {return _Pmin;};
 double GetPmax() const {return _Pmax;};
 //Формирование установленных пороговых значений напряжений в строке s
 string& GetThreshold_U(string& s) const;
 //Формирование установленных пороговых значений мощности в строке s
 string& GetThreshold_P(string& s) const;
 //Формирование коэффициентов функционального преобразователя в строке s
 string& GetFactors(string& s) const;
 //Получение свойств функционального преобразователя в строковом виде
 string& Info(string& s) const;

 //Установка пороговых значений напряжения по умолчанию
 void SetDefault_U() {_Umin = 0; _Umax = 255.0; _CalcFactors();};
 //Установка пороговых значений мощности по умолчанию
 void SetDefault_P() {_Pmin = 10; _Pmax = 100.0; _CalcFactors();};
 //Установка пороговых значений по напряжению и мощности по умолчанию
 void SetDefault() {_SetDefault(); _CalcFactors();};

 //Установка пороговых значений напряжений
 void SetThreshold_U(double Umin, double Umax);
 //Установка пороговых значений мощности
 void SetThreshold_P(double Pmin, double Pmax);
 //Установка пороговых значений напряжений и мощности
 void SetThresholds(double Umin, double Umax, double Pmin, double Pmax)
 {_SetThresholds(Umin,Umax,Pmin,Pmax); _CalcFactors();};

 //Импорт из строки s пороговых значений напряжений и мощности и их установка
 void SetThresholds(const char* s) {_SetThresholds(s); _CalcFactors();};
 void SetThresholds(const string& s) {return SetThresholds(s.c_str());};

 //Прямое преобразование: P(U) = k*F(U) + c
 double Encode(double U) const;
 //Обратное преобразование: U(P) = InvF((P-c)/k)
 double Decode(double P) const;

 //Консольное редактирование свойств объекта
 virtual void Edit();

 //***************************************************************************************
 // ДРУЖЕСТВЕННЫЕ ФУНКЦИИ КЛАССА TFuncGen_DSClipper
 // 1. ФУНКЦИИ ВВОДА - ВЫВОДА ПАРАМЕТРОВ
 //***************************************************************************************
 //Перегрузка оператора вывода (<<) для вывода параметров класса
 friend ostream& operator <<(ostream& out, const TFuncGen_DSClipper& Obj)
 {string s; return out << Obj.Info(s);};

//---------------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TFuncGen_DSClipper
//---------------------------------------------------------------------------------------
protected:
 //Начальная установка параметров
 void _Reset() {_Umin = _Umax = _Pmin = _Pmax = k = c = 0.0;};
 //Установка пороговых значений по напряжению и мощности по умолчанию
 void _SetDefault() {_Umin = 0; _Umax = 255.0; _Pmin = 10; _Pmax = 100;};
 //Установка пороговых значений напряжений и мощности
 void _SetThresholds(double Umin, double Umax, double Pmin, double Pmax);
 //Импорт из строки s пороговых значений напряжений и мощности и их установка
 void _SetThresholds(const char* s);

 //Установка возрастающего типа функции кодирования
 void _SetIncFunc() {_FuncType = IncFunc;};
 //Установка убывающего типа функции кодирования
 void _SetDecFunc() {_FuncType = DecFunc;};

 //Вызов прямой (модуляционной) функции F(U)
 virtual double Func(double InU) const = 0;
 //Вызов обратной (демодуляционной) функции InvF(P)
 virtual double InvFunc(double InP) const = 0;
 //Расчет коэффициентов k & c функционального преобразователя
 virtual void _CalcFactors();
 //Вид прямой (модуляционной) функции F(U) в строковом виде
 virtual string& Func(string& s) const = 0;
 //Вид обратной (демодуляционной) функции InvF(P) в строковом виде
 virtual string& InvFunc(string& s) const = 0;

 //Консольное редактирование порогов напряжений и мощностей: Umin, Umax, Pmin и Pmax
 virtual void Edit_Thresholds();

};//Завершение объявления класса TFuncGen_DSClipper


//****************************************************************************************
//Объявление производного класса TFuncGen_DSC_LinLaw от абстрактного (базового) класса
//TFuncGen_DSClipper
//Copyright (c) JohnSoft 2006. All rights reserved.
//Initial date: September,13,2006; Final date:
//Класс наследует все свойства класса TFuncGen_DSClipper и реализует два взаимообратных
//функциональных преобразования значений сигналов с ограничением по ЛИНЕЙНОМУ ЗАКОНУ:
//1. ПРЯМОЕ ПРЕОБРАЗОВАНИЕ:   P(U) = k*F(U) + c, где F(x) = x;
//2. ОБРАТНОЕ ПРЕОБРАЗОВАНИЕ: U(P) = InvF((P-c)/k),  InvF(x) = x.
//****************************************************************************************
class TFuncGen_DSC_LinLaw : public TFuncGen_DSClipper {

//-----------------------------------------------------------------------------------
// I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TFuncGen_DSC_LinLaw
//-----------------------------------------------------------------------------------
public:
//***********************************************************************************
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TFuncGen_DSC_LinLaw
//***********************************************************************************
 //Конструктор по умолчанию
 TFuncGen_DSC_LinLaw() : TFuncGen_DSClipper() {_SetIncFunc(); _CalcFactors();};

 //Конструктор с аргументами
 TFuncGen_DSC_LinLaw(const char* str) : TFuncGen_DSClipper(str)
 {_SetIncFunc(); _CalcFactors();};

 TFuncGen_DSC_LinLaw(double Umin, double Umax, double Pmin, double Pmax) :
 TFuncGen_DSClipper(Umin,Umax,Pmin,Pmax) {_SetIncFunc(); _CalcFactors();};

 //Объявление деструктора класса
 virtual ~TFuncGen_DSC_LinLaw() {};
//---------------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TFuncGen_DSC_LinLaw
//---------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TFuncGen_DSC_LinLaw
//---------------------------------------------------------------------------------------
protected:
 //Вызов прямой (модуляционной) функции F(U)
 virtual double Func(double InU) const {return InU;};
 //virtual double Func(double U) const {return U;};
 //Вызов обратной (демодуляционной) функции InvF(P)
 virtual double InvFunc(double P) const {return P;};
 //Вид прямой (модуляционной) функции F(U) в строковом виде
 virtual string& Func(string& s) const {s.assign("F(x) = x"); return s;};
 //Вид обратной (демодуляционной) функции InvF(P) в строковом виде
 virtual string& InvFunc(string& s) const {s.assign("InvF(x) = x"); return s;};
};//Завершение объявления класса TFuncGen_DSC_LinLaw


//****************************************************************************************
//Объявление производного класса TFuncGen_DSC_DecLinLaw от абстрактного (базового) класса
//TFuncGen_DSClipper
//Copyright (c) JohnSoft 2006. All rights reserved.
//Initial date: September,13,2006; Final date:
//Класс наследует все свойства класса TFuncGen_DSClipper и реализует два взаимообратных
//функциональных преобразования значений сигналов с ограничением по УБЫВАЮЩЕМУ ЛИНЕЙНОМУ
//ЗАКОНУ:
//1. ПРЯМОЕ ПРЕОБРАЗОВАНИЕ:   P(U) = k*F(U) + c, где F(x) = x;
//2. ОБРАТНОЕ ПРЕОБРАЗОВАНИЕ: U(P) = InvF((P-c)/k),  InvF(x) = x.
//Алгоритм кодирования-декодирования реализован по убывающему линейному закону, что озна-
//чает уменьшение мощности сигнала при увеличении его амплитуды при кодировании и уменьшение
//уровня амплитуды сигнала при увеличении его мощности при декодировании.
//****************************************************************************************
class TFuncGen_DSC_DecLinLaw : public TFuncGen_DSClipper {

//-----------------------------------------------------------------------------------
// I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TFuncGen_DSC_DecLinLaw
//-----------------------------------------------------------------------------------
public:
//***********************************************************************************
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TFuncGen_DSC_DecLinLaw
//***********************************************************************************
 //Конструктор по умолчанию
 TFuncGen_DSC_DecLinLaw() : TFuncGen_DSClipper() {_SetDecFunc(); _CalcFactors();};

 //Конструктор с аргументами
 TFuncGen_DSC_DecLinLaw(const char* str) : TFuncGen_DSClipper(str)
 {_SetDecFunc(); _CalcFactors();};

 TFuncGen_DSC_DecLinLaw(double Umin, double Umax, double Pmin, double Pmax) :
 TFuncGen_DSClipper(Umin,Umax,Pmin,Pmax) {_SetDecFunc(); _CalcFactors();};

 //Объявление деструктора класса
 virtual ~TFuncGen_DSC_DecLinLaw() {};
//---------------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TFuncGen_DSC_DecLinLaw
//---------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TFuncGen_DSC_DecLinLaw
//---------------------------------------------------------------------------------------
protected:
 //Вызов прямой (модуляционной) функции F(U)
 virtual double Func(double InU) const {return InU;};
 //virtual double Func(double U) const {return U;};
 //Вызов обратной (демодуляционной) функции InvF(P)
 virtual double InvFunc(double P) const {return P;};
 //Вид прямой (модуляционной) функции F(U) в строковом виде
 virtual string& Func(string& s) const {s.assign("F(x) = x [DecFunc]"); return s;};
 //Вид обратной (демодуляционной) функции InvF(P) в строковом виде
 virtual string& InvFunc(string& s) const {s.assign("InvF(x) = x [DecFunc]"); return s;};
};//Завершение объявления класса TFuncGen_DSC_DecLinLaw


//****************************************************************************************
//Объявление производного класса TFuncGen_DSC_SqrtLaw от абстрактного (базового) класса
//TFuncGen_DSClipper
//Copyright (c) JohnSoft 2006. All rights reserved.
//Initial date: September,13,2006; Final date:
//Класс наследует все свойства класса TFuncGen_DSClipper и реализует два взаимообратных
//функциональных преобразования значений сигналов с ограничением по ОБРАТНОКВАДРАТИЧЕСКОМУ
//ЗАКОНУ:
//1. ПРЯМОЕ ПРЕОБРАЗОВАНИЕ:   P(U) = k*F(U) + c, где F(x) = Sqrt(x);
//2. ОБРАТНОЕ ПРЕОБРАЗОВАНИЕ: U(P) = InvF((P-c)/k),  InvF(x) = x^2.
//****************************************************************************************
class TFuncGen_DSC_SqrtLaw : public TFuncGen_DSClipper {

//-----------------------------------------------------------------------------------
// I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TFuncGen_DSC_SqrtLaw
//-----------------------------------------------------------------------------------
public:
//***********************************************************************************
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TFuncGen_DSC_SqrtLaw
//***********************************************************************************
 //Конструктор по умолчанию
 TFuncGen_DSC_SqrtLaw() : TFuncGen_DSClipper() {_SetIncFunc(); _CalcFactors();};
 //Конструктор с аргументами
 TFuncGen_DSC_SqrtLaw(const char* str) : TFuncGen_DSClipper(str)
 {_SetIncFunc(); _CalcFactors();};

 TFuncGen_DSC_SqrtLaw(double Umin, double Umax, double Pmin, double Pmax) :
 TFuncGen_DSClipper(Umin,Umax,Pmin,Pmax) {_SetIncFunc(); _CalcFactors();};

 //Объявление деструктора класса
 virtual ~TFuncGen_DSC_SqrtLaw() {};
//---------------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TFuncGen_DSC_SqrtLaw
//---------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TFuncGen_DSC_SqrtLaw
//---------------------------------------------------------------------------------------
protected:
 //Вызов прямой (модуляционной) функции F(U)
 virtual double Func(double U) const {return sqrt(U);};
 //Вызов обратной (демодуляционной) функции InvF(P)
 virtual double InvFunc(double P) const {return P*P;};
 //Вид прямой (модуляционной) функции F(U) в строковом виде
 virtual string& Func(string& s) const {s.assign("F(x) = Sqrt(x)"); return s;};
 //Вид обратной (демодуляционной) функции InvF(P) в строковом виде
 virtual string& InvFunc(string& s) const {s.assign("InvF(x) = x^2"); return s;};
};//Завершение объявления класса TFuncGen_DSC_SqrtLaw

//****************************************************************************************
//Объявление производного класса TFuncGen_DSC_ExpLaw от абстрактного (базового) класса
//TFuncGen_DSClipper
//Copyright (c) JohnSoft 2006. All rights reserved.
//Initial date: September,13,2006; Final date:
//Класс наследует все свойства класса TFuncGen_DSClipper и реализует два взаимообратных
//функциональных преобразования значений сигналов с ограничением по ЭКСПОНЕНЦИАЛЬНОМУ
//ЗАКОНУ:
//1. ПРЯМОЕ ПРЕОБРАЗОВАНИЕ:   P(U) = k*F(U) + c, где F(x) = Exp(x);
//2. ОБРАТНОЕ ПРЕОБРАЗОВАНИЕ: U(P) = InvF((P-c)/k),  InvF(x) = Ln(x).
//****************************************************************************************
class TFuncGen_DSC_ExpLaw : public TFuncGen_DSClipper {

//-----------------------------------------------------------------------------------
// I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TFuncGen_DSC_ExpLaw
//-----------------------------------------------------------------------------------
public:
//***********************************************************************************
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TFuncGen_DSC_ExpLaw
//***********************************************************************************
 //Конструктор по умолчанию
 TFuncGen_DSC_ExpLaw() : TFuncGen_DSClipper() {_SetIncFunc(); _CalcFactors();};
 //Конструктор с аргументами
 TFuncGen_DSC_ExpLaw(const char* str) : TFuncGen_DSClipper(str)
 {_SetIncFunc(); _CalcFactors();};

 TFuncGen_DSC_ExpLaw(double Umin, double Umax, double Pmin, double Pmax) :
 TFuncGen_DSClipper(Umin,Umax,Pmin,Pmax) {_SetIncFunc(); _CalcFactors();};

 //Объявление деструктора класса
 virtual ~TFuncGen_DSC_ExpLaw() {};
//---------------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TFuncGen_DSC_ExpLaw
//---------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TFuncGen_DSC_ExpLaw
//---------------------------------------------------------------------------------------
protected:
 //Вызов прямой (модуляционной) функции F(U)
 virtual double Func(double U) const {return exp(U);};
 //Вызов обратной (демодуляционной) функции InvF(P)
 virtual double InvFunc(double P) const {return (P <= 0) ? this->_Umin : log(P);};
 //Вид прямой (модуляционной) функции F(U) в строковом виде
 virtual string& Func(string& s) const {s.assign("F(x) = Exp(x)"); return s;};
 //Вид обратной (демодуляционной) функции InvF(P) в строковом виде
 virtual string& InvFunc(string& s) const {s.assign("InvF(x) = Ln(x)"); return s;};
};//Завершение объявления класса TFuncGen_DSC_ExpLaw

//****************************************************************************************
//Объявление производного класса TFuncGen_DSC_DecExpLaw от абстрактного (базового) класса
//TFuncGen_DSClipper
//Copyright (c) JohnSoft 2006. All rights reserved.
//Initial date: September,13,2006; Final date:
//Класс наследует все свойства класса TFuncGen_DSClipper и реализует два взаимообратных
//функциональных преобразования значений сигналов с ограничением по УБЫВАЮЩЕМУ ЭКСПОНЕН-
//ЦИАЛЬНОМУ ЗАКОНУ:
//1. ПРЯМОЕ ПРЕОБРАЗОВАНИЕ:   P(U) = k*F(U) + c, где F(x) = Exp(-x);
//2. ОБРАТНОЕ ПРЕОБРАЗОВАНИЕ: U(P) = InvF((P-c)/k),  InvF(x) = -Ln(x) = Ln(1/x).
//Алгоритм кодирования реализован убывающей по экспоненциальному закону функцией, что
//соответствует убыванию уровня мощности при возрастании амплитуды сигнала или уменьшению
//амплитуды при возрастании мощности при декодировании.
//****************************************************************************************
class TFuncGen_DSC_DecExpLaw : public TFuncGen_DSClipper {

//-----------------------------------------------------------------------------------
// I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TFuncGen_DSC_DecExpLaw
//-----------------------------------------------------------------------------------
public:
//***********************************************************************************
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TFuncGen_DSC_DecExpLaw
//***********************************************************************************
 //Конструктор по умолчанию
 TFuncGen_DSC_DecExpLaw() : TFuncGen_DSClipper() {_SetDecFunc(); _CalcFactors();};
 //Конструктор с аргументами
 TFuncGen_DSC_DecExpLaw(const char* str) : TFuncGen_DSClipper(str)
 {_SetDecFunc(); _CalcFactors();};

 TFuncGen_DSC_DecExpLaw(double Umin, double Umax, double Pmin, double Pmax) :
 TFuncGen_DSClipper(Umin,Umax,Pmin,Pmax) {_SetDecFunc(); _CalcFactors();};

 //Объявление деструктора класса
 virtual ~TFuncGen_DSC_DecExpLaw() {};
//---------------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TFuncGen_DSC_DecExpLaw
//---------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TFuncGen_DSC_DecExpLaw
//---------------------------------------------------------------------------------------
protected:
 //Вызов прямой (модуляционной) функции F(U)
 virtual double Func(double U) const {return exp(-U);};
 //Вызов обратной (демодуляционной) функции InvF(P)
 virtual double InvFunc(double P) const {return (P <= 0) ? this->_Umin : log(P);};
 //Вид прямой (модуляционной) функции F(U) в строковом виде
 virtual string& Func(string& s) const {s.assign("F(x) = Exp(-x)"); return s;};
 //Вид обратной (демодуляционной) функции InvF(P) в строковом виде
 virtual string& InvFunc(string& s) const {s.assign("InvF(x) = Ln(1/x)"); return s;};
};//Завершение объявления класса TFuncGen_DSC_DecExpLaw


//****************************************************************************************
//Объявление производного класса TFuncGen_DSC_SinLaw от абстрактного (базового) класса
//TFuncGen_DSClipper
//Copyright (c) JohnSoft 2006. All rights reserved.
//Initial date: September,13,2006; Final date:
//Класс наследует все свойства класса TFuncGen_DSClipper и реализует два взаимообратных
//функциональных преобразования значений сигналов с ограничением по СИНУСОИДАЛЬНОМУ ЗАКОНУ
//F(x) = Sin(x), с D(x) = [0..Pi/2], E(F(x) = [0..1]. В этом случае F(x) принимает вид:
//F(x) = Sin[a*(X - Xmin)], где a = 0.5*Pi/(Xmax-Xmin).
//Таким образом, коэффициенты k и c вычисляются по формулам: k = Pmax-Pmin, c = Pmin.
//1. ПРЯМОЕ ПРЕОБРАЗОВАНИЕ: P(U) = k*F(U) + c = (Pmax-Pmin)*Sin(a*(U-Umin)) + Pmin, где
//   a = 0.5Pi/(Umax-Umin);
//2. ОБРАТНОЕ ПРЕОБРАЗОВАНИЕ: U(P) = InvF((P-c)/k) = (1/a)*ArcSin((P-c)/k) + Umin.
//****************************************************************************************
class TFuncGen_DSC_SinLaw : public TFuncGen_DSClipper {
//-----------------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ДАННЫХ КЛАССА TFuncGen_DSClipper_SinLaw
//-----------------------------------------------------------------------------------
protected:
 double a;//a = 0.5Pi/(Umax-Umin)
//-----------------------------------------------------------------------------------
// I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TFuncGen_DSC_SinLaw
//-----------------------------------------------------------------------------------
public:
//***********************************************************************************
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TFuncGen_DSC_SinLaw
//***********************************************************************************
 //Конструктор по умолчанию
 TFuncGen_DSC_SinLaw() : TFuncGen_DSClipper() {_SetIncFunc(); _CalcFactors();};
 //Конструктор с аргументами
 TFuncGen_DSC_SinLaw(const char* str) : TFuncGen_DSClipper(str)
 {_SetIncFunc(); _CalcFactors();};

 TFuncGen_DSC_SinLaw(double Umin, double Umax, double Pmin, double Pmax) :
 TFuncGen_DSClipper(Umin,Umax,Pmin,Pmax) {_SetIncFunc(); _CalcFactors();};

 //Объявление деструктора класса
 virtual ~TFuncGen_DSC_SinLaw() {};
//---------------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TFuncGen_DSC_SinLaw
//---------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TFuncGen_DSC_SinLaw
//---------------------------------------------------------------------------------------
protected:
 //Расчет коэффициентов k, c и a функционального преобразователя по закону синуса
 virtual void _CalcFactors() {k = _Pmax-_Pmin; c = _Pmin; a = HalfPI/(_Umax-_Umin);};
 //Вызов прямой (модуляционной) функции F(U)
 virtual double Func(double U) const {return sin(a*(U - _Umin));};
 //Вызов обратной (демодуляционной) функции InvF(P)
 virtual double InvFunc(double P) const {return asin(P)/a + _Umin;};
 //Вид прямой (модуляционной) функции F(U) в строковом виде
 virtual string& Func(string& s) const
 {string t; _GetFactorA(t); s.assign("F(x) = Sin(a*[x-Umin]), "); s.append(t); return s;};
 //Вид обратной (демодуляционной) функции InvF(P) в строковом виде
 virtual string& InvFunc(string& s) const
 {string t; _GetFactorA(t);
  s.assign("InvF(x) = (1/a)*ArcSin(x)+Umin, "); s.append(t); return s;
 };
 //Формирование коэффициента <a = 0.5Pi/(Umax-Umin)> в строке s. Формат вывода:
 //< a = 0.5Pi/(Umax-Umin) = <d_value> >
 string& _GetFactorA(string& s) const;

};//Завершение объявления класса TFuncGen_DSC_SinLaw


//****************************************************************************************
//Объявление производного класса TFuncGen_DSC_CosLaw от абстрактного (базового) класса
//TFuncGen_DSClipper
//Copyright (c) JohnSoft 2006. All rights reserved.
//Initial date: September,13,2006; Final date:
//Класс наследует все свойства класса TFuncGen_DSClipper и реализует два взаимообратных
//функциональных преобразования значений сигналов с ограничением по КОСИНУСОИДАЛЬНОМУ ЗАКОНУ
//F(x) = Cos(x), с D(x) = [0..Pi/2], E(F(x) = [0..1]. В этом случае F(x) принимает вид:
//F(x) = Cos[a*(X - Xmin)], где a = 0.5*Pi/(Xmax-Xmin).
//Функции кодирования и декодирования реализованы как монотонно-убывающие функции, т.е.
//с возрастанием амплитуды уменьшается мощность и с возрастанием мощности уменьшается
//амплитуда.
//Таким образом, коэффициенты k и c вычисляются по формулам: k = Pmax-Pmin, c = Pmin.
//1. ПРЯМОЕ ПРЕОБРАЗОВАНИЕ: P(U) = k*F(U) + c = (Pmax-Pmin)*Cos(a*(U-Umin)) + Pmin, где
//   a = 0.5Pi/(Umax-Umin);
//2. ОБРАТНОЕ ПРЕОБРАЗОВАНИЕ: U(P) = InvF((P-c)/k) = (1/a)*ArcCos((P-c)/k) + Umin.
//****************************************************************************************
class TFuncGen_DSC_CosLaw : public TFuncGen_DSClipper {
//-----------------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ДАННЫХ КЛАССА TFuncGen_DSClipper_CosLaw
//-----------------------------------------------------------------------------------
protected:
 double a;//a = 0.5Pi/(Umax-Umin)
//-----------------------------------------------------------------------------------
// I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TFuncGen_DSC_CosLaw
//-----------------------------------------------------------------------------------
public:
//***********************************************************************************
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TFuncGen_DSC_CosLaw
//***********************************************************************************
 //Конструктор по умолчанию
 TFuncGen_DSC_CosLaw() : TFuncGen_DSClipper() {_SetDecFunc(); _CalcFactors();};
 //Конструктор с аргументами
 TFuncGen_DSC_CosLaw(const char* str) : TFuncGen_DSClipper(str)
 {_SetDecFunc(); _CalcFactors();};

 TFuncGen_DSC_CosLaw(double Umin, double Umax, double Pmin, double Pmax) :
 TFuncGen_DSClipper(Umin,Umax,Pmin,Pmax) {_SetDecFunc(); _CalcFactors();};

 //Объявление деструктора класса
 virtual ~TFuncGen_DSC_CosLaw() {};
//---------------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TFuncGen_DSC_CosLaw
//---------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TFuncGen_DSC_CosLaw
//---------------------------------------------------------------------------------------
protected:
 //Расчет коэффициентов k, c и a функционального преобразователя по закону косинуса
 virtual void _CalcFactors() {k = _Pmax-_Pmin; c = _Pmin; a = HalfPI/(_Umax-_Umin);};
 //Вызов прямой (модуляционной) функции F(U)
 virtual double Func(double U) const {return cos(a*(U - _Umin));};
 //Вызов обратной (демодуляционной) функции InvF(P)
 virtual double InvFunc(double P) const {return acos(P)/a + _Umin;};
 //Вид прямой (модуляционной) функции F(U) в строковом виде
 virtual string& Func(string& s) const
 {string t; _GetFactorA(t); s.assign("F(x) = Cos(a*[x-Umin]), "); s.append(t); return s;};
 //Вид обратной (демодуляционной) функции InvF(P) в строковом виде
 virtual string& InvFunc(string& s) const
 {string t; _GetFactorA(t);
  s.assign("InvF(x) = (1/a)*ArcCos(x)+Umin, "); s.append(t); return s;
 };
 //Формирование коэффициента <a = 0.5Pi/(Umax-Umin)> в строке s. Формат вывода:
 //< a = 0.5Pi/(Umax-Umin) = <d_value> >
 string& _GetFactorA(string& s) const;

};//Завершение объявления класса TFuncGen_DSC_CosLaw


//****************************************************************************************
//Объявление производного класса TFuncGen_DSC_HyperbolicLaw от абстрактного (базового)
//класса TFuncGen_DSClipper
//Copyright (c) JohnSoft 2006. All rights reserved.
//Initial date: September,13,2006; Final date:
//Класс наследует все свойства класса TFuncGen_DSClipper и реализует два взаимообратных
//функциональных преобразования значений сигналов с ограничением по ГИПЕРБОЛИЧЕСКОМУ ЗАКОНУ:
//1. ПРЯМОЕ ПРЕОБРАЗОВАНИЕ:   P(U) = k*F(U) + c, где F(x) = 1/(x+1);
//2. ОБРАТНОЕ ПРЕОБРАЗОВАНИЕ: U(P) = InvF((P-c)/k),  InvF(x) = 1/x - 1 = k/(P-c) - 1.
//****************************************************************************************
class TFuncGen_DSC_HyperbolicLaw : public TFuncGen_DSClipper {

//-----------------------------------------------------------------------------------
// I. ОБЪЯВЛЕНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TFuncGen_DSC_HyperbolicLaw
//-----------------------------------------------------------------------------------
public:
//***********************************************************************************
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРА КЛАССА TFuncGen_DSC_HyperbolicLaw
//***********************************************************************************
 //Конструктор по умолчанию
 TFuncGen_DSC_HyperbolicLaw() : TFuncGen_DSClipper() {_SetDecFunc(); _CalcFactors();};

 //Конструктор с аргументами
 TFuncGen_DSC_HyperbolicLaw(const char* str) : TFuncGen_DSClipper(str)
 {_SetDecFunc(); _CalcFactors();};

 TFuncGen_DSC_HyperbolicLaw(double Umin, double Umax, double Pmin, double Pmax) :
 TFuncGen_DSClipper(Umin,Umax,Pmin,Pmax) {_SetDecFunc(); _CalcFactors();};

 //Объявление деструктора класса
 virtual ~TFuncGen_DSC_HyperbolicLaw() {};
//---------------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TFuncGen_DSC_HyperbolicLaw
//---------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TFuncGen_DSC_HyperbolicLaw
//---------------------------------------------------------------------------------------
protected:
 //Вызов прямой (модуляционной) функции F(U)
 virtual double Func(double InU) const {return 1/(InU+1.0);};
 //Вызов обратной (демодуляционной) функции InvF(P)
 virtual double InvFunc(double P) const {return 1/P-1.0;};
 //Вид прямой (модуляционной) функции F(U) в строковом виде
 virtual string& Func(string& s) const {s.assign("F(x) = 1/(x+1)"); return s;};
 //Вид обратной (демодуляционной) функции InvF(P) в строковом виде
 virtual string& InvFunc(string& s) const {s.assign("InvF(x) = 1/x - 1"); return s;};
};//Завершение объявления класса TFuncGen_DSC_HyperbolicLaw


//--------------------------- The end of file "CoDec.h" ----------------------------------
#endif //ЗАВЕРШЕНИЕ ОБЪЯВЛЕНИЯ ЗАГОЛОВОЧНОГО ФАЙЛА "CoDec.h"
