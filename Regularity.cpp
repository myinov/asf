//----------------------------------------------------------------------------------------
//Regularity.cpp
//Реализация классов, связанных с исследованием влияния внутрисистемных возмущений на
//качество работы адаптивных информационных систем и алгоритмов регуляризации, призванных
//улучшить работу адаптивной системы в условиях присутствия внутрисистемных возмущений.
//Initial date: December,20,2006. Final date:
//Copyright (c) JohnSoft 2006. All rights reserved. C++ Builder 6
//----------------------------------------------------------------------------------------
#pragma hdrstop

#include "Regularity.h"

#pragma package(smart_init)

//****************************************************************************************
//                          РЕАЛИЗАЦИЯ КЛАССА TCovMatrixPerturbOperator
//Класс реализует матричный оператор возмущения ковариационной матрицы. Матричный оператор
//является эрмитовой матрицей. Данный класс является абстрактным. Классы-наследники реали-
//зуют конкретные функции распределения случайной величины с заданной дисперсией и нулевым
//математическим ожиданием.
//****************************************************************************************

//========================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TCovMatrixPerturbOperator
//    PUBLIC MEMBER-FUNCTION OF TCovMatrixPerturbOperator CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TCovMatrixPerturbOperator class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Disturb(cmatrix& A, double Disp)
//Возмущение ковариационной матрицы A случайным процессом с нулевым математическим
//ожиданием и дисперсией Disp. Матрица A, передаваемая в функцию по ссылке, изменяется
//при работе функции. Функция возвращает true при успешном возмущении матрицы A и false
//в противном случае. Матрица A должна быть эрмитовой, с целью ускорения работы функция
//проверяет матрицу A является она квадратной или нет.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& A - ссылка на матрицу, элементы которой подвергаются случайным возмущениям;
//2. double Disp - значение дисперсии случайного возмущающего процесса.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TCovMatrixPerturbOperator::Disturb(cmatrix& A, double Disp)
{//Проверка матрицы A на ее корректность
 if (A.IsZeroSize() || (A.Rows() != A.Cols())) return false;
 if (Disp == 0.0) return true;//При Disp == 0.0 матрица A не изменяется
 //Формируем возмущающий оператор dA размерности равной матрице A
 cmatrix dA;
 if (!this->GetDistOperator(dA,A,Disp)) return false;
 //Возмущение элементов матрицы A: A = A + dA
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   A.Put(i,j,A.Get(i,j) + dA.Get(i,j));
 return true;
}
//****************************************************************************************
//СТАТУС: I.2; public; TCovMatrixPerturbOperator class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Disturb(cmatrix& B, const cmatrix& A, double Disp)
//Возмущение ковариационной матрицы A случайным процессом с нулевым математическим
//ожиданием и дисперсией Disp. Матрица A, передаваемая в функцию по ссылке, не изменяется
//при работе функции. Возмущенная матрица A + dA формируется в матрице B, которая изменяется
//при работе функции. Функция возвращает true при успешном возмущении матрицы A и false
//в противном случае. Матрица A должна быть эрмитовой, с целью ускорения работы функция
//проверяет матрицу A является она квадратной или нет. В случае неудачи матрица B становится
//матрицей нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& B - ссылка на результирующую матрицу вида A + dA;
//2. const cmatrix& A - ссылка на матрицу, элементы которой подвергаются случайным возмущениям;
//3. double Disp - значение дисперсии случайного возмущающего процесса.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TCovMatrixPerturbOperator::Disturb(cmatrix& B, const cmatrix& A, double Disp)
{//Проверка матрицы A на ее корректность
 if (A.IsZeroSize() || (A.Rows() != A.Cols())) {B.Set(0,false); return false;}
 B = A;
 if (B.IsZeroSize()) return false;
 if (Disp == 0.0) return true;//При Disp == 0.0 матрица A не изменяется
 //Формируем возмущающий оператор dA размерности равной матрице A
 cmatrix dA;
 if (!this->GetDistOperator(dA,B,Disp)) return false;
 //Возмущение элементов матрицы B: A = A + dA
 for (ulong i = 0L; i < B.Rows(); i++)
  for (ulong j = 0L; j < B.Cols(); j++)
   B.Put(i,j,B.Get(i,j) + dA.Get(i,j));
 return true;
}
//****************************************************************************************
//СТАТУС: I.3; public; TCovMatrixPerturbOperator class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool GetDistVector(cvector& dV, ulong N, double NormA, double RelDisp)
//Формирование вектора dV, передаваемого по ссылке, возмущений комплексной СВ, согласованный
//с евклидовой нормой матрицы NormA размерности N, по случайному закону с заданным распре-
//делением с нулевым MO и относительной дисперсией RelDisp. Функция возвращает true при
//удачном формировании возмущенного вектора и false - в противном случае. В случае неудачи
//возвращается вектор dV нулевого размера.
//Пересчет относительной дисперсии RelDisp внутрисистемных ошибок в ковариационной матрице
//A в реальную Disp для комплексного случайного вектора, соответствующего данной матрице
//осуществляется по формуле: Disp = sqrt(0.5*RelDisp)*NormA/N.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& dV - ссылка на вектор-приемник, реализаций комплексной СВ;
//2. ulong N - размерность вектора-приемника dV (ковариационной матрицы A);
//3. double NormA - евклидова норма ковариационной матрицы A;
//4. double RelDisp - значение относительной дисперсии случайного процесса, по которому
//   возмущаются элементы ковариационной матрицы A.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TCovMatrixPerturbOperator::GetDistVector(cvector& dV, ulong N, double NormA,
     double RelDisp)
{//Проверка возможности создания вектора dV
 if (N == 0) {dV.Set(0,COL,false); return false;}
 //Пересчитываем относительную дисперсию RelDisp для матрицы A в реальную дисперсию для
 //вектора dV, согласованного с возмущающим оператором для матрицы A
 double Disp = 0.5*sqrt(RelDisp)*(NormA/N);
 //Формируем комплексный случайный вектор размерности N с нулевым МО, дисперсией Disp и
 //заданным законом распределения
 return this->GetRandVector(dV,N,Disp);
}
//****************************************************************************************
//СТАТУС: I.4; public; TCovMatrixPerturbOperator class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool GetDistOpAsSymmetrMatrix(cmatrix& dA, ulong N, double NormA, double RelDisp)
//Формирование матричного оператор возмущения dA как симметрическую комплексную матрицу,
//элементы которой распределены по случайному закону с нулевым МО, относительной дисперсией
//RelDisp для исходной матрицы A размерности N и евклидовой нормой NormA.
//Оператор возмущения формируется в матрице dA, передаваемой в функцию по ссылке. Матрица
//dA является комплексной квадратной матрицей с наддиагональными и поддиагональными комп-
//лексно-сопряженными элементами размерности равной матрице A. Матрица A задает размерность
//матрицы dA. Относительная дисперсия RelDisp пересчитывается в значение дисперсии Disp для
//каждого случайного комплексного значения матрицы dA по формуле:
// Disp = 0.5*RelDisp*NormA^2/N^2.
//Далее формируется случайный вектор комплексных величин с заданным законом распределения,
//нулевым МО, дисперсией Disp размерности N(N+1)/2, что позволяет сформировать диагональные
//и поддиагональные элементы матрицы dA и комплексно-сопряженные наддиагональные элементы
//матрицы dA с ее поддиагональными элементами. С этой целью осуществляется вызов виртуаль-
//ной функции GetRandVector(cvector& V, ulong size, double Disp), которая реализуется неза-
//висимо для каждого производного класса TCovMatrixPerturbOperator, что позволяет реализо-
//вать разные законы распределения для комплексных СВ с заданными статистическими парамет-
//рами - нулевым МО и дисперсией Disp.
//Функция возвращает true при успешном формировании dA и false - в противном случае. В случае
//неудачи создается матрица dA нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& dA - ссылка на матрицу-приемник, в которой формируется оператор возмущения;
//2. ulong N - размерность матричного оператора возмущения dA;
//3. double NormA - евклидова норма ковариационной возмущаемой матрицы A;
//4. double RelDisp - значение относительной дисперсии случайного процесса.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TCovMatrixPerturbOperator::GetDistOpAsSymmetrMatrix(cmatrix& dA, ulong N, double NormA,
     double RelDisp)
{double Disp;
 ulong szRandVect;
 ulong index;
 cvector RandVect;
 complex z;
 bool lSuccess;
 //Нулевой относительной дисперсии RelDisp или нулевой норме NormA соответствует матрица dA
 //с нулевыми элементами размерности N
 if (RelDisp == 0.0 || NormA == 0.0) return dA.Set(N,C_ZERO);
 //Проверка на матрицу нулевого размера
 if (N == 0) {dA.Set(0,false); return false;}
 //Устанавливаем матрицу dA размерности N
 if (dA.Set(N,false) == false) return false;
 //Пересчет относительной дисперсии RelDisp в дисперсию Disp
 Disp = (0.5*RelDisp*NormA*NormA)/(N*N);
 //Рассчитываем размерность случайного вектора для формирования диагональных и поддиагональных
 //элементов матрицы dA размерности N
 szRandVect = N*(N+1);
 szRandVect = szRandVect >> 1;
 //Вызов виртуальной функции, формирующий комплексный случайный вектор для заданного закона
 //распределения с нулевым МО и дисперсией Disp
 lSuccess = this->GetRandVector(RandVect,szRandVect,Disp);
 if (!lSuccess) {dA.Set(0,false); return false;};
 //Формируем элементы матрицы dA
 index = 0;
 for (ulong i = 0L; i < N; i++)
  for (ulong j = 0L; j <= i; j++)
  {z = RandVect.Get(index++);
   if (i == j) dA.Put(i,i,z);
   else {dA.Put(i,j,z); dA.Put(j,i,conj(z));}
  }
 return true;
}
//****************************************************************************************
//СТАТУС: I.5; public; TCovMatrixPerturbOperator class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool GetDistOpByVector(cmatrix& dA, ulong N, double NormA, double RelDisp)
//Формирование матричного оператор возмущения dA как ковариационную матрицу по вектору V,
//элементы которого распределены по случайному закону с нулевым МО, относительной дисперсией
//RelDisp для исходной матрицы A размерности N и евклидовой нормой NormA: dA = dV*Tr(dV).
//Оператор dA, сформированный таким способом, соответствует случаю независимости внутрисис-
//темных возмущений.
//Оператор возмущения формируется в матрице dA, передаваемой в функцию по ссылке. Матрица
//dA является эрмитовой. Относительная дисперсия RelDisp пересчитывается в значение диспер-
//сии Disp для каждого случайного комплексного значения матрицы dA с учетом операции пере-
//множения по формуле: Disp = 0.5*sqrt(RelDisp)*NormA/N.
//Далее формируется случайный вектор комплексных величин с заданным законом распределения,
//нулевым МО, дисперсией Disp размерности N, что позволяет сформировать элементы матрицы dA
//как ковариационную матрицу. С целью формирования вектора осуществляется вызов виртуальной
//функции GetRandVector(cvector& V, ulong size, double Disp), которая реализуется независимо
//для каждого производного класса TCovMatrixPerturbOperator, что позволяет задавать разные
//законы распределения для комплексных СВ с заданными статистическими параметрами - нулевым
//МО и дисперсией Disp.
//Функция возвращает true при успешном формировании dA и false - в противном случае. В случае
//неудачи создается матрица dA нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& dA - ссылка на матрицу-приемник, в которой формируется оператор возмущения;
//2. ulong N - размерность матричного оператора возмущения dA;
//3. double NormA - евклидова норма ковариационной возмущаемой матрицы A;
//4. double RelDisp - значение относительной дисперсии случайного процесса.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TCovMatrixPerturbOperator::GetDistOpByVector(cmatrix& dA, ulong N, double NormA,
     double RelDisp)
{double Disp;
 cvector dV;
 bool lSuccess;
 //Нулевой относительной дисперсии RelDisp или нулевой норме NormA соответствует матрица dA
 //с нулевыми элементами размерности N
 if (RelDisp == 0.0 || NormA == 0.0) return dA.Set(N,C_ZERO);
 //Проверка на матрицу нулевого размера
 if (N == 0) {dA.Set(0,false); return false;}
 //Пересчет относительной дисперсии RelDisp в дисперсию Disp
 Disp = 0.5*sqrt(RelDisp)*(NormA/N);
 //Вызов виртуальной функции, формирующий комплексный случайный вектор для заданного закона
 //распределения с нулевым МО и дисперсией Disp
 lSuccess = this->GetRandVector(dV,N,Disp);
 if (!lSuccess) {dA.Set(0,false); return false;};
 //Формируем dA по вектору dV: dA = dV*Tr(dV)
 return CorrelationMatrix(dV,dA);
}

//****************************************************************************************
//                          РЕАЛИЗАЦИЯ КЛАССА TDisturbCovMatrix_Random
//Класс наследует все свойства класса TCovMatrixPerturbOperator и реализует случайный про-
//цесс с нулевым математическим ожиданием, заданной дисперсией по равномерному закону
//распределения. Формула соответствия интервала распределения [-a..a] и значения дисперсии
//D' следующая: a = sqrt(3D). Таким образом, ГСЧ для дисперсии D' должны вырабатываться
//числа равномерно распределенные в интервале: [-sqrt(3D') .. sqrt(3D'].
//P.S. При построении матрицы возмущений dA ковариационной матрицы A в функции-члены клас-
//са передаются обобщенные значения дисперсии D, которые не учитывают конкретную структуру
//возмущаемой ковариационной матрицы A. При выработке случайных значений элементов матрицы
//dA используется значение дисперсии D', учитывающее структуру матрицы A. Формула связи
//между D и D' следующая: D' = ||A||^2*D/N^2.
//****************************************************************************************

//========================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TDisturbCovMatrix_Random
//    PUBLIC MEMBER-FUNCTION OF TDisturbCovMatrix_Random CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TDisturbCovMatrix_Random class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetDistOperator(cmatrix& dA, const cmatrix& A, double Disp)
//Построение матричного оператора возмущения dA для ковариационной матрицы A. Элементы
//матрицы dA подчиняются равномерному закону распределения с нулевым мат. ожиданием и
//дисперсией D' = ||A||^2*D/N^2. Дисперсии D' будет соответствовать равномерно распределен-
//ная СВ на интервале [-sqrt(3D') .. sqrt(3D'].
//Оператор возмущения формируется в матрице dA, передаваемой в функцию по ссылке. Матрица
//dA является комплексной квадратной матрицей с наддиагональными и поддиагональными комп-
//лексно-сопряженными элементами размерности равной матрице A. Матрица A задает размерность
//матрицы dA, по ее элементам рассчитывается евклидова норма ||A||, которая используется
//для пересчета обобщенного значения дисперсии Disp в действительное значение D', которое
//используется при формировании случайных элементов матрицы dA.
//Функция возвращает true при успешном формировании dA и false - в противном случае.
//В случае неудачи создается матрица dA нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& dA - ссылка на матрицу-приемник, в которой формируется оператор возмущения;
//2. cmatrix& A  - ссылка на ковариационну матрицу, для которой строится матрица dA;
//3. double Disp - значение обобщенной дисперсии случайного процесса.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TDisturbCovMatrix_Random::GetDistOperator(cmatrix& dA, const cmatrix& A, double Disp)
{//Проверка матрицы A на ее корректность
 if (A.IsZeroSize() || (A.Rows() != A.Cols())) {dA.Set(0,false); return false;}

 ulong N = A.Rows(); //Размерность ковариационной матрицы A
 double NormA;       //Евклидова норма матрицы A
 double a;
 complex z;

 //Нулевой дисперсии соответствует матрица dA с нулевыми элементами размерности N
 if (Disp == 0.0) return dA.Set(N,C_ZERO);
 //Устанавливаем матрицу dA размерности N
 if (dA.Set(N,false) == false) return false;
 //Вычисляем евклидову норму матрицы A
 NormA = A.ThirdNorm();
 //Пересчет обобщенного значения дисперсии D на интервал, равномерно распределенной СВ,
 //с учетом нормы и размерности матрицы A
 a = sqrt(3*fabs(Disp))*(NormA/N);
 a = a/sqrt(2);
 //Формируем матрицу dA равномерно распределенных СВ на интервале [-a..a] с комплексно-
 //сопряженными над- и поддиагональными элементами
 for (ulong i = 0L; i < N; i++)
  for (ulong j = 0L; j <= i; j++)
  {RandGen.Random(z,-a,a);
   if (i == j) dA.Put(i,i,z);
   else {dA.Put(i,j,z); dA.Put(j,i,conj(z));}
  }
 return true;
}
//****************************************************************************************
//СТАТУС: I.1; protected; TDisturbCovMatrix_Random class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetRandVector(cvector& V, ulong size, double Disp)
//НАЗНАЧЕНИЕ: Формирование в векторе V, передаваемом по ссылке, реализаций комплексной СВ
//с дисперсией Disp, нулевым мат. ожиданием с равномерным законом распределения. Функция
//возвращает true при успешном формировании вектора V и false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& V - ссылка на вектор-приемник реализаций равномерно распределенной СВ;
//2. ulong size - размерность вектора;
//3. double Disp - значение дисперсии.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TDisturbCovMatrix_Random::GetRandVector(cvector& V, ulong size, double Disp)
{Disp = fabs(Disp);
 if (Disp == 0.0) return V.Set(size,COL,C_ZERO);
 //Пересчет значения дисперсии на интервал равномерно распределенной СВ
 double a = sqrt(3*Disp);
 return this->RandGen.RandomVector(V,size,-a,a);
}

//****************************************************************************************
//                          РЕАЛИЗАЦИЯ КЛАССА TDisturbCovMatrix_Gauss
//Класс наследует все свойства класса TCovMatrixPerturbOperator и реализует случайный про-
//цесс с нулевым математическим ожиданием, заданной дисперсией по нормальному закону.
//Для получения нормально распределенной СВ с M = 0 и дисперсией D' используется датчик,
//вырабатывающий нормально распределенную СВ X с Mx = 0 и Dx = 1. Далее используется форму-
//ла перехода к нормально распределенной СВ Y с произвольным мат. ожиданием M и дисперсией
//D': Y = M + sqrt(D')*X. В случае M = 0 получаем Y = sqrt(D')*X.
//P.S. При построении матрицы возмущений dA ковариационной матрицы A в функции-члены клас-
//са передаются обобщенные значения дисперсии D, которые не учитывают конкретную структуру
//возмущаемой ковариационной матрицы A. При выработке случайных значений элементов матрицы
//dA используется значение дисперсии D', учитывающее структуру матрицы A. Формула связи
//между D и D' следующая: D' = ||A||^2*D/N^2.
//****************************************************************************************

//========================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TDisturbCovMatrix_Gauss
//    PUBLIC MEMBER-FUNCTION OF TDisturbCovMatrix_Random CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TDisturbCovMatrix_Gauss class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetDistOperator(cmatrix& dA, const cmatrix& A, double Disp)
//Построение матричного оператора возмущения dA для ковариационной матрицы A. Элементы мат-
//рицы dA подчиняются нормальному закону распределения с нулевым мат. ожиданием и диспер-
//сией D' = ||A||^2*D/N^2.
//Оператор возмущения формируется в матрице dA, передаваемой в функцию по ссылке. Матрица
//dA является комплексной квадратной матрицей с наддиагональными и поддиагональными комп-
//лексно-сопряженными элементами размерности равной матрице A. Матрица A задает размерность
//матрицы dA, по ее элементам рассчитывается евклидова норма ||A||, которая используется
//для пересчета обобщенного значения дисперсии Disp в действительное значение D', которое
//используется при формировании случайных элементов матрицы dA.
//Функция возвращает true при успешном формировании dA и false - в противном случае.
//В случае неудачи создается матрица dA нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& dA - ссылка на матрицу-приемник, в которой формируется оператор возмущения;
//2. cmatrix& A  - ссылка на ковариационну матрицу, для которой строится матрица dA;
//3. double Disp - значение обобщенной дисперсии случайного процесса.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TDisturbCovMatrix_Gauss::GetDistOperator(cmatrix& dA, const cmatrix& A, double Disp)
{//Проверка матрицы A на ее корректность
 if (A.IsZeroSize() || (A.Rows() != A.Cols())) {dA.Set(0,false); return false;}

 ulong N = A.Rows(); //Размерность ковариационной матрицы A
 double NormA;       //Евклидова норма матрицы A
 complex z;

 //Нулевой дисперсии соответствует матрица dA с нулевыми элементами размерности N
 if (Disp == 0.0) return dA.Set(N,C_ZERO);
 //Устанавливаем матрицу dA размерности N
 if (dA.Set(N,false) == false) return false;
 //Вычисляем евклидову норму матрицы A
 NormA = A.ThirdNorm();
 //Пересчет обобщенного значения дисперсии D в значение дисперсии нормально распределенной
 //СВ, с учетом нормы и размерности матрицы A
 Disp = (fabs(Disp)*NormA*NormA)/(N*N);
 Disp = Disp/2;
 //Формируем матрицу dA равномерно распределенных СВ на интервале [-a..a] с комплексно-
 //сопряженными над- и поддиагональными элементами
 for (ulong i = 0L; i < N; i++)
  for (ulong j = 0L; j <= i; j++)
  {RandGen.Gauss(z,0.0,Disp);
   if (i == j) dA.Put(i,i,z);
   else {dA.Put(i,j,z); dA.Put(j,i,conj(z));}
  }
 return true;
}
//****************************************************************************************
//СТАТУС: I.1; protected; TDisturbCovMatrix_Gauss class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetRandVector(cvector& V, ulong size, double Disp)
//НАЗНАЧЕНИЕ: Формирование в векторе V, передаваемом по ссылке, реализаций комплексной СВ
//с дисперсией Disp, нулевым МО с нормальным законом распределения. Функция возвращает true
//при успешном формировании вектора реализаций СВ и false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& V - ссылка на вектор-приемник реализаций нормально распределенной СВ;
//2. ulong size - размерность вектора;
//3. double Disp - значение дисперсии.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TDisturbCovMatrix_Gauss::GetRandVector(cvector& V, ulong size, double Disp)
{Disp = fabs(Disp);
 if (Disp == 0.0) return V.Set(size,COL,C_ZERO);
 //Формирование в векторе V нормально распределенной СВ (комплексной) с M = 0 и дисперсией
 //Disp
 return this->RandGen.GaussVector(V,size,0.0,Disp);
}

//****************************************************************************************
//                          РЕАЛИЗАЦИЯ КЛАССА TCovMatrixInversion
// Базовый абстрактный класс построения обратной матрицы к ковариационной матрице, которая
// может быть возмущенной. Ковариационная матрица является эрмитовой - комплексный аналог
// вещественной симметрической матрицы. Производные классы реализуют различные методы (схемы)
// регуляризации исходной ковариационной матрицы перед ее обращением, что дает возможность
// в зависимости от выбранного параметра регуляризации и регуляризирующего алгоритма компен-
// сировать внутрисистемные ошибки информационной системы, которые вызывают возмущение
// исходной ковариационной матрицы. Таким образом, в условиях внутрисистемных возмущений
// регуляризация возмущенной матрицы входного процесса дает возможность повысить устойчи-
// вость и точность решения (нахождения обратной матрицы к ковариационной матрице).
// При обращении матрицы не осуществляется ее проверка на эрмитовость с целью убыстрения
// работы, проверяется только ее квадратность. Алгоритм обращения матрицы реализуется по
// схеме Краута применительно к комплексной матрицы (без учета ее эрмитовости).
//****************************************************************************************

//========================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TCovMatrixInversion
//    PUBLIC MEMBER-FUNCTION OF TCovMatrixInversion CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TCovMatrixInversion class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Info(string& s) const
//Формирование свойств объекта в строке s, передаваемой по ссылке. Возвращается ссылка на
//строку s. Предыдущее содержимое строки s уничтожается. Формат представления сведений об
//объекте:
//<-------------------------------------------------------------------------------------->
// Inversion of the Covariation Matrix:
// 1. Method: <TCovMatrixInversion->Method(string_arg)>;
// 2. Algorithm: <TCovMatrixInversion->Algorithm(string_arg)>.
//<-------------------------------------------------------------------------------------->
//Пункты 1 и 2 формируются вызовами виртуальных функций производных классов, так как именно
//они реализуют конкрентные схемы регуляризации ковариационной матрицы для ее последующего
//обращения.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// string& s - ссылка на строку-приемник свойств объекта класса в символьном виде.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с представлением свойств объекта.
//****************************************************************************************
string& TCovMatrixInversion::Info(string& s) const
{string t;
 s.assign("Inversion of the Covariation Matrix\n");
 //Полное наименование метода регуляризации
 s.append(" 1. Method: "); this->Method(t,false); s.append(t); s.append(";\n");
 //Алгоритм обращения матрицы с использованием метода регуляризации
 s.append(" 2. Algorithm: "); this->Algorithm(t); s.append(t); s.append(".\n");
 return s;
}
//****************************************************************************************
//СТАТУС: I.2; public; TCovMatrixInversion class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: virtual void Edit()
//НАЗНАЧЕНИЕ: Консольное редактирование свойств объекта класса TCovMatrixInversion.
//Свойства большинства объектов производных от класса TCovMatrixInversion не нуждаются в
//редактировании, поэтому данная функция только отображает свойства объекта и сигнализирует
//о том, что свойства объекта не редактируются.
//----------------------------------------------------------------------------------------
//< Edit < Covariation Matrix Inversion Operator >
//< Inversion Operator properties>
//  1. Edit < No data to be edited !!!>
//  2. Exit
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TCovMatrixInversion::Edit()
{//Рабочие переменные
 STR_UINT EditOpts[2] = {
 {1, "Edit < No data to be edited !!! >"},
 {2, "Exit"} };
 TB_STR_UINT EditMenu = {2,EditOpts};
 int row_start = wherey();
 int choice;
 bool flag = true;
 string s, line(78,'-');
 string h("Edit < Covariation Matrix Inversion Operator >");

 gotoxy(1,row_start); clreol();
 do //Цикл редактирования свойств объекта
 {cout << line << endl << h << endl;
  cout << this->Info(s) << endl << line << endl;
  //Выбор опции редактирования
  s = "Choose option [1..2]: ";
  choice = ConsoleChoice(EditMenu,1,s.c_str(),1);
  switch (choice)
  {case 1:
    ClrScr(1,row_start);
    break;
   case 2: flag = false; break;
  }
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}

//****************************************************************************************
//                          РЕАЛИЗАЦИЯ КЛАССА TInvCovMatrix_Classical
//Класс наследует свойства класса TCovMatrixInversion и реализует прямой метод обращения
//ковариационной матрицы без ее регуляризации по схеме Краута (для комплексных матриц).
//Таким образом, такой класс реализует классический подход к вычислению обратной матрицы,
//что не позволяет компенсировать наличие внутрисистемных ошибок в исходной ковариационной
//матрице, подлежащей обращению.
//****************************************************************************************

//========================================================================================
// II. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TInvCovMatrix_Classical
//     PUBLIC MEMBER-FUNCTION OF TInvCovMatrix_Classical CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TInvCovMatrix_Classical class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Method(string& s, bool lBrief = true) const
//НАЗНАЧЕНИЕ: Формирование в строке s, передаваемой по ссылке, наименования метода регуля-
//ризации. Прежнее содержимое s удаляется. Опция lBrief определяет сокращенную или полную
//форму наименования метода. Функция возвращает ссылку на s.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку-приемник наименования метода регуляризации;
//2. bool lBrief (true) - опция определяющая сокращенное (true) или полное наименование
//   метода регуляризации.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с наименованием метода регуляризации
//****************************************************************************************
string& TInvCovMatrix_Classical::Method(string& s, bool lBrief) const
{if (lBrief) s.assign("CLS");
 else s.assign("Classical without matrix regularity");
 return s;
}
//****************************************************************************************
//СТАТУС: I.2; public; TInvCovMatrix_Classical class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Algorithm(string& s) const
//НАЗНАЧЕНИЕ: Формирование в строке s, передаваемой по ссылке, алгоритма обращения ковариа-
//ционной матрицы с учетом или без ее регуляризации. Прежнее содержимое s удаляется.
//Функция возвращает ссылку на s.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строку-приемник алгоритма обращения матрицы;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с алгоритмом обращения матрицы.
//****************************************************************************************
string& TInvCovMatrix_Classical::Algorithm(string& s) const
{s.assign("Inv(A)");
 return s;
}
//****************************************************************************************
//СТАТУС: I.3; public; TInvCovMatrix_Classical class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Inverse(cmatrix& InvA, const cmatrix& A, double a = 0) const
//НАЗНАЧЕНИЕ: Обращение ковариационной матрицы A методом Краута. Результат обращения фор-
//мируется в матрице InvA, передаваемой в функцию по ссылке. Матрица A функцией не изменяется.
//Параметр регуляризации a функцией не используется. Функция возвращает результат обращения
//матрицы. Для успешного обращения матрицы A необходимо, чтобы она была квадратной и
//невырожденной. В противном случае функция возвращает false и матрицу InvA нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& InvA - ссылка на матрицу, в которой формируется обратная матрица к A;
//2. const cmatrix& A - ссылка на ковариационную матрицу, подлежащую обращению;
//3. double a - параметр регуляризации.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат обращения матрицы A.
//****************************************************************************************
bool TInvCovMatrix_Classical::Inverse(cmatrix& InvA, const cmatrix& A, double a) const
{a = fabs(a);
 //Обращение матрицы A методом Краута
 InvA = A.INV_Krauth();
 return !InvA.IsZeroSize();
}

//****************************************************************************************
//                          РЕАЛИЗАЦИЯ КЛАССА TInvCovMatrix_Laurentiev
//Класс наследует свойства класса TCovMatrixInversion и реализует метод обращения ковариа-
//ционной матрицы c ее регуляризацией по методу Лаврентьева:
// InvA = Inv(A + aI), где
// 1) a - параметр регуляризации (a >= 0);
// 2) A - возмущенная ковариационная матрица;
// 3) I - единичная матрица размерности равной A.
//При согласованном выборе параметра регуляризации с диспресией внутрисистемных ошибок,
//присутствующих в матрице A и ее структуры метод Лаврентьева позволяет компенсировать
//влияние возмущений на вычисление обратной матрицы InvA. Обращение регуляризированной по
//методу Лаврентьева матрицы (A+aI) выполняется по алгоритму Краута.
//****************************************************************************************

//========================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TInvCovMatrix_Laurentiev
//    PUBLIC MEMBER-FUNCTION OF TInvCovMatrix_Laurentiev CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TInvCovMatrix_Laurentiev class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Method(string& s, bool lBrief = true) const
//НАЗНАЧЕНИЕ: Формирование в строке s, передаваемой по ссылке, наименования метода регуля-
//ризации. Прежнее содержимое s удаляется. Опция lBrief определяет сокращенную или полную
//форму наименования метода. Функция возвращает ссылку на s.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку-приемник наименования метода регуляризации;
//2. bool lBrief (true) - опция определяющая сокращенное (true) или полное наименование
//   метода регуляризации.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с наименованием метода регуляризации
//****************************************************************************************
string& TInvCovMatrix_Laurentiev::Method(string& s, bool lBrief) const
{if (lBrief) s.assign("LAVR");
 else s.assign("Laurentiev");
 return s;
}
//****************************************************************************************
//СТАТУС: I.2; public; TInvCovMatrix_Laurentiev class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Algorithm(string& s) const
//НАЗНАЧЕНИЕ: Формирование в строке s, передаваемой по ссылке, алгоритма обращения ковариа-
//ционной матрицы с учетом или без ее регуляризации. Прежнее содержимое s удаляется.
//Функция возвращает ссылку на s.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строку-приемник алгоритма обращения матрицы;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с алгоритмом обращения матрицы.
//****************************************************************************************
string& TInvCovMatrix_Laurentiev::Algorithm(string& s) const
{s.assign("Inv(A+Ia)");
 return s;
}
//****************************************************************************************
//СТАТУС: I.3; public; TInvCovMatrix_Laurentiev class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Inverse(cmatrix& InvA, const cmatrix& A, double a = 0) const
//НАЗНАЧЕНИЕ: Обращение ковариационной матрицы A с ее регуляризацией по методу Лаврентьева.
//Для обращения регуляризированной матрицы применяется алгоритм Краута. Результат обращения
//формируется в матрице InvA, передаваемой в функцию по ссылке. Матрица A функцией не из-
//меняется. Функция возвращает результат обращения матрицы A. Для успешного обращения мат-
//рицы A необходимо, чтобы регуляризированная матрица (A + aI) была квадратной и невырожден-
//ной. В противном случае функция возвращает false и матрицу InvA нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& InvA - ссылка на матрицу, в которой формируется обратная матрица к A;
//2. const cmatrix& A - ссылка на ковариационную матрицу, подлежащую обращению;
//3. double a - параметр регуляризации.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат обращения матрицы A.
//****************************************************************************************
bool TInvCovMatrix_Laurentiev::Inverse(cmatrix& InvA, const cmatrix& A, double a) const
{//Проверка на возможность обращения матрицы A
 InvA = A;
 if (!InvA.IsSquare() || InvA.IsZeroSize()) {InvA.Set(0,false); return false;}
 //Обращение матрицы с ее регуляризацией по методу Лаврентьева
 a = fabs(a);
 //Реализация операции: A+a*I
 if (a != 0.0) for (ulong i = 0; i < InvA.Rows(); i++) InvA.Put(i,i,InvA.Get(i,i)+a);
 //Обращение матрицы (A+a*I) методом Краута
 InvA = InvA.INV_Krauth();
 return !InvA.IsZeroSize();
}

//****************************************************************************************
//                          РЕАЛИЗАЦИЯ КЛАССА TInvCovMatrix_Tychonoff
//Класс наследует свойства класса TCovMatrixInversion и реализует метод обращения ковариа-
//ционной матрицы c ее регуляризацией по методу Тихонова:
// InvA = Inv[TrA*A + aI]*TrA, где
// 1) a   - параметр регуляризации (a >= 0);
// 2) A   - возмущенная ковариационная матрица;
// 3) TrA - транспонированная (комплексно-сопряженная) матрица к матрице A;
// 4) I   - единичная матрица размерности равной A.
//При согласованном выборе параметра регуляризации с диспресией внутрисистемных ошибок,
//присутствующих в матрице A и ее структуры метод Тихонова позволяет компенсировать влияние
//возмущений на вычисление обратной матрицы InvA. Обращение регуляризированной по методу
//Тихонова матрицы (TrA*A + aI) выполняется по алгоритму Краута.
//****************************************************************************************

//========================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TInvCovMatrix_Tychonoff
//    PUBLIC MEMBER-FUNCTION OF TInvCovMatrix_Tychonoff CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TInvCovMatrix_Tychonoff class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Method(string& s, bool lBrief = true) const
//НАЗНАЧЕНИЕ: Формирование в строке s, передаваемой по ссылке, наименования метода регуля-
//ризации. Прежнее содержимое s удаляется. Опция lBrief определяет сокращенную или полную
//форму наименования метода. Функция возвращает ссылку на s.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку-приемник наименования метода регуляризации;
//2. bool lBrief (true) - опция определяющая сокращенное (true) или полное наименование
//   метода регуляризации.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с наименованием метода регуляризации
//****************************************************************************************
string& TInvCovMatrix_Tychonoff::Method(string& s, bool lBrief) const
{if (lBrief) s.assign("TYCH");
 else s.assign("Tychonoff");
 return s;
}
//****************************************************************************************
//СТАТУС: I.2; public; TInvCovMatrix_Tychonoff class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Algorithm(string& s) const
//НАЗНАЧЕНИЕ: Формирование в строке s, передаваемой по ссылке, алгоритма обращения ковариа-
//ционной матрицы с учетом или без ее регуляризации. Прежнее содержимое s удаляется.
//Функция возвращает ссылку на s.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строку-приемник алгоритма обращения матрицы;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с алгоритмом обращения матрицы.
//****************************************************************************************
string& TInvCovMatrix_Tychonoff::Algorithm(string& s) const
{s.assign("Inv[TrA*A+Ia]*TrA");
 return s;
}
//****************************************************************************************
//СТАТУС: I.3; public; TInvCovMatrix_Tychonoff class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Inverse(cmatrix& InvA, const cmatrix& A, double a = 0) const
//НАЗНАЧЕНИЕ: Обращение ковариационной матрицы A с ее регуляризацией по методу Тихонова.
//Для обращения регуляризированной матрицы применяется алгоритм Краута. Результат обращения
//формируется в матрице InvA, передаваемой в функцию по ссылке. Матрица A функцией не из-
//меняется. Функция возвращает результат обращения матрицы A. Для успешного обращения мат-
//рицы A необходимо, чтобы регуляризированная матрица (TrA*A+Ia) была квадратной и невырожден-
//ной. В противном случае функция возвращает false и матрицу InvA нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& InvA - ссылка на матрицу, в которой формируется обратная матрица к A;
//2. const cmatrix& A - ссылка на ковариационную матрицу, подлежащую обращению;
//3. double a - параметр регуляризации.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат обращения матрицы A.
//****************************************************************************************
bool TInvCovMatrix_Tychonoff::Inverse(cmatrix& InvA, const cmatrix& A, double a) const
{//Проверка на возможность обращения матрицы A
 if (!A.IsSquare() || A.IsZeroSize()) {InvA.Set(0,false); return false;}
 cmatrix TrA;
 //Комплексно-сопряженное транспонирование матрицы A;
 TrA = A.Transpose(true);
 //---------------------------------------------------------------------------------
 //Обращение матрицы A с ее регуляризацией по методу Тихонова
 //---------------------------------------------------------------------------------
 //Вычисляем произведение TrA*A
 InvA = TrA*A;
 a = fabs(a); // a >= 0
 //Реализация операции: TrA*A+a*I
 if (a != 0.0) for (ulong i = 0; i < InvA.Rows(); i++) InvA.Put(i,i,InvA.Get(i,i)+a);
 //Обращение матрицы (TrA*A+a*I) методом Краута
 InvA = InvA.INV_Krauth();
 //Умножение справа обращенной матрицы (TrA*A+a*I) на TrA
 InvA = InvA*TrA;

 return !InvA.IsZeroSize();
}

//****************************************************************************************
//                          РЕАЛИЗАЦИЯ КЛАССА TInvCovMatrix_ModTychonoff
//Класс наследует свойства класса TCovMatrixInversion и реализует метод обращения ковариа-
//ционной матрицы c ее регуляризацией по модифицированному методу Тихонова:
// InvA = Inv[A^(n+1) + a*I]*A^n, где
// 1) a - параметр регуляризации (a >= 0);
// 2) A - возмущенная ковариационная матрица;
// 3) n - показатель степени (n > 0, при n = 1 - метод Тихонова);
// 4) A^n - n-кратное перемножение матрицы A саму на себя;
// 5) I - единичная матрица размерности равной A.
//Модифицированный метод Тихонова использует n-кратное перемножение ковариационной матрицы
//A саму на себя, что позволяет реализовать при достаточно большом n КВАЗИУСТОЙЧИВЫЙ к ва-
//риациям регуляризирующей меры <a> алгоритм. При согласованном выборе параметра регуляри-
//зации с дисперсией внутрисистемных ошибок, присутствующих в матрице A и ее структуры мо-
//дифицированный метод Тихонова позволяет компенсировать влияние возмущений на вычисление
//обратной матрицы InvA. Обращение регуляризированной по данному методу матрицы выполняется
//по алгоритму Краута.
//****************************************************************************************

//========================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TInvCovMatrix_ModTychonoff
//    PUBLIC MEMBER-FUNCTION OF TInvCovMatrix_ModTychonoff CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TInvCovMatrix_ModTychonoff class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Method(string& s, bool lBrief = true) const
//НАЗНАЧЕНИЕ: Формирование в строке s, передаваемой по ссылке, наименования метода регуля-
//ризации. Прежнее содержимое s удаляется. Опция lBrief определяет сокращенную или полную
//форму наименования метода. Функция возвращает ссылку на s.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку-приемник наименования метода регуляризации;
//2. bool lBrief (true) - опция определяющая сокращенное (true) или полное наименование
//   метода регуляризации.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с наименованием метода регуляризации
//****************************************************************************************
string& TInvCovMatrix_ModTychonoff::Method(string& s, bool lBrief) const
{if (lBrief) s.assign("ModTYCH");
 else s.assign("Modified Tychonoff");
 return s;
}
//****************************************************************************************
//СТАТУС: I.2; public; TInvCovMatrix_ModTychonoff class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Algorithm(string& s) const
//НАЗНАЧЕНИЕ: Формирование в строке s, передаваемой по ссылке, алгоритма обращения ковариа-
//ционной матрицы с учетом или без ее регуляризации. Прежнее содержимое s удаляется.
//Функция возвращает ссылку на s.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строку-приемник алгоритма обращения матрицы;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с алгоритмом обращения матрицы.
//****************************************************************************************
string& TInvCovMatrix_ModTychonoff::Algorithm(string& s) const
{char buffer[41];
 ostrstream text(buffer, sizeof(buffer));
 text << "Inv[A^(n+1)+a*I]*A^n, n: " << n << ends;
 s.assign(text.str());
 return s;
}
//****************************************************************************************
//СТАТУС: I.3; public; TInvCovMatrix_ModTychonoff class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: virtual void Edit()
//НАЗНАЧЕНИЕ: Консольное редактирование свойств объекта класса TInvCovMatrix_ModTychonoff.
//----------------------------------------------------------------------------------------
//< Edit < Covariation Matrix Inversion Operator >
//< Inversion Operator properties>
//  1. Edit < Exponent n >
//  2. Exit
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TInvCovMatrix_ModTychonoff::Edit()
{//Рабочие переменные
 STR_UINT EditOpts[2] = {
 {1, "Edit < Exponent n >"},
 {2, "Exit"} };
 TB_STR_UINT EditMenu = {2,EditOpts};
 int row_start = wherey();
 int choice;
 bool flag = true;
 string s, line(78,'-');
 string h("Edit < Covariation Matrix Inversion Operator >");

 gotoxy(1,row_start); clreol();
 do //Цикл редактирования свойств объекта
 {cout << line << endl << h << endl;
  cout << this->Info(s) << endl << line << endl;
  //Выбор опции редактирования
  s = "Choose option [1..2]: ";
  choice = ConsoleChoice(EditMenu,1,s.c_str(),1);
  switch (choice)
  {case 1:
    ClrScr(1,row_start);
    Edit_Exponent();//Редактирование показателя степени n
    break;
   case 2: flag = false; break;
  }
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}
//****************************************************************************************
//СТАТУС: I.4; public; TInvCovMatrix_ModTychonoff class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Inverse(cmatrix& InvA, const cmatrix& A, double a = 0) const
//НАЗНАЧЕНИЕ: Обращение ковариационной матрицы A с ее регуляризацией по модифицированному
//методу Тихонова. Для обращения регуляризированной матрицы применяется алгоритм Краута.
//Результат обращения формируется в матрице InvA, передаваемой в функцию по ссылке. Матрица
//A функцией не изменяется. Функция возвращает результат обращения матрицы A. Для успешного
//обращения матрицы A необходимо, чтобы регуляризированная матрица (A^(n+1)+a*I) была
//квадратной и невырожденной. В противном случае функция возвращает false и матрицу InvA
//нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& InvA - ссылка на матрицу, в которой формируется обратная матрица к A;
//2. const cmatrix& A - ссылка на ковариационную матрицу, подлежащую обращению;
//3. double a - параметр регуляризации.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат обращения матрицы A.
//****************************************************************************************
bool TInvCovMatrix_ModTychonoff::Inverse(cmatrix& InvA, const cmatrix& A, double a) const
{//Проверка на возможность обращения матрицы A
 if (!A.IsSquare() || A.IsZeroSize()) {InvA.Set(0,false); return false;}
 cmatrix B;// B = A^n
 cmatrix C;// C = A^(n+1)
 //---------------------------------------------------------------------------------
 //Обращение матрицы A с ее регуляризацией по модифицированному методу Тихонова
 //---------------------------------------------------------------------------------
 //Вычисляем n-кратное произведение матрицы A саму на себя.
 B = A;
 for (ulong i = 1; i < n; i++) B = B*A;
 //Вычисляем (n+1)-кратное произведение матрицы A саму на себя.
 C = B*A;
 a = fabs(a); // a >= 0
 //Реализация операции: (A^(n+1)+a*I)
 if (a != 0.0) for (ulong i = 0; i < C.Rows(); i++) C.Put(i,i,C.Get(i,i)+a);
 //Обращение матрицы (A^(n+1)+a*I) методом Краута
 InvA = C.INV_Krauth();
 //Умножение справа обращенной матрицы (A^(n+1)+a*I) на B
 InvA = InvA*B;

 return !InvA.IsZeroSize();
}

//========================================================================================
// II. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TInvCovMatrix_ModTychonoff
//     PROTECTED MEMBER-FUNCTION OF TInvCovMatrix_ModTychonoff CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: II.1; protected; TInvCovMatrix_ModTychonoff class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: virtual void Edit_Exponent()
//НАЗНАЧЕНИЕ: Консольное редактирование показателя степени n, в которую возводится ковариа-
//ционная матрица A.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TInvCovMatrix_ModTychonoff::Edit_Exponent()
{//Рабочие переменные
 ulong Exp;
 int row_start = wherey();
 char c;
 string s;
 string line(78,'-');
 string h("Edit < Exponent n (n > 0) >");
 bool flag;
 gotoxy(1,row_start); clreol();

 do //Цикл ввода показателя степени
 {//--------------------------------------------------------------------------------------
  cout << line << endl << this->Info(s) << line << endl;//Свойства объекта до редакт-я
  cout << h << endl << line << endl;
  //--------------------------------------------------------------------------------------
  //Ввод нового значения показателя степени n
  //--------------------------------------------------------------------------------------
  cout << "> "; cin.ignore(); cin >> Exp;
  this->SetExponent(Exp);
  ClrScr(1,row_start);//Очистка экрана
  //Вывод нового значения показателя степени
  cout << "New Exponent => n: " << this->n << endl << line << endl;
  //--------------------------------------------------------------------------------------
  //Подтверждение введенных данных
  cout << "Would you like to exit? [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
}

//****************************************************************************************
//                          РЕАЛИЗАЦИЯ КЛАССА TInvCovMatrix_Skachkov
//Класс наследует свойства класса TCovMatrixInversion и реализует метод обращения ковариа-
//ционной матрицы c ее регуляризацией по методу Скачкова:
// InvA = Inv[A + a*T], где
// 1) a  - параметр регуляризации (a >= 0);
// 2) A  - возмущенная ковариационная матрица;
// 3) T  - матрица, составленная из суммы произведений собственных векторов Vk матрицы A на
//         комплексно-сопряженные транспонированные с ними собственные векторы TrVk, кото-
//         рые соответствуют вырожденным собственным числам матрицы A - EigenVal = 1.0:
//         T = SUM[Vk*TrVk], для k, у которых EigenVals = 1.0.
//Таким образом, для составления матрицы T необходимо решить полную проблему собственных
//чисел и векторов матрицы A. Для этого применяется метод Якоби с понижением нормы для
//комплексных матриц общего вида.
//Метод регуляризации Скачков делает инвариантным выбор параметра регуляризации a к уровню
//внутрисистемных ошибок по сравнению с метода Лаврентьева (самый чувствительный метод),
//так и метод Тихонова. Обращение регуляризированной по методу Скачкова матрицы (*A + aT)
//выполняется по алгоритму Краута.
//****************************************************************************************

//========================================================================================
// II. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TInvCovMatrix_Skachkov
//     PUBLIC MEMBER-FUNCTION OF TInvCovMatrix_Skachkov CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TInvCovMatrix_Skachkov class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Method(string& s, bool lBrief = true) const
//НАЗНАЧЕНИЕ: Формирование в строке s, передаваемой по ссылке, наименования метода регуля-
//ризации. Прежнее содержимое s удаляется. Опция lBrief определяет сокращенную или полную
//форму наименования метода. Функция возвращает ссылку на s.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку-приемник наименования метода регуляризации;
//2. bool lBrief (true) - опция определяющая сокращенное (true) или полное наименование
//   метода регуляризации.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с наименованием метода регуляризации
//****************************************************************************************
string& TInvCovMatrix_Skachkov::Method(string& s, bool lBrief) const
{if (lBrief) s.assign("SKCHV");
 else s.assign("Skachkov");
 return s;
}
//****************************************************************************************
//СТАТУС: I.2; public; TInvCovMatrix_Skachkov class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Algorithm(string& s) const
//НАЗНАЧЕНИЕ: Формирование в строке s, передаваемой по ссылке, алгоритма обращения ковариа-
//ционной матрицы с учетом или без ее регуляризации. Прежнее содержимое s удаляется.
//Функция возвращает ссылку на s.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строку-приемник алгоритма обращения матрицы;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с алгоритмом обращения матрицы.
//****************************************************************************************
string& TInvCovMatrix_Skachkov::Algorithm(string& s) const
{s.assign("Inv[A+a*T],T=Sum{Qk*TrQk},Qk:EigenVect of A matched EigenVal=1");
 return s;
}
//****************************************************************************************
//СТАТУС: I.3; public; TInvCovMatrix_Skachkov class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Inverse(cmatrix& InvA, const cmatrix& A, double a = 0) const
//НАЗНАЧЕНИЕ: Обращение ковариационной матрицы A с ее регуляризацией по методу Скачкова.
//Для обращения регуляризированной матрицы применяется алгоритм Краута. Результат обращения
//формируется в матрице InvA, передаваемой в функцию по ссылке. Матрица A функцией не из-
//меняется. Функция возвращает результат обращения матрицы A. Для успешного обращения мат-
//рицы A необходимо, чтобы регуляризированная матрица (A+a*T) была квадратной и невырожден-
//ной. В противном случае функция возвращает false и матрицу InvA нулевого размера.
//Для составления матрицы T суммы произведений Qk*TrQk собственных векторов Qk матрицы A,
//соответствующих вырожденным собственным числам (равным 1) необходимо решить полную проблему
//собственных чисел и векторов матрицы A. Для этого применяется метод Якоби с понижением
//нормы для комплексных матриц общего вида.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& InvA - ссылка на матрицу, в которой формируется обратная матрица к A;
//2. const cmatrix& A - ссылка на ковариационную матрицу, подлежащую обращению;
//3. double a - параметр регуляризации.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат обращения матрицы A.
//****************************************************************************************
bool TInvCovMatrix_Skachkov::Inverse(cmatrix& InvA, const cmatrix& A, double a) const
{//Проверка на возможность обращения матрицы A
 InvA = A;
 if (!InvA.IsSquare() || InvA.IsZeroSize()) {InvA.Set(0,false); return false;}
 cmatrix T;
 cvector W;//Вектор собственных значений матрицы A
 cmatrix Q;//Матрица собственных векторов матрицы A
 complex z;
 ulong N = A.Rows();//Размерность обращаемой матрицы A
 //double eps = 1e-9;//Допустимая точность определения вырожденных собственных чисел
 //---------------------------------------------------------------------------------
 //Обращение матрицы A с ее регуляризацией по методу Скачкова
 //---------------------------------------------------------------------------------
 a = fabs(a); // a >= 0
 if (a != 0.0)
 {//cmatrix InvQ;
  //1. Вычисление собственных чисел и векторов матрицы A методом Якоби с понижением нормы
  if (A.EVV_NormReducingJacobi(W,Q) == false) {InvA.Set(0,false); return false;}
  //InvQ = Q.INV_Krauth();

  //2. Формирование матрицы T = SUM{Qk*TrQk}, для Wk < 0 || |Wk| < 2
  T.Set(N,C_ZERO);

  for (ulong k = 0; k < W.Size(); k++)
  {//Поиск собственного значения: Wk < 0 || |Wk| < 2 (отрицательных, нулевых или равных 1)
   if ((real(W.Get(k)) < 0)  || (abs(W.Get(k)) < 2))
   {//Перемножение k-столбца матрицы правых собственных векторов Q на k-ую строку
    //матрицы левых собственных векторов InvQ = Inv(Q) = Tr(Q). Получаемая матрица
    //ковариаций прибавляется к матрице T
    for (ulong i = 0; i < N; i++)
     for (ulong j = 0; j <= i; j++)
     {if (i == j) T.Put(i,j, T.Get(i,j) + norm(Q.Get(i,k)));
      else //Вычисление внедиагональных элементов матрицы T
      {z = Q.Get(i,k)*conj(Q.Get(j,k));
       T.Put(i,j, T.Get(i,j) + z);
       T.Put(j,i, T.Get(j,i) + conj(z));
      }
     }
      //T.Put(i,j, T.Get(i,j) + Q.Get(i,k)*InvQ.Get(k,j));
      //T.Put(i,j, T.Get(i,j) + W.Get(k)*Q.Get(i,k)*conj(Q.Get(j,k)));
   }
  }//End цикла по W - собственным числам

  //3. Выполнение операции A + aT
  for (ulong i = 0; i < T.Rows(); i++)
   for (ulong j = 0; j < T.Cols(); j++)
    InvA.Put(i,j,InvA.Get(i,j)+a*T.Get(i,j));

  //Отладка
  /*
  if (A.Rows() < 100)
  {int y = wherey();
   //cout << "Matrix DistA: " << A << endl;
   //cout << "Matrix DistA+a*T: " << InvA << endl;
   cout << "Eigen Vals: " << W << endl;
   //cout << "Matrix Q: " << Q << endl;
   //cout << "Matrix InvQ: " << InvQ << endl;
   cout << "Matrix T: " << T << endl;
   getch();
   ClrScr(1,y);
  }
  */

 }// a != 0.0

 //Обращение матрицы (A+a*T) методом Краута
 InvA = InvA.INV_Krauth();

 return !InvA.IsZeroSize();
}

