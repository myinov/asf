//adaptlaa.cpp
//Initial date: December,6,1999. Final date:
//Copyright (c) JohnSoft 1999. All rights reserved. Borland C++ 5.01

#include "adaptlaa.h"

const double EPS = 1.0e-10;

//******************************************************************************
//                РЕАЛИЗАЦИЯ КЛАССА TMultiBeamFormer
//       МОДЕЛЬ МНОГОЛУЧЕВОЙ ЛУЧЕОБРАЗУЮЩЕЙ СХЕМЫ АДАПТИВНОЙ LAA
//Класс используется для построения численной и статистической (имитационной)
//моделей адаптивной LAA с многоканальным пространственным адаптивным фильтром и
//многолучевой схемы формирования лучей на выходе фильтра
//******************************************************************************
//==============================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TMultiBeamFormer
//   PUBLIC MEMBER-FUNCTION OF TMultiBeamFormer CLASS
//==============================================================================
//******************************************************************************
//СТАТУС: I.1; public TMultiBeamFormer member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool Set(TInputSignal* InSignal, const ivector& Index = ivector(),
//          const rvector& Angle = rvector())
//НАЗНАЧЕНИЕ: Установка параметров многолучевой лучеобразующей схемы, подключен-
//ной к LAA. В ходе  установки параметров осуществляется их проверка на коррект-
//ность. Функция обрабатывает следующие исключительные ситуации:
//1. InSignal == NULL - LAA не подключена к MultiBeamFormer. Выход из режима ус-
//   тановки параметров схемы (MultiBeamFormer не работоспособен).
//В ходе установки новых параметров объекта все векторы проверяются по следующим
//условиям:
//1. На уникальность данных - из двух или более одинаковых значений остается одно;
//2. На принадлежность диапазону допустимых значений - все значения не входящие
//   в заданный диапазон исключаются.
//Функция возвращает true - при успешной установки параметров. Это возможно при
//ненулевом указателе на входной воздействие InSignal. В противном случае, схема
//будет не работоспособна.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TInputSignal* InSignal - указатель на LAA;
//2. const ivector& Index - ссылка на индексы каналов LAA, подключаемые к схеме;
//3. const rvector& Angle - углы сканирования, реализуемые схемой.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//lSuccess - признак успешной/неудачной установки параметров MultiBeamFormer
//******************************************************************************
bool TMultiBeamFormer::Set(TInputSignal* InSignal, const ivector& Index,
                           const rvector& Angle)
{_Reset(); //Сброс предыдущих параметров схемы
 //Проверка на возможность подключения LAA к MultiBeamFormer
 if (InSignal == NULL) return false;
 pLAA = InSignal; //Подключаем LAA к MultiBeamFormer
 //Устанавливаем индексы каналов LAA, подключаемые к схеме
 _SetChannel(Index);
 //Устанавливаем пространственные положения лучей (направления сканирования)
 _SetBeam(Angle);
 //Рассчитываем лучеобразующую матрицу коэффициентов B
 _CalcMultiBeamFactors();
 return true;
}
//******************************************************************************
//СТАТУС: I.2; public TMultiBeamFormer member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SetLAACh(const ivector& Index = ivector())
//НАЗНАЧЕНИЕ: Установка индексов каналов LAA, подключаемых к MultiBeamFormer.
//Функция осуществляет проверка значений индексов на корректность. В случае век-
//тора Index нулевой длины подключаются все каналы LAA. Функция возвращает true
//при успешной установки индексов. Это возможно при работоспособности схемы. В
//противном случае, функция возвращает false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const ivector& Index - ссылка на индексы каналов LAA, подключаемые к схеме
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//lSuccess - признак успешной/неудачной установки каналов LAA
//******************************************************************************
bool TMultiBeamFormer::SetLAACh(const ivector& Index)
{//Проверка работоспособности схемы
 if (!IsReady()) return false;
 //Устанавливаем индексы каналов LAA, подключаемые к схеме
 _SetChannel(Index);
 //Рассчитываем лучеобразующую матрицу коэффициентов B
 _CalcMultiBeamFactors();
 return true;
}
//******************************************************************************
//СТАТУС: I.3; public TMultiBeamFormer member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SetBeams(const rvector& Angle = rvector())
//НАЗНАЧЕНИЕ: Установка направлений сканирования MultiBeamFormer. Функция прове-
//ряет значения, передаваемые вектором Angle, на корректность. Если вектор Angle
//нулевой длины, то устанавливается один луч в направлении на 0 градусов. Функция
//возвращает true при успешной установки направлений сканирования. Это возможно
//только при работоспособности схемы. В противном случае, функция возвращает false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const rvector& Angle - ссылка на задаваемые направления сканирования (в градусах)
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//lSuccess - признак успешной/неудачной установки каналов LAA
//******************************************************************************
bool TMultiBeamFormer::SetBeams(const rvector& Angle)
{//Проверка работоспособности схемы
 if (!IsReady()) return false;
 //Устанавливаем пространственные положения лучей (направления сканирования)
 _SetBeam(Angle);
 //Рассчитываем лучеобразующую матрицу коэффициентов B
 _CalcMultiBeamFactors();
 return true;
}
//******************************************************************************
//СТАТУС: I.4; public TMultiBeamFormer member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetLAACh(ivector& Index) const
//НАЗНАЧЕНИЕ: Присвоение вектору Index номеров каналов LAA, подключенных к схеме.
//Функция возвращает false, если MultiBeamFormer не работоспособна.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ivector& Index - ссылка на вектор-приемник
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::GetLAACh(ivector& Index) const
{//Проверка работоспособности схемы
 if (!IsReady()) {Index = Channel; return false;}
 //Подключены все каналы LAA
 if (IsConnectedAllLAACh())
 {Index.Resize(GetLAACh());
  for (ulong i = 0L; i < Index.Size(); i++) Index.Put(i,i);
 }
 else Index = Channel;
 return true;
}
//******************************************************************************
//СТАТУС: I.5; public TMultiBeamFormer member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetBeams(rvector& Angle) const
//НАЗНАЧЕНИЕ: Присвоение вектору Angle направлений сканирования MultiBeamFormer.
//Функция возвращает false, если MultiBeamFormer не работоспособна.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: rvector& Angle - ссылка вектор-приемник
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::GetBeams(rvector& Angle) const
{Angle = Beam;
 return (IsReady()) ? true : false; //Проверка работоспособности схемы
}
//****************************************************************************************
//СТАТУС: I.6; public TMultiBeamFormer member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//  string& Properties(string& s, string& title, ulong MaxCh = 0L, ulong MaxBeam = 0L,
//                     uint indent = 0) const;
//НАЗНАЧЕНИЕ: Формирование характеристик объекта TMultiBeamFormer в строке s, передаваемой
//по ссылке. В строку s заносятся индексы каналов LAA, используемых для формирования лучей
//и направлений сканирования (пространственных положений основных лепестков) схемы.
//Предыдущее содержимое строки s уничтожается.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& title - ссылка на строку с заголовком объекта;
//3. ulong MaxCh - максимальное кол-во индексов каналов LAA, подключенных к схеме;
//4. ulong MaxBeam - максимальное кол-во значений, формируемых лучей;
//5. uint indent - начальное смещение строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//****************************************************************************************
string& TMultiBeamFormer::Properties(string& s, string& title, ulong MaxCh, ulong MaxBeam,
        uint indent) const
{string t, header; string space(' ',indent);
 //Формирование заголовка объекта
 s = space;
 if (title.empty()) s.append("LAA MultiBeamFormer: ");
 else s.append(title);
 //-----------------------------------------------------------------------------
 //МНОГОЛУЧЕВАЯ СХЕМА НЕРАБОТОСПОСОБНА:
 if (!IsReady()) {s.append("< Off >\n"); s.append(space); return s; }
 else s.append("< On >\n");
 //-----------------------------------------------------------------------------
 //1. Формирование индексов каналов LAA, подключенных к MultiBeamFormer
 s.append(GetLAACh(t,MaxCh,indent+1));
 //-----------------------------------------------------------------------------
 //2. Формирование пространственных положений лучей MultiBeamFormer
 s.append(GetBeams(t,MaxBeam,indent+1));
return s;
}
//******************************************************************************
//СТАТУС: I.7; public TMultiBeamFormer member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& GetLAACh(string& s, ulong max = 0L, uint indent = 0) const
//string& AuxChProp(string& s, string& title = string(), uint indent = 0) const;
//НАЗНАЧЕНИЕ: Формирует индексы каналов LAA, подключенные к MultiBeamFormer в
//виде строки. В строку s, передаваемую по ссылке, заносится информация:
//1)число каналов LAA, подключенных к схеме;
//2)номера каналов LAA, подключенных к схеме (до max, если max == 0, то выводятся
//  все номера);
//КАНАЛЫ LAA, подключенные к MultiBeamFormer в виде строки могут быть представлены:
//1. Схема не работоспособна: IsReady() == OFF
// LAA CHANNELs: <0>;
//------------------------------------------------------------------------------
//2. Схема работоспособна: IsReady() == ON
// LAA CHANNELs: <GetLAACh()> [<index LAA channels, count = 1..max>];
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. ulong max - максимальное число индексов каналов, выводимых в строку s;
//3. uint indent - начальное смещение строки.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка с данными по КАНАЛАМ LAA
//*****************************************************************************
string& TMultiBeamFormer::GetLAACh(string& s, ulong max, uint indent) const
{char buffer[80]; ostrstream text (buffer, sizeof(buffer));
 string t; string space(' ',indent);
 //Формирование заголовка объекта
 s = space; s.append("LAA CHANNELs: ");
 //-----------------------------------------------------------------------------
 //1. MultiBeamFormer НЕРАБОТОСПОСОБНА:
 if (!IsReady()) {s.append("0;\n"); return s;}
 //-----------------------------------------------------------------------------
 //2. MultiBeamFormer РАБОТОСПОСОБНА:
 //2.1 Количество каналов LAA, подключенных к схеме
 text << GetLAACh() << ends;  s.append(text.str()); text.seekp(0);
 //2.2 Формирование индексов каналов LAA, подключенных к схеме (до max)
 //Подключены все каналы
 if (IsConnectedAllLAACh())
 {text << " [0.." << (GetLAACh()-1) << "];" << endl << ends;
  s.append(text.str()); text.seekp(0);
 }
 else
 {if (max == 0L) max = GetLAACh();
  t = Channel.ConvertToString(t, max);
  text << " [" << t << "];" << endl << ends;
  s.append(text.str()); text.seekp(0);
 }
return s;
}
//******************************************************************************
//СТАТУС: I.8; public TMultiBeamFormer member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//  string& GetBeams(string& s, ulong max = 0L, uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирует направления сканирования (пространственные положения ос-
//новных лепестков лучей) MultiBeamFormer в виде строки. В строку s, передаваемую
//по ссылке, заносится следующая информация:
//1)количество лучей, формируемых схемой одновременно;
//2)углы сканирования (до max, если max == 0, то выводятся все направления);
//Лучи, формируемые MultiBeamFormer в виде строки, могут быть представлены:
//1. Схема не работоспособна: IsReady() == OFF
// BEAMs: <0>;
//------------------------------------------------------------------------------
//2. Схема работоспособна: IsReady() == ON
// BEAMs: <Beam.Size()> [<scanning angles, count = 1..max>];
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. ulong max - максимальное число направлений сканирования, выводимых в s;
//3. uint indent - начальное смещение строки.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка с направлениям сканирования
//******************************************************************************
string& TMultiBeamFormer::GetBeams(string& s, ulong max, uint indent) const
{char buffer[80]; ostrstream text (buffer, sizeof(buffer));
 string t; string space(indent,' ');
 string sep(1,' '), etc("...");
 //Формирование заголовка объекта
 s = space; s.append("BEAMs: ");
 //-----------------------------------------------------------------------------
 //1. MultiBeamFormer НЕРАБОТОСПОСОБНА:
 if (!IsReady()) {s.append("0;\n"); return s;}
 //-----------------------------------------------------------------------------
 //2. MultiBeamFormer РАБОТОСПОСОБНА:
 //2.1 Количество лучей, формируемых схемой
 text << GetBeams() << ends;  s.append(text.str()); text.seekp(0);
 //2.2 Формирование значений направлений сканирования
 if (max == 0L) max = GetBeams();
 t = Beam.ConvertToString(t,sep,etc,max);
 s.append(" ["); s.append(t); s.append("];\n");
return s;
}
//******************************************************************************
//СТАТУС: I.9; public TMultiBeamFormer member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Edit()
//НАЗНАЧЕНИЕ: Ввод новых параметров объекта класса через стандартный поток ввода
//cin (>>). Если схема не работоспособна, то функция возвращает false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::Edit()
{//-----------------------------------------------------------------------------
 //СХЕМА НЕРАБОТОСПОСОБНА:
 //-----------------------------------------------------------------------------
 if (IsReady() == OFF)
 {gotoxy(1,wherey()); clreol();
  cout << "\aInput LAA MULTIBEAMFORMER parameters is impossible !!!\n";
  cout << "Cause: MultiBeamFormer doesn't plug to LAA." << endl;
  return false;
 }
 //Рабочие переменные
 int y_start = wherey(); char c; string s, line(78,'-'); bool flag;
 gotoxy(1,y_start); clreol();
 do
 {cout << line << endl;
  cout << "LAA MultiBeamFormer: < Input Parameters >" << endl;
  //1. Ввод индексов каналов LAA, подключаемых к схеме
  EditLAACh();
  //2. Ввод направлений сканирования
  EditBeams();
  //Подтверждение введенных данных
  cout << line << endl;
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
 cout << Properties(s,STR_NULL); //Вывод введенных параметров схемы
 return true;
}
//******************************************************************************
//СТАТУС: I.10; public TMultiBeamFormer class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool EditLAACh(bool Confirm = ON)
//НАЗНАЧЕНИЕ: Ввод индексов каналов LAA, подключаемых к MultiBeamFormer через
//стандартный поток ввода cin (>>). Функция осуществляет контроль ввода индексов
//каналов пользователем. Формат ввода КАНАЛОВ LAA:
//------------------------------------------------------------------------------
//LAA CHANNELs: <Input LAA channel indexes>
// Channel LAA: <LAA indexes interval can be used>
// Input LAA indexes: ________________________________________
//------------------------------------------------------------------------------
//Введенные КАНАЛЫ заносятся в вектор Channel. Функция используется для установки
//новых  параметров объекта через стандартный поток ввода cin. Если схема не ра-
//ботоспособна, то функция возвращает false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: bool Confirm - опция подтверждения ввода
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::EditLAACh(bool Confirm)
{//-----------------------------------------------------------------------------
 //СХЕМА НЕРАБОТОСПОСОБНА:
 //-----------------------------------------------------------------------------
 if (IsReady() == OFF)
 {gotoxy(1,wherey()); clreol();
  cout << "\aInput indexes of LAA channels for MULTIBEAMFORMER is impossible !!!\n";
  cout << "Cause: MultiBeamFormer doesn't plug to LAA." << endl;
  return false;
 }
 ivector Index;
 //-----------------------------------------------------------------------------
 //1. Ввод индексов каналов LAA, подключаемых к схеме
 //-----------------------------------------------------------------------------
 //Рабочие переменные
 int y_start = wherey();
 char c;
 string s, line(78,'-');
 bool flag;
 char buffer[80];
 ostrstream text (buffer, sizeof(buffer));
 //-----------------------------------------------------------------------------
 //Формирование интервала каналов LAA, которые можно подключать к схеме
 string interval;
 interval.append(" LAA Channels: ");
 text << "[0.." << (pLAA->LAAElem()-1) << "]" << endl << ends;
 interval.append(text.str()); text.seekp(0);
 //-----------------------------------------------------------------------------
 gotoxy(1,y_start); clreol();
 do //Цикл ввода индексов каналов LAA
 {//----------------------------------------------------------------------------
  cout << line << endl;
  cout << "LAA CHANNELs: < Input LAA channel indexes >" << endl;
  cout << interval;
  //Ввод строки индексов каналов LAA из стандартного потока ввода cin
  cout << "LAA indexes: "; cin.ignore(); getline(cin,s,'\n');
  Index.GetDataFromString(s,true);
  SetLAACh(Index);
  //Отображение результатов ввода номеров каналов LAA, подключенных к схеме
  ClrScr(1,y_start);//Очистка экрана
  cout << line << endl << GetLAACh(s) << line << endl;
  //----------------------------------------------------------------------------
  //Подтверждение введенных данных
  if (Confirm)
  {cout << "Confirm data entry, please [y/n]: "; cin >> c;
   if (c == 'Y' || c == 'y') flag = false;
   else flag = true;//Повторный ввод данных
  }
  else flag = false;
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
 //Вывод результатов консольного ввода индексов КАНАЛОВ LAA
 cout << s;
 return true;
}
//******************************************************************************
//СТАТУС: I.11; public TMultiBeamFormer class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool EditBeams(bool Confirm = ON)
//НАЗНАЧЕНИЕ: Ввод направлений сканирования лучей, формируемых MultiBeamFormer
//через стандартный поток ввода cin (>>). Функция осуществляет контроль ввода
//углов сканирования пользователем. Формат ввода ЛУЧЕЙ:
//------------------------------------------------------------------------------
//BEAMs: <Input scanning angles>
// ScanAngles [-90..+90]: < scanning angles >
//------------------------------------------------------------------------------
//Введенные ЛУЧИ заносятся в вектор Beam. Функция используется для установки но-
//вых параметров  объекта через стандартный поток ввода cin. Если схема не рабо-
//тоспособна, то функция возвращает false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: bool Confirm - опция подтверждения ввода
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::EditBeams(bool Confirm)
{//-----------------------------------------------------------------------------
 //СХЕМА НЕРАБОТОСПОСОБНА:
 //-----------------------------------------------------------------------------
 if (IsReady() == OFF)
 {gotoxy(1,wherey()); clreol();
  cout << "\aInput scanning angles for MULTIBEAMFORMER is impossible !!!\n";
  cout << "Cause: MultiBeamFormer doesn't plug to LAA." << endl;
  return false;
 }
 rvector ScanAngle;
 //-----------------------------------------------------------------------------
 //Ввод направлений сканирования, формируемых MultiBeamFormer
 //-----------------------------------------------------------------------------
 //Рабочие переменные
 int y_start = wherey();
 char c;
 string s, line(78,'-');
 bool flag;
 //-----------------------------------------------------------------------------
 //Формирование допустимого диапазона углов сканирования
 string interval;
 interval.append(" ScanAngles [-90..+90] deg: ");
 //-----------------------------------------------------------------------------
 gotoxy(1,y_start); clreol();
 do //Цикл ввода индексов каналов LAA
 {//----------------------------------------------------------------------------
  cout << line << endl;
  cout << "Beams: < Input scanning angles >" << endl;
  cout << interval;
  //Ввод строки из стандартного потока ввода cin
  cin.ignore(); getline(cin,s,'\n');
  ScanAngle.GetDataFromString(s,true);
  SetBeams(ScanAngle);
  //Отображение результатов ввода направлений сканирования
  ClrScr(1,y_start);//Очистка экрана
  cout << line << endl << GetBeams(s) << line << endl;
  //----------------------------------------------------------------------------
  //Подтверждение введенных данных
  if (Confirm)
  {cout << "Confirm data entry, please [y/n]: "; cin >> c;
   if (c == 'Y' || c == 'y') flag = false;
   else flag = true;//Повторный ввод данных
  }
  else flag = false;
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
 //Вывод результатов консольного ввода направлений сканирования
 cout << s;
 return true;
}
//******************************************************************************
//СТАТУС: I.12; public TMultiBeamFormer class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: operator =(const TMultiBeamFormer& MultiBeam)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ класса TMultiBeamFormer.
//Функция осуществляет копирование исходных параметров схемы из одного  объекта
//TMultiBeamFormer в другой. Осуществляется корректное копирование членов-данных
//с целью  недопущения  ссылок указателей разных объектов класса на одно и то же
//место памяти.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TMultiBeamFormer& MultiBeam - ссылка на копию
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TMultiBeamFormer::operator =(const TMultiBeamFormer& MultiBeam)
{//Предотвращение попытки присваивания объекта самому себе
 if (this == &MultiBeam) return;
 if (!MultiBeam.IsReady()) {_Reset(); return;}  //MultiBeam не работоспособен
 ivector Index;
 rvector Angle;
 MultiBeam.GetLAACh(Index); MultiBeam.GetBeams(Angle);
 Set(MultiBeam.GetLAAPtr(),Index,Angle);
}
//------------------------------------------------------------------------------
// РЕАЛИЗАЦИЯ ПЕРЕДАТОЧНЫХ ФУНКЦИЙ КЛАССА TMultiBeamFormer
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.13; public TMultiBeamFormer class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool TFunc(rmatrix& P, double InitAngle=-90, double EndAngle=90, double Step=0.1,
//     uint NormType = GLOBAL, bool dB = ON, double MindB = -60.0) const
//НАЗНАЧЕНИЕ: Вычисление диаграмм направленностей ЛУЧЕЙ, формируемых схемой, в
//зависимости от плоскости расположения LAA (в меридиональной или экваториальной)
//в секторе от InitAngle до EndAngle. Углы отсчитываются относительно нормали к
//раскрыву LAA. При расчете диаграммы направленности (ДН) используется функция
//TestSignal(...) класса InSignal, формирующая вектор напряжений на элементах LAA,
//подключенных  к MultiBeamFormer, при действии с заданного направления (по ази-
//муту или углу места в зависимости от положения LAA) источника сигнала ЕДИНИЧНОЙ
//МОЩНОСТИ. Изменяя положение источника сигнала в заданном секторе строятся ДН
//ЛУЧЕЙ. ДИАГРАММА НАПРАВЛЕННОСТИ k-го ЛУЧА A(q) вычисляется:
// Ak(q) = SUM{ARF[i]*F(q)[i]*EXP(j(i-1)Ph[i]*B[i,k]) by i = 1..N},
// 1. i - i-ый элемент LAA, подключенного к MultiBeamFormer;
// 2. ARF[i] - относительный коэфф-т усиления i-го элемента LAA
// 3. F(q)[i] - значение нормированной диаграммы направленности i-го элемента АР
//    в направлении источника сигнала
// 4. Ph[i] - фазовый набег (сдвиг) в i-ом элементе АР по сравнению с ОСНОВНЫМ.
// Ph[i] = 2*PI*(L[i])*sin(q), L[i] - относительное расстояние между i-ым и 0-ым
// элементами АР.
// 5. B[i,k] - лучеобразующий коэффициент, соответствующий i-му элементу LAA для
//    формирования k-го луча.
//------------------------------------------------------------------------------
//Функция может рассчитывать НОРМИРОВАННУЮ или НЕНОРМИРОВАННУЮ ДИАГРАММУ НАПРАВ-
//ЛЕННОСТИ ЛУЧЕЙ в зависимости от аргумента NormType. Нормировка может осуществ-
//ляться  для  каждого  луча  индивидуально (LOCAL), либо  одновременно для всех
//лучей (GLOBAL). Нормированная ДН может вычисляться в децибелах (dB = ON), либо
//в относительных единицах (dB = OFF). При нормировании в dB задается минимальный
//порог мощности (значения меньше MindB приравниваются данному). Ненормированная
//ДН - значения в единицах мощности на выходе канала, нормированная ДН вычисляется
//по формуле: G(q) = 10*log10{A(q)/Amax} [Db] - в децибелах,
// 1. q - угол между источником сигнала и нормалью к оси решетки, проходящая
//    через ОСНОВНОЙ элемент АР.
// 2. A(q) - диаграмма направленности адаптивной АР в направлении на угол q
// 3. Amax - МАКСИМАЛЬНОЕ значение диаграммы направленности адаптивной АР в сек-
//    торе от InitAngle до EndAngle.
//Все значения характеристики направленности лучей в заданном секторе размещаются
//в матрице P. Каждый столбец матрицы P соответствует ДН одного луча, формируемого
//схемой. Строки матрицы P соответствуют углам, начиная с наименьшего, при кото-
//рых вычисляются ДН лучей.
//Функция возвращает false и матрицу P нулевого размера в случае НЕРАБОТОСПОСОБ-
//НОСТИ схемы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& P - ссылка на матрицу мощностей лучей схемы в заданном секторе;
//2. double InitAngle (-90 deg) - начальный угол, построения ДН ОСНОВНОГО КАНАЛА;
//3. double EndAngle (+90 deg) - конечный угол, построения ДН ОСНОВНОГО КАНАЛА;
//4. double Step - приращение угла;
//5. uint NormType (GLOBAL) - опция нормирования выходных мощностей [0..1];
//6. bool dB (ON) - опция нормирования в децибелах (действует при NormType > 0);
//7. double MindB - минимальный уровень в децибелах (действует при dB = ON).
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::TFunc(rmatrix& P, double InitAngle, double EndAngle,
     double Step, uint NormType, bool dB, double MindB) const
{//Проверка РАБОТОСПОСОБНОСТИ схемы
 if (!IsReady()) {P.Set(0L,0L,false); return false;}
 //-----------------------------------------------------------------------------
 //Формирование размеров матрицы P и сектора исследования ДН лучей
 ulong cols = GetBeams(); //Количество столбцов матрицы соответствует числу лучей
 if (EndAngle < InitAngle)
 { double Value = InitAngle; InitAngle = EndAngle; EndAngle = Value; }
 //Приращение угла может быть только положительным значением
 Step = fabs(Step);
 if (Step == 0.0) Step = 0.1;
 //Определяем количество строк матрицы P
 ulong rows = ceil((EndAngle-InitAngle)/Step);
 if (((EndAngle-InitAngle)/Step) != 0.0) rows += 1;
 //Создаем матрицу P для хранения данных
 P.Set(rows,cols,false);
 //-----------------------------------------------------------------------------
 // Расчет ДН лучей в заданном секторе
 //-----------------------------------------------------------------------------
 double Angle = InitAngle;
 complex Usum;
 //Векторы сигнала единичной мощности (тест-сигнала) с элементов LAA, подключен-
 //ных к MultiBeamFormer
 cvector U(GetLAACh(),COL,OFF);
 ivector IndexChLAA; GetLAACh(IndexChLAA);
 for (ulong i = 0L; i < P.Rows(); i++) //По углам сектора
 {//Входной тест-сигнал с элементов LAA, подключенных к BFC
  U = pLAA->TestSignal(IndexChLAA,Angle,DEG,OFF);
  for (ulong j = 0L; j < GetBeams(); j++) //По лучам
  {Usum = C_ZERO;
   //По каналам LAA
   for (ulong k = 0L; k < GetLAACh(); k++) Usum += U.Get(k)*B.Get(k,j);
   P.Put(i,j,norm(Usum));
  }
  Angle = Angle+Step; //Вычисляем новую величину угла
  if (fabs(Angle) < EPS) Angle = 0.0;
 } //Конец цикла по i - сектору определения ДН лучей
 //-----------------------------------------------------------------------------
 // Нормирование диаграмм направленностей ЛУЧЕЙ
 //-----------------------------------------------------------------------------
 if ((NormType != GLOBAL) && (NormType != LOCAL)) return true;
 bool lSuccess;
 if (NormType == GLOBAL)
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.Normalize(FIRST_NORM);
 }
 else if (NormType == LOCAL) //для каждого луча индивидуально
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeColsToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.NormalizeCols(FIRST_NORM);
 }
 return lSuccess;
}
//******************************************************************************
//СТАТУС: I.14,public TMultiBeamFormer class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool TFunc(rmatrix& P, const TEvenCloseInterval& Sector, uint NormType = GLOBAL,
//           bool dB = ON, double MindB = -60.0) const;
//НАЗНАЧЕНИЕ: Вычисление диаграммы направленности ЛУЧЕЙ, формируемых схемой, в
//плоскости расположения LAA относительно Земли (по ЭКВАТОРУ или МЕРИДИАНУ) в
//секторе Sector. Углы отсчитываются относительно нормали к раскрыву LAA. При
//расчете диаграмм направленностей (ДН) лучей используется функция TestSignal(...)
//класса InSignal, формирующая  вектор  напряжений на элементах LAA, подключенных
//к MultiBeamFormer, при действии с заданного направления (по азимуту или углу
//места) источника сигнала ЕДИНИЧНОЙ МОЩНОСТИ. Изменяя положение источника сигнала
//в заданном секторе строятся ДН ЛУЧЕЙ.
//ДИАГРАММА НАПРАВЛЕННОСТИ k-го ЛУЧА A(q) вычисляется:
// Ak(q) = SUM{ARF[i]*F(q)[i]*EXP(j(i-1)Ph[i]*B[i,k]) by i = 1..N},
// 1. i - i-ый элемент LAA, подключенного к MultiBeamFormer;
// 2. ARF[i] - относительный коэфф-т усиления i-го элемента LAA
// 3. F(q)[i] - значение нормированной диаграммы направленности i-го элемента АР
//    в направлении источника сигнала
// 4. Ph[i] - фазовый набег (сдвиг) в i-ом элементе АР по сравнению с ОСНОВНЫМ.
// Ph[i] = 2*PI*(L[i])*sin(q), L[i] - относительное расстояние между i-ым и 0-ым
// элементами АР.
// 5. B[i,k] - лучеобразующий коэффициент, соответствующий i-му элементу LAA для
//    формирования k-го луча.
//------------------------------------------------------------------------------
//Функция может рассчитывать НОРМИРОВАННУЮ или НЕНОРМИРОВАННУЮ ДИАГРАММУ НАПРАВ-
//ЛЕННОСТИ ЛУЧЕЙ в зависимости от аргумента NormType. Нормировка может осуществ-
//ляться  для  каждого  луча  индивидуально (LOCAL), либо  одновременно для всех
//лучей (GLOBAL). Нормированная ДН может вычисляться в децибелах (dB = ON), либо
//в относительных единицах (dB = OFF). При нормировании в dB задается минимальный
//порог мощности (значения меньше MindB приравниваются данному). Ненормированная
//ДН - значения в единицах мощности на выходе канала, нормированная ДН вычисляется
//по формуле: G(q) = 10*log10{A(q)/Amax} [Db] - в децибелах,
// 1. q - угол между источником сигнала и нормалью к оси решетки, проходящая
//    через ОСНОВНОЙ элемент АР.
// 2. A(q) - диаграмма направленности адаптивной АР в направлении на угол q
// 3. Amax - МАКСИМАЛЬНОЕ значение диаграммы направленности адаптивной АР в сек-
//    торе от InitAngle до EndAngle.
//Все значения характеристики направленности лучей в заданном секторе размещаются
//в матрице P. Каждый столбец матрицы P соответствует ДН одного луча, формируемого
//схемой. Строки матрицы P соответствуют углам, начиная с наименьшего, при кото-
//рых вычисляются ДН лучей.
//Функция возвращает false и матрицу P нулевого размера в случае НЕРАБОТОСПОСОБ-
//НОСТИ схемы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& P - ссылка на матрицу мощностей лучей схемы в заданном секторе;
//2. const TEvenCloseInterval& Sector - сектор по углу места (азимуту), в  кото-
//   ром рассчитывается диаграммы направленностей (в градусах);
//3. uint NormType (GLOBAL) - опция нормирования выходных мощностей [0..1];
//4. bool dB (ON) - опция нормирования в децибелах (действует при Norm = ON);
//5. double MindB - минимальный уровень в децибелах (действует при dB = ON).
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::TFunc(rmatrix& P, const TEvenCloseInterval& Sector,
     uint NormType, bool dB, double MindB) const
{//Проверка РАБОТОСПОСОБНОСТИ схемы
 if (!IsReady()) {P.Set(0L,0L,false); return false;}
 //-----------------------------------------------------------------------------
 //Создаем матрицу P для хранения данных
 P.Set(Sector.Size(),GetBeams(),false);
 //-----------------------------------------------------------------------------
 // Расчет ДН лучей в заданном секторе
 //-----------------------------------------------------------------------------
 complex Usum;
 //Векторы сигнала единичной мощности (тест-сигнала) с элементов LAA, подключен-
 //ных к MultiBeamFormer
 cvector U(GetLAACh(),COL,OFF);
 ivector IndexChLAA; GetLAACh(IndexChLAA);
 for (ulong i = 0L; i < P.Rows(); i++) //По углам сектора
 {//Входной тест-сигнал с элементов LAA, подключенных к BFC
  U = pLAA->TestSignal(IndexChLAA,Sector(i),DEG,OFF);
  for (ulong j = 0L; j < GetBeams(); j++) //По лучам
  {Usum = C_ZERO;
   //По каналам LAA
   for (ulong k = 0L; k < GetLAACh(); k++) Usum += U.Get(k)*B.Get(k,j);
   P.Put(i,j,norm(Usum));
  }
 } //Конец цикла по i - сектору определения ДН лучей
 //-----------------------------------------------------------------------------
 // Нормирование диаграмм направленностей ЛУЧЕЙ
 //-----------------------------------------------------------------------------
 if ((NormType != GLOBAL) && (NormType != LOCAL)) return true;
 bool lSuccess;
 if (NormType == GLOBAL)
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.Normalize(FIRST_NORM);
 }
 else if (NormType == LOCAL) //для каждого луча индивидуально
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeColsToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.NormalizeCols(FIRST_NORM);
 }
 return lSuccess;
}
//******************************************************************************
//СТАТУС: I.15,public TMultiBeamFormer class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool TFunc(rmatrix& P, const rvector& Angle, uint NormType = GLOBAL,
//            bool dB = ON, double MindB = -60.0) const;
//НАЗНАЧЕНИЕ: Вычисление диаграммы направленности ЛУЧЕЙ, формируемых схемой, в
//плоскости расположения LAA относительно Земли (по ЭКВАТОРУ или МЕРИДИАНУ) в
//направлениях, определяемых вектором Angle (в градусах). Углы отсчитываются от-
//носительно нормали к раскрыву LAA. При расчете диаграмм направленностей (ДН)
//лучей используется функция TestSignal(...) класса InSignal, формирующая вектор
//напряжений на элементах LAA, подключенных к MultiBeamFormer, при действии с
//заданного направления (по азимуту или углу места) источника сигнала ЕДИНИЧНОЙ
//МОЩНОСТИ. Изменяя положение источника сигнала в заданных направлениях строятся
//ДН ЛУЧЕЙ. ДИАГРАММА НАПРАВЛЕННОСТИ k-го ЛУЧА A(q) вычисляется:
// Ak(q) = SUM{ARF[i]*F(q)[i]*EXP(j(i-1)Ph[i]*B[i,k]) by i = 1..N},
// 1. i - i-ый элемент LAA, подключенного к MultiBeamFormer;
// 2. ARF[i] - относительный коэфф-т усиления i-го элемента LAA
// 3. F(q)[i] - значение нормированной диаграммы направленности i-го элемента АР
//    в направлении источника сигнала
// 4. Ph[i] - фазовый набег (сдвиг) в i-ом элементе АР по сравнению с ОСНОВНЫМ.
// Ph[i] = 2*PI*(L[i])*sin(q), L[i] - относительное расстояние между i-ым и 0-ым
// элементами АР.
// 5. B[i,k] - лучеобразующий коэффициент, соответствующий i-му элементу LAA для
//    формирования k-го луча.
//------------------------------------------------------------------------------
//Функция может рассчитывать НОРМИРОВАННУЮ или НЕНОРМИРОВАННУЮ ДИАГРАММУ НАПРАВ-
//ЛЕННОСТИ ЛУЧЕЙ в зависимости от аргумента NormType. Нормировка может осуществ-
//ляться  для  каждого  луча  индивидуально (LOCAL), либо  одновременно для всех
//лучей (GLOBAL). Нормированная ДН может вычисляться в децибелах (dB = ON), либо
//в относительных единицах (dB = OFF). При нормировании в dB задается минимальный
//порог мощности (значения меньше MindB приравниваются данному). Ненормированная
//ДН - значения в единицах мощности на выходе канала, нормированная ДН вычисляется
//по формуле: G(q) = 10*log10{A(q)/Amax} [Db] - в децибелах,
// 1. q - угол между источником сигнала и нормалью к оси решетки, проходящая
//    через ОСНОВНОЙ элемент АР.
// 2. A(q) - диаграмма направленности адаптивной АР в направлении на угол q
// 3. Amax - МАКСИМАЛЬНОЕ значение диаграммы направленности адаптивной АР в сек-
//    торе от InitAngle до EndAngle.
//Все значения характеристики направленности лучей в заданном секторе размещаются
//в матрице P. Каждый столбец матрицы P соответствует ДН одного луча, формируемого
//схемой. Строки матрицы P соответствуют углам, начиная с наименьшего, при кото-
//рых вычисляются ДН лучей.
//Функция возвращает false и матрицу P нулевого размера в случае НЕРАБОТОСПОСОБ-
//НОСТИ схемы либо, если Angle - вектор нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& P - ссылка на матрицу мощностей лучей схемы в заданном секторе;
//2. const rvector& Angle - углы места (азимута) при которых рассчитываются мощ-
//   ности лучей (в градусах);
//3. uint NormType (GLOBAL) - опция нормирования выходных мощностей [0..1];
//4. bool dB (ON) - опция нормирования в децибелах (действует при Norm = ON);
//5. double MindB - минимальный уровень в децибелах (действует при dB = ON).
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::TFunc(rmatrix& P, const rvector& Angle, uint NormType,
      bool dB, double MindB) const
{//Проверка РАБОТОСПОСОБНОСТИ схемы
 if ((!IsReady()) || (Angle.Size() == 0L)) {P.Set(0L,0L,false); return false;}
 //-----------------------------------------------------------------------------
 //Создаем матрицу P для хранения данных
 P.Set(Angle.Size(),GetBeams(),false);
 //-----------------------------------------------------------------------------
 // Расчет ДН лучей в заданном секторе
 //-----------------------------------------------------------------------------
 complex Usum;
 //Векторы сигнала единичной мощности (тест-сигнала) с элементов LAA, подключен-
 //ных к MultiBeamFormer
 cvector U(GetLAACh(),COL,OFF);
 ivector IndexChLAA; GetLAACh(IndexChLAA);
 for (ulong i = 0L; i < P.Rows(); i++) //По углам сектора
 {//Входной тест-сигнал с элементов LAA, подключенных к BFC
  U = pLAA->TestSignal(IndexChLAA,Angle[i],DEG,OFF);
  for (ulong j = 0L; j < GetBeams(); j++) //По лучам
  {Usum = C_ZERO;
   //По каналам LAA
   for (ulong k = 0L; k < GetLAACh(); k++) Usum += U.Get(k)*B.Get(k,j);
   P.Put(i,j,norm(Usum));
  }
 } //Конец цикла по i - сектору определения ДН лучей
 //-----------------------------------------------------------------------------
 // Нормирование диаграмм направленностей ЛУЧЕЙ
 //-----------------------------------------------------------------------------
 if ((NormType != GLOBAL) && (NormType != LOCAL)) return true;
 bool lSuccess;
 if (NormType == GLOBAL)
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.Normalize(FIRST_NORM);
 }
 else if (NormType == LOCAL) //для каждого луча индивидуально
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeColsToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.NormalizeCols(FIRST_NORM);
 }
 return lSuccess;
}
//******************************************************************************
//СТАТУС: I.16,public TMultiBeamFormer class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool Envelope(rvector& P, const TEvenCloseInterval& Sector, bool Norm = ON,
//               bool dB = ON, double MindB = -60.0) const
//НАЗНАЧЕНИЕ: Построение огибающей диаграмм направленностей МНОГОЛУЧЕВОЙ СХЕМЫ в
//заданном секторе Sector в плоскости расположения LAA относительно поверхности
//Земли (по азимуту или углу места). С этой целью вычисляются диаграммы направлен-
//ности ЛУЧЕЙ для заданного сектора, формируемые в матрице Power. Затем в каждой
//строке матрицы отыскиваются максимальные значения направленностей для заданного
//угла. Из найденных максимальных строковых значений формируется в векторе P,
//передаваемом по ссылке, ОГИБАЮЩАЯ диаграмм направленностей. Для многолучевой
//схемы, формирующей ОДИН луч, ОГИБАЮЩАЯ совпадает с ДН данного луча.
//------------------------------------------------------------------------------
//Функция может рассчитывать НОРМИРОВАННУЮ или НЕНОРМИРОВАННУЮ ОГИБАЮЩУЮ ДН лучей
//в зависимости от аргумента NormType. Нормированная огибающая может вычисляться
//в децибелах (dB = ON), либо в относительных единицах (dB = OFF). При нормирова-
//нии  в dB задается минимальный порог мощности (значения меньше MindB приравни-
//ваются данному).
//Функция возвращает false и вектор P нулевого размера в  случае НЕРАБОТОСПОСОБ-
//НОСТИ схемы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор огибающей ДН лучей схемы в заданном секторе;
//2. const TEvenCloseInterval& Sector - сектор по углу места (азимуту), в  кото-
//   ром рассчитывается диаграммы направленностей (в градусах);
//3. bool Norm (ON) - опция нормирования выходных мощностей [0..1];
//4. bool dB (ON) - опция нормирования в децибелах (действует при Norm = ON);
//5. double MindB - минимальный уровень в децибелах (действует при dB = ON).
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::Envelope(rvector& P, const TEvenCloseInterval& Sector,
     bool Norm, bool dB, double MindB) const
{//Проверка РАБОТОСПОСОБНОСТИ схемы
 if (!IsReady()) {P.Set(0L,ROW,false); return false;}
 //-----------------------------------------------------------------------------
 //Создаем вектор Power для хранения промежуточных результатов
 rvector Power(GetBeams(),COL,false);
 //Устанавливаем размеры вектора огибающей ДН лучей
 P.Set(Sector.Size(),COL,false);
 //-----------------------------------------------------------------------------
 // Расчет ОГИБАЮЩЕЙ ДН лучей в заданном секторе
 //-----------------------------------------------------------------------------
 double Max;
 //Векторы сигнала единичной мощности (тест-сигнала) с элементов LAA, подключен-
 //ных к MultiBeamFormer
 cvector U(GetLAACh(),COL,OFF);
 ivector IndexChLAA; GetLAACh(IndexChLAA);
 for (ulong i = 0L; i < P.Size(); i++) //По углам сектора
 {//Входной тест-сигнал с элементов LAA, подключенных к BFC
  U = pLAA->TestSignal(IndexChLAA,Sector(i),DEG,OFF);
  //Расчет выходных значений в единицах мощности лучеобразующей схемы
  TFunc(U,Power);
  //Поиск максимума для вычисления значения огибающей для i-го угла
  Max = Power.Get(0);
  if (Power.Size() > 1)
   for (ulong j = 1L; j < Power.Size(); j++)
   {if (Max < Power.Get(j)) Max = Power.Get(j);}
  P.Put(i,Max);
 } //Конец цикла по i - сектору определения ДН лучей
 //-----------------------------------------------------------------------------
 // Нормирование огибающей диаграмм направленностей ЛУЧЕЙ
 //-----------------------------------------------------------------------------
 if (Norm == OFF) return true;
 bool lSuccess;
 if (dB == ON) //Нормирование в децибелах [-MindB..0]
  lSuccess = P.NormalizeToDB(true,MindB);
 else //Нормирование в единицах мощности (0..1]
  lSuccess = P.Normalization(FIRST_NORM);
 return lSuccess;
}

//------------------------------------------------------------------------------
// ОБЩЕДОСТУПНЫЕ ФУНКЦИИ РАСЧЕТА ВЫХОДНЫХ ЗНАЧЕНИЙ TMultiBeamFormer
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1; public TMultiBeamFormer class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(const cvector& In, cvector& Out) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ TMultiBeamFormer. В качестве входного воздейст-
//вия используется входной сигнал In (вектор-строка или вектор-столбец). Вектор
//входного сигнала In не изменяется функцией. Результат формируется в векторе Out,
//передаваемый по ссылке. Размерность Out равна количеству лучей, формируемых
//лучеобразующей схемой.
//Если объект класса НЕРАБОТОСПОСОБЕН или размерность вектора In не соответствует
//размерности TMultiBeamFormer, то возвращается false и вектор Out становится
//вектором нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& In - ссылка на вектор входного сигнала;
//2. cvector& Out - ссылка на результирующий вектор.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::TFunc(const cvector& In, cvector& Out) const
{//Проверка на возможность вычисления передаточной функции
 if ((!IsReady()) || (In.Size() != GetLAACh()))
 {Out.Set(0L,ROW,false); return false;}
 //Расчет передаточной функции
 Out.Set(GetBeams(),ROW,C_ZERO);
 for (ulong j = 0L; j < B.Cols(); j++)
  for (ulong i = 0L; i < B.Rows(); i++)
   Out.Put(j,Out.Get(j)+In.Get(i)*B.Get(i,j));
 return true;
}
//******************************************************************************
//СТАТУС: I.2; public TMultiBeamFormer class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(const cmatrix& In, cvector& Out) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ TMultiBeamFormer. В качестве входного воздейст-
//вия используется корреляционная матрица входного сигнала In (эрмитова матрица),
//которая не изменяется функцией. Результат формируется в векторе Out, передавае-
//мый по ссылке. Размерность Out равна количеству лучей, формируемых лучеобразую-
//щей схемой.
//Если объект класса НЕРАБОТОСПОСОБЕН или размерность матрицы In не соответствует
//размерности TMultiBeamFormer, то возвращается false и вектор Out становится
//вектором нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& In - ссылка на корреляционную матрицу входного сигнала;
//2. cvector& Out - ссылка на результирующий вектор.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::TFunc(const cmatrix& In, cvector& Out) const
{//Проверка на возможность вычисления передаточной функции
 if ((!IsReady()) || (!In.IsSquare()) || (In.Rows() != GetLAACh()))
 {Out.Set(0L,ROW,false); return false;}
 //Расчет передаточной функции
 Out.Set(GetBeams(),ROW,C_ZERO);
 cvector V(GetLAACh(),ROW,false);
 //-----------------------------------------------------------------------------
 for (ulong k = 0L; k < Out.Size(); k++) //По лучам
 {V = C_ZERO;
  for (ulong j = 0L; j < In.Cols(); j++)
   for (ulong i = 0L; i < In.Rows(); i++)
    V.Put(j,V.Get(j)+B.Get(i,k)*In.Get(i,j));

  for (ulong i = 0L; i < V.Size(); i++)
   Out.Put(k,Out.Get(k)+V.Get(i)*conj(B.Get(i,k)));
 }
 return true;
}
//******************************************************************************
//СТАТУС: I.3; public TMultiBeamFormer class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(const cvector& In, rvector& P) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ TMultiBeamFormer. В качестве входного воздейст-
//вия используется входной сигнал In (вектор-строка или вектор-столбец). Вектор
//входного сигнала In не изменяется функцией. Результат формируется в векторе P,
//передаваемый по ссылке. Размерность P равна количеству лучей, формируемых луче-
//образующей схемой. Вектор P будет содержать выходные мощности каждого луча при
//действии входного сигнала In.
//Если объект класса НЕРАБОТОСПОСОБЕН или размерность вектора In не соответствует
//размерности TMultiBeamFormer, то возвращается false и вектор P становится
//вектором нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& In - ссылка на вектор входного сигнала;
//2. rvector& P - ссылка на результирующий вектор мощности.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::TFunc(const cvector& In, rvector& P) const
{cvector Out;
 //Вычисление передаточной функции и анализ результата вычисления
 if (TFunc(In,Out) == false) {P.Set(0L,ROW,false); return false;}
 //Вычисление мощностей на выходах многолучевой схемы
 P.Set(GetBeams(),ROW,false);
 for (ulong i = 0L; i < P.Size(); i++) P.Put(i,norm(Out.Get(i)));
 return true;
}
//******************************************************************************
//СТАТУС: I.4; public TMultiBeamFormer class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(const cmatrix& In, rvector& P) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ TMultiBeamFormer. В качестве входного воздейст-
//вия используется корреляционная матрица входного сигнала In (эрмитова матрица),
//которая не изменяется функцией. Результат формируется в векторе P, передаваемый
//по ссылке. Размерность P равна количеству лучей, формируемых лучеобразующей
//схемой. Вектор P будет содержать выходные мощности каждого луча при  действии
//корреляционной матрицы входного сигнала In.
//Если объект класса НЕРАБОТОСПОСОБЕН или размерность матрицы In не соответствует
//размерности TMultiBeamFormer, то возвращается false и вектор Out становится
//вектором нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& In - ссылка на корреляционную матрицу входного сигнала;
//2. rvector& P - ссылка на результирующий вектор мощности.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::TFunc(const cmatrix& In, rvector& P) const
{cvector Out;
 //Вычисление передаточной функции и анализ результата вычисления
 if (TFunc(In,Out) == false) {P.Set(0L,ROW,false); return false;}
 //Вычисление мощностей на выходах многолучевой схемы
 P.Set(GetBeams(),ROW,false);
 for (ulong i = 0L; i < P.Size(); i++) P.Put(i,abs(Out.Get(i)));
 return true;
}
//******************************************************************************
//СТАТУС: I.5; public TMultiBeamFormer class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Signal(cvector& Us, bool PolarType) const
//НАЗНАЧЕНИЕ: Расчет ПОЛЕЗНОГО СИГНАЛА на выходах лучеобразующей схемы при ее
//подключении к LAA. Используется для ЧИСЛЕННОГО и СТАТИСТИЧЕСКОГО МОДЕЛИРОВАНИЯ.
//Результат формируется в векторе Us, передаваемый по ссылке. PolarType указывает
//поляризационную составляющую (V_POLAR || H_POLAR) полезного сигнала, подаваемую
//на вход MultiBeamFormer.
//Если объект класса НЕРАБОТОСПОСОБЕН, то возвращается false и вектор Us будет
//вектором нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& Us - ссылка на выходной вектор полезного сигнала;
//2. bool PolarType - поляризационная составляющая полезного сигнала.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::Signal(cvector& Us, bool PolarType) const
{//Проверка работоспособности схемы
 if (!IsReady()) {Us.Set(0L,ROW,false); return false;}
 //-----------------------------------------------------------------------------
 cvector In(GetLAACh(),ROW,false);
 const cvector* Polar =
 (PolarType == VP_SIGNAL) ? pLAA->GetVPSignal() : pLAA->GetHPSignal();
 //Формирование вектора ПОЛЕЗНОГО СИГНАЛА
 if (IsConnectedAllLAACh()) //Подключены все каналы LAA
  for (ulong i = 0L; i < In.Size(); i++) In.Put(i,Polar->Get(i));
 else //Подключена часть каналов LAA
  for (ulong i = 0L; i < In.Size(); i++) In.Put(i,Polar->Get(Channel.Get(i)));
 //-----------------------------------------------------------------------------
 return TFunc(In,Us);//Вычисление передаточной функции
}
//******************************************************************************
//СТАТУС: I.6; public TMultiBeamFormer class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Noise(cvector& Un, bool PolarType) const
//НАЗНАЧЕНИЕ: Расчет ВНУТРЕННЕГО ШУМА на выходах лучеобразующей схемы при ее
//подключении к LAA. Используется для ЧИСЛЕННОГО и СТАТИСТИЧЕСКОГО МОДЕЛИРОВАНИЯ.
//Результат формируется в векторе Un, передаваемый по ссылке. PolarType указывает
//поляризационную составляющую (V_POLAR || H_POLAR) внутреннего шума, подаваемую
//на вход MultiBeamFormer.
//Если объект класса НЕРАБОТОСПОСОБЕН, то возвращается false и вектор Un будет
//вектором нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& Un - ссылка на выходной вектор внутреннего шума;
//2. bool PolarType - поляризационная составляющая внутреннего шума.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::Noise(cvector& Un, bool PolarType) const
{//Проверка работоспособности схемы
 if (!IsReady()) {Un.Set(0L,ROW,false); return false;}
 //-----------------------------------------------------------------------------
 cvector In(GetLAACh(),ROW,false);
 const cvector* Polar =
 (PolarType == VP_SIGNAL) ? pLAA->GetVPNoise() : pLAA->GetHPNoise();
 //Формирование вектора ВНУТРЕННЕГО ШУМА
 if (IsConnectedAllLAACh()) //Подключены все каналы LAA
  for (ulong i = 0L; i < In.Size(); i++) In.Put(i,Polar->Get(i));
 else //Подключена часть каналов LAA
  for (ulong i = 0L; i < In.Size(); i++) In.Put(i,Polar->Get(Channel.Get(i)));
 //-----------------------------------------------------------------------------
 return TFunc(In,Un);//Вычисление передаточной функции
}
//******************************************************************************
//СТАТУС: I.7; public TMultiBeamFormer class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Jammers(cvector& Ujam, bool PolarType) const
//НАЗНАЧЕНИЕ: Расчет АДДИТИВНОЙ ПОМЕХИ на выходах лучеобразующей схемы при ее
//подключении к LAA. Используется только для СТАТИСТИЧЕСКОГО МОДЕЛИРОВАНИЯ !!!
//Результат формируется в векторе Ujam, передаваемый по ссылке. PolarType указывает
//поляризационную составляющую (V_POLAR || H_POLAR) аддитивной помехи на входе
//MultiBeamFormer.
//Если объект класса НЕРАБОТОСПОСОБЕН, то возвращается false и вектор Ujam будет
//вектором нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& Ujam - ссылка на выходной вектор аддитивной помехи;
//2. bool PolarType - поляризационная составляющая аддитивной помехи.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::Jammers(cvector& Ujam, bool PolarType) const
{//Проверка работоспособности схемы
 if (!IsReady()) {Ujam.Set(0L,ROW,false); return false;}
 //-----------------------------------------------------------------------------
 cvector In(GetLAACh(),ROW,C_ZERO);
 const cmatrix* Polar =
 (PolarType == VP_SIGNAL) ? pLAA->GetVPJammer() : pLAA->GetHPJammer();
 //Формирование вектора АДДИТИВНОЙ ПОМЕХИ
 if (IsConnectedAllLAACh()) //Подключены все каналы LAA
  for (ulong i = 0L; i < In.Size(); i++)
   for (ulong j = 0L; j < Polar->Cols(); j++) //По компонентам активной помехи
    In.Put(i,In.Get(i)+Polar->Get(i,j));
 else //Подключена часть каналов LAA
  for (ulong i = 0L; i < In.Size(); i++)
   for (ulong j = 0L; j < Polar->Cols(); j++) //По компонентам активной помехи
    In.Put(i,In.Get(i)+Polar->Get(Channel.Get(i),j));
 //-----------------------------------------------------------------------------
 return TFunc(In,Ujam);//Вычисление передаточной функции
}
//******************************************************************************
//СТАТУС: I.8; public TMultiBeamFormer class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Jammers(cmatrix& Ujam, bool PolarType) const
//НАЗНАЧЕНИЕ: Расчет АДДИТИВНОЙ ПОМЕХИ на выходах лучеобразующей схемы при ее
//подключении к LAA. Используется только для ЧИСЛЕННОГО МОДЕЛИРОВАНИЯ !!!
//Результат формируется в матрице Ujam, передаваемой по ссылке. Матрица Ujam
//будет иметь размерность (VPJammer.Cols() x GetBeams()). PolarType указывает
//поляризационную составляющую (V_POLAR || H_POLAR) аддитивной помехи на входе
//MultiBeamFormer. Функция производит ПОКОМПОНЕНТНЫЙ расчет для АДДИТИВНОЙ ПОМЕ-
//ХИ на выходе многолучевой лучеобразующей схемы.
//Если объект класса НЕРАБОТОСПОСОБЕН, то возвращается false и матрица Ujam будет
//нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& Ujam - ссылка на выходную матрицу компонент аддитивной помехи;
//2. bool PolarType - поляризационная составляющая аддитивной помехи.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::Jammers(cmatrix& Ujam, bool PolarType) const
{//Проверка работоспособности схемы
 if (!IsReady()) {Ujam.Set(0L,ROW,false); return false;}
 //-----------------------------------------------------------------------------
 cvector In(GetLAACh(),ROW,false);
 cvector Out;
 const cmatrix* Polar =
 (PolarType == VP_SIGNAL) ? pLAA->GetVPJammer() : pLAA->GetHPJammer();
 Ujam.Set(Polar->Cols(),GetBeams(),false);
 //Формирование матрицы покомпонентного представления АДДИТИВНОЙ ПОМЕХИ
 //на выходах MultiBeamFormer
 for (ulong k = 0L; k < Ujam.Rows(); k++) //Для k-ой активной помехи
 {if (IsConnectedAllLAACh()) //Подключены все каналы LAA
   for (ulong i = 0L; i < In.Size(); i++) In.Put(i,Polar->Get(i,k));
  else //Подключена часть каналов LAA
   for (ulong i = 0L; i < In.Size(); i++) In.Put(i,Polar->Get(Channel.Get(i),k));
  //----------------------------------------------------------------------------
  //Вычисление передаточной функции при действии k-ой активной помехи
  TFunc(In,Out);
  //Заносим результаты в матрицу Ujam
  for (ulong i = 0L; i < Ujam.Cols(); i++) Ujam.Put(k,i,Out.Get(i));
 }
 return true;
}
//******************************************************************************
//СТАТУС: I.9; public TMultiBeamFormer class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Psignal(rvector& P, bool PolarType) const
//НАЗНАЧЕНИЕ: Расчет мощности ПОЛЕЗНОГО СИГНАЛА на выходах лучеобразующей схемы
//при ее подключении к LAA. Используется для ЧИСЛЕННОГО и СТАТИСТИЧЕСКОГО МОДЕЛИ-
//РОВАНИЯ. Результат формируется в векторе P, передаваемый по ссылке.
//PolarType указывает поляризационную составляющую (V_POLAR || H_POLAR) полезного
//сигнала на входе MultiBeamFormer.
//Если объект класса НЕРАБОТОСПОСОБЕН, то возвращается false и вектор P будет
//вектором нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на выходной вектор мощности полезного сигнала;
//2. bool PolarType - поляризационная составляющая полезного сигнала.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::Psignal(rvector& P, bool PolarType) const
{cvector Out;
 //Расчет полезного сигнала на выходах схемы и его анализ
 if (Signal(Out,PolarType) == false) {P.Set(0L,ROW,false); return false;}
 //Расчет мощности полезного сигнала
 P.Set(Out.Size(),ROW,false);
 for (ulong i = 0L; i < P.Size(); i++) P.Put(i,norm(Out.Get(i)));
 return true;
}
//******************************************************************************
//СТАТУС: I.10; public TMultiBeamFormer class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Pnoise(rvector& P, bool PolarType) const
//НАЗНАЧЕНИЕ: Расчет мощности ВНУТРЕННЕГО ШУМА на выходах лучеобразующей схемы
//при ее подключении к LAA. Используется для ЧИСЛЕННОГО и СТАТИСТИЧЕСКОГО МОДЕЛИ-
//РОВАНИЯ. Результат формируется в векторе P, передаваемый по ссылке.
//PolarType указывает поляризационную составляющую (V_POLAR || H_POLAR) внутрен-
//него шума на входе MultiBeamFormer.
//Если объект класса НЕРАБОТОСПОСОБЕН, то возвращается false и вектор P будет
//вектором нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на выходной вектор мощности внутреннего шума;
//2. bool PolarType - поляризационная составляющая внутреннего шума.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::Pnoise(rvector& P, bool PolarType) const
{cvector Out;
 //Расчет внутреннего шума на выходах схемы и его анализ
 if (Noise(Out,PolarType) == false) {P.Set(0L,ROW,false); return false;}
 //Расчет мощности внутреннего шума
 P.Set(Out.Size(),ROW,false);
 for (ulong i = 0L; i < P.Size(); i++) P.Put(i,norm(Out.Get(i)));
 return true;
}
//******************************************************************************
//СТАТУС: I.11; public TMultiBeamFormer class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Pjams(rvector& P, bool PolarType) const
//НАЗНАЧЕНИЕ: Расчет мощности АДДИТИВНОЙ ПОМЕХИ на выходах лучеобразующей схемы
//при ее подключении к LAA. Используется только для СТАТИСТИЧЕСКОГО МОДЕЛИРОВАНИЯ.
//Результат формируется в векторе P, передаваемый по ссылке. PolarType указывает
//поляризационную составляющую (V_POLAR || H_POLAR) аддитивной помехи на входе
//MultiBeamFormer.
//Если объект класса НЕРАБОТОСПОСОБЕН, то возвращается false и вектор P будет
//вектором нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на выходной вектор мощности аддитивной помехи;
//2. bool PolarType - поляризационная составляющая аддитивной помехи.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::Pjams(rvector& P, bool PolarType) const
{cvector Out;
 //Расчет аддитивной помехи на выходах схемы и его анализ
 if (Jammers(Out,PolarType) == false) {P.Set(0L,ROW,false); return false;}
 //Расчет мощности аддитивной помехи
 P.Set(Out.Size(),ROW,false);
 for (ulong i = 0L; i < P.Size(); i++) P.Put(i,norm(Out.Get(i)));
 return true;
}
//******************************************************************************
//СТАТУС: I.12; public TMultiBeamFormer class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Pjams(rmatrix& P, bool PolarType) const
//НАЗНАЧЕНИЕ: Расчет мощности АДДИТИВНОЙ ПОМЕХИ на выходах лучеобразующей схемы
//при ее подключении к LAA. Используется только для ЧИСЛЕННОГО МОДЕЛИРОВАНИЯ !!!
//Результат формируется в матрице P, передаваемый по ссылке. Матрица Ujam будет
//иметь размерность (VPJammer.Cols() x GetBeams()).
//PolarType указывает поляризационную составляющую (V_POLAR || H_POLAR) аддитивной
//помехи на входе MultiBeamFormer.
//Если объект класса НЕРАБОТОСПОСОБЕН, то возвращается false и матрица P будет
//матрицей нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& P - ссылка на выходную матрицу мощностей компонент аддитивной помехи;
//2. bool PolarType - поляризационная составляющая аддитивной помехи.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiBeamFormer::Pjams(rmatrix& P, bool PolarType) const
{cmatrix Out;
 //Покомпонентный расчет аддитивной помехи на выходах схемы и его анализ
 if (Jammers(Out,PolarType) == false) {P.Set(0L,0L,false); return false;}
 //Расчет мощности для каждой аддитивной помехи
 P.Set(Out.Rows(),Out.Cols(),false);
 for (ulong i = 0L; i < P.Rows(); i++)
  for (ulong j = 0L; j < P.Cols(); j++)
   P.Put(i,j,norm(Out.Get(i,j)));
 return true;
}

//==============================================================================
//II. РЕАЛИЗАЦИЯ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TMultiBeamFormer
//    PROTECTED MEMBER-FUNCTION OF TMultiBeamFormer CLASS
//==============================================================================
//******************************************************************************
//СТАТУС: II.1., protected MultiBeamFormer class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void _Reset()
//НАЗНАЧЕНИЕ: Начальная установка характеристик класса при конструировании и из-
//менении его характеристик. Указателю на LAA присвается  NULL. Освобождается вся
//динамическая память, выделенная под хранение свойств объекта класса.
//ПРЕДУПРЕЖДЕНИЕ: После  выполнения данной функции объект класса становится
//НЕРАБОТОСПОСОБНЫМ. Начальная установка характеристик следующая:
//------------------------------------------------------------------------------
//1. TInputSignal* pLAA = NULL;
//1. ivector Channel - вектор нулевого размера;
//2. rvector Beam - вектор нулевого размера;
//3. bool lUsedAllCh = OFF;
//3. cmatrix B - матрица нулевого размера;
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TMultiBeamFormer::_Reset()
{pLAA = NULL; Channel = ivector(); Beam = rvector(); lUsedAllCh = OFF;
 B = cmatrix();//Коэффициенты лучеобразующей схемы - MultiBeamFormer
}
//******************************************************************************
//СТАТУС: II.2., protected MultiBeamFormer class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void _SetChannel(const ivector& Index)
//НАЗНАЧЕНИЕ: Установка индексов каналов LAA, подключаемых к MultiBeamFormer.
//При установке индексов каналов LAA осуществляется проверка на корректность
//устанавливаемых индексов по следующим признакам:
//1. ivector Index - вектор НУЛЕВОГО размера, подключаются все элементы LAA,
//   lUsedAllCh устанавливается в ON (true), вектору Channel присваивается нуле-
//   вой длины (с целью экономии памяти).
//2. ivector Index - вектор НЕНУЛЕВОГО размера. Осуществляется проверка вектора
//   на УНИКАЛЬНОСТЬ хранимых индексов элементов LAA (дублирующиеся индексы изв-
//   лекаются) и на ДОПУСТИМОСТЬ индексов каналов LAA диапазону от 0 до LAAElem(),
//   (индексы не входящие в указанный диапазон исключаются).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const ivector& Index - ссылка на вектор с индексами каналов LAA
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TMultiBeamFormer::_SetChannel(const ivector& Index)
{//Установка индексов каналов LAA, подключенных к MultiBeamFormer
 Channel = Index;
 if (Channel.Size() != 0L) Channel = Channel.Unique();
 //Проверка на корректность индексов каналов LAA, подключенных к MultiBeamFormer
 //Установка фильтра корректных индексов
 if (Channel.Size() != 0L)
 {ivector interval(2,0L); interval[1] = pLAA->LAAElem()-1;
  TBelongClosedInterval<long,ivector> Predicate(interval);
  Channel = Channel.SubVector(Predicate);
 }
 //Не подключено ни одного канала
 if (Channel.Size() == 0L) lUsedAllCh = ON;//Подключаем все каналы LAA
 else
 {//Подключены все каналы LAA
  if (Channel.Size() == pLAA->LAAElem()) {Channel.Resize(0L); lUsedAllCh = ON;}
  //Подключены не все каналы LAA
  else {Channel.BubbleSort(); lUsedAllCh = OFF;}
 }
}
//******************************************************************************
//СТАТУС: II.3., protected MultiBeamFormer class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void _SetBeam(const rvector& Angle)
//НАЗНАЧЕНИЕ: Установка направлений лучей MultiBeamFormer. При  установке прост-
//ранственных положений лучей осуществляется проверка на корректность передавае-
//мых значений по следующим признакам:
//1. rvector Angle - вектор НУЛЕВОГО размера, устанавливается один луч в направ-
//   лении 0 градусов (Beam[0] = 0).
//2. rvector Angle - вектор НЕНУЛЕВОГО размера. Осуществляется проверка вектора
//   на УНИКАЛЬНОСТЬ хранимых углов сканирования (дублирующиеся углы извлекаются)
//   и на ДОПУСТИМОСТЬ углов сканирования диапазону от -90 до +90 градусов (зна-
//   чения, не входящие в указанный диапазон, исключаются).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const rvector& Angle - ссылка на вектор с направлениями сканирования
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TMultiBeamFormer::_SetBeam(const rvector& Angle)
{//Установка значений направлений лучей MultiBeamFormer
 Beam = Angle;
 if (Beam.Size() != 0L) Beam = Beam.Unique();
 //Проверка на соответствие направлений сканирования указанному диапазону
 //Установка фильтра корректных индексов
 if (Beam.Size() != 0L)
 {rvector interval(2,COL,false); interval[0] = -90.0; interval[1] = 90.0;
  TBelongClosedInterval<double,rvector> Predicate(interval);
  Beam = Beam.SubVector(Predicate);
 }
 //Не задано ни одного направления
 if (Beam.Size() == 0L) Beam.Set(1,ROW,0.0);
 else Beam.BubbleSort();
}
//******************************************************************************
//СТАТУС: II.4., protected TMultiBeamFormer class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void _CalcMultiBeamFactors()
//НАЗНАЧЕНИЕ: Расчет коэффициентов лучеобразующей схемы класса. Коэффициенты за-
//дают пространственное положение главных лепестков лучей MultiBeamFormer. Коэф-
//фициенты хранятся в комплексной матрице B (столбец матрицы соответствует одно-
//му лучу). Функция рассчитывает коэффициенты для каналов LAA, которые подключа-
//ются к схеме по формуле: PHI(i,j) = 2*PI*LV[i]*sin(Beam[j]), где
// Beam[j] - направление сканирования j-го луча многолучевой схемы (1<=j<= m);
// LV[i] - относительное расстояние между 0 и i-м каналом антенной решетки, под-
// ключенным к многолучевой схеме (1<=i<=N).
//В общем случае, матрица B - прямоугольная размерностью N x M, где N - число
//каналов LAA, подключенных к MultiBeamFormer и M - количество формируемых схемой
//лучей сканирования.
//Индексы элементов LAA, подключаемые к схеме хранятся в векторе Channel.
//Пространственные положения основных лепестков лучей хранятся в векторе Beam.
//Направления лучей в векторе Beam хранятся в градусах.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TMultiBeamFormer::_CalcMultiBeamFactors()
{//Устанавливаем параметры лучеобразующей матрицы B
 ulong LAACh = (IsConnectedAllLAACh()) ? pLAA->LAAElem() : Channel.Size();
 B.Set(LAACh,Beam.Size(),C_ONE);
 //Расчет коэффициентов лучеобразующей матрицы
 for (ulong j = 0L; j < Beam.Size(); j++) //По направлениям сканирования
 {if (Beam.Get(j) != 0.0)
  {double Const = -TwoPI * sin(Beam.Get(j) * DegRad);
   //Проверка подключения всех каналов LAA к MultiBeamFormer
   if (IsConnectedAllLAACh()) //Подключены все каналы LAA
    for (ulong i = 0L; i < pLAA->LAAElem(); i++)
     B.Put(i,j,polar(1, Const * pLAA->GetL(i)));
   else //Подключены не все каналы LAA
    for (ulong i = 0L; i < Channel.Size(); i++)
     B.Put(i,j,polar(1, Const * pLAA->GetL(Channel[i])));
  }
 }
}
//**************** Конец реализации класса TMultiBeamFormer ********************
//******************************************************************************
//                РЕАЛИЗАЦИЯ КЛАССА TAMultiChSpaceFilter
//      Численная модель адаптивной антенной линейной антенной решетки с
//       пространственным фильтром и многолучевой лучеобразующей схемой.
//******************************************************************************
//==============================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TAMultiChSpaceFilter
//   PUBLIC MEMBER-FUNCTION OF TAMultiChSpaceFilter CLASS
//==============================================================================
//******************************************************************************
//СТАТУС: I.1; TAMultiChSpaceFilter public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SetSFilter(uint SF_Type, rvector& SF_Param=rvector())
//НАЗНАЧЕНИЕ: Установка свойств адаптивного пространственного фильтра. Если
//лучеобразующая схема не работоспособна, то функция возвращает false.
//Тип фильтра устанавливается согласно параметру SF_Type, если такой тип весового
//сумматора N x N отсутствует, то по умолчанию устанавливается MS_SDM_MIMO_WSum.
//Дополнительные параметры весового сумматора передаются в векторе SF_Param.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint SF_Type - тип весового сумматора конфигурации N x N;
//2. rvector& SF_Param - ссылка на вектор с параметрами весового сумматора;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TAMultiChSpaceFilter::SetSFilter(uint SF_Type, rvector& SF_Param)
{//Проверка на работоспособность MultiBeamFormer
 if (!IsBeamFormerReady()) return false;
 if (IsSpaceFilterReady()) {delete Filter; Filter = NULL;}
 switch (SF_Type)
 {case MS_SDM_MIMO_WSum: //Выбор MS_SDM_MIMO_WSum
   //Конструирование фильтра
   Filter = new TMultiStageSDA_MIMOWSum(Size(),SF_Param);
   break;
  case MS_SDM_ENCC_MIMO_WSum: //Выбор MS_SDM_ENCC_MIMO_WSum
   //Конструирование фильтра
   Filter = new TMultiStageSDA_ENCC_MIMOWSum(Size(),SF_Param);
   break;
  case MS_SDM_DMPE_MIMO_WSum: //Выбор MS_SDM_DMPE_MIMO_WSum
   //Конструирование фильтра
   Filter = new TMultiStageSDA_DMPE_MIMOWSum(Size(),SF_Param);
   break;
  case MS_SDM_DIPE_MIMO_WSum: //Выбор MS_SDM_DIPE_MIMO_WSum
   //Конструирование фильтра
   Filter = new TMultiStageSDA_DIPE_MIMOWSum(Size(),SF_Param);
   break;
  case MS_DSDM_MIMO_WSum: //Выбор MS_DSDM_MIMO_WSum
   //Конструирование фильтра
   Filter = new TDMultiStageSDA_MIMOWSum(Size(),SF_Param);
   break;
  case MS_DSDM_DMPE_MIMO_WSum: //Выбор MS_DSDM_DMPE_MIMO_WSum
   //Конструирование фильтра
   Filter = new TDMultiStageSDA_DMPE_MIMOWSum(Size(),SF_Param);
   break;
  case MS_DSDM_DIPE_MIMO_WSum: //Выбор MS_DSDM_DIPE_MIMO_WSum
   //Конструирование фильтра
   Filter = new TDMultiStageSDA_DIPE_MIMOWSum(Size(),SF_Param);
   break;
  case MS_DSDM_EITPE_MIMO_WSum: //Выбор MS_DSDM_EITPE_MIMO_WSum
   //Конструирование фильтра
   Filter = new TDMultiStageSDA_EITPE_MIMOWSum(Size(),SF_Param);
   break;
  default: //По умолчанию MS_SDM_MIMO_WSum
   //Конструирование фильтра
   Filter = new TMultiStageSDA_MIMOWSum(Size(),SF_Param);
 }
 _MatrixSet();//Установка размеров корреляционных матриц
 return true;
}
//******************************************************************************
//СТАТУС: I.2; TAMultiChSpaceFilter public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool SetBeamFormer(TInputSignal* pLAA, const ivector& LAACh = ivector(),
//     const rvector& Beams = rvector())
//НАЗНАЧЕНИЕ: Установка свойств многолучевой лучеобразующей схемы. Если свойства
//лучеобразующая схема не могут быть установлены, то функция возвращает false и
//все параметры адаптивной LAA сбрасываются - она становится неработоспособной.
//При изменении свойств MultiBeamFormer происходит настройка размерности прост-
//ранственного фильтра согласно числу каналов LAA, подключенных к фильтру.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TInputSignal* pLAA - указатель на LAA;
//2. const ivector& LAACh - номера каналов LAA, подключаемые к фильтру;
//3. const rvector& Beams - направления лучей, формируемых MultiBeamFormer
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TAMultiChSpaceFilter::SetBeamFormer(TInputSignal* pLAA, const ivector& LAACh,
     const rvector& Beams)
{//Установка свойств многолучевой схемы
 if (TMultiBeamFormer::Set(pLAA,LAACh,Beams))
  return _SetSFilterSize();//Установка размеров фильтра и корреляционных матриц
 else _Reset();//Сброс всех параметров адаптивной LAA
 return false;
};
//******************************************************************************
//СТАТУС: I.3; TAMultiChSpaceFilter public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//string& Properties(string& s, string& title = string(), uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта TAMultiChSpaceFilter в виде строки.
//Функция формирует строковое представление свойств численной модели адаптивной
//LAA с пространственным фильтром конфигурации NxN, многолучевой лучеобразующей
//схемой и свойств входного воздействия. Информация заносится в строку s, переда-
//ваемую в функцию по ссылке, предыдущее содержимое строки уничтожается.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& title - ссылка на строку с заголовком объекта;
//3. uint indent - начальное смещение строки.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//******************************************************************************
string& TAMultiChSpaceFilter::Properties(string& s, string& title, uint indent) const
{string t, head, space(' ',indent);
 s.resize(0);
 //Формирование заголовка объекта
 s.append(space);
 if (title.empty())
  s.append("NUMERICAL MODEL of ADAPTIVE LAA < NxN SpaceFilter & MultiBeamFormer >: ");
 else s.append(title);
 //-----------------------------------------------------------------------------
 //Анализ работоспособности адаптивной LAA
 //-----------------------------------------------------------------------------
 if (!IsReady()) s.append("< Off >\n"); //АДАПТИВНАЯ LAA НЕРАБОТОСПОСОБНА
 else s.append("< On >\n");
 //-----------------------------------------------------------------------------
 //1. Формирование свойств аналитической модели предпроцессора
 head = "I. MultiBeamFormer ";
 if (!IsBeamFormerReady()) //MultiBeamFormer не работоспособен
 {s.append(space);s.append(1,' ');
  s.append(head+": < Off >\n"); s.append(space);
  s.append("  Cause: MultiBeamFormer didn't switched to LAA.\n");
 }
 s.append(TMultiBeamFormer::Properties(t,head,0,0,indent+1));
 //-----------------------------------------------------------------------------
 //2. Формирование свойств пространственного фильтра (весового сумматора)
 head = "II. Space Filter ";
 if (!IsSpaceFilterReady()) //Фильтр не подключен к адаптивной LAA
 {s.append(space);s.append(1,' ');
  s.append(head+": < Off >\n"); s.append(space);
  s.append("  Cause: Filter didn't switched to Adaptive LAA.\n");
 }
 else s.append(Filter->Properties(t,head,indent+1)); //Фильтр подключен
 //-----------------------------------------------------------------------------
 //3. Формирование свойств входного воздействия
 head = "III. Input Signal ";
 s.append(TAnalInSignalProperty::Properties(t,head,indent+1));
 //-----------------------------------------------------------------------------
 //4. Поляризационная составляющая входного воздействия
 head = "IV. Polarization: ";
 s.append(Polarization(t,head,indent+1));
return s;
}
//****************************************************************************************
//СТАТУС: I.4; public TAMultiChSpaceFilter member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& Polarization(string& s, string& title, uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирование поляризационной составляющей сигнала принимаемого адаптивной LAA
//в строке s, передаваемой по ссылке. Прежнее содержимое строки s уничтожается.
// Polarization: <VERTICAL || HORIZONTAL>;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& title - ссылка на строку-заголовок;
//3. uint indent - начальное смещение строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление поляризации
//****************************************************************************************
string& TAMultiChSpaceFilter::Polarization(string& s, string& title, uint indent) const
{string t, header; string space(' ',indent);
 //Формирование заголовка объекта
 s = space;
 if (title.empty()) s.append("Polarization: ");
 else s.append(title);
 //-----------------------------------------------------------------------------
 if (GetPolar() == VP_SIGNAL) s.append("< Vertical >\n");
 else s.append("< Horizontal >\n");
 return s;
}
//******************************************************************************
//СТАТУС: I.5; TAMultiChSpaceFilter public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit()
//НАЗНАЧЕНИЕ: Редактирование свойств объекта класса через стандартный поток
//ввода cin (консольный ввод данных).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TAMultiChSpaceFilter::Edit()
{//-----------------------------------------------------------------------------
 //АДАПТИВНАЯ LAA НЕРАБОТОСПОСОБЕНА: редактирование свойств объекта невозможно
 //-----------------------------------------------------------------------------
 if (!IsReady())
 {gotoxy(1,wherey()); clreol();
  cout << "Editing NUMERICAL MODEL of ADAPTIVE LAA is impossible !!!\a\n";
  if (!IsBeamFormerReady())
   cout << " Cause: MultiBeamFormer hasn't been connected to LAA yet." << endl;
  if (!IsSpaceFilterReady())
   cout << " Cause: SpaceFilter hasn't been connected to Adaptive LAA yet." << endl;
  return;
 }
 STR_UINT Option[6] = {
  {1, "Edit < MultiBeamFormer >" },
  {2, "Edit < Space Filter >" },
  {3, "Edit < InPut Signal >" },
  {4, "Edit < Polarization >" },
  {5, "View < Properties   >" },
  {6, "Exit                 " } };
 TB_STR_UINT Menu = {6, Option};
 string head = " Choice menu option [1-6]: ";
 //Рабочие переменные
 int y_start = wherey();
 string line(78,'-');
 const string msg = "Press any key...";
 const string s = "Numerical Model of ADAPTIVE LAA: < Editing >";
 string t;
 bool flag = true;
 gotoxy(1,y_start); clreol();
 do
 {cout << line << endl << s << endl << line << endl;
  uint choice = ConsoleChoice(Menu, 4, head.c_str(), 2);
  switch (choice)
  {case 1: //Редактирование свойств аналитической модели предпроцессора
    TMultiBeamFormer::Edit();
    //Установка размерности адаптивного фильтра и корреляционных матриц
    _SetSFilterSize();
    cout << msg << endl; getch();
    break;
   case 2: //Редактирование свойств пространственного фильтра
    EditSFilter();
    break;
   case 3: //Редактирование свойств входного воздействия
    TAnalInSignalProperty::Edit();
    cout << msg << endl; getch();
    break;
   case 4: //Редактирование поляризационных свойств входного воздействия
    EditPolar();
    cout << msg << endl; getch();
    break;
   case 5: //Свойства адаптивной LAA
    cout << Properties(t,STR_NULL);
    cout << msg << endl; getch();
    break;
   case 6: flag = false; break;//Выход из режима редактирования
  }
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
}
//******************************************************************************
//СТАТУС: I.6; TAMultiChSpaceFilter public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditFilter()
//НАЗНАЧЕНИЕ: Редактирование свойств / выбор пространственного фильтра адаптивной
//LAA через стандартный поток ввода cin (консольный ввод данных).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TAMultiChSpaceFilter::EditSFilter()
{STR_UINT Option[11] = {
  {MS_SDM_MIMO_WSum,       "Select < MStage_SDM_MIMO_Filter >" },          //1
  {MS_SDM_ENCC_MIMO_WSum,  "Select < MStage_SDM_ENCC_MIMO_Filter >" },     //2
  {MS_SDM_DMPE_MIMO_WSum,  "Select < MStage_SDM_DMPE_MIMO_Filter >" },     //3
  {MS_SDM_DIPE_MIMO_WSum,  "Select < MStage_SDM_DIPE_MIMO_Filter >" },     //4
  {MS_DSDM_MIMO_WSum,      "Select < MStage_DigSDM_MIMO_Filter >" },       //5
  {MS_DSDM_DMPE_MIMO_WSum, "Select < MStage_DigSDM_DMPE_MIMO_Filter >" },  //6
  {MS_DSDM_DIPE_MIMO_WSum, "Select < MStage_DigSDM_DIPE_MIMO_Filter >" },  //7
  {MS_DSDM_EITPE_MIMO_WSum,"Select < MStage_DigSDM_EITPE_MIMO_Filter >" }, //8
  {9,                      "Edit < Internal Properties >"},
  {10,                     "View < Properties >" },
  {11,                     "Exit" } };
 TB_STR_UINT Menu = {11, Option};
 string head = " Choice menu option [1-11]: ";
 //Рабочие переменные
 int y_start = wherey();
 string line(78,'-');
 const string msg = "Press any key...";
 const string s = "Adaptive Space MIMO Filter : < Editing/Choosing >";
 string t;
 bool flag = true;
 gotoxy(1,y_start); clreol();
 do
 {cout << line << endl << s << endl << line << endl;
  uint choice = ConsoleChoice(Menu, 7, head.c_str(), 2);
  switch (choice)
  {//Выбор нового типа фильтра
   case MS_SDM_MIMO_WSum:
   case MS_SDM_ENCC_MIMO_WSum:
   case MS_SDM_DMPE_MIMO_WSum:
   case MS_SDM_DIPE_MIMO_WSum:
   case MS_DSDM_MIMO_WSum:
   case MS_DSDM_DMPE_MIMO_WSum:
   case MS_DSDM_DIPE_MIMO_WSum:
   case MS_DSDM_EITPE_MIMO_WSum:
    //Конструирование фильтра
    SetSFilter(choice);
    //Редактирование внутренних параметров фильтра
    Filter->Edit(OFF);
    break;
   case 9: //Редактирование внутренних параметров фильтра
    if (IsSpaceFilterReady()) Filter->Edit(OFF);
    else
    {cout << "Space Filter didn't switched to AdaptLAA !!!" << endl;
     cout << msg << endl; getch();
    }
    break;
   case 10: //Свойства пространственного фильтра
    if (IsSpaceFilterReady()) cout << Filter->Properties(t,STR_NULL);
    else cout << "Space Filter didn't switched to AdaptLAA !!!" << endl;
    cout << msg << endl; getch();
    break;
   case 11: flag = false; break;//Выход из режима редактирования
  }
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
}
//******************************************************************************
//СТАТУС: I.7;  TAMultiChSpaceFilter class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditPolar()
//НАЗНАЧЕНИЕ: Ввод поляризационной составляющей входного воздействия, принимае-
//мой AdaptiveLAA. Формат ввода ПОЛЯРИЗАЦИИ:
//------------------------------------------------------------------------------
//Polarization: <Input polarization type>
// 1. Vertical polarization;
// 2. Horizontal polarization.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TAMultiChSpaceFilter::EditPolar()
{//Рабочие переменные
 int choice, y_start = wherey(); char c; string s, line(78,'-');
 bool PolarType, flag;
 STR_UINT ListPolarComponent[2] = {
  {1,  "Vertical polarization"  },
  {2,  "Horizontal polarization" } };
 TB_STR_UINT TbPolarComponent = {2, ListPolarComponent};
 string head =  " Choice polarizing component of input signal:";
 //----------------------------------------------------------------------------
 //Ввод поляризационной составляющей входного сигнала, поступающей на вход
 //адаптивного пространственного фильтра
 //----------------------------------------------------------------------------
 gotoxy(1,y_start); clreol();
 do
 {cout << line << endl;
  cout << "POLARIZATION: < Input polarization type >" << endl;
  choice = ConsoleChoice(TbPolarComponent, VP_SIGNAL, head.c_str(), 4);
  switch (choice)
  { case 1: PolarType = VP_SIGNAL; break;
    case 2: PolarType = HP_SIGNAL; break;
  }
  SetPolar(PolarType);
  //Отображение результатов ввода поляризационной составляющей
  ClrScr(1,y_start);//Очистка экрана
  cout << line << endl << Polarization(s,STR_NULL) << line << endl;
  //----------------------------------------------------------------------------
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
}
//******************************************************************************
//СТАТУС: I.8; public TAMultiChSpaceFilter class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: operator =(const TAMultiChSpaceFilter& SFilter)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ класса TAMultiChSpaceFilter.
//Функция осуществляет копирование исходных параметров схемы из одного  объекта
//TAMultiChSpaceFilter в другой. Осуществляется корректное копирование членов-данных
//с целью  недопущения  ссылок указателей разных объектов класса на одно и то же
//место памяти.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TAMultiChSpaceFilter& SFilter - ссылка на копию
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TAMultiChSpaceFilter::operator =(const TAMultiChSpaceFilter& SFilter)
{//Предотвращение попытки присваивания объекта самому себе
 if (this == &SFilter) return;
 if (!SFilter.IsReady()) {_Reset(); return;}  //SFilter не работоспособен
 //Установка свойств лучеобразующей схемы
 ivector Index;
 rvector Angle;
 SFilter.GetLAACh(Index); SFilter.GetBeams(Angle);
 SetBeamFormer(SFilter.GetLAAPtr(),Index,Angle);
 //Установка поляризационной составляющей сигнала
 SetPolar(SFilter.GetPolar());
 //Установка свойств пространственного фильтра
 rvector Arg;
 SetSFilter(SFilter.SFilterType(),SFilter.SFilterParam(Arg));
 //Установка свойств "стационарности" входного воздействия
 SetInSignalStat(SFilter.GetSignalStat(), SFilter.GetJammerStat(),
                 SFilter.GetNoiseStat());
}
//------------------------------------------------------------------------------
//  ПЕРЕДАТОЧНЫЕ ФУНКЦИИ КЛАССА TAMultiChSpaceFilter
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1,public,class member-function TAMultiChSpaceFilter
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool TFunc(rmatrix& P, const TEvenCloseInterval& Sector, uint NormType = GLOBAL,
//           bool dB = ON, double MindBb = -60.0) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ AdaptLAA с пространственным адаптивным фильт-
//ром типа N x N и многолучевой лучеобразующей схемой. В качестве тест-сигнала
//для численной модели адаптивной LAA используем вектор-сигнал с целью ускорения
//раблты функции.
//Если AdaptLAA не работоспособна функция возвращает false и матрицу P нулевого
//размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& P - ссылка на выходную матрицу мощностей в заданном секторе;
//2. const TEvenCloseInterval& Sector - сектор по углу места (азимуту), в  кото-
//   ром рассчитывается передаточная функция (в градусах);
//3. uint NormType (GLOBAL) - опция нормирования выходных мощностей [0..1];
//4. bool dB (ON) - опция нормирования в децибелах (действует при Norm = ON);
//5. double MindB - минимальный уровень в децибелах (действует при dB = ON).
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//******************************************************************************
bool TAMultiChSpaceFilter::TFunc(rmatrix& P, const TEvenCloseInterval& Sector,
                                 uint NormType, bool dB, double MindB) const
{//Проверка работоспособности Adaptive LAA:
 if (!IsReady()) {P.Set(0L,0L,false); return false;}
 //-----------------------------------------------------------------------------
 //Создаем матрицу P для хранения данных
 P.Set(Sector.Size(),TMultiBeamFormer::GetBeams(),false);
 //-----------------------------------------------------------------------------
 // Расчет Rjn, InvRjn при T = 0, вычисление потенциальной выходной мощности
 // адаптивной LAA по заданной Rjn
 //-----------------------------------------------------------------------------
 rvector MinP;
 cmatrix A(GetLAACh(),GetLAACh(),C_ZERO);
 cmatrix W; GetW(W);
 for (ulong i = 0L; i < A.Rows(); i++) A.Put(i,i,W.Get(i,i));
 A.LowerColumnEM(W,LEFT); A.RightRowEM(W,RIGHT);
 //Выходная мощность AdaptLAA в данной помеховой ситуации
 TMultiBeamFormer::TFunc(A,MinP);
 //-----------------------------------------------------------------------------
 // Расчет ДН лучей в заданном секторе
 //-----------------------------------------------------------------------------
 //Вектор сигнала единичной мощности (тест-сигнала) с элементов LAA, подключен-
 //ных к адаптивной LAA
 cvector U(GetLAACh(),COL,OFF);
 cmatrix R(GetLAACh(),GetLAACh(),OFF);
 rvector OutP(TMultiBeamFormer::GetBeams(),COL,OFF);
 ivector LAACh; TMultiBeamFormer::GetLAACh(LAACh);
 for (ulong i = 0L; i < P.Rows(); i++) //По углам сектора
 {//Входной тест-сигнал с элементов LAA, подключенных к адаптивной LAA
  U = TMultiBeamFormer::pLAA->TestSignal(LAACh,Sector(i),DEG,OFF);
  //Формирование корреляционной матрицы тест-сигнала
  for (ulong i = 0L; i < R.Rows(); i++)
   for (ulong j = 0L; j <= i ; j++)
   {if (i == j) R.Put(i,j,norm(U.Get(i)));
    else
    {R.Put(i,j,U.Get(i)*conj(U.Get(j))); R.Put(j,i,conj(R.Get(i,j)));}
   }
  //----------------------------------------------------------------------------
  //1. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ пространственного фильтра AdaptiveLAA
  //----------------------------------------------------------------------------
  Filter->TF_WSum(R);
  //----------------------------------------------------------------------------
  //2. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ лучеобразующей схемы
  //----------------------------------------------------------------------------
  TMultiBeamFormer::TFunc(R,OutP);
  //Записываем мощности на выходе лучеобразующей схемы в матрицу P
  for (ulong j = 0L; j < P.Cols(); j++) P.Put(i,j,OutP.Get(j)/MinP.Get(j));
 } //Конец цикла по i - сектору определения ДН лучей
 //-----------------------------------------------------------------------------
 // Нормирование диаграмм направленностей ЛУЧЕЙ
 //-----------------------------------------------------------------------------
 if ((NormType != GLOBAL) && (NormType != LOCAL)) return true;
 bool lSuccess;
 if (NormType == GLOBAL)
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.Normalize(FIRST_NORM);
 }
 else if (NormType == LOCAL) //для каждого луча индивидуально
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeColsToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.NormalizeCols(FIRST_NORM);
 }
 return lSuccess;
}
//******************************************************************************
//СТАТУС: I.2,public,class member-function TAMultiChSpaceFilter
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool TF_SFilter(rmatrix& P, const TEvenCloseInterval& Sector,
//     uint NormType = GLOBAL, bool dB = ON, double MindBb = -60.0) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ пространственного адаптивным фильтра N x N.
//В качестве тест-сигнала для численной модели пространственного фильтра адаптив-
//ной LAA используем вектор-сигнал с целью ускорения работы функции. Функция вы-
//числяет диаграммы направленностей каналов LAA, подключенных к адаптивной LAA,
//на выходе пространственного фильтра.
//Если AdaptLAA не работоспособна функция возвращает false и матрицу P нулевого
//размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& P - ссылка на выходную матрицу мощностей каналов в заданном секторе;
//2. const TEvenCloseInterval& Sector - сектор по углу места (азимуту), в  кото-
//   ром рассчитывается передаточная функция (в градусах);
//3. uint NormType (GLOBAL) - опция нормирования выходных мощностей [0..1];
//4. bool dB (ON) - опция нормирования в децибелах (действует при Norm = ON);
//5. double MindB - минимальный уровень в децибелах (действует при dB = ON).
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//******************************************************************************
bool TAMultiChSpaceFilter::TF_SFilter(rmatrix& P, const TEvenCloseInterval& Sector,
                           uint NormType, bool dB, double MindB) const
{//Проверка работоспособности Adaptive LAA:
 if (!IsReady()) {P.Set(0L,0L,false); return false;}
 //-----------------------------------------------------------------------------
 //Создаем матрицу P для хранения данных
 P.Set(Sector.Size(),Size(),false);
 //-----------------------------------------------------------------------------
 // Расчет ДН лучей в заданном секторе
 //-----------------------------------------------------------------------------
 //Вектор сигнала единичной мощности (тест-сигнала) с элементов LAA, подключен-
 //ных к адаптивной LAA
 cvector U(Size(),COL,OFF);
 cmatrix R(Size(),Size(),OFF);
 rvector OutP(Size(),COL,OFF);
 ivector LAACh; TMultiBeamFormer::GetLAACh(LAACh);
 for (ulong i = 0L; i < P.Rows(); i++) //По углам сектора
 {//Входной тест-сигнал с элементов LAA, подключенных к адаптивной LAA
  U = TMultiBeamFormer::pLAA->TestSignal(LAACh,Sector(i),DEG,OFF);
  //Формирование корреляционной матрицы тест-сигнала
  for (ulong i = 0L; i < R.Rows(); i++)
   for (ulong j = 0L; j <= i ; j++)
   {if (i == j) R.Put(i,j,norm(U.Get(i)));
    else
    {R.Put(i,j,U.Get(i)*conj(U.Get(j))); R.Put(j,i,conj(R.Get(i,j)));}
   }
  //----------------------------------------------------------------------------
  //1. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ пространственного фильтра AdaptiveLAA
  //----------------------------------------------------------------------------
  Filter->TF_WSum(OutP,R);
  //Записываем мощности на выходе фильтра в матрицу P
  for (ulong j = 0L; j < P.Cols(); j++) P.Put(i,j,OutP.Get(j));
 } //Конец цикла по i - сектору определения ДН лучей
 //-----------------------------------------------------------------------------
 // Нормирование диаграмм направленностей ЛУЧЕЙ
 //-----------------------------------------------------------------------------
 if ((NormType != GLOBAL) && (NormType != LOCAL)) return true;
 bool lSuccess;
 if (NormType == GLOBAL)
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.Normalize(FIRST_NORM);
 }
 else if (NormType == LOCAL) //для каждого луча индивидуально
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeColsToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.NormalizeCols(FIRST_NORM);
 }
 return lSuccess;
}
//***********************************************************************************
//СТАТУС: I.3,public,class member-function TAMultiChSpaceFilter
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool TF_Potent(rmatrix& P, double Time, const TEvenCloseInterval& Sector,
//               uint NormType = GLOBAL, bool dB = ON, double MindBb = -60.0)
//НАЗНАЧЕНИЕ: ПОТЕНЦИАЛЬНАЯ ПЕРЕДАТОЧНАЯ ФУНКЦИЯ AdaptLAA с пространственным адаптивным
//фильтром типа N x N и многолучевой лучеобразующей схемой при заданной помеховой си-
//туации. Помеховая ситуация задается корреляционной матрицей Rjn, формируемой в момент
//времени Time. Rjn - это корреляционная матрица аддитивной активной помехи и внутрен-
//него шума на входе адаптивной LAA в произвольный момент времени. Методика расчета
//ПОТЕНЦИАЛЬНОЙ ПЕРЕДАТОЧНОЙ функции адаптивной LAA с N-канальным пространственным
//фильтром и многолучевой лучеобразующей схемой:
//1. Вычисляем матрицу InvRjn ОБРАТНУЮ к матрице Rjn.
//2. Рассчитываем передаточную функцию MultiBeamFormer при подаче матрицы InvRjn.
//   Получим вектор мощностей MinP. Данный вектор определяет минимальную выходную
//   мощность помехи и шума каждого луча, формируемого схемой.
//3. Рассчитываем в цикле отношение выходной мощности каждого луча при нахождении
//   единичного источника мощности в определенном угловом положении q сектора
//   к минимальной выходной мощности для каждого луча по формуле:
//             Pin(q,i)   trB(i) x InvRjn x R(q) x InvRjn x B(i)
//   P(q,i) = --------- = -------------------------------------- ;
//             Pmin(i)            trB(i) x InvRjn x B(i)
// i - порядковый номер луча, формируемого лучеобразующей схемой;
// q - угловое положение источника сигнала единичной мощности;
// B(i) - лучеобразующий вектор с фазосдигающими коэффициентами для формирования
//        i-го луча;
// trB(i) - сопряженно-транспонированный вектор к B(i);
// InvRjn - обратная матрица к корреляционной матрице Rjn помеховой обстановки
// R(q) - корреляционная матрица источника сигнала едиичной мощности,
//        расположенного под углом q относительно раскрыва LAA
// По матрице R(q) рассчитывается величина Pin(q,i) - мощность на выходе адаптивной
// LAA для i-го луча при положении источника сигнала под углом q при заданной помеховой
// ситуации. Если положение источника сигнала q совпадет с положением источника помехи,
// то P(q,i) примет минимальное значение. Это вызвано тем, что адаптивная LAA формирует
// провалы в направлениях расположения источников активных помех.
// Таким образом, функция позволяет оценить ПОТЕНЦИАЛЬНУЮ ЭФФЕКТИВНОСТЬ адаптивной LAA
// c N-канальным пространственным фильтром и многолучевой лучеобразующей схемой на
// выходе фильтра.
// Если AdaptLAA не работоспособна либо матрица Rjn не соответствует размерности
// пространственного фильтра, то возвращается false и матрица P нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& P - ссылка на выходную матрицу мощностей (активной помехи + внутренний
//   шум) в заданном секторе;
//2. double Time - момент времени при котором производятся расчеты;
//3. const TEvenCloseInterval& Sector - сектор по углу места (азимуту), в  котором
//   рассчитывается передаточная функция (в градусах);
//4. uint NormType (GLOBAL) - опция нормирования выходных мощностей [0..1];
//5. bool dB (ON) - опция нормирования в децибелах (действует при Norm = ON);
//6. double MindB - минимальный уровень в децибелах (действует при dB = ON).
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//***********************************************************************************
bool TAMultiChSpaceFilter::TF_Potent(rmatrix& P, double Time,
     const TEvenCloseInterval& Sector, uint NormType, bool dB, double MindB)
{//Проверка работоспособности Adaptive LAA:
 if (!IsReady()) {P.Set(0L,0L,false); return false;}
 //Моделирование входного воздействия в момент времени Time и формирование
 //корреляционных матриц Rnn и Rjn
 cmatrix Rjn, Rnn;
 TInputSignal* pLAA = GetLAAPtr();
 pLAA->Update(Time,false); Update(0);
 GetInR(Rjn,OFF,ON,ON); GetInRnn(Rnn);
 //----------------------------------------------------------------------------------
 //Создаем матрицу P для хранения данных
 P.Set(Sector.Size(),2*GetBeams(),false);
 //----------------------------------------------------------------------------------
 // Расчет InvRjn, InvRnn вычисление потенциальной выходной мощности
 // адаптивной LAA по заданной Rjn и Rnn
 //----------------------------------------------------------------------------------
 cmatrix Bjn, Bnn;
 cmatrix InvRjn = Rjn.INV_Krauth();
 cmatrix InvRnn = Rnn.INV_Krauth();
 rvector MinPjn, MinPn;
 //Потенциальная выходная мощность AdaptLAA в данной помеховой ситуации
 //(с аддитивной активной помехой и без нее)
 TMultiBeamFormer::TFunc(InvRjn,MinPjn);
 TMultiBeamFormer::TFunc(InvRnn,MinPn);
 //----------------------------------------------------------------------------------
 // Расчет ДН лучей в заданном секторе
 //----------------------------------------------------------------------------------
 //Вектор сигнала единичной мощности (тест-сигнала) с элементов LAA, подключенных к
 //адаптивной LAA
 cvector U(GetLAACh(),COL,OFF);
 cmatrix R(GetLAACh(),GetLAACh(),OFF);
 rvector OutPjn(TMultiBeamFormer::GetBeams(),COL,OFF);
 rvector OutPn(TMultiBeamFormer::GetBeams(),COL,OFF);
 ivector LAACh; TMultiBeamFormer::GetLAACh(LAACh);
 for (ulong i = 0L; i < P.Rows(); i++) //По углам сектора
 {//Входной тест-сигнал с элементов LAA, подключенных к адаптивной LAA
  U = TMultiBeamFormer::pLAA->TestSignal(LAACh,Sector(i),DEG,OFF);
  //Формирование корреляционной матрицы тест-сигнала
  for (ulong i = 0L; i < R.Rows(); i++)
   for (ulong j = 0L; j <= i ; j++)
   {if (i == j) R.Put(i,j,norm(U.Get(i)));
    else
    {R.Put(i,j,U.Get(i)*conj(U.Get(j))); R.Put(j,i,conj(R.Get(i,j)));}
   }
  //---------------------------------------------------------------------------------
  //1. Потенциальная ПЕРЕДАТОЧНАЯ ФУНКЦИЯ пространственного фильтра AdaptiveLAA
  //---------------------------------------------------------------------------------
  Bjn = InvRjn * R * InvRjn;
  Bnn = InvRnn * R * InvRnn;
  //---------------------------------------------------------------------------------
  //2. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ лучеобразующей схемы
  //---------------------------------------------------------------------------------
  TMultiBeamFormer::TFunc(Bjn,OutPjn);
  TMultiBeamFormer::TFunc(Bnn,OutPn);
  //Записываем мощности на выходе лучеобразующей схемы в матрицу P
  ulong k;
  for (ulong j = 0L; j < GetBeams(); j++)
  {k = 2*j;
   P.Put(i,k,OutPjn.Get(j)/MinPjn.Get(j));
   P.Put(i,k+1,OutPn.Get(j)/MinPn.Get(j));
  }
 } //Конец цикла по i - сектору определения ДН лучей
 //----------------------------------------------------------------------------------
 // Нормирование диаграмм направленностей ЛУЧЕЙ
 //----------------------------------------------------------------------------------
 if ((NormType != GLOBAL) && (NormType != LOCAL)) return true;
 bool lSuccess;
 if (NormType == GLOBAL)
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.Normalize(FIRST_NORM);
 }
 else if (NormType == LOCAL) //для каждого луча индивидуально
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeColsToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.NormalizeCols(FIRST_NORM);
 }
 return lSuccess;
}

//-----------------------------------------------------------------------------------
//           ФУНКЦИИ МОДЕЛИРОВАНИЯ КЛАССА TAMultiChSpaceFilter
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: I.1, TAMultiChSpaceFilter public class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Update(double Time)
//НАЗНАЧЕНИЕ: Расчет корреляционных матриц ПОЛЕЗНОГО СИГНАЛА Rss, АДДИТИВНОЙ ПО-
//МЕХИ Rjj и ВНУТРЕННЕГО ШУМА Rnn на входе аналитической модели адаптивного
//пространственного фильтра с ОСНОВНЫМ КАНАЛОМ в момент времени Time.
//Если какая-либо компонента входного  воздействия (полезный  сигнал, внутренний
//шум или аддитивная помеха) является стационарной, то соответствующая ей корре-
//ляционная матрица (Rss, Rjj, Rnn)  рассчитывается один раз, только в  начале
//процесса моделирования работы адаптивного фильтра (Time == 0).
//Если класс неработоспособен, то функция завершает свою работу и возвращает
//значение false (OFF) - признак неудачного завершения работы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: double Time - модельное время
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//******************************************************************************
bool TAMultiChSpaceFilter::Update(double Time)
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) return OFF;
 bool TimeZero = OFF;//Индикатор начало отсчета времени
 if (Time < EPS) TimeZero = ON;
 //-----------------------------------------------------------------------------
 //Расчет корреляционных матриц
 //-----------------------------------------------------------------------------
 //В начальный момент времени
 if (TimeZero == ON) {_CalcInRss();  _CalcInRjj();  _CalcInRnn();}
 else //В другие моменты времени
 {//Полезный сигнал "нестационарен"
  if (GetSignalStat() == OFF) _CalcInRss();
  if (GetJammerStat() == OFF) _CalcInRjj();
  if (GetNoiseStat()  == OFF) _CalcInRnn();
 }
 //-----------------------------------------------------------------------------
 //Формирование входной корреляционной матрица полезного сигнала, аддитивной
 //помехи и внутреннего шума -- R
 complex Sum;
  for (ulong i = 0L; i < R.Rows(); i++)
   for (ulong j = 0L; j < R.Cols(); j++)
    R.Put(i,j,Rss.Get(i,j) + Rjj.Get(i,j) + Rnn.Get(i,j));
 //-----------------------------------------------------------------------------
 //Расчет коэффициентов нормирования по матрице R
 Filter->TuneNorm(R);
 return ON;
}
//******************************************************************************
//СТАТУС: I.2., public TAMultiChSpaceFilter class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool InPs_SFilter(rvector& Ps) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ПОЛЕЗНОГО СИГНАЛА на входах адаптив-
//ного пространственного фильтра.
//Если адаптивный фильтр не активен (IsReady() == OFF), то возвращается вектор
//нулевого размера. Вектор мощности полезного сигнала формируется в векторе Ps,
//передаваемый в функцию по ссылке. Для вычислений используется матрица Rss.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//rvector& Ps - ссылка на вектор, в котором формируется мощность полезного сигнала
//на входах адаптивного фильтра
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TAMultiChSpaceFilter::InPs_SFilter(rvector& Ps) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {Ps.Set(0L,ROW,false); return false;}
 //-----------------------------------------------------------------------------
 //Формирование входного вектора мощности ПОЛЕЗНОГО СИГНАЛА
 //-----------------------------------------------------------------------------
 Ps.Set(Rss.Rows(),ROW,false);//Формирование вектора необходимого размера
 //Цикл формирования значений элементов вектора
 for (ulong i = 0L; i < Ps.Size(); i++) Ps.Put(i,real(Rss.Get(i,i)));
 return true;
}
//******************************************************************************
//СТАТУС: I.3., public TAMultiChSpaceFilter class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool InPjam_SFilter(rvector& Pjam) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности АКТИВНОЙ ПОМЕХИ на входах адаптивного
//пространственного фильтра.
//Если адаптивный фильтр не активен (IsReady() == OFF), то возвращается вектор
//нулевого размера. Вектор мощности активной помехи формируется в векторе Pjam,
//передаваемый в функцию по ссылке. Для вычислений используется матрица Rjj.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//rvector& Pjam - ссылка на вектор, в котором формируется мощность активной помехи
//на входах адаптивного фильтра
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TAMultiChSpaceFilter::InPjam_SFilter(rvector& Pjam) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {Pjam.Set(0L,ROW,false); return false;}
 //-----------------------------------------------------------------------------
 //Формирование входного вектора мощности АКТИВНОЙ ПОМЕХИ
 //-----------------------------------------------------------------------------
 Pjam.Set(Rjj.Rows(),ROW,false);//Формирование вектора необходимого размера
 //Цикл формирования значений элементов вектора
 for (ulong i = 0L; i < Pjam.Size(); i++) Pjam.Put(i,real(Rjj.Get(i,i)));
 return true;
}
//******************************************************************************
//СТАТУС: I.4., public TAMultiChSpaceFilter class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool InPn_SFilter(rvector& Pn) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ВНУТРЕННЕГО ШУМА на входах адаптивного
//пространственного фильтра.
//Если адаптивный фильтр не активен (IsReady() == OFF), то возвращается вектор
//нулевого размера. Вектор мощности внутреннего шума формируется в векторе Pn,
//передаваемый в функцию по ссылке. Для вычислений используется матрица Rnn.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//rvector& Pn - ссылка на вектор, в котором формируется мощность внутреннего шума
//на входах адаптивного фильтра
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TAMultiChSpaceFilter::InPn_SFilter(rvector& Pn) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {Pn.Set(0L,ROW,false); return false;}
 //-----------------------------------------------------------------------------
 //Формирование входного вектора мощности ВНУТРЕННЕГО ШУМА
 //-----------------------------------------------------------------------------
 Pn.Set(Rnn.Rows(),ROW,false);//Формирование вектора необходимого размера
 //Цикл формирования значений элементов вектора
 for (ulong i = 0L; i < Pn.Size(); i++) Pn.Put(i,real(Rnn.Get(i,i)));
 return true;
}
//******************************************************************************
//СТАТУС: I.5., public TAMultiChSpaceFilter class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& OutPjnPotent_SFilter(rvector& P) const
//НАЗНАЧЕНИЕ: Расчет  потенциальной  мощности активной помехи и внутреннего шума
//на выходах  адаптивного пространственного фильтра. Потенциальная выходная мощ-
//ность каналов фильтра рассчитывается  по обращенной корреляционной матрице ак-
//тивной помехи и внутреннего шума на входе фильтра. Диагональные элементы обрат-
//ной матрицы InvRjn соответствуют потенциальным выходным мощностям каналов. Ре-
//зультат вычислений помещается в вектор P, передаваемый в функцию по ссылке.
//Если адаптивная LAA неработоспособна, то возвращается вектор P нулевого размера.
//Размерность вектора P равна числу каналов пространственного фильтра.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: rvector& P - ссылка на вектор с потенциальными выходными
//мощностями активной помехи и внутреннего шума пространственного фильтра
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка на результирующий вектор
//******************************************************************************
rvector& TAMultiChSpaceFilter::OutPjnPotent_SFilter(rvector& P) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {P.Set(0L,ROW,false); return P;}
 P.Set(Size(),ROW,0.0);//Формирование вектора необходимого размера
 //Формирование входной корреляционной матрицы активной помехи и шума
 cmatrix Rjn, InvRjn; GetInR(Rjn,OFF,ON,ON);
 //Обращение матрицы помехи и внутреннего шума
 InvRjn = Rjn.INV_Krauth();
 //Цикл формирования значений элементов вектора
 for (ulong i = 0L; i < P.Size(); i++) P.Put(i,real(InvRjn.Get(i,i)));
 return P;
}
//******************************************************************************
//СТАТУС: I.6., public TAMultiChSpaceFilter class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& KsupPotent_SFilter(rvector& Ksup) const
//НАЗНАЧЕНИЕ: Расчет потенциальных коэффициентов подавления каналов адаптивного
//пространственного фильтра. Результат помещается в вектор Ksup, передаваемый в
//функцию по ссылке. Если адаптивная LAA неработоспособна, то функция возвращает
//Ksup нулевого размера. Для N-канального пространственного фильтра потенциальный
//коэффициент подавления для i-го канала рассчитывается по формуле:
//  Ksup[i] = 10*log10(InPjn[i]/OutPjnPotent[i]).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: rvector& Ksup - ссылка на вектор с потенциальными коэф-
//фициентами подавления каждого канала пространственного фильтра
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& Ksup - ссылка на результирующий вектор
//******************************************************************************
rvector& TAMultiChSpaceFilter::KsupPotent_SFilter(rvector& Ksup) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {Ksup.Set(0L,ROW,false); return Ksup;}
 rvector InPj, InPn, OutPjn;
 InPjam_SFilter(InPj); InPn_SFilter(InPn); OutPjnPotent_SFilter(OutPjn);
 Ksup.Set(Size(),ROW,0.0);
 //Расчет потенциальных коэффициентов подавления каналов фильтра
 for (ulong i = 0L; i < Ksup.Size(); i++)
 {if (OutPjn.Get(i) > 0)
   Ksup.Put(i,10*log10((InPj.Get(i)+InPn.Get(i))/OutPjn.Get(i)));
 }
 return Ksup;
}
//******************************************************************************
//СТАТУС: I.7., public TAMultiChSpaceFilter class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& OutPjnPotent(rvector& P) const
//НАЗНАЧЕНИЕ: Расчет потенциальной мощности активной помехи и внутреннего шума
//на выходах адаптивной LAA. Потенциальная выходная мощность каналов фильтра
//рассчитывается по входной корреляционной матрице активной помехи и внутреннего
//шума. Результат вычислений помещается в вектор P, передаваемый по ссылке. Раз-
//мерность матрицы равна числу, формируемых MultiBeamFormer лучей. Если Adaptive
//LAA неработоспособна, то функция возвращает вектор P нулевого размера.
//Для N-канальной адаптивной LAA с многоканальным пространственным фильтром и
//многолучевой лучеобразующей схемой потенциальная выходная мощность вычисляется
//по следующей методике:
//1. Формируем диагональную комплексную матрицу D с элементами по диагонали вида:
//   Каналы фильтра:   0      1      2      3           k           N
//                  [1/D0  D0/D1  D1/D2  D2/D3 ... Dk-1/Dk ...  Dn-1/Dn], где
//   Dk - главный минор матрицы InRjn вида M(0 1 ... k-1 k; 0 1 ... k-1 k)
//2. Рассчитываем передаточную функцию MultiBeamFormer при подаче на ее вход
//   диагональной комплексной матрицы D.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: rvector& P - ссылка на вектор с потенциальными выходными
//мощностями активной помехи и внутреннего шума адаптивной LAA
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка на результирующий вектор
//******************************************************************************
rvector& TAMultiChSpaceFilter::OutPjnPotent(rvector& P) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {P.Set(0L,ROW,false); return P;}
 //-----------------------------------------------------------------------------
 //1. Формирование и обращение входной корреляционной матрицы активной помехи и
 //   внутреннего шума
 //-----------------------------------------------------------------------------
 cmatrix Rjn,InvRjn; GetInR(Rjn,OFF,ON,ON); InvRjn = Rjn.INV_Krauth();
 //-----------------------------------------------------------------------------
 //2. Расчет потенциальной выходной мощности активной помехи и внутреннего шума
 //   на выходе адаптивной LAA /выходы MultiBeamFormer
 //-----------------------------------------------------------------------------
 TMultiBeamFormer::TFunc(InvRjn,P);
 return P;
}
//******************************************************************************
//СТАТУС: I.8., public TAMultiChSpaceFilter class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& KsupPotent(rvector& Ksup) const
//НАЗНАЧЕНИЕ: Расчет потенциальных коэффициентов подавления выходов адаптивной
//LAA /выходы MultiBeamFormer/. Результат помещается в вектор Ksup, передаваемый
//в функцию по ссылке. Если адаптивная LAA неработоспособна, то функция возвращает
//Ksup нулевого размера. Для адаптивной LAA потенциальный коэффициент подавления
//для i-го луча рассчитывается по формуле:
//  Ksup[i] = 10*log10(InPjn[i]/OutPjnPotent[i]) [dB],
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: rvector& Ksup - ссылка на вектор с потенциальными коэф-
//фициентами подавления каждого луча адаптивной LAA
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& Ksup - ссылка на результирующий вектор
//******************************************************************************
rvector& TAMultiChSpaceFilter::KsupPotent(rvector& Ksup) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {Ksup.Set(0L,ROW,false); return Ksup;}
 rvector InPj, InPn, OutPjn;
 InPJammer(InPj); InPNoise(InPn); OutPjnPotent(OutPjn);
 Ksup.Set(GetBeams(),ROW,0.0);
 //Расчет потенциальных коэффициентов подавления каждого луча Adaptive LAA
 for (ulong i = 0L; i < Ksup.Size(); i++)
 {if (OutPjn.Get(i) > 0)
   Ksup.Put(i,10*log10((InPj.Get(i)+InPn.Get(i))/OutPjn.Get(i)));
 }
 return Ksup;
}

//==============================================================================
//II. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TAMultiChSpaceFilter
//    PROTECTED MEMBER-FUNCTION OF TAMultiChSpaceFilter CLASS
//==============================================================================
//******************************************************************************
//СТАТУС: II.1; protected TAMultiChSpaceFilter class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: void _CalcInRss()
//НАЗНАЧЕНИЕ: Расчет корреляционной матрицы ПОЛЕЗНОГО СИГНАЛА на входе адаптивной
//LAA. Результат формируется в матрице Rss.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TAMultiChSpaceFilter::_CalcInRss()
{const cvector* Polar =
 (GetPolar() == VP_SIGNAL) ? pLAA->GetVPSignal() : pLAA->GetHPSignal();
 cvector Us(Size(),COL,false);
 if (IsConnectedAllLAACh()) //Подключены все каналы LAA
  for (ulong i = 0L; i < Us.Size(); i++) Us.Put(i,Polar->Get(i));
 else //Подключена часть каналов LAA
  for (ulong i = 0L; i < Us.Size(); i++) Us.Put(i,Polar->Get(Channel.Get(i)));
 //-----------------------------------------------------------------------------
 //Формирование корреляционной матрицы ПОЛЕЗНОГО СИГНАЛА
 for (ulong i = 0L; i < Rss.Rows(); i++)
  for (ulong j = 0L; j <= i ; j++)
  {if (i == j) Rss.Put(i,j,norm(Us.Get(i)));
   else
   {Rss.Put(i,j,Us.Get(i)*conj(Us.Get(j))); Rss.Put(j,i,conj(Rss.Get(i,j)));}
  }
}
//******************************************************************************
//СТАТУС: II.2; protected TAMultiChSpaceFilter class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: void _CalcInRnn()
//НАЗНАЧЕНИЕ: Расчет корреляционной матрицы ВНУТРЕННЕГО ШУМА на входе адаптивной
//LAA. Результат формируется в матрице Rnn.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TAMultiChSpaceFilter::_CalcInRnn()
{const cvector* Polar =
 (GetPolar() == VP_SIGNAL) ? pLAA->GetVPNoise() : pLAA->GetHPNoise();
 cvector Un(Size(),COL,false);
 if (IsConnectedAllLAACh()) //Подключены все каналы LAA
  for (ulong i = 0L; i < Un.Size(); i++) Un.Put(i,Polar->Get(i));
 else //Подключена часть каналов LAA
  for (ulong i = 0L; i < Un.Size(); i++) Un.Put(i,Polar->Get(Channel.Get(i)));
 //-----------------------------------------------------------------------------
 //Формирование корреляционной матрицы ВНУТРЕННЕГО ШУМА
 for (ulong i = 0L; i < Rnn.Rows(); i++)
  for (ulong j = 0L; j <= i ; j++)
  {if (i == j) Rnn.Put(i,j,norm(Un.Get(i)));
   else {Rnn.Put(i,j,C_ZERO); Rnn.Put(j,i,C_ZERO);}
  }
}
//******************************************************************************
//СТАТУС: II.3; protected TAMultiChSpaceFilter class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: void _CalcInRjj()
//НАЗНАЧЕНИЕ: Расчет корреляционной матрицы АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ на входе
//адаптивной LAA. Результат формируется в матрице Rjj.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TAMultiChSpaceFilter::_CalcInRjj()
{const cmatrix* Polar =
 (GetPolar() == VP_SIGNAL) ? pLAA->GetVPJammer() : pLAA->GetHPJammer();
 cvector Uj(Size(),COL,false);
 //-----------------------------------------------------------------------------
 //Формирование корреляционной матрицы ВНУТРЕННЕГО ШУМА
 Rjj = C_ZERO;
 for (ulong k = 0L; k < Polar->Cols(); k++) //Для k-ой помехи
 {if (IsConnectedAllLAACh()) //Подключены все каналы LAA
   for (ulong i = 0L; i < Uj.Size(); i++) Uj.Put(i,Polar->Get(i,k));
  else //Подключена часть каналов LAA
   for (ulong i = 0L; i < Uj.Size(); i++) Uj.Put(i,Polar->Get(Channel.Get(i),k));
  //----------------------------------------------------------------------------
  for (ulong i = 0L; i < Rjj.Rows(); i++)
   for (ulong j = 0L; j <= i ; j++)
   {if (i == j) Rjj.Put(i,j, Rjj.Get(i,j) + norm(Uj.Get(i)));
    else
    {Rjj.Put(i,j, Rjj.Get(i,j) + Uj.Get(i)*conj(Uj.Get(j)));
     Rjj.Put(j,i, conj(Rjj.Get(i,j)));
    }
   }
 }//Конец цикла по k-ой помехе
}

//******************************************************************************
//                РЕАЛИЗАЦИЯ КЛАССА TMultiChSpaceFilter
//    Статистическая модель адаптивной антенной линейной антенной решетки с
//      пространственным фильтром и многолучевой лучеобразующей схемой.
//******************************************************************************
//==============================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TMultiChSpaceFilter
//   PUBLIC MEMBER-FUNCTION OF TMultiChSpaceFilter CLASS
//==============================================================================
//******************************************************************************
//СТАТУС: I.1; TMultiChSpaceFilter public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SetSFilter(uint SF_Type, rvector& SF_Param=rvector())
//НАЗНАЧЕНИЕ: Установка свойств адаптивного пространственного фильтра. Если
//лучеобразующая схема не работоспособна, то функция возвращает false.
//Тип фильтра устанавливается согласно параметру SF_Type, если такой тип весового
//сумматора N x N отсутствует, то по умолчанию устанавливается MS_SDM_MIMO_WSum.
//Дополнительные параметры весового сумматора передаются в векторе SF_Param.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint SF_Type - тип весового сумматора конфигурации N x N;
//2. rvector& SF_Param - ссылка на вектор с параметрами весового сумматора;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiChSpaceFilter::SetSFilter(uint SF_Type, rvector& SF_Param)
{//Проверка на работоспособность MultiBeamFormer
 if (!IsBeamFormerReady()) return false;
 if (IsSpaceFilterReady()) {delete Filter; Filter = NULL;}
 switch (SF_Type)
 {case MS_SDM_MIMO_WSum: //Выбор MS_SDM_MIMO_WSum
   //Конструирование фильтра
   Filter = new TMultiStageSDA_MIMOWSum(Size(),SF_Param);
   break;
  case MS_SDM_ENCC_MIMO_WSum: //Выбор MS_SDM_ENCC_MIMO_WSum
   //Конструирование фильтра
   Filter = new TMultiStageSDA_ENCC_MIMOWSum(Size(),SF_Param);
   break;
  case MS_SDM_DMPE_MIMO_WSum: //Выбор MS_SDM_DMPE_MIMO_WSum
   //Конструирование фильтра
   Filter = new TMultiStageSDA_DMPE_MIMOWSum(Size(),SF_Param);
   break;
  case MS_SDM_DIPE_MIMO_WSum: //Выбор MS_SDM_DIPE_MIMO_WSum
   //Конструирование фильтра
   Filter = new TMultiStageSDA_DIPE_MIMOWSum(Size(),SF_Param);
   break;
  case MS_DSDM_MIMO_WSum: //Выбор MS_DSDM_MIMO_WSum
   //Конструирование фильтра
   Filter = new TDMultiStageSDA_MIMOWSum(Size(),SF_Param);
   break;
  case MS_DSDM_DMPE_MIMO_WSum: //Выбор MS_DSDM_DMPE_MIMO_WSum
   //Конструирование фильтра
   Filter = new TDMultiStageSDA_DMPE_MIMOWSum(Size(),SF_Param);
   break;
  case MS_DSDM_DIPE_MIMO_WSum: //Выбор MS_DSDM_DIPE_MIMO_WSum
   //Конструирование фильтра
   Filter = new TDMultiStageSDA_DIPE_MIMOWSum(Size(),SF_Param);
   break;
  case MS_DSDM_EITPE_MIMO_WSum: //Выбор MS_DSDM_EITPE_MIMO_WSum
   //Конструирование фильтра
   Filter = new TDMultiStageSDA_EITPE_MIMOWSum(Size(),SF_Param);
   break;
  default: //По умолчанию MS_SDM_MIMO_WSum
   //Конструирование фильтра
   Filter = new TMultiStageSDA_MIMOWSum(Size(),SF_Param);
 }
 _VectorSet();//Установка размеров векторов и матрицы AvW
 return true;
}
//******************************************************************************
//СТАТУС: I.2; TMultiChSpaceFilter public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool SetBeamFormer(TInputSignal* pLAA, const ivector& LAACh = ivector(),
//     const rvector& Beams = rvector())
//НАЗНАЧЕНИЕ: Установка свойств многолучевой лучеобразующей схемы. Если свойства
//лучеобразующая схема не могут быть установлены, то функция возвращает false и
//все параметры адаптивной LAA сбрасываются - она становится неработоспособной.
//При изменении свойств MultiBeamFormer происходит настройка размерности прост-
//ранственного фильтра согласно числу каналов LAA, подключенных к фильтру.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TInputSignal* pLAA - указатель на LAA;
//2. const ivector& LAACh - номера каналов LAA, подключаемые к фильтру;
//3. const rvector& Beams - направления лучей, формируемых MultiBeamFormer
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiChSpaceFilter::SetBeamFormer(TInputSignal* pLAA, const ivector& LAACh,
     const rvector& Beams)
{//Установка свойств многолучевой схемы
 if (TMultiBeamFormer::Set(pLAA,LAACh,Beams))
  return _SetSFilterSize();//Установка размеров фильтра и корреляционных матриц
 else _Reset();//Сброс всех параметров адаптивной LAA
 return false;
};
//****************************************************************************************
//СТАТУС: I.3; TMultiChSpaceFilter public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//string& Properties(string& s, string& title, uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта TAMultiChSpaceFilter в виде строки.
//Функция  формирует строковое представление свойств статистической модели адап-
//тивной LAA с пространственным фильтром конфигурации NxN, многолучевой лучеобра-
//зующей схемой и свойств входного воздействия. Информация заносится в строку s,
//передаваемую в функцию по ссылке, предыдущее содержимое строки уничтожается.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& title - ссылка на строку с заголовком объекта;
//3. uint indent - начальное смещение строки.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//******************************************************************************
string& TMultiChSpaceFilter::Properties(string& s, string& title, uint indent) const
{string t, head, space(' ',indent);
 s.resize(0);
 //Формирование заголовка объекта
 s.append(space);
 if (title.empty())
  s.append("STATISTICAL MODEL of ADAPTIVE LAA < NxN SpaceFilter & MultiBeamFormer >: ");
 else s.append(title);
 //-----------------------------------------------------------------------------
 //Анализ работоспособности адаптивной LAA
 //-----------------------------------------------------------------------------
 if (!IsReady()) s.append("< Off >\n"); //АДАПТИВНАЯ LAA НЕРАБОТОСПОСОБНА
 else s.append("< On >\n");
 //-----------------------------------------------------------------------------
 //1. Формирование свойств многолучевой лучеобразующей схемы
 head = "I. MultiBeamFormer ";
 if (!IsBeamFormerReady()) //MultiBeamFormer не работоспособен
 {s.append(space);s.append(1,' ');
  s.append(head+": < Off >\n"); s.append(space);
  s.append("  Cause: MultiBeamFormer didn't switched to LAA.\n");
 }
 s.append(TMultiBeamFormer::Properties(t,head,0,0,indent+1));
 //-----------------------------------------------------------------------------
 //2. Формирование свойств пространственного фильтра (весового сумматора)
 head = "II. Space Filter ";
 if (!IsSpaceFilterReady()) //Фильтр не подключен к адаптивной LAA
 {s.append(space);s.append(1,' ');
  s.append(head+": < Off >\n"); s.append(space);
  s.append("  Cause: Filter didn't switched to Adaptive LAA.\n");
 }
 else s.append(Filter->Properties(t,head,indent+1)); //Фильтр подключен
 //-----------------------------------------------------------------------------
 //3. Поляризационная составляющая входного воздействия
 head = "III. Polarization: ";
 s.append(Polarization(t,head,indent+1));
return s;
}
//******************************************************************************
//СТАТУС: I.4; public TMultiChSpaceFilter member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//string& Polarization(string& s, string& title, uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирование символьного представления поляризационной составляющей
//сигнала принимаемого адаптивной LAA в строке s, передаваемой по ссылке. Прежнее
//содержимое строки s уничтожается.
// Polarization: <VERTICAL || HORIZONTAL>;
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& title - ссылка на строку-заголовок;
//3. uint indent - начальное смещение строки.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление поляризации
//******************************************************************************
string& TMultiChSpaceFilter::Polarization(string& s, string& title, uint indent) const
{string t, header; string space(' ',indent);
 //Формирование заголовка объекта
 s = space;
 if (title.empty()) s.append("Polarization: ");
 else s.append(title);
 //-----------------------------------------------------------------------------
 if (GetPolar() == VP_SIGNAL) s.append("< Vertical >\n");
 else s.append("< Horizontal >\n");
 return s;
}
//******************************************************************************
//СТАТУС: I.5; TMultiChSpaceFilter public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit()
//НАЗНАЧЕНИЕ: Редактирование свойств объекта класса через стандартный поток
//ввода cin (консольный ввод данных).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TMultiChSpaceFilter::Edit()
{//-----------------------------------------------------------------------------
 //АДАПТИВНАЯ LAA НЕРАБОТОСПОСОБЕНА: редактирование свойств объекта невозможно
 //-----------------------------------------------------------------------------
 if (!IsReady())
 {gotoxy(1,wherey()); clreol();
  cout << "Editing STATISTICAL MODEL of ADAPTIVE LAA is impossible !!!\a\n";
  if (!IsBeamFormerReady())
   cout << " Cause: MultiBeamFormer hasn't been connected to LAA yet." << endl;
  if (!IsSpaceFilterReady())
   cout << " Cause: SpaceFilter hasn't been connected to Adaptive LAA yet." << endl;
  return;
 }
 STR_UINT Option[5] = {
  {1, "Edit < MultiBeamFormer >" },
  {2, "Edit < Space Filter >" },
  {3, "Edit < Polarization >" },
  {4, "View < Properties   >" },
  {5, "Exit                 " } };
 TB_STR_UINT Menu = {5, Option};
 string head = " Choice menu option [1-5]: ";
 //Рабочие переменные
 int y_start = wherey();
 string line(78,'-');
 const string msg = "Press any key...";
 const string s = "Statistical Model of ADAPTIVE LAA: < Editing >";
 string t;
 bool flag = true;
 gotoxy(1,y_start); clreol();
 do
 {cout << line << endl << s << endl << line << endl;
  uint choice = ConsoleChoice(Menu, 4, head.c_str(), 2);
  switch (choice)
  {case 1: //Редактирование свойств лучеобразующей схемы
    TMultiBeamFormer::Edit();
    //Установка размерности адаптивного фильтра, векторов и матрицы AvW
    _SetSFilterSize();
    cout << msg << endl; getch();
    break;
   case 2: //Редактирование свойств пространственного фильтра
    EditSFilter();
    break;
   case 3: //Редактирование поляризационных свойств входного воздействия
    EditPolar();
    cout << msg << endl; getch();
    break;
   case 4: //Свойства адаптивной LAA
    cout << Properties(t,STR_NULL);
    cout << msg << endl; getch();
    break;
   case 5: flag = false; break;//Выход из режима редактирования
  }
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
}
//******************************************************************************
//СТАТУС: I.6; TMultiChSpaceFilter public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditFilter()
//НАЗНАЧЕНИЕ: Редактирование свойств / выбор пространственного фильтра адаптивной
//LAA через стандартный поток ввода cin (консольный ввод данных).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TMultiChSpaceFilter::EditSFilter()
{STR_UINT Option[11] = {
  {MS_SDM_MIMO_WSum,       "Select < MStage_SDM_MIMO_Filter >" },          //1
  {MS_SDM_ENCC_MIMO_WSum,  "Select < MStage_SDM_ENCC_MIMO_Filter >" },     //2
  {MS_SDM_DMPE_MIMO_WSum,  "Select < MStage_SDM_DMPE_MIMO_Filter >" },     //3
  {MS_SDM_DIPE_MIMO_WSum,  "Select < MStage_SDM_DIPE_MIMO_Filter >" },     //4
  {MS_DSDM_MIMO_WSum,      "Select < MStage_DigSDM_MIMO_Filter >" },       //5
  {MS_DSDM_DMPE_MIMO_WSum, "Select < MStage_DigSDM_DMPE_MIMO_Filter >" },  //6
  {MS_DSDM_DIPE_MIMO_WSum, "Select < MStage_DigSDM_DIPE_MIMO_Filter >" },  //7
  {MS_DSDM_EITPE_MIMO_WSum,"Select < MStage_DigSDM_EITPE_MIMO_Filter >" }, //8
  {9,                      "Edit < Internal Properties >"},
  {10,                     "View < Properties >" },
  {11,                     "Exit" } };
 TB_STR_UINT Menu = {11, Option};
 string head = " Choice menu option [1-11]: ";
 //Рабочие переменные
 int y_start = wherey();
 string line(78,'-');
 const string msg = "Press any key...";
 const string s = "Adaptive Space MIMO Filter : < Editing/Choosing >";
 string t;
 bool flag = true;
 gotoxy(1,y_start); clreol();
 do
 {cout << line << endl << s << endl << line << endl;
  uint choice = ConsoleChoice(Menu, 7, head.c_str(), 2);
  switch (choice)
  {//Выбор нового типа фильтра
   case MS_SDM_MIMO_WSum:
   case MS_SDM_ENCC_MIMO_WSum:
   case MS_SDM_DMPE_MIMO_WSum:
   case MS_SDM_DIPE_MIMO_WSum:
   case MS_DSDM_MIMO_WSum:
   case MS_DSDM_DMPE_MIMO_WSum:
   case MS_DSDM_DIPE_MIMO_WSum:
   case MS_DSDM_EITPE_MIMO_WSum:
    //Конструирование фильтра
    SetSFilter(choice);
    //Редактирование внутренних параметров фильтра
    Filter->Edit(OFF);
    break;
   case 9: //Редактирование внутренних параметров фильтра
    if (IsSpaceFilterReady()) Filter->Edit(OFF);
    else
    {cout << "Space Filter didn't switched to AdaptLAA !!!" << endl;
     cout << msg << endl; getch();
    }
    break;
   case 10: //Свойства пространственного фильтра
    if (IsSpaceFilterReady()) cout << Filter->Properties(t,STR_NULL);
    else cout << "Space Filter didn't switched to AdaptLAA !!!" << endl;
    cout << msg << endl; getch();
    break;
   case 11: flag = false; break;//Выход из режима редактирования
  }
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
}
//******************************************************************************
//СТАТУС: I.7;  TMultiChSpaceFilter class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditPolar()
//НАЗНАЧЕНИЕ: Ввод поляризационной составляющей входного воздействия, принимае-
//мой AdaptiveLAA. Формат ввода ПОЛЯРИЗАЦИИ:
//------------------------------------------------------------------------------
//Polarization: <Input polarization type>
// 1. Vertical polarization;
// 2. Horizontal polarization.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TMultiChSpaceFilter::EditPolar()
{//Рабочие переменные
 int choice, y_start = wherey(); char c; string s, line(78,'-');
 bool PolarType, flag;
 STR_UINT ListPolarComponent[2] = {
  {1,  "Vertical polarization"  },
  {2,  "Horizontal polarization" } };
 TB_STR_UINT TbPolarComponent = {2, ListPolarComponent};
 string head =  " Choice polarizing component of input signal:";
 //----------------------------------------------------------------------------
 //Ввод поляризационной составляющей входного сигнала, поступающей на вход
 //адаптивного пространственного фильтра
 //----------------------------------------------------------------------------
 gotoxy(1,y_start); clreol();
 do
 {cout << line << endl;
  cout << "POLARIZATION: < Input polarization type >" << endl;
  choice = ConsoleChoice(TbPolarComponent, VP_SIGNAL, head.c_str(), 4);
  switch (choice)
  { case 1: PolarType = VP_SIGNAL; break;
    case 2: PolarType = HP_SIGNAL; break;
  }
  SetPolar(PolarType);
  //Отображение результатов ввода поляризационной составляющей
  ClrScr(1,y_start);//Очистка экрана
  cout << line << endl << Polarization(s,STR_NULL) << line << endl;
  //----------------------------------------------------------------------------
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
}
//******************************************************************************
//СТАТУС: I.8; public TMultiChSpaceFilter class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: operator =(const TMultiChSpaceFilter& SFilter)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ класса TMultiChSpaceFilter.
//Функция осуществляет копирование исходных параметров схемы из одного  объекта
//TMultiChSpaceFilter в другой. Осуществляется корректное копирование членов-данных
//с целью  недопущения  ссылок указателей разных объектов класса на одно и то же
//место памяти.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TMultiChSpaceFilter& SFilter - ссылка на копию
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TMultiChSpaceFilter::operator =(const TMultiChSpaceFilter& SFilter)
{//Предотвращение попытки присваивания объекта самому себе
 if (this == &SFilter) return;
 if (!SFilter.IsReady()) {_Reset(); return;}  //SFilter не работоспособен
 //Установка свойств лучеобразующей схемы
 ivector Index;
 rvector Angle;
 SFilter.GetLAACh(Index); SFilter.GetBeams(Angle);
 SetBeamFormer(SFilter.GetLAAPtr(),Index,Angle);
 //Установка поляризационной составляющей сигнала
 SetPolar(SFilter.GetPolar());
 //Установка свойств пространственного фильтра
 rvector Arg;
 SetSFilter(SFilter.SFilterType(),SFilter.SFilterParam(Arg));
}
//------------------------------------------------------------------------------
//  ПЕРЕДАТОЧНЫЕ ФУНКЦИИ КЛАССА TMultiChSpaceFilter
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1,public,class member-function TMultiChSpaceFilter
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool TFunc(rmatrix& P, const TEvenCloseInterval& Sector, uint NormType = GLOBAL,
//           bool dB = ON, double MindBb = -60.0) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ AdaptLAA с пространственным адаптивным фильт-
//ром типа N x N и многолучевой лучеобразующей схемой. В качестве тест-сигнала
//для статистической модели адаптивной LAA используем вектор-сигнал единичной
//мощности.
//Если AdaptLAA не работоспособна функция возвращает false и матрицу P нулевого
//размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& P - ссылка на выходную матрицу мощностей в заданном секторе;
//2. const TEvenCloseInterval& Sector - сектор по углу места (азимуту), в  кото-
//   ром рассчитывается передаточная функция (в градусах);
//3. uint NormType (GLOBAL) - опция нормирования выходных мощностей [0..1];
//4. bool dB (ON) - опция нормирования в децибелах (действует при Norm = ON);
//5. double MindB - минимальный уровень в децибелах (действует при dB = ON).
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//******************************************************************************
bool TMultiChSpaceFilter::TFunc(rmatrix& P, const TEvenCloseInterval& Sector,
                                uint NormType, bool dB, double MindB) const
{//Проверка работоспособности Adaptive LAA:
 if (!IsReady()) {P.Set(0L,0L,false); return false;}
 //-----------------------------------------------------------------------------
 //Создаем матрицу P для хранения данных
 P.Set(Sector.Size(),TMultiBeamFormer::GetBeams(),false);
 //-----------------------------------------------------------------------------
 // Расчет Rjn, InvRjn при T = 0, вычисление потенциальной выходной мощности
 // адаптивной LAA по заданной Rjn
 //-----------------------------------------------------------------------------
 rvector MinP;
 cmatrix A(GetLAACh(),GetLAACh(),C_ZERO);
 cmatrix W; GetW(W);
 for (ulong i = 0L; i < A.Rows(); i++) A.Put(i,i,W.Get(i,i));
 A.LowerColumnEM(W,LEFT); A.RightRowEM(W,RIGHT);
 //Выходная мощность AdaptLAA в данной помеховой ситуации
 TMultiBeamFormer::TFunc(A,MinP);

 //-----------------------------------------------------------------------------
 // Расчет ДН лучей в заданном секторе
 //-----------------------------------------------------------------------------
 //Вектор сигнала единичной мощности (тест-сигнала) с элементов LAA, подключен-
 //ных к адаптивной LAA
 cvector InV(GetLAACh(),COL,OFF);
 cvector OutV(GetLAACh(),COL,OFF);
 rvector OutP(TMultiBeamFormer::GetBeams(),COL,OFF);
 ivector LAACh; TMultiBeamFormer::GetLAACh(LAACh);
 for (ulong i = 0L; i < P.Rows(); i++) //По углам сектора
 {//Входной тест-сигнал с элементов LAA, подключенных к адаптивной LAA
  InV = TMultiBeamFormer::pLAA->TestSignal(LAACh,Sector(i),DEG,OFF);
  //----------------------------------------------------------------------------
  //1. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ пространственного фильтра AdaptiveLAA
  //----------------------------------------------------------------------------
  Filter->TF_WSum(InV,OutV);
  //----------------------------------------------------------------------------
  //2. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ лучеобразующей схемы
  //----------------------------------------------------------------------------
  TMultiBeamFormer::TFunc(OutV,OutP);
  //Записываем мощности на выходе лучеобразующей схемы в матрицу P
  for (ulong j = 0L; j < P.Cols(); j++) P.Put(i,j,OutP.Get(j)/MinP.Get(j));
 } //Конец цикла по i - сектору определения ДН лучей
 //-----------------------------------------------------------------------------
 // Нормирование диаграмм направленностей ЛУЧЕЙ
 //-----------------------------------------------------------------------------
 if ((NormType != GLOBAL) && (NormType != LOCAL)) return true;
 bool lSuccess;
 if (NormType == GLOBAL)
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.Normalize(FIRST_NORM);
 }
 else if (NormType == LOCAL) //для каждого луча индивидуально
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeColsToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.NormalizeCols(FIRST_NORM);
 }
 return lSuccess;
}
//******************************************************************************
//СТАТУС: I.2,public,class member-function TMultiChSpaceFilter
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool TF_SFilter(rmatrix& P, const TEvenCloseInterval& Sector,
//     uint NormType = GLOBAL, bool dB = ON, double MindBb = -60.0) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ пространственного адаптивным фильтра N x N.
//В качестве тест-сигнала для статистической модели пространственного фильтра
//адаптивной LAA используем источник сигнала единичной мощности. Функция вычисляет
//диаграммы направленностей каналов LAA, подключенных к адаптивной LAA, на выходе
//пространственного фильтра.
//Если AdaptLAA не работоспособна функция возвращает false и матрицу P нулевого
//размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& P - ссылка на выходную матрицу мощностей каналов в заданном секторе;
//2. const TEvenCloseInterval& Sector - сектор по углу места (азимуту), в  кото-
//   ром рассчитывается передаточная функция (в градусах);
//3. uint NormType (GLOBAL) - опция нормирования выходных мощностей [0..1];
//4. bool dB (ON) - опция нормирования в децибелах (действует при Norm = ON);
//5. double MindB - минимальный уровень в децибелах (действует при dB = ON).
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//******************************************************************************
bool TMultiChSpaceFilter::TF_SFilter(rmatrix& P, const TEvenCloseInterval& Sector,
                           uint NormType, bool dB, double MindB) const
{//Проверка работоспособности Adaptive LAA:
 if (!IsReady()) {P.Set(0L,0L,false); return false;}
 //-----------------------------------------------------------------------------
 //Создаем матрицу P для хранения данных
 P.Set(Sector.Size(),Size(),false);
 //-----------------------------------------------------------------------------
 // Расчет ДН лучей в заданном секторе
 //-----------------------------------------------------------------------------
 //Вектор сигнала единичной мощности (тест-сигнала) с элементов LAA, подключен-
 //ных к адаптивной LAA
 cvector InV(Size(),COL,OFF);
 rvector OutP(Size(),COL,OFF);
 ivector LAACh; TMultiBeamFormer::GetLAACh(LAACh);
 for (ulong i = 0L; i < P.Rows(); i++) //По углам сектора
 {//Входной тест-сигнал с элементов LAA, подключенных к адаптивной LAA
  InV = TMultiBeamFormer::pLAA->TestSignal(LAACh,Sector(i),DEG,OFF);
  //----------------------------------------------------------------------------
  //1. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ пространственного фильтра AdaptiveLAA
  //----------------------------------------------------------------------------
  Filter->TF_WSum(OutP,InV);
  //Записываем мощности на выходе фильтра в матрицу P
  for (ulong j = 0L; j < P.Cols(); j++) P.Put(i,j,OutP.Get(j));
 } //Конец цикла по i - сектору определения ДН лучей
 //-----------------------------------------------------------------------------
 // Нормирование диаграмм направленностей ЛУЧЕЙ
 //-----------------------------------------------------------------------------
 if ((NormType != GLOBAL) && (NormType != LOCAL)) return true;
 bool lSuccess;
 if (NormType == GLOBAL)
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.Normalize(FIRST_NORM);
 }
 else if (NormType == LOCAL) //для каждого луча индивидуально
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) lSuccess = P.NormalizeColsToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else lSuccess = P.NormalizeCols(FIRST_NORM);
 }
 return lSuccess;
}
//------------------------------------------------------------------------------
//           ФУНКЦИИ МОДЕЛИРОВАНИЯ КЛАССА TMultiChSpaceFilter
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1, TMultiChSpaceFilter public class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Update()
//НАЗНАЧЕНИЕ: Расчет входных выборок ПОЛЕЗНОГО СИГНАЛА Us, АДДИТИВНОЙ ПОМЕХИ Ujam
//и ВНУТРЕННЕГО ШУМА Unoise на входе статистической модели адаптивного пространст-
//венного фильтра с ОСНОВНЫМ КАНАЛОМ в момент времени Time.
//Если класс неработоспособен, то функция завершает свою работу и возвращает
//значение false (OFF) - признак неудачного завершения работы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//******************************************************************************
bool TMultiChSpaceFilter::Update()
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) return OFF;
 //-----------------------------------------------------------------------------
 //Расчет входных выборок
 //-----------------------------------------------------------------------------
 _CalcUs();
 _CalcUjam();
 _CalcUnoise();
 //-----------------------------------------------------------------------------
 //Формирование входной суммарной выборки полезного сигнала, аддитивной помехи и
 //внутреннего шума -- Usum
 for (ulong i = 0L; i < Usum.Size(); i++)
  Usum.Put(i,Us.Get(i) + Ujam.Get(i) + Unoise.Get(i));
 //-----------------------------------------------------------------------------
 //Расчет коэффициентов нормирования по вектору Usum
 Filter->TuneNorm(Usum);
 return ON;
}
//******************************************************************************
//СТАТУС: I.2., public, TMultiChSpaceFilter class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool AverageW(ulong Realization)
//НАЗНАЧЕНИЕ: Усреднение значений весовых коэффициентов адаптивного весового
//сумматора, которые накапливаются в матрице AvW. Функция должна вызываться на
//каждом последнем шаге i-ой реализации, когда весовые коэффициенты окончательно
//настраиваются на помеховую обстановку. При первой реализации (Realization = 0)
//весовые  коэффициенты весового сумматора присваиваются матрице AvW, при после-
//дующих реализациях осуществляется операция усреднения. Реализации должны начи-
//наться с 0.
//Если адаптивный пространственный фильтр НЕ РАБОТОСПОСОБЕН, функция возвращает
//false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong Realization - порядковый номер реализации
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
bool TMultiChSpaceFilter::AverageW(ulong Realization)
{//Проверка работоспособности адаптивного фильтра
 if (!IsReady()) return false;
 //Проверка порядкового номера реализации
 if (Realization != 0) //Усреднение
 {cmatrix W; Filter->GetW(W);//Получение текущих весовых коэффициентов сумматора
  for(ulong i = 0L; i < AvW.Rows(); i++)
   for (ulong j = 0L; j < AvW.Cols(); j++)
    AvW.Put(i,j,0.5*(AvW.Get(i,j)+W.Get(i,j)));
 }
 else Filter->GetW(AvW); //Присвоение при первой реализации
return true;
}
//******************************************************************************
//СТАТУС: I.3., public TMultiChSpaceFilter class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool InPs_SFilter(rvector& Ps) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ПОЛЕЗНОГО СИГНАЛА на входах адаптив-
//ного пространственного фильтра.
//Если адаптивный фильтр не активен (IsReady() == OFF), то возвращается вектор
//нулевого размера. Вектор мощности полезного сигнала формируется в векторе Ps,
//передаваемый в функцию по ссылке. Для вычислений используется вектор Us.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//rvector& Ps - ссылка на вектор, в котором формируется мощность полезного сигнала
//на входах адаптивного фильтра
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiChSpaceFilter::InPs_SFilter(rvector& Ps) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {Ps.Set(0L,ROW,false); return false;}
 //-----------------------------------------------------------------------------
 //Формирование входного вектора мощности ПОЛЕЗНОГО СИГНАЛА
 //-----------------------------------------------------------------------------
 Ps.Set(Us.Size(),ROW,false);//Формирование вектора необходимого размера
 //Цикл формирования значений элементов вектора
 for (ulong i = 0L; i < Ps.Size(); i++) Ps.Put(i,norm(Us.Get(i)));
 return true;
}
//******************************************************************************
//СТАТУС: I.4., public TMultiChSpaceFilter class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool InPjam_SFilter(rvector& Pjam) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности АКТИВНОЙ ПОМЕХИ на входах адаптивного
//пространственного фильтра.
//Если адаптивный фильтр не активен (IsReady() == OFF), то возвращается вектор
//нулевого размера. Вектор мощности активной помехи формируется в векторе Pjam,
//передаваемый в функцию по ссылке. Для вычислений используется вектор Ujam.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//rvector& Pjam - ссылка на вектор, в котором формируется мощность активной помехи
//на входах адаптивного фильтра
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiChSpaceFilter::InPjam_SFilter(rvector& Pjam) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {Pjam.Set(0L,ROW,false); return false;}
 //-----------------------------------------------------------------------------
 //Формирование входного вектора мощности АКТИВНОЙ ПОМЕХИ
 //-----------------------------------------------------------------------------
 Pjam.Set(Ujam.Size(),ROW,false);//Формирование вектора необходимого размера
 //Цикл формирования значений элементов вектора
 for (ulong i = 0L; i < Pjam.Size(); i++) Pjam.Put(i,norm(Ujam.Get(i)));
 return true;
}
//******************************************************************************
//СТАТУС: I.5., public TMultiChSpaceFilter class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool InPn_SFilter(rvector& Pn) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ВНУТРЕННЕГО ШУМА на входах адаптивного
//пространственного фильтра.
//Если адаптивный фильтр не активен (IsReady() == OFF), то возвращается вектор
//нулевого размера. Вектор мощности внутреннего шума формируется в векторе Pn,
//передаваемый в функцию по ссылке. Для вычислений используется вектор Unoise.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//rvector& Pn - ссылка на вектор, в котором формируется мощность внутреннего шума
//на входах адаптивного фильтра
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TMultiChSpaceFilter::InPn_SFilter(rvector& Pn) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {Pn.Set(0L,ROW,false); return false;}
 //-----------------------------------------------------------------------------
 //Формирование входного вектора мощности ВНУТРЕННЕГО ШУМА
 //-----------------------------------------------------------------------------
 Pn.Set(Unoise.Size(),ROW,false);//Формирование вектора необходимого размера
 //Цикл формирования значений элементов вектора
 for (ulong i = 0L; i < Pn.Size(); i++) Pn.Put(i,norm(Unoise.Get(i)));
 return true;
}
//==============================================================================
//II. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TMultiChSpaceFilter
//    PROTECTED MEMBER-FUNCTION OF TMultiChSpaceFilter CLASS
//==============================================================================
//******************************************************************************
//СТАТУС: II.1; protected TMultiChSpaceFilter class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: void _CalcUs()
//НАЗНАЧЕНИЕ: Расчет входного вектора ПОЛЕЗНОГО СИГНАЛА на входе адаптивной
//LAA. Результат формируется в векторе Us.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TMultiChSpaceFilter::_CalcUs()
{const cvector* Polar =
 (GetPolar() == VP_SIGNAL) ? pLAA->GetVPSignal() : pLAA->GetHPSignal();
 if (IsConnectedAllLAACh()) //Подключены все каналы LAA
  for (ulong i = 0L; i < Us.Size(); i++) Us.Put(i,Polar->Get(i));
 else //Подключена часть каналов LAA
  for (ulong i = 0L; i < Us.Size(); i++) Us.Put(i,Polar->Get(Channel.Get(i)));
}
//******************************************************************************
//СТАТУС: II.2; protected TAMultiChSpaceFilter class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: void _CalcInRnn()
//НАЗНАЧЕНИЕ: Расчет входного вектора ВНУТРЕННЕГО ШУМА на входе адаптивной
//LAA. Результат формируется в векторе Unoise.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TMultiChSpaceFilter::_CalcUnoise()
{const cvector* Polar =
 (GetPolar() == VP_SIGNAL) ? pLAA->GetVPNoise() : pLAA->GetHPNoise();
 if (IsConnectedAllLAACh()) //Подключены все каналы LAA
  for (ulong i = 0L; i < Unoise.Size(); i++)
   Unoise.Put(i,Polar->Get(i));
 else //Подключена часть каналов LAA
  for (ulong i = 0L; i < Unoise.Size(); i++)
   Unoise.Put(i,Polar->Get(Channel.Get(i)));
}
//******************************************************************************
//СТАТУС: II.3; protected TMultiChSpaceFilter class member-function of class
//НАИМЕНОВАНИЕ ФУНКЦИИ: void _CalcUjam()
//НАЗНАЧЕНИЕ: Расчет входного вектора АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ на входе
//адаптивной LAA. Результат формируется в векторе Ujam.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TMultiChSpaceFilter::_CalcUjam()
{const cmatrix* Polar =
 (GetPolar() == VP_SIGNAL) ? pLAA->GetVPJammer() : pLAA->GetHPJammer();
 //-----------------------------------------------------------------------------
 //Формирование входного вектора АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ
 Ujam = C_ZERO;
 for (ulong k = 0L; k < Polar->Cols(); k++) //Для k-ой помехи
 {if (IsConnectedAllLAACh()) //Подключены все каналы LAA
   for (ulong i = 0L; i < Ujam.Size(); i++)
    Ujam.Put(i,Ujam.Get(i)+Polar->Get(i,k));
  else //Подключена часть каналов LAA
   for (ulong i = 0L; i < Ujam.Size(); i++)
    Ujam.Put(i,Ujam.Get(i)+Polar->Get(Channel.Get(i),k));
  //----------------------------------------------------------------------------
 }//Конец цикла по k-ой помехе
}

//****************************************************************************************
//                РЕАЛИЗАЦИЯ КЛАССА TSingleStageAuxChSRF
// МОДЕЛЬ ОДНОСТУПЕНЧАТОГО ПРОСТРАНСТВЕННОГО РЕЖЕКТОРНОГО ФИЛЬТРА ДОПОЛНИТЕЛЬНЫХ КАНАЛОВ
//                 АДАПТИВНОГО ПРОСТРАНСТВЕННОГО ФИЛЬТРА с ОСНОВНЫМ КАНАЛОМ
//****************************************************************************************
//========================================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TSingleStageAuxChSRF
//   PUBLIC MEMBER-FUNCTION OF TSingleStageAuxChSRF CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1,public,class member-function TSingleStageAuxChSRF
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Tuning(const cmatrix& A);
//НАЗНАЧЕНИЕ: РАСЧЕТ КОЭФФИЦИЕНТОВ ПРОСТРАНСТВЕННОГО РЕЖЕКТОРНОГО ФИЛЬТРА ДЛЯ ЗАДАННЫХ
//НАПРАВЛЕНИЙ ВСПОМОГАТЕЛЬНЫМИ КАНАЛАМИ АДАПТИВНОГО ПРОСТРАНСТВЕННОГО ФИЛЬТРА С ОСНОВНЫМ
//КАНАЛОМ.
//Коэффициенты Space Reject Filter обеспечивают нулевые уровни приема сигналов с
//направлений исключения в AuxCh. Таким образом, обеспечивается  передача сигна-
//лов с направлений исключения только через ОСНОВНОЙ КАНАЛ без его компенсации
//на весовом сумматоре адаптивного фильтра. Методика вычисления коэффициентов
//одноступенчатых режекторных пространственных фильтров следующая:
//1. Формируются сигналы ЕДИНИЧНОЙ МОЩНОСТИ, приходящие с K НАПРАВЛЕНИЙ ИСКЛЮЧЕ-
// НИЯ, и рассчитываются комплексные значения напряжений на каналах LAA,
// подключенных к SingleStageAuxChSRF. К этим каналам относятся RDECh и AuxCh.
// Тестовые сигналы для каналов LAA и ОСНОВНОГО канала (при его подключении),
// которые подключены к AuxChSRF, и заданных направлениях исключения передаются
// в обучающей матрице L. За формирование данной матрицы ответственен класс, ко-
// торый использует объект класса TSingleStageAuxChSRF. Класс TSingleStageAuxChSRF
// выполняет только проверку корректности по размерности матрицы L. Матрица L не
// должна быть нулевой и число строк матрицы должно быть строго больше числа
// столбцов матрицы. В противном случае, объект класса не будет работоспособным.
// Структура обучающей матрицы  для  реализации  пространственного  режекторного
// фильтра  для 4-х  дополнительных  каналов и 3-х направлений  исключения будет
// иметь следующий вид: N = 4; K = 3; M = 7.
//Размерность L: rows = M = 7; cols = K = 3.
//     | U11 U12 U13 |  Uij - комплексное напряжение в i-ом канале при действии
//     | U21 U22 U23 |        одного источника сигнала ЕДИНИЧНОЙ мощности с j-го
//     | U31 U32 U33 |        направления исключения;
// L = | U41 U42 U43 |  U1j..U3j - рабочие каналы AuxChSpaceRejectFilter;
//     | U51 U52 U53 |  U4j..U7j - дополнительные каналы AdaptSpaceFilterBaseCh
//     | U61 U62 U63 |
//     | U71 U72 U73 |
// 2. На основе матрицы L строится система линейных алгебраических уравнений с N
// правыми частями (по числу AuxCh или числу одноступенчатых сумматоров) следую-
// щего вида: A*W = B, где A - подматрица матрицы L с коэффициентами Uij для ра-
// бочих  каналов  фильтра; В - подматрица  матрицы L с  коэффициентами Uij  для
// вспомогательных каналов AuxCh; W - матрица весовых коэффициентов для N одно-
// ступенчатых сумматоров, которая рассчитывается. Для данной матрицы L СЛАУ с
// N правыми частями записывается следующим образом:
// U11*W1 + U21*W2 + U31*W3 = -U41 -U51 -U61 -U71
// U12*W1 + U22*W2 + U32*W3 = -U42 -U52 -U62 -U72
// U13*W1 + U23*W2 + U33*W3 = -U43 -U53 -U63 -U73
// При решении данной системы уравнений получаем коэффициенты матрицы W:
//     | w11 w12 w13 w14 |
// W = | w21 w22 w23 w24 |
//     | w31 w32 w33 w34 |
// Столбцы матрицы W содержат весовые коэффициенты для 4-x одноступенчатых прос-
// ранственных режекторных фильтра, которые обеспечивают по 3 направления исклю-
// чения в 4-х дополнительных  каналах  адаптивного  пространственного фильтра с
// ОСНОВНЫМ каналом.
// Отметим, что для обеспечения правильной работы пространственного режекторного
// фильтра после его настройки, последовательность каналов LAA и BaseCh (при его
// использовании) должна быть аналогичной как и в обучающей матрице L.
// Коэффициенты матрицы W являются частью коэффициентов матрицы Q. Приведем мат-
// рицу Q для схемы AuxChRDEUnit с тремя направлениями исключения для адаптивно-
// го пространственного фильтра с основным каналом и 4 дополнительными каналами.
// Таким образом, RDECh = 3, AuxCh = 4, Dimension Q = (3+4+1)x(4+1) = 8x5
// (с учетом включения ОСНОВНОГО КАНАЛА). Матрица Q будет иметь следующий вид:
//       U0  U1  U2  U3  U4  U5  U6  U7
//     | w11 w21 w31  1   0   0   0   0 | U3
//     | w12 w22 w32  0   1   0   0   0 | U4
// Q = | w13 w23 w33  0   0   1   0   0 | U5
//     | w14 w24 w34  0   0   0   1   0 | U6
//     |  0   0   0   0   0   0   0   1 | U7
// U0..U2 - RDECh, U3..U6 - AuxCh, U7 - BaseChannel.
//С целью минимизации числа неиспользуемых при вычислениях элементов матрицы Q,
//она преобразуется в матрицу Q следующего вида:
//       U0  U1  U2
//     | q00 q01 q02 | U3
//     | q10 q11 q12 | U4
// Q = | q20 q21 q22 | U5
//     | q30 q31 q32 | U6
//Из матрицы первоначальной матрицы Q вырезается  единичная  матрица и последняя
//ее строка, так как отсутствие данных элементов можно легко учесть при реализа-
//ции алгоритма Q-преобразования.
//В качестве  входного  воздействия может быть использованы комплексные корреля-
//ционная матрица R или вектор напряжений U, которые должны содержать компоненту
//ОСНОВНОГО канала адаптивного фильтра. При Q-преобразовании проверяется работо-
//способность фильтра и соответствие размерности входного воздействия размернос-
//ти пространственного режекторного фильтра. При их несоответствии или неработо-
//способности фильтра возвращается вектор или матрица нулевого размера.
//Размерность входного вектора должна быть равна числу входов фильтра. Матрица R
//должна быть квадратной и ее размерность, также, д.б. равна числу входов SRF. В
//качестве выходного значения объект класса возвращает вектор или квадратную мат-
//рицу с размерностями равными числу выходов Space Reject Filter.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const cmatrix& A - ссылка на обучающую матрицу
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак настройки SingleStageAuxChSRF
//****************************************************************************************
bool TSingleStageAuxChSRF::Tuning(const cmatrix& A)
{Reset();//Сброс характеристик режекторного пространственного фильтра
 //Проверка матрицы A на корректность
 if ((A.IsZeroSize()) || (A.Rows() <= A.Cols())) return false;
 //Создание и начальная инициализация элементов матрицы Q
 Input = A.Rows()+1; Output = Input - A.Cols();
 Q.Set(Out()-1,Directs(),C_ZERO);
 trQ.Set(Directs(),Out()-1,C_ZERO);
 //Вспомогательные переменные
 cmatrix L(Directs(),Directs(),C_ZERO);
 cmatrix R(Directs(),Out()-1,C_ZERO);
 cmatrix W;
 //****************************************************************************
 //Расчет коэффициентов матрицы Q решением СЛАУ L*W = R
 //****************************************************************************
 //1. Формирование матрицы коэффициентов L при весовых коэффициентах W
 for (ulong i = 0L; i < L.Rows(); i++)
  for (ulong j = 0L; j < L.Cols(); j++) L.Put(i,j,A.Get(j,i));
 //2. Формирование матрицы правых частей R
 ulong OffSet = Directs();
 for (ulong i = 0L; i < R.Rows(); i++)
  for (ulong j = 0L; j < R.Cols(); j++) R.Put(i,j,-1.0*A.Get(j+OffSet,i));
 //3. Расчет весовых коэффициентов для каналов подключенных к SRF L*W = R
 W = LE_UnSymSolution(L, R);
 //4. Вычисление коэффициентов матрицы Q & trQ
 complex w;
 for (ulong i = 0L; i < W.Rows(); i++)
  for (ulong j = 0L; j < W.Cols(); j++)
  {w = W.Get(i,j); Q.Put(j,i,w); trQ.Put(i,j,conj(w));}
return true;
}
//*****************************************************************************
//СТАТУС: I.2; TSingleStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(const cmatrix& InR, cmatrix& OutR) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ одноступенчатого режекторного фильтра AuxCh.
//Входным воздействием является корреляционная матрица InR, ее размерность долж-
//на  быть  равна числу  входов  фильтра. Выходная матрица формируется в матрице
//OutR, ее  размерность  равна числу выходов фильтра. При работе функции матрица
//OutR изменяется. Функция возвращает признак успешной или неуспешной работы.
//Функция возвращает false в двух случаях. Во-первых, если фильтр неработоспосо-
//бен, во-вторых, размерность  входной  корреляционная матрица InR не соответст-
//вует числу входов SingleStageAuxChSRF.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cmatrix& InR - ссылка на корреляционную матрицу входного сигнала
//cmatrix& OutR - ссылка на выходную корреляционную матрицу
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//*****************************************************************************
bool TSingleStageAuxChSRF::TFunc(const cmatrix& InR, cmatrix& OutR) const
{//Space Reject Filter НЕРАБОТОСПОСОБЕН или размерность InR не соответствует
 //числу входов фильтра
 if ((!IsReady()) || (InR.Rows() != InR.Cols()) || (InR.Rows() != In()))
 {OutR.Set(0L,0L,false); return false;}
 //*****************************************************************************
 //Определение передаточной характеристики SRF при заданном входном воздействии
 //*****************************************************************************
 //Создание промежуточной матрицы R: R = Q*InR
 cmatrix R(Out(),In(),C_ZERO);
 ulong OffSet = Directs();
 //Q-преобразование (оптимальная операция умножения) R = Q*InR
 for (ulong i = 0L; i < R.Rows(); i++)
  for (ulong j = 0L; j < R.Cols(); j++)
   R.Put(i,j,InR.Get(i+OffSet,j));

 for (ulong i = 0L; i < R.Rows()-1; i++)
  for (ulong j = 0L; j < R.Cols(); j++)
   for (ulong k = 0L; k < Directs(); k++)
    R.Put(i,j,R.Get(i,j)+Q.Get(i,k)*InR.Get(k,j));

 //Q-преобразование (оптимальная операция умножения) OutR = R*trQ
 //Формирование выходной матрицы OutR
 OutR.Set(Out(),Out(),C_ZERO);
 for (ulong i = 0L; i < OutR.Rows(); i++)
  for (ulong j = 0L; j < OutR.Cols(); j++)
   OutR.Put(i,j,R.Get(i,j+OffSet));

 for (ulong i = 0L; i < OutR.Rows(); i++)
  for (ulong j = 0L; j < OutR.Cols()-1; j++)
   for (ulong k = 0L; k < Directs(); k++)
    OutR.Put(i,j,OutR.Get(i,j)+R.Get(i,k)*trQ.Get(k,j));
return true;
}
//****************************************************************************************
//СТАТУС: I.3; TSingleStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFuncDM(const cmatrix& InR, cmatrix& OutR) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ одноступенчатого режекторного фильтра AuxCh.
//Входным воздействием является корреляционная диагональная матрица InR, ее размерность
//должна быть равна числу входов фильтра. Выходная матрица формируется в матрице OutR, ее
//размерность равна числу выходов фильтра. При работе функции матрица OutR изменяется.
//Функция возвращает признак успешной или неуспешной работы. Функция возвращает false в
//двух случаях. Во-первых, если фильтр неработоспособен, во-вторых, размерность входной
//корреляционная матрица InR не соответствует числу входов SingleStageAuxChSRF.
//Функция используется для быстрого Q-преобразования над корреляционной матрицей внутреннего
//шума, так как данная матрица является ДИАГОНАЛЬНОЙ. Проверка на диагональность InR не
//производится.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cmatrix& InR - ссылка на корреляционную диагональную матрицу входного сигнала
//cmatrix& OutR - ссылка на выходную корреляционную матрицу
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//****************************************************************************************
bool TSingleStageAuxChSRF::TFuncDM(const cmatrix& InR, cmatrix& OutR) const
{//Space Reject Filter НЕРАБОТОСПОСОБЕН или размерность InR не соответствует
 //числу входов фильтра
 if ((!IsReady()) || (InR.Rows() != InR.Cols()) || (InR.Rows() != In()))
 {OutR.Set(0L,0L,false); return false;}
 //*****************************************************************************
 //Определение передаточной характеристики SRF при заданном входном воздействии
 //*****************************************************************************
 //Создание промежуточной матрицы R: R = Q*InR
 cmatrix R(Out(),In(),C_ZERO);
 ulong OffSet = Directs();
 ulong j;
 //Q-преобразование (оптимальная операция умножения на диагональную матрицу)
 //R = Q*InR
 for (ulong i = 0L; i < R.Rows(); i++) {j = i+OffSet; R.Put(i,j,InR.Get(j,j));}

 for (ulong i = 0L; i < R.Rows()-1; i++)
  for (ulong j = 0L; j < OffSet; j++)
   R.Put(i,j,Q.Get(i,j)*InR.Get(j,j));

 //Q-преобразование (оптимальная операция умножения) OutR = R*trQ
 //Формирование выходной матрицы OutR
 OutR.Set(Out(),Out(),C_ZERO);
 for (ulong i = 0L; i < OutR.Rows(); i++) OutR.Put(i,i,R.Get(i,i+OffSet));

 for (ulong i = 0L; i < OutR.Rows()-1; i++)
  for (ulong j = 0L; j < OutR.Cols()-1; j++)
   for (ulong k = 0L; k < Directs(); k++)
    OutR.Put(i,j,OutR.Get(i,j)+R.Get(i,k)*trQ.Get(k,j));
return true;
}
//*****************************************************************************
//СТАТУС: I.4; TSingleStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(const cvector& InV, cvector& OutV) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ одноступенчатого режекторного фильтра AuxCh.
//Входным  воздействием  является  вектор  входного сигнала InV, его размерность
//должна быть равна числу входов фильтра. Выходной  вектор формируется в векторе
//OutV, его  размерность равна числу выходов фильтра. При работе функции  вектор
//OutV изменяется. Функция возвращает признак успешной или неуспешной работы.
//Функция возвращает false в двух случаях. Во-первых, если фильтр неработоспосо-
//бен, во-вторых, размерность вектора входного сигнала InV не соответствует чис-
//лу входов SingleStageAuxChSRF.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cvector& InV - ссылка на вектор входного сигнала
//cvector& OutV - ссылка на вектор выходного сигнала
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//*****************************************************************************
bool TSingleStageAuxChSRF::TFunc(const cvector& InV, cvector& OutV) const
{//Space Reject Filter НЕРАБОТОСПОСОБЕН или размерность InR не соответствует
 //числу входов фильтра
 if ((!IsReady()) || (InV.Size() != In())) {OutV.Resize(0); return false;}
 //*****************************************************************************
 //Определение передаточной характеристики SRF при заданном входном воздействии
 //*****************************************************************************
 OutV.Resize(Out()); //Формирование выходного вектора OutV
 //Q-преобразование входного сигнала (оптимальная операция умножения)
 //OutV = Q*InV
 ulong OffSet = Directs();
 for (ulong i = 0L; i < Out(); i++) OutV.Put(i,InV.Get(i+OffSet));

 for (ulong i = 0L; i < OutV.Size()-1; i++)
  for (ulong j = 0L; j < OffSet; j++)
   OutV.Put(i,OutV.Get(i)+InV.Get(j)*Q.Get(i,j));
return true;
}
//*****************************************************************************
//СТАТУС: I.5; TSingleStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetW(cmatrix& W, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Получение  значений  весовых коэффициентов одноступенчатого прост-
//ранственного режекторного фильтра дополнительных каналов. Значения коэффициен-
//тов  заносятся  в  матрицу  W. В матрицу W не заносятся комплексно-сопряженные
//коэффициенты матрицы trQ. Функция может формировать матрицу W двумя способами.
//ВАРИАНТ #1 (lExtend = ON): W - прямоугольная матрица с коэффициентами для всех
//каналов, подключенных к режекторному пространственному фильтру;
//ВАРИАНТ #2 (lExtend = OFF): W - прямоугольная  матрица с коэффициентами только
//РАБОЧИХ  каналов режекторного фильтра.
//Пример: BaseCh, AuxCh = 4; DirectElim = 3. Input=3+4+1=8, Output=4+1=5.
//Матрица W (lExtend = ON):
//       U0  U1  U2  U3  U4  U5  U6  U7
//     | q00 q01 q02  1   0   0   0   0 | U3
//     | q10 q11 q12  0   1   0   0   0 | U4
// Q = | q20 q21 q22  0   0   1   0   0 | U5
//     | q30 q31 q32  0   0   0   1   0 | U6
//     |  0   0   0   0   0   0   0   1 | U7
// U0..U2 - RDECh, U3..U6 - AuxCh, U7 - BaseChannel.
//Матрица W (lExtend = OFF):
//       U0  U1  U2
//     | q00 q01 q02 | U3
//     | q10 q11 q12 | U4
// Q = | q20 q21 q22 | U5
//     | q30 q31 q32 | U6
//Если SingleStageAuxChSRF НЕРАБОТОСПОСОБЕН, функция формирует матрицу W нулевого
//размера и возвращает false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1.cmatrix& W - ссылка на матрицу, в которой будут формироваться коэффициенты
//  Space Reject Fulter of AuxCh;
//2.bool lExtend (ON) - режим формирования матрицы W.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//*****************************************************************************
bool TSingleStageAuxChSRF::GetW(cmatrix& W, bool lExtend) const
{//SingleStageAuxChSRF НЕРАБОТОСПОСОБЕН
 if (!IsReady()) {W.Set(0L,0L,false); return false;}
 //Формирование вектора W со значениями весовых коэффициентов SRF
 if (lExtend) //ВАРИАНТ №_1
 {W.Set(Out(),In(),C_ZERO);
  ulong OffSet = Directs();
  for (ulong i = 0L; i < W.Rows(); i++) W.Put(i,i+OffSet,C_ONE);
  //Присвоение коэффициентов матрицы Q матрице W
  for (ulong i = 0L; i < Q.Rows(); i++)
   for (ulong j = 0L; j < Q.Cols(); j++) W.Put(i,j,Q.Get(i,j));
 }
 else W = Q; //ВАРИАНТ №_2
return true;
}
//****************************************************************************************
//СТАТУС: I.6; TSingleStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& Properties(string& s, string& head, uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта TSingleStageAuxChSRF в строке s, передаваемой по
//ссылке (свойства одноступенчатого пространственного режекторного фильтра AuxCh Adaptive
//SpaceFilter with BaseCh). Предыдущее содержимое строки s уничтожается.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& head - ссылка на строку с заголовком объекта;
//3. uint indent - начальное смещение строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//****************************************************************************************
string& TSingleStageAuxChSRF::Properties(string& s, string& head, uint indent) const
{string t; string space(' ',indent);
 //Формирование заголовка объекта
 s = space;
 if (head.empty()) s.append(Clip(t));
 else s.append(head);
 //-------------------------------------------------------------------------------------
 //SingleStageAuxChSRF НЕРАБОТОСПОСОБЕН:
 if (!IsReady()) {s.append(": < Off >;\n"); return s;}
 s.append(" "+GetConfig(t)); //Формирование конфигурации весового сумматора
return s;
}

//****************************************************************************************
//                РЕАЛИЗАЦИЯ КЛАССА TMultiStageAuxChSRF
//МОДЕЛЬ МНОГОСТУПЕНЧАТОГО ПРОСТРАНСТВЕННОГО РЕЖЕКТОРНОГО ФИЛЬТРА ДОПОЛНИТЕЛЬНЫХ
//       КАНАЛОВ АДАПТИВНОГО ПРОСТРАНСТВЕННОГО ФИЛЬТРА с ОСНОВНЫМ КАНАЛОМ
//****************************************************************************************
//========================================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TMultiStageAuxChSRF
//   PUBLIC MEMBER-FUNCTION OF TMultiStageAuxChSRF CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1,public,class member-function TMultiStageAuxChSRF
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Tuning(const cmatrix& A);
//НАЗНАЧЕНИЕ: РАСЧЕТ КОЭФФИЦИЕНТОВ ПРОСТРАНСТВЕННОГО РЕЖЕКТОРНОГО ФИЛЬТРА ДЛЯ
// ЗАДАННЫХ НАПРАВЛЕНИЙ ВСПОМОГАТЕЛЬНЫМИ КАНАЛАМИ АДАПТИВНОГО ПРОСТРАНСТВЕННОГО
// ФИЛЬТРА С ОСНОВНЫМ КАНАЛОМ.
//Коэффициенты хранятся в матрице Q. Матрица Q имеет размерность равную:
//1. RDECh (каналы LAA используемые для исключения приема сигналов с заданных
//   направлений вспомогательными каналами фильтра);
//2. AuxCh (дополнительные каналы фильтра, подключаемые с LAA);
//3. BaseChannel размерности 1 (основной канал фильтра).
//Матрица Q хранит коэффициенты в упакованном виде. Для осуществления исключения
//приема сигналов с N направлений необходимо 2*N элементарных матриц специального
//вида: R' = Qn*Qn-1*...*Q2*Q1*R*trQ1*trQ2*...*trQn-1*trQn, где
//R - входная корреляционная матрица;
//R' - преобразованная корреляционная матрица с N исключенными направлениями;
//Qn,Qn-1,...,Q2,Q1 - комплексные элементарные матрицы специального вида с коэф-
//фициентами исключения для каждого канала для N-направлений. Данные матрицы -
//НИЖНИЕ СТОЛБЦОВЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ;
//trQ1,trQ2,...,trQn-1,trQn - транспонированные к Q1,tQ2,...,Qn-1,Qn матрицы ве-
//совых коэффициентов. Данные матрицы - ПРАВЫЕ СТРОЧНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ.
//Данная особенность позволяет хранить все 2*N матриц в одной матрице Q.  Реали-
//зованные в классах cvector и cmatrix операции умножения на элементарные матри-
//цы специального вида с учетом компактной формы их хранения в одной матрице поз-
//воляют корректно и быстро выполнять необходимые операции для исключения задан-
//ных направлений исключения из входных корреляционных матриц и векторов  сигна-
//лов.
//Для задания N направлений исключения приема  сигналов с  заданных  направлений
//дополнительными каналами фильтра  используются  N каналов LAA, индексы которых
//не должны совпадать с индексами каналов LAA, которые используются как дополни-
//тельные  каналы пространственного фильтра с выделенным каналом. В основном ка-
//нале подавление приема сигналов с заданных направлений не должно происходить,
//поэтому в матрице Q последняя строка и последний столбец содержат нулевые коэф-
//фициенты, за исключением последнего элемента матрицы (на пересечении последних
//столбца и строки) равного 1. Если не задано ни одного направления исключения,
//матрица Q должна быть ЕДИНИЧНОЙ.
//Функция рассчитывает коэффициенты режекторного пространственного фильтра адап-
//тивной LAA. Коэффициенты обеспечивают нулевые уровни приема сигналов с направ-
//лений  исключения в AuxCh. Таким образом, обеспечивается  передача  сигналов с
//направлений  исключения только через ОСНОВНОЙ КАНАЛ без его компенсации на ве-
//совом сумматоре фильтра. Коэффициенты для всех ДОПОЛНИТЕЛЬНЫХ КАНАЛОВ и ОДНОГО
//НАПРАВЛЕНИЯ ИСКЛЮЧЕНИЯ рассчитываются относительно ОДНОГО RDE КАНАЛА,  который
//подключается с АР к MultiStageAuxChSRF и не должен совпадать ни с одним AuxCh.
//Для  расчета  коэффициентов для другого направления исключения должен быть за-
//действован другой рабочий канал SRF и так далее.
//Функция в качестве параметра принимает ссылку на обучающую матрицу A. Структу-
//ра обучающей матрицы A для реализации пространственного режекторного фильтра
//для для 4-х дополнительных каналов и 3-х направлений исключения имеет вид:
//N = 4; K = 3; M = 7. Размерность A: rows = M = 7; cols = K = 3.
//     | U11 U12 U13 |  Uij - комплексное напряжение в i-ом канале при действии
//     | U21 U22 U23 |        одного источника сигнала ЕДИНИЧНОЙ мощности с j-го
//     | U31 U32 U33 |        направления исключения;
// A = | U41 U42 U43 |  U1j..U3j - рабочие каналы AuxChSpaceRejectFilter;
//     | U51 U52 U53 |  U4j..U7j - дополнительные каналы AdaptSpaceFilterBaseCh
//     | U61 U62 U63 |
//     | U71 U72 U73 |
//Каждый столбец матрицы A содержит настроечные сигналы для всех каналов, подклю-
//ченных к MultiStageAuxChSRF, для одного направления исключения в порядке подк-
//лячения данных каналов к фильтру. Матрица должна быть отлична от нуля и число
//строк матрицы  должно превышать число столбцов. Числу столбцов матрицы A соот-
//ветствует кол-во направлений исключения; числу строк - число входов SRF и раз-
//мерность квадратной матрицы Q. Число выходов SRF равно: A.rows()-A.cols().
//Методика вычисления коэффициентов схемы исключения направлений приема сигналов с заданных
//направлений в вспомогательных каналах фильтра следующая:
//1. Формируется сигнал ЕДИНИЧНОЙ МОЩНОСТИ, приходящий с ПЕРВОГО НАПРАВЛЕНИЯ
// ИСКЛЮЧЕНИЯ, и рассчитываются комплексные значения напряжений на каналах LAA,
// подключенных к AuxChRDEUnit. К этим каналам относятся RDEChannel и AuxChannel.
// Комплексные коэффициенты для ПЕРВОГО НАПРАВЛЕНИЯ исключения рассчитываются по
// следующей формуле: Q(i,0) = - Ui/U0, Q(0,i) = conj(Q(i,0)),  0 < i < LAACh
// Q(i,0) - коэффициент AuxChSRF для i-го канала LAA, подключенного к нему,
//          для первого направления исключения;
// Ui - комплексное напряжение i-го канала LAA, подключенного к AuxChSRF,
// при действии источника единичной мощности с первого направления исключения;
// U0 - комплексное напряжение 1-го рабочего канала RDECh, которое обеспечивает
// исключение направления приема сигнала с первого направления в остальных кана-
// лах подключенных к AuxChSRF.
// 2. Алгоритм расчета для j-го направления исключения (0 < j <= N). Формируется
//  сигнал ЕДИНИЧНОЙ МОЩНОСТИ с j-го направления исключения и формируется вектор
//  комплексных напряжений на каналах LAACh, подключенных к RDEUnit. Полученный
//  вектор U умножается на последовательность левых столбцовых элементарных мат-
//  риц Lkc: U' = Lj-1c*...*L1c*L0c*U. В результате этого вектор U изменяется на
//  вектор U', из данного вектора исключаются источники сигнала с 0..j-1 направ-
//  лений исключения. Коэффициенты для j-го направления исключения рассчитываются
//  аналогично п.1 по формуле: Q(i,j)=-U'i/U'j, Q(j,i)=conj(Q(i,j)), j<i<LAACh
// Q(i,j) - коэффициент AuxChSRF для i-го канала LAA, подключенного к нему,
//          для j-го направления исключения;
// U'i - комплексное напряжение i-го канала LAA, подключенного к AuxChSRF,
// при действии источника единичной мощности с j-го направления исключения;
// U'j - комплексное напряжение j-го рабочего канала RDECh, которое обеспечивает
// исключение направления приема сигнала с j-го направления в остальных каналах
// подключенных к AuxChSRF.
// Выполнение п.2 продолжается расчета для всех N направлений исключения.
// Приведем обобщенную структуру матрицы Q для MultiStageAuxChSRF для трех  нап-
// равлений исключения и пространственного фильтра с основным каналом и 5 допол-
// нительными каналами. Таким образом, RDECh = 3, AuxCh = 5, Dimension Q = 9x9
// (с учетом включения ОСНОВНОГО КАНАЛА). Матрица Q будет иметь следующий вид:
//       U0  U1  U2  U3  U4  U5  U6  U7  U8
//     |  1  q01 q02 q03 q04 q05 q06 q07  0| U0
//     | q10  1  q12 q13 q14 q15 q16 q17  0| U1
//     | q20 q21  1  q23 q24 q25 q26 q27  0| U2
//     | q30 q31 q32  1   0   0   0   0   0| U3
// Q = | q40 q41 q42  0   1   0   0   0   0| U4
//     | q50 q51 q52  0   0   1   0   0   0| U5
//     | q60 q61 q62  0   0   0   1   0   0| U6
//     | q70 q71 q72  0   0   0   0   1   0| U7
//     |  0   0   0   0   0   0   0   0   1| U8
// U0..U2 - RDECh, U3..U7 - AuxCh, U8 - BaseChannel
//С целью минимизации числа неиспользуемых при вычислениях элементов матрицы Q,
//она разбивается на две прямоугольные матрицы Q и trQ. Матрицы Q и trQ будут
//иметь следующий вид:
//       U0  U1  U2
//     |  1   0   0  | U0
//     | q10  1   0  | U1
//     | q20 q21  1  | U2          U0  U1  U2  U3  U4  U5  U6  U7
//     | q30 q31 q32 | U3         | 1  q01 q02 q03 q04 q05 q06 q07 | U0
// Q = | q40 q41 q42 | U4   trQ = | 0   1  q12 q13 q14 q15 q16 q17 | U1
//     | q50 q51 q52 | U5         | 0   0   1  q23 q24 q25 q26 q27 | U2
//     | q60 q61 q62 | U6
//     | q70 q71 q72 | U7
// U0..U2 - RDECh, U3..U7 - AuxCh.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const cmatrix& A - ссылка на обучающую матрицу
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак настройки MultiStageAuxChSRF
//*****************************************************************************
bool TMultiStageAuxChSRF::Tuning(const cmatrix& A)
{Reset();//Сброс характеристик режекторного пространственного фильтра
 //Проверка матрицы A на корректность
 if ((A.IsZeroSize()) || (A.Rows() <= A.Cols())) return false;
 //Создание и начальная инициализация элементов матрицы Q
 Input = A.Rows()+1; Output = Input - A.Cols();
 Q.Set(In()-1,Directs(),C_ZERO);
 trQ.Set(Directs(),In()-1,C_ZERO);
 for (ulong i = 0L; i < Q.Cols(); i++) Q.Put(i,i,C_ONE);
 for (ulong i = 0L; i < trQ.Rows(); i++) trQ.Put(i,i,C_ONE);
 //Вспомогательные переменные
 cvector V(A.Rows(),COL);
 complex w;
 //Расчет коэффициентов матрицы Q
 for (ulong j = 0; j < A.Cols(); j++)
 {//1. Формирование тест-сигнала ЕДИНИЧНОЙ МОЩНОСТИ с j-го направления исключения
  for (ulong i = 0; i < A.Rows(); i++) V.Put(i,A.Get(i,j));
  //2. Расчет весовых коэффициентов для каналов подключенных к SRF для j-го
  //направления исключения приема сигналов, j < i < LAACh.Size()
  for (ulong k = 0L; k < j; k++)
   for (ulong i = k+1; i < V.Size(); i++)
    V.Put(i,V.Get(i)+V.Get(k)*Q.Get(i,k));
  //Вычисление коэффициентов матрицы Q & trQ
  for (ulong i = j+1; i < Q.Rows(); i++)
  {w = -1.0*V.Get(i)/V.Get(j); Q.Put(i,j,w); trQ.Put(j,i,conj(w));}
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.2; TMultiStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(const cmatrix& InR, cmatrix& OutR) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ многоступенчатого режекторного фильтра AuxCh.
//Входным воздействием является корреляционная матрица InR, ее размерность долж-
//на  быть  равна числу  входов  фильтра. Выходная матрица формируется в матрице
//OutR, ее  размерность  равна числу выходов фильтра. При работе функции матрица
//OutR изменяется. Функция возвращает признак успешной или неуспешной работы.
//Функция возвращает false в двух случаях. Во-первых, если фильтр неработоспосо-
//бен, во-вторых, размерность  входной  корреляционная матрица InR не соответст-
//вует числу входов MultiStageAuxChSRF.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cmatrix& InR - ссылка на корреляционную матрицу входного сигнала
//cmatrix& OutR - ссылка на выходную корреляционную матрицу
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//*****************************************************************************
bool TMultiStageAuxChSRF::TFunc(const cmatrix& InR, cmatrix& OutR) const
{//Space Reject Filter НЕРАБОТОСПОСОБЕН или размерность InR не соответствует
 //числу входов фильтра
 if ((!IsReady()) || (InR.Rows() != InR.Cols()) || (InR.Rows() != In()))
 {OutR.Set(0L,0L,false); return false;}
 //Определение передаточной характеристики SRF при заданном входном воздействии
 cmatrix R = InR;
 //Q-преобразование (оптимальная операция умножения) R = Q*R
 for (ulong k = 0; k < Directs(); k++) //По всем направлениям исключения
  for (ulong i = k+1; i < R.Rows()-1; i++)
   for (ulong j = 0L; j < R.Cols(); j++)
    R.Put(i,j,R.Get(i,j)+Q.Get(i,k)*R.Get(k,j));

 //Q-преобразование (оптимальная операция умножения) R = R*trQ
 for (ulong k = 0; k < Directs(); k++) //По всем направлениям исключения
  for (ulong j = k+1; j < R.Cols()-1; j++)
   for (ulong i = 0L; i < R.Rows(); i++)
    R.Put(i,j,R.Get(i,j)+R.Get(i,k)*trQ.Get(k,j));

 //Формирование выходной матрицы OutR
 OutR.Set(Out(),Out(),C_ZERO);
 ulong row, col;
 ulong OffSet = Directs();
 for (ulong i = 0L; i < OutR.Rows(); i++)
 {row = i+OffSet;
  for (ulong j = 0L; j < OutR.Cols(); j++)
  {col = j+OffSet; OutR.Put(i,j,R.Get(row,col));}
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.3; TMultiStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFuncDM(const cmatrix& InR, cmatrix& OutR) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ многоступенчатого режекторного фильтра AuxCh.
//Входным воздействием является корреляционная диагональная матрица InR, ее раз-
//мерность должна быть равна числу входов  фильтра. Выходная матрица формируется в матрице
//OutR, ее  размерность  равна числу выходов фильтра. При работе функции матрица
//OutR изменяется. Функция возвращает признак успешной или неуспешной работы.
//Функция возвращает false в двух случаях. Во-первых, если фильтр неработоспосо-
//бен, во-вторых, размерность  входной  корреляционная матрица InR не соответст-
//вует числу входов MultiStageAuxChSRF.
//Функция используется для быстрого Q-преобразования над корреляционной матрицей
//внутреннего  шума, так  как данная  матрица является ДИАГОНАЛЬНОЙ. Проверка на
//диагональность InR не производится.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cmatrix& InR - ссылка на корреляционную диагональную матрицу входного сигнала
//cmatrix& OutR - ссылка на выходную корреляционную матрицу
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//*****************************************************************************
bool TMultiStageAuxChSRF::TFuncDM(const cmatrix& InR, cmatrix& OutR) const
{//Space Reject Filter НЕРАБОТОСПОСОБЕН или размерность InR не соответствует
 //числу входов фильтра
 if ((!IsReady()) || (InR.Rows() != InR.Cols()) || (InR.Rows() != In()))
 {OutR.Set(0L,0L,false); return false;}
 //Определение передаточной характеристики SRF при заданном входном воздействии
 cmatrix R = InR;
 //Q-преобразование диагональной матрицы (оптимальная операция умножения) R=Q*R
 for (ulong k = 0; k < Directs(); k++) //По всем направлениям исключения
  for (ulong i = k+1; i < R.Rows()-1; i++)
   for (ulong j = 0L; j <= k; j++)
    R.Put(i,j,R.Get(i,j)+Q.Get(i,k)*R.Get(k,j));

 //Q-преобразование (оптимальная операция умножения) R = R*trQ
 for (ulong k = 0; k < Directs(); k++) //По всем направлениям исключения
  for (ulong j = k+1; j < R.Cols()-1; j++)
   for (ulong i = 0L; i < R.Rows()-1; i++)
    R.Put(i,j,R.Get(i,j)+R.Get(i,k)*trQ.Get(k,j));

 //Формирование выходной матрицы OutR
 OutR.Set(Out(),Out(),C_ZERO);
 ulong row, col;
 ulong OffSet = Directs();
 for (ulong i = 0L; i < OutR.Rows(); i++)
 {row = i+OffSet;
  for (ulong j = 0L; j < OutR.Cols(); j++)
  {col = j+OffSet; OutR.Put(i,j,R.Get(row,col));}
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.4; TMultiStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(const cvector& InV, cvector& OutV) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ многоступенчатого режекторного фильтра AuxCh.
//Входным  воздействием  является  вектор  входного сигнала InV, его размерность
//должна быть равна числу входов фильтра. Выходной  вектор формируется в векторе
//OutV, его  размерность равна числу выходов фильтра. При работе функции  вектор
//OutV изменяется. Функция возвращает признак успешной или неуспешной работы.
//Функция возвращает false в двух случаях. Во-первых, если фильтр неработоспосо-
//бен, во-вторых, размерность вектора входного сигнала InV не соответствует чис-
//лу входов MultiStageAuxChSRF.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const cvector& InV - ссылка на вектор входного сигнала
//cvector& OutV - ссылка на вектор выходного сигнала
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак работы функции
//*****************************************************************************
bool TMultiStageAuxChSRF::TFunc(const cvector& InV, cvector& OutV) const
{//Space Reject Filter НЕРАБОТОСПОСОБЕН или размерность InR не соответствует
 //числу входов фильтра
 if ((!IsReady()) || (InV.Size() != In())) {OutV.Resize(0L); return false;}
 cvector V = InV;
 //Определение передаточной характеристики SRF при заданном входном воздействии
 for (ulong k = 0L; k < Directs(); k++)
  for (ulong i = k+1; i < V.Size()-1; i++)
   V.Put(i,V.Get(i)+V.Get(k)*Q.Get(i,k));
 //Формирование выходного вектора OutV
 OutV.Resize(Out());
 ulong OffSet = Directs();
 for (ulong i = 0L; i < OutV.Size(); i++) OutV.Put(i,V.Get(i+OffSet));
return true;
}
//*****************************************************************************
//СТАТУС: I.5; TMultiStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetW(cmatrix& W, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Получение  значений весовых коэффициентов многоступенчатого прост-
//ранственного режекторного фильтра дополнительных каналов. Значения коэффициен-
//тов  заносятся  в  матрицу  W. В матрицу W не заносятся комплексно-сопряженные
//коэффициенты матрицы Q. Функция может формировать матрицу W двумя способами.
//ВАРИАНТ #1 (lExtend = ON): W - нижняя треугольная матрица с коэффициентами для
//ОСНОВНОГО канала;
//ВАРИАНТ #2 (lExtend = OFF): W - прямоугольная  матрица  без  коэффициентов для
//ОСНОВНОГО канала. Столбцы матрицы Q, внедиагональные элементы которых содержат
//только нулевые коэффициенты, не включаются в матрицу W.
//Пример: AuxCh = 5; DirectElim = 3. Input = 3+5+1 = 9, Output = 5+1 = 6.
//       U0  U1  U2  U3  U4  U5  U6  U7  U8
//     |  1  q01 q02 q03 q04 q05 q06 q07  0| U0
//     | q10  1  q12 q13 q14 q15 q16 q17  0| U1
//     | q20 q21  1  q23 q24 q25 q26 q27  0| U2
//     | q30 q31 q32  1   0   0   0   0   0| U3
// Q = | q40 q41 q42  0   1   0   0   0   0| U4
//     | q50 q51 q52  0   0   1   0   0   0| U5
//     | q60 q61 q62  0   0   0   1   0   0| U6
//     | q70 q71 q72  0   0   0   0   1   0| U7
//     |  0   0   0   0   0   0   0   0   1| U8
// U0..U2 - RDECh, U3..U7 - AuxCh, U8 - BaseChannel.
//Матрица W (lExtend = ON):
//       U0  U1  U2  U3  U4  U5  U6  U7  U8
//     |  1   0   0   0   0   0   0   0   0| U0
//     | q10  1   0   0   0   0   0   0   0| U1
//     | q20 q21  1   0   0   0   0   0   0| U2
//     | q30 q31 q32  1   0   0   0   0   0| U3
// W = | q40 q41 q42  0   1   0   0   0   0| U4
//     | q50 q51 q52  0   0   1   0   0   0| U5
//     | q60 q61 q62  0   0   0   1   0   0| U6
//     | q70 q71 q72  0   0   0   0   1   0| U7
//     |  0   0   0   0   0   0   0   0   1| U8
//Матрица W (lExtend = OFF):
//       U0  U1  U2
//     |  1   0   0  | U0
//     | q10  1   0  | U1
//     | q20 q21  1  | U2
//     | q30 q31 q32 | U3
// W = | q40 q41 q42 | U4
//     | q50 q51 q52 | U5
//     | q60 q61 q62 | U6
//     | q70 q71 q72 | U7
//Если MultiStageAuxChSRF НЕРАБОТОСПОСОБЕН, функция формирует матрицу W нулевого
//размера и возвращает false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1.cmatrix& W - ссылка на матрицу, в которой будут формироваться коэффициенты
//  Space Reject Fulter of AuxCh;
//2.bool lExtend (ON) - режим формирования матрицы W.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//*****************************************************************************
bool TMultiStageAuxChSRF::GetW(cmatrix& W, bool lExtend) const
{//MultiStageAuxChSRF НЕРАБОТОСПОСОБЕН
 if (!IsReady()) {W.Set(0L,0L,false); return false;}
 //Формирование вектора W со значениями весовых коэффициентов SRF
 if (lExtend) //ВАРИАНТ №_1
 {W.Set(In(),In(),C_ZERO);
  for (ulong i = 0L; i < W.Rows(); i++) W.Put(i,i,C_ONE);
  //Присвоение коэффициентов матрицы Q матрице W
  for (ulong j = 0L; j < Q.Cols(); j++)
   for (ulong i = j+1; i < Q.Rows(); i++) W.Put(i,j,Q.Get(i,j));
 }
 else W = Q; //ВАРИАНТ №_2
 return true;
}
//****************************************************************************************
//СТАТУС: I.6; TMultiStageAuxChSRF public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//string& Properties(string& s, string& head, uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта TMultiStageAuxChSRF в строке s, передаваемой по
//ссылке (свойства многоступенчатого пространственного режекторного фильтра AuxCh Adaptive
//SpaceFilter with BaseCh). Предыдущее содержимое строки s уничтожается.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& head - ссылка на строку с заголовком объекта;
//3. uint indent - начальное смещение строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//****************************************************************************************
string& TMultiStageAuxChSRF::Properties(string& s, string& head, uint indent) const
{string t; string space(' ',indent);
 //Формирование заголовка объекта
 s = space;
 if (head.empty()) s.append(Clip(t));
 else s.append(head);
 //---------------------------------------------------------------------------------------
 //MultiStageAuxChSRF НЕРАБОТОСПОСОБЕН:
 if (!IsReady()) {s.append(": < Off >;\n"); return s;}
 s.append(" "+GetConfig(t)); //Формирование конфигурации весового сумматора
 return s;
}

//****************************************************************************************
//               РЕАЛИЗАЦИЯ КЛАССА TPreProcessorSpaceFilterBaseCh
//Общие  свойства для  аналитической  и  статистической  моделей  предпроцессора
//обработки  входного сигнала пространственного адаптивного фильтра с выделенным
//каналом на основе LAA.
//****************************************************************************************
//******************************************************************************
//I. ОПИСАНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРОВ КЛАССА TPreProcessorSpaceFilterBaseCh
//******************************************************************************
//*****************************************************************************
//СТАТУС: I.1; public; TPreProcessorSpaceFilterBaseCh constructor by default
//НАИМЕНОВАНИЕ ФУНКЦИИ: TPreProcessorSpaceFilterBaseCh()
//НАЗНАЧЕНИЕ: Конструктор  по умолчанию класса TPreProcessorSpaceFilterBaseCh -
//свойства предпроцессора обработки входного сигнала пространственного фильтра с
//выделенным каналом на основе LAA. Начальная инициализация членов-данных класса
//осуществляется функцией Initial(). Значения членов-данных объекта по умолчанию
//следующие:
//------------------------------------------------------------------------------
//I. СХЕМА ФОРМИРОВАНИЯ ОСНОВНОГО (ВЫДЕЛЕННОГО) КАНАЛА - BaseChannel
// 1. ivector Channel - вектор нулевого размера;
// 2. double ScanAngle = 0 [deg];
// 3. cvector B - вектор нулевого размера;
// 4. InSignal* OutLAA = NULL;
//II. ВСПОМОГАТЕЛЬНЫЕ КАНАЛЫ ФИЛЬТРА (AuxChannel) и РАБОЧИЕ КАНАЛЫ AuxChRDEUnit
//    (при ее использовании) с LAA
// 1. ivector LAACh - вектор нулевого размера;
//III. ПАРАМЕТРЫ СХЕМЫ ИСКЛЮЧЕНИЯ НАПРАВЛЕНИЙ ПРИЕМА ДОПОЛНИТЕЛЬНЫМИ КАНАЛАМИ
// 1. rvector DirectElim - вектор нулевого размера;
// 2. lBaseChInRDEUnit = OFF;
// 3. TAuxChSpaceRejectFilter* RDEUnit = NULL;
//IV. ВХОДНОЙ СИГНАЛ С КАНАЛОВ LAA, К КОТОРЫМ ПОДКЛЮЧЕН ФИЛЬТР
// 1. TInputSignal* OutLAA = NULL;
// 2. PolarType = VP_SIGNAL;
// 3. cvector Signal - вектор нулевого размера;
// 4. cvector Noise  - вектор нулевого размера;
// 5. cmatrix\cvector Jammer - матрица\вектор нулевого размера;
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TPreProcessorSpaceFilterBaseCh::TPreProcessorSpaceFilterBaseCh()
{Initial();//Начальная установка свойств предпроцессора
}
//*****************************************************************************
//СТАТУС: I.2; public; TPreProcessorSpaceFilterBaseCh constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// TPreProcessorSpaceFilterBaseCh(TInputSignal* InSignal, bool Polar = VP_SIGNAL,
//  const ivector& BaseCh = ivector(), double ScanAngle = 0,
//  const ivector& AuxCh = ivector(), const rvector& Directs = rvector(),
//  bool lBaseChInRDE = OFF, ivector& RDECh = ivector(),
//  uint AuxChRDEType = MultiStageUnit);
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TPreProcessorSpaceFilterBaseCh.
//Функция создает экземпляр класса через вызов функции Set(...).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TInputSignal* InSignal - указатель на входное воздействие, поступающее на
//   вход предпроцессора с LAA;
//2. bool Polar (VP_SIGNAL) - поляризационная составляющая InSignal, принимаемая
//   препроцессором;
//3. const ivector& BaseCh - ссылка на индексы каналов LAA, подключаемые к
//   BaseChannel;
//4. double ScanAngle - значение угла сканирования при использовании лучеобразую-
//   щей схемы BaseChannel;
//5. const ivector& AuxCh - ссылка на индексы каналов LAA, используемые в
//   качестве дополнительных каналов пространственного фильтра;
//6. const rvector& Directs - ссылка на значения направлений исключения приема
//   сигналов вспомогательными каналами AuxCh;
//7. bool lBaseChInRDE - опция подключения BaseCh к AuxChRDEUnit;
//8. ivector& RDECh - ссылка на индексы каналов LAA, используемые как рабочие
//   каналы AuxChRDEUnit;
//9. uint AuxChRDEType - тип схемы исключения направлений приема сигналов с
//   заданных направлений в дополнительных каналах SpaceFilter с BaseCh.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TPreProcessorSpaceFilterBaseCh::
 TPreProcessorSpaceFilterBaseCh(TInputSignal* InSignal, bool Polar,
 const ivector& BaseCh, double ScanAngle, const ivector& AuxCh,
 const rvector& Directs, bool lBaseChInRDE, ivector& RDECh, uint AuxChRDEType)
{Initial();//Начальная установка свойств предпроцессора
 //Устанавливаем характеристики экземпляра класса с проверкой передаваемых
 //параметров
 Set(InSignal, Polar, BaseCh, ScanAngle,AuxCh, Directs, lBaseChInRDE, RDECh,
     AuxChRDEType);
}
//*****************************************************************************
//СТАТУС: I.3; public; TPreProcessorSpaceFilterBaseCh constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// TPreProcessorSpaceFilterBaseCh(TInputSignal* InSignal, bool Polar,
//  const TInDataBaseCh& BaseChProp, const ivector& AuxCh = ivector(),
//  const rvector& Directs = rvector(), bool lBaseChInRDE = OFF,
//  ivector& RDECh = ivector(), uint AuxChRDEType = MultiStageUnit);
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TPreProcessorSpaceFilterBaseCh.
//Функция создает экземпляр класса через вызов функции Set(...).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TInputSignal* InSignal - указатель на входное воздействие, поступающее на
//   вход предпроцессора с LAA;
//2. bool Polar - поляризационная составляющая InSignal, принимаемая
//   препроцессором [VP_SIGNAL or HP_SIGNAL];
//3. const TInDataBaseCh& BaseChProp - ссылка на входные параметры BaseChannel;
//4. const ivector& AuxCh - ссылка на индексы каналов LAA, используемые в
//   качестве дополнительных каналов пространственного фильтра;
//5. const rvector& Directs - ссылка на значения направлений исключения приема
//   сигналов вспомогательными каналами AuxCh.
//6. bool lBaseChInRDE - опция подключения BaseCh к AuxChRDEUnit;
//7. ivector& RDECh - ссылка на индексы каналов LAA, используемые как рабочие
//   каналы AuxChRDEUnit;
//8. uint AuxChRDEType - тип схемы исключения направлений приема сигналов с
//   заданных направлений в дополнительных каналах SpaceFilter с BaseCh.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TPreProcessorSpaceFilterBaseCh::
 TPreProcessorSpaceFilterBaseCh(TInputSignal* InSignal, bool Polar,
 const TInDataBaseCh& BaseChProp, const ivector& AuxCh, const rvector& Directs,
 bool lBaseChInRDE, ivector& RDECh, uint AuxChRDEType)
{Initial();//Начальная установка свойств предпроцессора
 //Устанавливаем характеристики экземпляра класса с проверкой передаваемых
 //параметров
 Set(InSignal, Polar, BaseChProp, AuxCh, Directs, lBaseChInRDE, RDECh,
     AuxChRDEType);
}
//*****************************************************************************
//СТАТУС: I.4; public; TPreProcessorSpaceFilterBaseCh class destructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: ~TPreProcessorSpaceFilterBaseCh()
//НАЗНАЧЕНИЕ: Деструктор класса  TPreProcessorSpaceFilterBaseCh.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TPreProcessorSpaceFilterBaseCh::~TPreProcessorSpaceFilterBaseCh()
{Reset(); //Сброс свойств предпроцессора AdaptSpaceFilter with BaseChannel
}

//==============================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TPreProcessorSpaceFilterBaseCh
//   PUBLIC MEMBER-FUNCTION OF TPreProcessorSpaceFilterBaseCh CLASS
//==============================================================================
//*****************************************************************************
//СТАТУС: I.1; public TPreProcessorSpaceFilterBaseCh member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool Set(TInputSignal* InSignal, bool Polar = VP_SIGNAL,
//  const ivector& BaseCh = ivector(), double ScanAngle = 0,
//  const ivector& AuxCh = ivector(), const rvector& Directs = rvector(),
//  bool lBaseChInRDE = OFF, ivector& RDECh = ivector(),
//  uint AuxChRDEType = MultiStageUnit);
//НАЗНАЧЕНИЕ: Установка параметров предпроцессора адаптивного пространственного
//фильтра  с выделенным  каналом на основе LAA. В ходе установки параметров осу-
//ществляется их проверка на корректность. Функция обрабатывает следующие исклю-
//чительные ситуации:
//1. InSignal == NULL - LAA не подключена к предпроцессору фильтра. Выход из
//   режима установки параметров предпроцессора;
//2. InSignal->LAAElem() < 2 - количество каналов LAA недостаточно для работы
//   пространственного фильтра. Выход из режима установки параметров предпроцес-
//   сора пространственного адаптивного фильтра;
//3. BaseCh == ivector() - ни один канал LAA не подключен к BaseChUnit. В этом
//   случае, к BaseChUnit подключаются ВСЕ каналы LAA;
//4. |ScanAngle| > 90 - угол сканирования выходит за диапазон от -90 до +90 гра-
//   дусов. ScanAngle устанавливается равным 0;
//5. AuxCh == ivector() - не задан  ни один канал LAA в качестве дополнительного
//   канала  пространственного фильтра. В этом случае, в качестве дополнительных
//   каналов фильтра автоматически подключаются каналы LAA по количеству активных
//   помех  либо ВСЕ допустимые каналы LAA, если активных помех больше числа до-
//   пустимых к использованию каналов LAA в качестве ВСПОМОГАТЕЛЬНЫХ;
//6. Directs == rvector() - не  заданы  направления исключения приема сигналов в
//   AuxCh SpaceFilter с BaseCh. В  этом  случае  AuxChRDEUnit не подключается к
//   предпроцессору фильтра. В случае задания направлений исключения производит-
//   ся селекция уникальных значений направлений исключения и значения не входя-
//   щие в диапазон -90 до +90 градусов исключаются. Если вектор направлений ис-
//   ключения не нулевого размера, то AuxChRDEUnit подключается к предпроцессору
//   фильтра. Общее число направлений исключения не должно превышать числа кана-
//   лов LAA за вычетом AuxCh плюс 1 (при использовании BaseCh). В случае превы-
//   шения данной величины, "лишние" направления исключения исключаются.
//7. RDECh = ivector(). При использовании AuxChRDEUnit рассчитывается количество
//   каналов LAA, которые должны использоваться как ее РАБОЧИЕ КАНАЛЫ. При такой
//   необходимости, осуществляется  автоматический выбор допустимых индексов ка-
//   налов LAA. Следует отметить, что индексы RDECh и AuxCh (без учета BaseCh)
//   хранятся в одном векторе LAACh.
//8. AuxChRDEType - схемная реализация AuxChRDEUnit. Возможны два варианта схем-
//   ной реализации - МНОГОСТУПЕНЧАТЫЙ и ОДНОСТУПЕНЧАТЫЙ РЕЖЕКТОРНЫЕ ПРОСТРАНСТ-
//   ВЕННЫЕ ФИЛЬТРЫ в ДОПОЛНИТЕЛЬНЫХ КАНАЛАХ АДАПТИВНОГО ПРОСТРАНСТВЕННОГО ФИЛЬТ-
//   РА с ОСНОВНЫМ КАНАЛОМ. При попытки задания другого типа, реализуется много-
//   ступенчатая схема.
//В ходе установки новых параметров предпроцессора все векторы проверяются по
//следующим условиям:
//1. На уникальность данных - из двух или более одинаковых значений остается одно;
//2. На принадлежность диапазону допустимых значений - все значения не входящие
//   в заданный диапазон исключаются.
//Функция возвращает true - при успешной установки параметров. Это возможно при
//ненулевом указателе на входной воздействие InSignal и при наличии не менее 2-х
//элементов LAA. В противном случае, новые характеристики препроцессора не уста-
//навливаются.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TInputSignal* InSignal - указатель на входное воздействие, поступающее на
//   вход предпроцессора с LAA;
//2. bool Polar (VP_SIGNAL) - поляризационная составляющая InSignal, принимаемая
//   препроцессором адаптивной LAA с ОСНОВНЫМ каналом;
//3. const ivector& BaseCh - ссылка на индексы каналов LAA, подключаемые к
//   BaseChannel;
//4. double ScanAngle - значение угла сканирования при использовании лучеобразую-
//   щей схемы BaseChannel;
//5. const ivector& AuxCh - ссылка на индексы каналов LAA, используемые в
//   качестве дополнительных каналов пространственного фильтра;
//6. const rvector& Directs - ссылка на значения направлений исключения приема
//   сигналов вспомогательными каналами AuxCh.
//7. bool lBaseChInRDE - опция подключения BaseCh к AuxChRDEUnit;
//8. ivector& RDECh - ссылка на индексы каналов LAA, используемые как рабочие
//   каналы AuxChRDEUnit;
//9. uint AuxChRDEType - тип схемы исключения направлений приема сигналов с
//   заданных направлений в дополнительных каналах SpaceFilter с BaseCh.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//lSuccess - признак успешной/неудачной установки параметров препроцессора
//*****************************************************************************
bool TPreProcessorSpaceFilterBaseCh::Set(TInputSignal* InSignal, bool Polar,
 const ivector& BaseCh, double ScanAngle, const ivector& AuxCh,
 const rvector& Directs, bool lBaseChInRDE, ivector& RDECh, uint AuxChRDEType)
{//Проверка на возможность подключения LAA к предпроцессору фильтра
 if ((InSignal == NULL) || (InSignal->LAAElem() < 2)) return false;
 Reset(); //Сброс ранее устанавленных характеристик препроцессора
 OutLAA = InSignal; //Подключаем LAA к предпроцессору
 //Устанавливаем поляризационную составляющую входного воздействия, принимаемую
 //препроцессором адаптивной LAA с ОСНОВНЫМ каналом
 SetPolar(Polar);
 //Устанавливаем параметры схемы формирования ОСНОВНОГО КАНАЛА фильтра c
 //проверкой устанавливаемых характеристик
 BaseChannel.Set(InSignal,BaseCh,ScanAngle,ON);
 //Устанавливаем каналы LAA, используемые в качестве AuxChannel с проверкой
 //устанавливаемых параметров
 SetAuxCh(AuxCh);
 //-----------------------------------------------------------------------------
 //Устанавливаем входные параметры схемы исключения направлений приема сигналов
 //дополнительными каналами пространственного фильтра с выделенным каналом
 //-----------------------------------------------------------------------------
 //Установка опции подключения BaseCh к AuxChRDEUnit
 SetUsageBaseChInRDEUnit(lBaseChInRDE);
 //Установка направлений исключения и анализ на возможность подключения RDEUnit
 //к препроцессору
 if (SetDirectElim(Directs))
 {SetRDECh(RDECh);//Установка индексов РАБОЧИХ КАНАЛОВ AuxChRDEUnit
  SetTypeRDEUnit(AuxChRDEType);//Установка схемной реализации AuxChRDEUnit
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.2; TPreProcessorSpaceFilterBaseCh public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool Set(TInputSignal* InSignal, bool Polar, const TInDataBaseCh& BaseChProp,
//      const ivector& AuxCh = ivector(), const rvector& Directs = rvector(),
//      bool lBaseChInRDE = OFF, ivector& RDECh = ivector(),
//      uint AuxChRDEType = MultiStageUnit);
//НАЗНАЧЕНИЕ: Установка параметров предпроцессора адаптивного пространственного
//фильтра  с выделенным  каналом на основе LAA. В ходе установки параметров осу-
//ществляется их проверка на корректность. Функция обрабатывает следующие исклю-
//чительные ситуации:
//1. InSignal == NULL - LAA не подключена к предпроцессору фильтра. Выход из
//   режима установки параметров предпроцессора;
//2. InSignal->LAAElem() < 2 - количество каналов LAA недостаточно для работы
//   пространственного фильтра. Выход из режима установки параметров предпроцес-
//   сора пространственного адаптивного фильтра;
//3. BaseCh == ivector() - ни один канал LAA не подключен к BaseChUnit. В этом
//   случае, к BaseChUnit подключаются ВСЕ каналы LAA;
//4. |ScanAngle| > 90 - угол сканирования выходит за диапазон от -90 до +90 гра-
//   дусов. ScanAngle устанавливается равным 0;
//5. AuxCh == ivector() - не задан  ни один канал LAA в качестве дополнительного
//   канала  пространственного фильтра. В этом случае, в качестве дополнительных
//   каналов фильтра автоматически подключаются каналы LAA по количеству активных
//   помех  либо ВСЕ допустимые каналы LAA, если активных помех больше числа до-
//   пустимых к использованию каналов LAA в качестве ВСПОМОГАТЕЛЬНЫХ;
//6. Directs == rvector() - не  заданы  направления исключения приема сигналов в
//   AuxCh SpaceFilter с BaseCh. В  этом  случае  AuxChRDEUnit не подключается к
//   предпроцессору фильтра. В случае задания направлений исключения производит-
//   ся селекция уникальных значений направлений исключения и значения не входя-
//   щие в диапазон -90 до +90 градусов исключаются. Если вектор направлений ис-
//   ключения не нулевого размера, то AuxChRDEUnit подключается к предпроцессору
//   фильтра. Общее число направлений исключения не должно превышать числа кана-
//   лов LAA за вычетом AuxCh плюс 1 (при использовании BaseCh). В случае превы-
//   шения данной величины, "лишние" направления исключения исключаются.
//7. RDECh = ivector(). При использовании AuxChRDEUnit рассчитывается количество
//   каналов LAA, которые должны использоваться как ее РАБОЧИЕ КАНАЛЫ. При такой
//   необходимости, осуществляется  автоматический выбор допустимых индексов ка-
//   налов LAA. Следует отметить, что индексы RDECh и AuxCh (без учета BaseCh)
//   хранятся в одном векторе LAACh.
//8. AuxChRDEType - схемная реализация AuxChRDEUnit. Возможны два варианта схем-
//   ной реализации - МНОГОСТУПЕНЧАТЫЙ и ОДНОСТУПЕНЧАТЫЙ РЕЖЕКТОРНЫЕ ПРОСТРАНСТ-
//   ВЕННЫЕ ФИЛЬТРЫ в ДОПОЛНИТЕЛЬНЫХ КАНАЛАХ АДАПТИВНОГО ПРОСТРАНСТВЕННОГО ФИЛЬТ-
//   РА с ОСНОВНЫМ КАНАЛОМ. При попытки задания другого типа, реализуется много-
//   ступенчатая схема.
//В ходе установки новых параметров предпроцессора все векторы проверяются по
//следующим условиям:
//1. На уникальность данных - из двух или более одинаковых значений остается одно;
//2. На принадлежность диапазону допустимых значений - все значения не входящие
//   в заданный диапазон исключаются.
//Функция возвращает true - при успешной установки параметров. Это возможно при
//ненулевом указателе на входной воздействие InSignal и при наличии не менее 2-х
//элементов LAA. В противном случае, новые характеристики препроцессора не уста-
//навливаются.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TInputSignal* InSignal - указатель на входное воздействие, поступающее на
//   вход предпроцессора с LAA;
//2. bool Polar (VP_SIGNAL) - поляризационная составляющая InSignal, принимаемая
//   препроцессором адаптивной LAA с ОСНОВНЫМ каналом;
//3. const TInDataBaseCh& BaseChProp - ссылка на входные параметры BaseChannel;
//4. const ivector& AuxCh - ссылка на индексы каналов LAA, используемые в
//   качестве дополнительных каналов пространственного фильтра;
//5. const rvector& Directs - ссылка на значения направлений исключения приема
//   сигналов вспомогательными каналами AuxCh.
//6. bool lBaseChInRDE - опция подключения BaseCh к AuxChRDEUnit;
//7. ivector& RDECh - ссылка на индексы каналов LAA, используемые как рабочие
//   каналы AuxChRDEUnit;
//8. uint AuxChRDEType - тип схемы исключения направлений приема сигналов с
//   заданных направлений в дополнительных каналах SpaceFilter с BaseCh.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//lSuccess - признак успешной/неудачной установки параметров препроцессора
//*****************************************************************************
bool TPreProcessorSpaceFilterBaseCh::Set(TInputSignal* InSignal, bool Polar,
 const TInDataBaseCh& BaseChProp, const ivector& AuxCh, const rvector& Directs,
 bool lBaseChInRDE, ivector& RDECh, uint AuxChRDEType)
{//Проверка на возможность подключения LAA к предпроцессору фильтра
 if ((InSignal == NULL) || (InSignal->LAAElem() < 2)) return false;
 Reset(); //Сброс ранее устанавленных характеристик препроцессора
 OutLAA = InSignal; //Подключаем LAA к предпроцессору
 //Устанавливаем поляризационную составляющую входного воздействия, принимаемую
 //препроцессором адаптивной LAA с ОСНОВНЫМ каналом
 SetPolar(Polar);
 //Устанавливаем параметры схемы формирования ОСНОВНОГО КАНАЛА фильтра c
 //проверкой устанавливаемых характеристик
 BaseChannel = BaseChProp;
 //Устанавливаем каналы LAA, используемые в качестве AuxChannel с проверкой
 //устанавливаемых параметров
 SetAuxCh(AuxCh);
 //-----------------------------------------------------------------------------
 //Устанавливаем входные параметры схемы исключения направлений приема сигналов
 //дополнительными каналами пространственного фильтра с выделенным каналом
 //-----------------------------------------------------------------------------
 //Установка опции подключения BaseCh к AuxChRDEUnit
 SetUsageBaseChInRDEUnit(lBaseChInRDE);
 //Установка направлений исключения и анализ на возможность подключения RDEUnit
 //к препроцессору
 if (SetDirectElim(Directs))
 {SetRDECh(RDECh);//Установка индексов РАБОЧИХ КАНАЛОВ AuxChRDEUnit
  SetTypeRDEUnit(AuxChRDEType);//Установка схемной реализации AuxChRDEUnit
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.3; public member-function of class TPreProcessorSpaceFilterBaseCh
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool TestSignal(cvector& V,double Direct,bool lBaseCh = ON,bool lAbs = ON) const
//НАЗНАЧЕНИЕ: Формирование  тест-сигнала  на  входе  препроцессора.  Направление
//тест-сигнала передается в Direct, которое должно быть задано в градусах. Тест-
//сигнал представляет собой один источник ЕДИНИЧНОЙ мощности, расположенный под
//определенным углом к раскрыву LAA, к которой подключен препроцессор. Для одно-
//го направления формируется комплексный вектор напряжений. Размерность  вектора
//равна  числу  входов  препроцессора, если lBaseCh == ON, или на единицу меньше
//(lBaseCh == OFF). Опция lBaseCh указывает на необходимость формирования  тест-
//сигнала  для ОСНОВНОГО канала. Если RDEUnit в качестве рабочего канала исполь-
//зует BaseChannel, то тест-сигнал формируется и для ОСНОВНОГО канала, независи-
//мо от значения опции lBaseCh.
//Результаты работы функции помещаются в вектор V, передавемый по ссылке. В про-
//цессе  работы функция изменяет размерность и содержимое вектора V. Функция ис-
//пользуется для расчета передаточной функции препроцессора.
//Функция  формирует  результирующий комплексный вектор V размерностью N - число
//входов препроцессора (с учетом или без ОСНОВНОГО канала в зависимости от опции
//lBaseCh). Вектор V имеет следующий вид: V =  |U1 U2 U3 ... UN|
//Функция  возвращает false, если препроцессор НЕРАБОТОСПОСОБЕН. Во всех осталь-
//ных случаях функция возвращает true и формирует результирующий  вектор V вход-
//ных  комплексных  значений  напряжений препроцессора для заданного направления
//расположения источника сигнала относительно раскрыва LAA.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& V - ссылка на результирующий вектор;
//2. double Direct - угловая координата источника тест-сигналов;
//3. bool lBaseCh (ON) - опция формирования тест-сигнала для BaseChannel.
//4. bool lAbs (ON) - опция вычисления выходного напряжения с ОСНОВНОГО канала
//   по абсолютному значению (направленность антенны)
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат вычислений
//*****************************************************************************
bool TPreProcessorSpaceFilterBaseCh::TestSignal(cvector& V, double Direct, bool lBaseCh,
     bool lAbs) const
{//Проверка на возможность вычисления входного тест-сигнала
 if (!IsReady()) {V.Resize(0L); return false;}
 //Создаем результирующий вектор V необходимой размерности
 if (lBaseCh == ON) V.Resize(In());
 else V.Resize(In()-1);
 //Рассчитываем тест-сигнал для ОСНОВНОГО канала (по необходимости)
 if ((lBaseCh) || (IsBaseChInRDEUnit()))
 {complex BaseCh = BaseChannel(Direct,DEG,lAbs);
  //Переписываем значение BaseCh в вектор V
  if (IsBaseChInRDEUnit()) V.Put(0L,BaseCh);//В первый элемент вектора V
  if (lBaseCh) V.Put(V.Size()-1,BaseCh);//В последний элемент вектора V
 }
 //Рассчитываем вектор тест-сигнала для каналов LAA, подключенных к препроцес-
 //сору для данного источника
 cvector U = OutLAA->TestSignal(LAACh,Direct,DEG,OFF);
 //Копирование вектора U в вектор V
 ulong OffSet = (IsBaseChInRDEUnit()) ? 1L : 0L;
 for (ulong i = 0L; i < U.Size(); i++) V.Put(i+OffSet,U.Get(i));
return true;
}
//******************************************************************************
//СТАТУС: I.4; public member-function of class TPreProcessorSpaceFilterBaseCh
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TestSignal(cmatrix& A, const rvector& Directs,
//                      bool lBaseCh = ON, bool lAbs = ON) const
//НАЗНАЧЕНИЕ: Формирование тест-сигналов на входе препроцессора. Направления
//тест-сигналов передаются в векторе Directs, которые должны  быть заданы в гра-
//дусах. Тест-сигнал представляет собой один источник ЕДИНИЧНОЙ мощности, распо-
//ложенный под определенным углом к раскрыву LAA, к которой подключен препроцес-
//сор. Для  каждого  направления формируется комплексный вектор напряжений. Раз-
//мерность вектора равна числу входов препроцессора, если lBaseCh == ON, или на
//единицу меньше (lBaseCh == OFF). Опция lBaseCh указывает на необходимость фор-
//мирования тест-сигнала для ОСНОВНОГО канала. Следует отметить, что если RDEUnit
//в качестве рабочего канала использует BaseChannel, то тест-сигнал формируется
//и для ОСНОВНОГО канала, независимо от значения опции lBaseCh.
//Таким образом, для N входов препроцессора и M направлений (тест-сигналов) функ-
//ция  сформирует  матрицу  размерностью N строк и M столбцов. Результаты работы
//функции помещаются в матрицу A, передавемую в нее по ссылке. В процессе работы
//функция изменяет размерность и содержимое  матрицы A. Функция используется для
//настройки  весовых  коэффициентов  режекторного  пространственного фильтра для
//вспомогательных каналов АДАПТИВНОГО пространственного фильтра с ОСНОВНЫМ кана-
//лом.
//Функция формирует результирующую комплексную матрицу A размерностью N x M,
//где M - количество  угловых  положений  источника сигнала (размерность вектора
//Angle); N - количество входов препроцессора (с учетом или без ОСНОВНОГО канала
//в зависимости от опции lBaseCh). Матрица A имеет следующий вид:
//        1   2   3   ... M - угловая координата источника сигнала
//     1 |U11 U12 U13 ... U1N|
//     2 |U21 U22 U23 ... U2N|
//     3 |U31 U32 U33 ... U3N|
// A = . |... ... ... ... ...|
//     . |... ... ... ... ...|
//     . |... ... ... ... ...|
//     N |UM1 UM2 UM3 ... UMN|
//Функция  возвращает false, если препроцессор НЕРАБОТОСПОСОБЕН либо, когда век-
//тор Directs - вектор нулевого размера. Во всех остальных случаях функция  воз-
//вращает true и формирует в результирующей матрице A входные комплексные значе-
//ния напряжений препроцессора для заданных в векторе Directs направлений распо-
//ложения источников сигналов относительно раскрыва LAA.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& A - ссылка на результирующую матрицу;
//2. rvector& Directs - вектор угловых координат источников тест-сигналов;
//3. bool lBaseCh (ON) - опция формирования тест-сигнала для BaseChannel.
//4. bool lAbs (ON) - опция вычисления выходного напряжения с ОСНОВНОГО канала
//   по абсолютному значению (направленность антенны)
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат вычислений
//******************************************************************************
bool TPreProcessorSpaceFilterBaseCh::TestSignal(cmatrix& A, const rvector& Directs,
     bool lBaseCh, bool lAbs) const
{//Проверка на возможность вычисления матрицы тест-сигналов
 if ((!IsReady()) || (Directs.Size() == 0L)) {A.Set(0L,0L,false); return false;}
 //Создаем результирующую матрицу A необходимой размерности
 if (lBaseCh == ON) A.Set(In(),Directs.Size(),C_ZERO);
 else A.Set(In()-1,Directs.Size(),C_ZERO);
 //Рассчитываем тест-сигнал для ОСНОВНОГО канала (по необходимости)
 if ((lBaseCh) || (IsBaseChInRDEUnit()))
 {cvector BaseCh;
  BaseChannel.TFunc(BaseCh, Directs, lAbs);
  //Переписываем содержимое вектора BaseCh в матрицу A
  if (IsBaseChInRDEUnit()) //В первую строку матрицы A
   for (ulong i = 0L; i < Directs.Size(); i++) A.Put(0L,i,BaseCh.Get(i));
  if (lBaseCh) //В последнюю строку матрицы A
   for (ulong i = 0L; i < Directs.Size(); i++) A.Put(A.Rows()-1,i,BaseCh.Get(i));
 }
 //Рассчитываем матрицу тест-сигналов для каналов LAA, подключенных к препроцес-
 //сору, сразу для всех источников тест-сигналов
 cmatrix U = OutLAA->TestSignal(LAACh,Directs,DEG,OFF);
 //Копирование матрицы U в матрицу A
 ulong OffSet = (IsBaseChInRDEUnit()) ? 1L : 0L;
 for (ulong i = 0L; i < U.Rows(); i++)
  for (ulong j = 0L; j < Directs.Size(); j++)
   A.Put(i+OffSet,j,U.Get(i,j));
return true;
}
//*****************************************************************************
//СТАТУС: I.5; public member-function of class TPreProcessorSpaceFilterBaseCh
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//               bool TestR(cmatrix& R, double Direct, bool lBaseCh = ON) const
//НАЗНАЧЕНИЕ: Формирование входной  корреляционной матрицы тест-сигнала на входе
//предпроцессора. Направление  тест-сигнала  передается в Direct, которое должно
//быть  задано в градусах. Тест-сигнал - это источник ЕДИНИЧНОЙ мощности, распо-
//ложенный  под  определенным углом к раскрыву LAA, к которой подключен предпро-
//цессор. Для  заданного  направления  источника сигнала формируется комплексный
//вектор  напряжений V  функцией TestSignal(...). При  перемножении вектора V на
//комплексно-сопряженный с ним вектор trV получаем входную корреляционную матри-
//цу  тест-сигнала  для данного  направления. Размерность матрицы R определяется
//количеством входов предпроцессора (с учетом или без ОСНОВНОГО канала в зависи-
//мости от опции lBaseCh).
//Функция  возвращает false, если препроцессор НЕРАБОТОСПОСОБЕН. Во всех осталь-
//ных случаях функция возвращает true и формирует корреляционную матрицу R вход-
//ного  тест-сигнала  для заданного  направления  расположения источника сигнала
//относительно раскрыва LAA.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка  на матрицу, в которой будет формироваться входная кор-
//   реляционная матрица предпроцессора для тест-сигнала;
//2. double Direct - угловая координата источника тест-сигналов;
//3. bool lBaseCh (ON) - опция формирования тест-сигнала для BaseChannel.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат вычислений
//*****************************************************************************
bool TPreProcessorSpaceFilterBaseCh::TestR(cmatrix& R, double Direct, bool lBaseCh) const
{//Проверка на возможность вычисления входного тест-сигнала
 if (!IsReady()) {R.Set(0L,0L,false); return false;}
 //Создаем результирующий вектор V необходимой размерности
 cvector V;  TestSignal(V, Direct, lBaseCh, ON);
 //Создаем входную корреляционную матрицу тест-сигнала
 R.Set(V.Size(),V.Size(),C_ZERO);
 //Цикл расчета диагональных и наддиагональных элементов R
 for (ulong i = 0L; i < R.Rows(); i++)
  for (ulong j = i; j < R.Cols(); j++)
  {if (i == j) R.Put(i,j,norm(V.Get(i)));
   else R.Put(i,j,V.Get(i)*conj(V.Get(j)));
  }
 //Цикл расчета поддиагональных элементов R
 for (ulong i = 1L; i < R.Rows(); i++)
  for (ulong j = 0L; j < i; j++)
   R.Put(i,j,conj(R.Get(j,i)));

return true;
}
//****************************************************************************************
//СТАТУС: I.6,public,class member-function TPreProcessorSpaceFilterBaseCh
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(rmatrix& P, const TEvenCloseInterval& Sector,
//                                 bool Norm = ON, bool dB = ON, double MinDb = -60.0) const
//НАЗНАЧЕНИЕ: Передаточная функция предпроцессора адаптивной LAA. Функция формирует матрицу
//мощностей на всех выходах (AuxChannels + BaseCh). В каждую строку матрицы заносятся мощ-
//ности на выходах предпроцессора при определенном угловом положении источника сигнала ЕДИ-
//НИЧНОЙ мощности. Сектор перемещения источника тест сигнала передается в объекте Sector.
//Количество строк матрицы P определяется размерностью объекта Sector (Sector.Size()), ко-
//личество столбцов матрицы P определяется количеством выходов предпроцессора Out(). В пос-
//леднем столбце хранятся выходный мощности для ОСНОВНОГО канала, в предшествующих столбцах -
//выходные  мощности ДОПОЛНИТЕЛЬНЫХ каналов. Выходные мощности могут быть нормированы в
//dB индивидуально для каждого выхода (Norm == ON).
//Функция возвращает false, если препроцессор НЕРАБОТОСПОСОБЕН, в остальных случаях функция
//возвращает true.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& P - ссылка на матрицу со значениями мощности на выходах препроцессора AdaptLAA
//   при перемещении источника сигнала ЕДИНИЧНОЙ мощности в секторе Sector;
//2. const TEvenCloseInterval& Sector - сектор по углу места (азимуту), в  котором рассчи-
//   тывается передаточная функция препроцессора (в градусах);
//3. bool Norm (ON) - опция нормирования выходных мощностей;
//4. bool dB (ON) - опция нормирования в децибелах (действует при Norm = ON);
//5. double MindB - минимальный уровень в децибелах (действует при dB = ON).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//****************************************************************************************
bool TPreProcessorSpaceFilterBaseCh::TFunc(rmatrix& P, const TEvenCloseInterval& Sector,
     bool Norm, bool dB, double MindB) const
{//Проверка работоспособности ПРЕДПРОЦЕССОРА AdaptLAA с BaseCh:
 if (!IsReady()) {P.Set(0L,0L,false); return false;}
 cvector InSignal, OutSignal;
 //Создание матрицы P необходимых размеров: rows=Sector.Size(); cols=Out().
 P.Set(Sector.Size(),Out(),0.0);
 //Определение мощности на выходах предпроцессора в заданном секторе
 for (ulong i = 0L; i < P.Rows(); i++)
 {//----------------------------------------------------------------------------
  //1. ФОРМИРОВАНИЕ ВХОДНОГО ТЕСТ-СИГНАЛА ДЛЯ ПРЕДПРОЦЕССОРА AdaptLAA с BaseCh
  //----------------------------------------------------------------------------
  TestSignal(InSignal,Sector(i),ON);
  //----------------------------------------------------------------------------
  //2. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ режекторного пространственного фильтра для AuxCh при
  //   его подключении к предпроцессору (Q-преобразование)
  //----------------------------------------------------------------------------
  if (UsageRDEUnit() == ON)
  {RDEUnit->TFunc(InSignal,OutSignal);
   //Переписываем OutSignal в P
   for (ulong j = 0L; j < P.Cols(); j++) P.Put(i,j,norm(OutSignal.Get(j)));
  }
  else //Переписываем InSignal в P
   for (ulong j = 0L; j < P.Cols(); j++) P.Put(i,j,norm(InSignal.Get(j)));
 }
 //-----------------------------------------------------------------------------
 //Нормирование выходных мощностей предпроцессора индивидуально для каждого
 //-----------------------------------------------------------------------------
 if (Norm == ON)
 {double MaxPower;
  for (ulong j = 0L; j < P.Cols(); j++) //Нормирование для каждого выхода
  {MaxPower = 0.0;
   for (ulong i = 0L; i < P.Rows(); i++)
    MaxPower = (MaxPower < P.Get(i,j)) ? P.Get(i,j) : MaxPower;
   //Нормирование в пределах от [0..1]
   for (ulong i = 0L; i < P.Rows(); i++) P.Put(i,j,P.Get(i,j)/MaxPower);
  }
  if (dB == ON) //Нормирование в децибелах [MindB..0]
  {double Power;
   MindB = (MindB >= 0.0) ? -60.0 : MindB;//Минимальное значение в dB
   for (ulong i = 0L; i < P.Rows(); i++)
    for (ulong j = 0L; j < P.Cols(); j++)
    {Power = (P.Get(i,j) == 0.0) ? MindB : 10*log10(P.Get(i,j));
     Power = (Power < MindB) ? MindB : Power;
     P.Put(i,j,Power);
    }
  }
 }
return true;
}
//****************************************************************************************
//СТАТУС: I.7,public,class member-function TPreProcessorSpaceFilterBaseCh
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool TFunc(cvector& Uout, double Direct, bool lAbs = ON) const
//НАЗНАЧЕНИЕ: Передаточная  функция предпроцессора адаптивной LAA. Функция форми-
//рует вектор напряжений на всех выходах (AuxChannels + BaseCh) в зависимости от
//углового положения относительно раскрыва LAA источника сигнала ЕДИНИЧНОЙ МОЩ-
//НОСТИ. Рассчитанный функцией выходной сигнала с предпроцессора заносится в
//вектор Uout, передаваемый по ссылке. Угловое положение (в градусах) источника
//сигнала передается в функцию в переменной Direct.
//Функция возвращает false, если препроцессор НЕРАБОТОСПОСОБЕН, в остальных слу-
//чаях функция возвращает true.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& Uout - ссылка на вектор со значениями напряжения на выходах пред-
//   процессора AdaptLAA при действии источника сигнала ЕДИНИЧНОЙ мощности с оп-
//   ределенного направления;
//2. double Direct - угловое положение источника сигнала по углу места (азимуту),
//   по которому рассчитывается передаточная функция препроцессора (в градусах);
//3. bool lAbs (ON) - опция вычисления выходного напряжения с ОСНОВНОГО канала
//   по абсолютному значению (направленность антенны)
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TPreProcessorSpaceFilterBaseCh::TFunc(cvector& Uout, double Direct, bool lAbs) const
{//Проверка работоспособности ПРЕПРОЦЕССОРА AdaptLAA с BaseCh:
 if (!IsReady()) {Uout.Resize(0L); return false;}
 cvector Uin;
 //----------------------------------------------------------------------------
 //1. ФОРМИРОВАНИЕ ВХОДНОГО ТЕСТ-СИГНАЛА ДЛЯ ПРЕДПРОЦЕССОРА AdaptLAA с BaseCh
 //----------------------------------------------------------------------------
 TestSignal(Uin,Direct,ON,lAbs);
 //----------------------------------------------------------------------------
 //2. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ режекторного пространственного фильтра для AuxCh при
 //   его подключении к предпроцессору (Q-преобразование)
 //----------------------------------------------------------------------------
 if (UsageRDEUnit() == ON) RDEUnit->TFunc(Uin,Uout);
 else Uout = Uin;//Переписываем Uin в Uout
return true;
}
//***********************************************************************************
//СТАТУС: I.8,public,class member-function TPreProcessorSpaceFilterBaseCh
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(cmatrix& Rout, double Direct) const
//НАЗНАЧЕНИЕ: Передаточная  функция предпроцессора адаптивной LAA. Функция формирует
//выходную корреляционную матрицу (AuxChannels + BaseCh) в зависимости от углового
//положения относительно раскрыва LAA источника сигнала ЕДИНИЧНОЙ МОЩНОСТИ. Выходная
//корреляционная матрица предпроцессора заносится в матрицу Rout, передаваемую по
//ссылке. Угловое положение (в градусах) источника сигнала передается в функцию в
//переменной Direct.
//Функция возвращает false, если препроцессор НЕРАБОТОСПОСОБЕН, в остальных случаях
//функция возвращает true.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& Rout - ссылка  на  выходную  корреляционную матрицу предпроцессора
//   AdaptLAA при  действии источника сигнала ЕДИНИЧНОЙ мощности с определенного
//   направления;
//2. double Direct - угловое положение источника сигнала по углу места (азимуту),
//   по которому рассчитывается передаточная функция препроцессора (в градусах);
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TPreProcessorSpaceFilterBaseCh::TFunc(cmatrix& Rout, double Direct) const
{//Проверка работоспособности ПРЕПРОЦЕССОРА AdaptLAA с BaseCh:
 if (!IsReady()) {Rout.Set(0L,0L,false); return false;}
 cmatrix Rin;
 //----------------------------------------------------------------------------------
 //1. ФОРМИРОВАНИЕ ВХОДНОЙ КОРРЕЛЯЦИОННОЙ МАТРИЦЫ ТЕСТ-СИГНАЛА ПРЕДПРОЦЕССОРА
 //----------------------------------------------------------------------------------
 TestR(Rin,Direct,ON);
 //----------------------------------------------------------------------------------
 //2. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ режекторного пространственного фильтра для AuxCh при
 //   его подключении к предпроцессору (Q-преобразование)
 //----------------------------------------------------------------------------------
 if (UsageRDEUnit() == ON) RDEUnit->TFunc(Rin,Rout);
 else Rout = Rin;//Переписываем Rin в Rout
return true;
}
//****************************************************************************************
//СТАТУС: I.9; TPreProcessorSpaceFilterBaseCh public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong AuxChCount() const
//НАЗНАЧЕНИЕ: Количество ДОПОЛНИТЕЛЬНЫХ каналов адаптивного пространственного фильтра с
//BaseCh. При работе функции, члены-данные объекта не изменяются.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong amount - число ДОПОЛНИТЕЛЬНЫХ каналов фильтра
//****************************************************************************************
ulong TPreProcessorSpaceFilterBaseCh::AuxChCount() const
{if (!UsageRDEUnit()) return LAACh.Size();
 ulong OffSet = (IsBaseChInRDEUnit()) ? RDEChCount()-1 : RDEChCount();
 return LAACh.Size()-OffSet;
}
//****************************************************************************************
//СТАТУС: I.10; TPreProcessorSpaceFilterBaseCh public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong GetAuxCh(ivector& AuxCh) const
//НАЗНАЧЕНИЕ: Формирование индексов каналов LAA, которые используются как ДОПОЛНИТЕЛЬНЫЕ
//каналы адаптивного пространственного фильтра с BaseCh. Индексы заносятся в вектор AuxCh,
//передаваемый по ссылке. Для работы функция использует вектор LAACh. Функция возвращает
//общее количество дополнительных каналов SpaceFilter с BaseCh. При работе функции, члены-
//данные объекта не изменяются.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ivector& AuxCh - ссылка на вектор для размещения индексов каналов
//LAA, используемые как дополнительные каналы пространственного фильтра.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong amount - число ДОПОЛНИТЕЛЬНЫХ каналов фильтра
//****************************************************************************************
ulong TPreProcessorSpaceFilterBaseCh::GetAuxCh(ivector& AuxCh) const
{if (!IsReady()) {AuxCh.Resize(0L); return AuxCh.Size();}
 //Формирование индексов дополнительных каналов фильтра
 AuxCh.Resize(AuxChCount());
 ulong OffSet = LAACh.Size()-AuxChCount();
 for (ulong i = 0L; i < AuxCh.Size(); i++) AuxCh.Put(i,LAACh.Get(i+OffSet));
 return AuxCh.Size();
}
//****************************************************************************************
//СТАТУС: I.11; TPreProcessorSpaceFilterBaseCh public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong GetRDECh(ivector& RDECh) const
//НАЗНАЧЕНИЕ: Формирование индексов каналов LAA и ОСНОВНОГО канала, которые используются как
//РАБОЧИЕ каналы AuxChRDEUnit. Индексы заносятся в вектор AuxCh, передаваемый по ссылке.
//Индекс ОСНОВНОГО канала формируется только при его использовании AuxChRDEUnit, он всегда
//располагается первым по списку и всегда используется для компенсации первого направления
//приема в DirectElim. Для работы функция использует вектор LAACh и BaseChannel. Функция
//возвращает общее количество рабочих каналов AuxChRDEUnit. При работе функции, члены-дан-
//ные объекта не изменяются.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ivector& RDECh - ссылка на вектор, в котором будут формироваться
//индексы каналов LAA, используемые как рабочие каналы AuxChRDEUnit.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong amount - число РАБОЧИХ каналов AuxChRDEUnit
//****************************************************************************************
ulong TPreProcessorSpaceFilterBaseCh::GetRDECh(ivector& RDECh) const
{if (!UsageRDEUnit()) {RDECh.Resize(0L); return RDECh.Size();}
 //Формирование индексов рабочих каналов AuxChRDEUnit
 RDECh.Resize(RDEChCount());
 if (IsBaseChInRDEUnit()) //ОСНОВНОЙ канал подключен к AuxChRDEUnit
 {ulong BaseChIndex = OutLAA->LAAElem();
  ulong Border = RDEChCount()-1;
  //Лучеобразующая схема не используется при формировании ОСНОВНОГО канала
  if (!BaseChannel.UsageBFC()) BaseChIndex = BaseChannel.IndexLAACh(0);
  //ОСНОВНОЙ канал используется AuxChRDEUnit всегда ПЕРВЫМ
  RDECh.Put(0,BaseChIndex);
  for (ulong i = 0L; i < Border; i++) RDECh.Put(i+1,LAACh.Get(i));
 }
 else for (ulong i = 0L; i < RDEChCount(); i++) RDECh.Put(i,LAACh.Get(i));
 return RDECh.Size();
}
//****************************************************************************************
//СТАТУС: I.12; TPreProcessorSpaceFilterBaseCh public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& Polarization(string& s, string& title, uint indent = 0) const;
//НАЗНАЧЕНИЕ: Сведения о поляризационной составляющей входного воздействия, принимаемой
//препроцессором AdaptLAA с ОСНОВНЫМ каналом в виде строки. В строку s, передаваемую по
//ссылке, заносится информация о типе поляризации:
//a)VP_SIGNAL - вертикальная поляризация;
//b)HP_SIGNAL - горизонтальная поляризация;
//Свойства ТИПА ПОЛЯРИЗАЦИИ в виде строки могут быть представлены:
//1. Предпроцессор пространственного фильтра не работоспособен: IsReady() == OFF
// POLARIZATION: <Unknown;\n>
//----------------------------------------------------------------------------------------
//2. Предпроцессор пространственного фильтра работоспособен: IsReady() == ON
// POLARIZATION: <Vertical || Horizontal;\n>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& title - ссылка на строку с заголовком объекта;
//3. uint indent - начальное смещение строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка с данными по ТИПУ ПОЛЯРИЗАЦИИ
//****************************************************************************************
string& TPreProcessorSpaceFilterBaseCh::Polarization(string& s, string& title, uint indent) const
{string space(' ',indent);
 //Формирование заголовка объекта
 s = space;
 if (title.empty()) s.append("POLARIZATION: ");
 else s.append(title);
 //-----------------------------------------------------------------------------
 //1. ПРЕДПРОЦЕССОР НЕРАБОТОСПОСОБЕН:
 if (!IsReady()) {s.append("Unknown;\n"); return s;}
 //------------------------------------------------------------------------------
 //2. ПРЕДПРОЦЕССОР РАБОТОСПОСОБЕН:
 //Поляризационная составляющая, принимаемая препроцессором AdaptiveLAA
 if (Polarization() == VP_SIGNAL) s.append("< Vertical >;\n");
 else s.append("< Horizontal >;\n");
return s;
}
//****************************************************************************************
//СТАТУС: I.13; TPreProcessorSpaceFilterBaseCh public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& AuxChProp(string& s, string& title, uint indent = 0) const
//НАЗНАЧЕНИЕ: Сведения о дополнительных каналах пространственного фильтра на основе LAA в
//виде строки. В строку s, передаваемую по ссылке, заносится информация:
//1)число дополнительных каналов;
//2)номера каналов LAA, подключенных к пространственному фильтру как дополнительные каналы
//  (до 15);
//3)количество дополнительных каналов, индексы которых различаются с индексами каналов LAA,
//  подключенных к BaseChannel.
//Свойства ВСПОМОГАТЕЛЬНЫХ КАНАЛОВ в виде строки могут быть представлены:
//1. Предпроцессор пространственного фильтра не работоспособен: IsReady() == OFF
// AUXILIARY CHANNEL: <0>;
//----------------------------------------------------------------------------------------
//2. Предпроцессор пространственного фильтра работоспособен: IsReady() == ON
// AUXILIARY CHANNELs: <AuxChannel.Size()>; Independent: <(AuxCh^BaseCh).Size()>
//  CHANNELs = [<index LAA channels, count = 1..15>];
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& title - ссылка на строку с заголовком объекта;
//3. uint indent - начальное смещение строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка с данными по ВСПОМОГАТЕЛЬНЫМ КАНАЛАМ
//****************************************************************************************
string& TPreProcessorSpaceFilterBaseCh::AuxChProp(string& s, string& title, uint indent) const
{char buffer[80]; ostrstream text (buffer, sizeof(buffer));
 string t; string space(' ',indent);
 //Формирование заголовка объекта
 s = space;
 if (title.empty()) s.append("AUXILIARY CHANNELs: ");
 else s.append(title);
 //------------------------------------------------------------------------------
 //1. ПРЕДПРОЦЕССОР НЕРАБОТОСПОСОБЕН:
 if (!IsReady()) {s.append("0;\n"); return s;}
 //------------------------------------------------------------------------------
 //2. ПРЕДПРОЦЕССОР РАБОТОСПОСОБЕН:
 //Количество каналов LAA, используемых как ВСПОМОГАТЕЛЬНЫЕ КАНАЛЫ ФИЛЬТРА
 text << AuxChCount() << ends;
 s.append(text.str()); text.seekp(0);
 //Определение количества независимых вспомогательных каналов. К независимым каналам
 //относятся каналы, индексы которых не совпадают с индексами каналов LAA, подключенных к
 //схеме формирования ОСНОВНОГО КАНАЛА
 ivector AuxCh; GetAuxCh(AuxCh);
 ivector IndepCh = AuxCh ^ BaseChannel.Channels();
 text << ", Independent = " << IndepCh.Size() << endl << ends;
 s.append(text.str()); text.seekp(0);
 //Формирование индексов каналов LAA, используемых как ВСПОМОГАТЕЛЬНЫЕ КАНАЛЫ (до 15 каналов)
 t = AuxCh.ConvertToString(t,15);
 s.append(space);
 s.append(" Channels = ["); s.append(t); s.append("];\n");
return s;
}
//****************************************************************************************
//СТАТУС: I.14; TPreProcessorSpaceFilterBaseCh public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& RDEUnitProp(string& s, string& title, uint indent=0) const
//НАЗНАЧЕНИЕ: Свойства схемы формирования направлений исключения приема сигналов вспомога-
//тельными каналами пространственного фильтра на основе LAA в виде строки. В строку s, пе-
//редаваемую по ссылке, заносится следующая информация:
//1)статус RDEUnit: подключена || отключена;
//В случае использования AuxChSignalReceptDirectElimUnit:
//2)использование ОСНОВНОГО канала [ON || OFF]
//3)число направлений исключения и их значения (до 15);
//4)номера каналов LAA, подключенные к RDEUnit для формирования направлений исключения
//  приема сигналов у ВСПОМОГАТЕЛЬНЫХ КАНАЛОВ (до 15).
//5)схемная реализация AuxChRDEUnit [MultiStageUnit || SingleStageUnit]
//Свойства AuxChSignalReceptDirectElimUnit в виде строки представляются:
//1. Предпроцессор пространственного фильтра не работоспособен: IsReady() == OFF
// AuxChRDEUnit: <OFF>;
//----------------------------------------------------------------------------------------
//2. Предпроцессор пространственного фильтра работоспособен: IsReady() == ON
// SPACE REJECTION FILTER for AuxChannels: <OFF || Unit Type>
//  Unit Type: <MultiStageUnit || SingleStageUnit>
//  Usage BaseChannel: <Yes || No>
//  Direct Elimination: <DirectElim.Size()> [<angle1,[angle2...angleN],1..15>]
//  Channels = [<index LAA channels, count = 1..15>];
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& title - ссылка на строку с заголовком объекта;
//3. uint indent - начальное смещение строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка с данными по ВСПОМОГАТЕЛЬНЫМ КАНАЛАМ
//****************************************************************************************
string& TPreProcessorSpaceFilterBaseCh::RDEUnitProp(string& s, string& title, uint indent) const
{char buffer[80]; ostrstream text(buffer, sizeof(buffer));
 string t; string space(' ',indent);
 string sep(1,' '), etc("...");
 //Формирование заголовка объекта
 s = space;
 if (title.empty()) s.append("SPACE REJECTION FILTER for AuxChannels: ");
 else s.append(title);
 //-------------------------------------------------------------------------------------
 //1. ПРЕДПРОЦЕССОР НЕРАБОТОСПОСОБЕН или RDEUnit не используется:
 if ((!IsReady()) || (!UsageRDEUnit())) {s.append("< Off >;\n"); return s;}
 //-------------------------------------------------------------------------------------
 //2. RDEUnit используется предпроцессором. Формирование заголовка со схемной реализацией
 //   пространственного режекторного фильтра
 s.append(RDEUnit->Clip(t)+'\n');
 //Формирование строки по использованию BaseChannel
 s.append(space);
 t = (IsBaseChInRDEUnit()) ? "< Yes >" : "< No >";
 text << " Usage BaseChannel: " << t << endl << ends;
 s.append(text.str()); text.seekp(0);
 //Формирование данных по значениям направлений исключения и их количеству
 s.append(space);
 text << " Direct Elimination: " << DirectElim.Size() << ends;
 s.append(text.str()); text.seekp(0);
 t = DirectElim.ConvertToString(t,sep,etc,15);
 s.append(" ["); s.append(t); s.append("]\n");
 //Каналы LAA и их количество, используемые для формирования направлений исключения приема
 //сигналов ВСПОМОГАТЕЛЬНЫМИ КАНАЛАМИ фильтра
 s.append(space);
 text << " Channels: " << RDEChCount() << ends;
 s.append(text.str()); text.seekp(0);
 ivector RDECh; GetRDECh(RDECh);
 t = RDECh.ConvertToString(t,15);
 s.append(" ["); s.append(t); s.append("];\n");
return s;
}
//****************************************************************************************
//СТАТУС: I.15; TPreProcessorSpaceFilterBaseCh public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Properties(string& s, string& title, uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта TPreProcessorSpaceFilterBaseCh в виде строки.
//В строку s, передаваемой по ссылке, заносятся свойства ОСНОВНОГО КАНАЛА, индексы каналов
//LAA, используемые как дополнительные каналы пространственного фильтра и свойства схемы
//формирования направлений исключения приема сигналов вспомогательными каналами. Предыдущее
//содержимое строки s уничтожается.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& title - ссылка на строку с заголовком объекта;
//3. uint indent - начальное смещение строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//****************************************************************************************
string& TPreProcessorSpaceFilterBaseCh::Properties(string& s, string& title, uint indent) const
{string t, header; string space(' ',indent);
 //Формирование заголовка объекта
 s = space;
 if (title.empty()) s.append("PREPROCESSOR of ADAPTIVE SPACE FILTER with BASE CHANNEL: ");
 else s.append(title);
 //-----------------------------------------------------------------------------
 //ПРЕДПРОЦЕССОР НЕРАБОТОСПОСОБЕН:
 if (!IsReady())
 {s.append("< Off >;\n"); s.append(space);
  if (OutLAA == NULL) s.append(" Cause: Preprocessor unconnect with LAA.\n");
  else if (OutLAA->LAAElem() < 2) s.append(" Cause: LAA channels < 2.\n");
  return s;
 }
 else s.append("< On >\n");
 //--------------------------------------------------------------------------------------
 //1. Формирование поляризационной составляющей InSignal, принимаемой AdaptLAA
 s.append(Polarization(t,header,indent+1));
 //--------------------------------------------------------------------------------------
 //2. Формирование свойств ОСНОВНОГО КАНАЛА
 s.append(BaseChProp(t,header,indent+1));
 //--------------------------------------------------------------------------------------
 //3. Формирование индексов каналов LAA, используемых как вспомогательные каналы
 //   адаптивного пространственного фильтра с выделенным каналом
 s.append(AuxChProp(t,header,indent+1));
 //--------------------------------------------------------------------------------------
 //4. Формирование свойств схемы исключения направлений приема сигналов вспомогательными
 //   каналами пространственного фильтра
 s.append(RDEUnitProp(t,header,indent+1));
return s;
}
//****************************************************************************************
//СТАТУС: I.16; TPreProcessorSpaceFilterBaseCh public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit()
//НАЗНАЧЕНИЕ: Ввод новых параметров объекта класса через стандартный поток ввода cin (>>).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessorSpaceFilterBaseCh::Edit()
{//--------------------------------------------------------------------------------------
 //ПРЕДПРОЦЕССОР ПРОСТРАНСТВЕННОГО ФИЛЬТРА НЕРАБОТОСПОСОБЕН:
 //--------------------------------------------------------------------------------------
 if (IsReady() == OFF)
 {gotoxy(1,wherey()); clreol();
  cout << "\aInput SPACE FILTER PREPROCESSOR parameters is impossible !!!\n";
  if (OutLAA == NULL)
   cout << "Cause: PREPROCESSOR unconnect with LAA." << endl;
  else if (OutLAA->LAAElem() < 2)
   cout << "Cause: LAA channels < 2." << endl;
  return;
 }
 //Рабочие переменные
 int y_start = wherey(); char c; string s, line(78,'-'); bool flag;
 gotoxy(1,y_start); clreol();
 do
 {cout << line << endl;
  cout << "PREPROCESSOR of SPACE FILTER: < Input Parameters >" << endl;
  //1. Ввод поляризационной составляющей входного воздействия, принимаемой
  //   адаптивной LAA c BaseCh
  PolarEdit();
  //2. Ввод параметров Base Channel
  BaseChannel.Edit();
  //3. Ввод каналов LAA, подключаемых к ВСПОМОГАТЕЛЬНЫМ КАНАЛАМ ФИЛЬТРА
  ResetRDEUnit();//Сброс параметров схемы AuxChRDEUnit
  AuxChEdit();
  //4. Ввод параметров схемы исключения направлений приема сигналов вспомогатель-
  //  ными каналами пространственного фильтра
  AuxChRDEUnitEdit();
  //Подтверждение введенных данных
  cout << line << endl;
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
 //Вывод введенных параметров предпроцессора пространственного фильтра с
 //выделенным каналом
 cout << Properties(s,STR_NULL);
}
//*****************************************************************************
//СТАТУС: I.17;public;TPreProcessorSpaceFilterBaseCh class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// operator =(const TPreProcessorSpaceFilterBaseCh& Preprocessor)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ  ОПЕРАТОР ПРИСВАИВАНИЯ класса TPreProcessorSpaceFil-
//terBaseCh. Функция  копирует свойства одного объекта TPreProcessorSpaceFilter-
//BaseCh в другой.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const TPreProcessorSpaceFilterBaseCh& Preprocessor - ссылка на копируемый объект.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TPreProcessorSpaceFilterBaseCh::operator =
     (const TPreProcessorSpaceFilterBaseCh& Preprocessor)
{//Предотвращение попытки присваивания объекта самому себе
 if (this == &Preprocessor) return;
 TInputSignal* InSignal = Preprocessor.GetLAA();
 bool Polar = Preprocessor.Polarization();
 double ScanAngle = Preprocessor.GetScanAngle();
 ivector BaseCh, AuxCh, RDECh;
 rvector Directs;
 bool lBaseChInRDE = Preprocessor.IsBaseChInRDEUnit();
 uint AuxChRDEType = Preprocessor.RDEType();
 Preprocessor.GetBaseCh(BaseCh); Preprocessor.GetAuxCh(AuxCh);
 Preprocessor.GetRDECh(RDECh); Preprocessor.GetDirectElim(Directs);

 Set(InSignal, Polar, BaseCh, ScanAngle, AuxCh, Directs, lBaseChInRDE, RDECh,
     AuxChRDEType);
}
//========================================================================================
//II. РЕАЛИЗАЦИЯ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TPreProcessorSpaceFilterBaseCh
//    PRIVATE MEMBER-FUNCTION OF TPreProcessorSpaceFilterBaseCh CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: II.1., private, TPreProcessorSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Initial();
//НАЗНАЧЕНИЕ: Начальная установка свойств предпроцессора обработки входного сигнала прост-
//ранственного адаптивного фильтра с выделенным каналом при конструировании объекта.
//Начальная установка характеристик следующая:
//----------------------------------------------------------------------------------------
//I. СХЕМА ФОРМИРОВАНИЯ ОСНОВНОГО (ВЫДЕЛЕННОГО) КАНАЛА - BaseChannel
// 1. ivector Channel - вектор нулевого размера;
// 2. double ScanAngle = 0 [deg];
// 3. cvector B - вектор нулевого размера;
// 4. InSignal* OutLAA = NULL;
//II. ВСПОМОГАТЕЛЬНЫЕ КАНАЛЫ ФИЛЬТРА (AuxChannel) и РАБОЧИЕ КАНАЛЫ AuxChRDEUnit
//    (при ее использовании) с LAA
// 1. ivector LAACh - вектор нулевого размера;
//III. ПАРАМЕТРЫ СХЕМЫ ИСКЛЮЧЕНИЯ НАПРАВЛЕНИЙ ПРИЕМА ДОПОЛНИТЕЛЬНЫМИ КАНАЛАМИ
// 1. rvector DirectElim - вектор нулевого размера;
// 2. lBaseChInRDEUnit = OFF;
// 3. TAuxChSpaceRejectFilter* RDEUnit = NULL;
//IV. ВХОДНОЙ СИГНАЛ С КАНАЛОВ LAA, К КОТОРЫМ ПОДКЛЮЧЕН ФИЛЬТР
// 1. TInputSignal* OutLAA = NULL;
// 2. bool PolarType = VP_SIGNAL;
// 2. cvector Signal - вектор нулевого размера;
// 3. cvector Noise  - вектор нулевого размера;
// 4. cmatrix Jammer - матрица нулевого размера;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessorSpaceFilterBaseCh::Initial()
{//Начальная установка всех параметров предпроцессора при его конструировании
 BaseChannel = TBaseChannel();//ОСНОВНОЙ канал
 LAACh = ivector();//Каналы с LAA: [RDEChannels] || AuxChannels
 InitRDEUnit();//Начальная установка AuxChRDEUnit
 //LAA & Входная выборка компонент входного воздействия
 OutLAA = NULL; PolarType = VP_SIGNAL;
}
//****************************************************************************************
//СТАТУС: II.2., private, TPreProcessorSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: InitRDEUnit()
//НАЗНАЧЕНИЕ: Начальная установка свойств AuxChRDEUnit при конструировании предпроцессора
//адаптивной LAA. Начальная установка характеристик следующая:
//----------------------------------------------------------------------------------------
//ПАРАМЕТРЫ СХЕМЫ ИСКЛЮЧЕНИЯ НАПРАВЛЕНИЙ ПРИЕМА ДОПОЛНИТЕЛЬНЫМИ КАНАЛАМИ
// 1. rvector DirectElim - вектор нулевого размера;
// 2. lBaseChInRDEUnit = OFF;
// 3. TAuxChSpaceRejectFilter* RDEUnit = NULL;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessorSpaceFilterBaseCh::InitRDEUnit()
{DirectElim = rvector(); lBaseChInRDEUnit = OFF; RDEUnit = NULL; }
//****************************************************************************************
//СТАТУС: II.3., private, TPreProcessorSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void ResetRDEUnit();
//НАЗНАЧЕНИЕ: Сброс параметров схемы AuxChRDEUnit предпроцессора обработки входного сигнала
//при разрушении объекта класса или изменении его характеристик.
//Установка характеристик AuxChRDEUnit:
//----------------------------------------------------------------------------------------
//ПАРАМЕТРЫ СХЕМЫ ИСКЛЮЧЕНИЯ НАПРАВЛЕНИЙ ПРИЕМА ДОПОЛНИТЕЛЬНЫМИ КАНАЛАМИ
// 1. rvector DirectElim - вектор нулевого размера;
// 2. lBaseChInRDEUnit = OFF;
// 3. TAuxChSpaceRejectFilter* RDEUnit = NULL;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessorSpaceFilterBaseCh::ResetRDEUnit()
{if (!UsageRDEUnit()) return;//AuxChRDEUnit не использовалась предпроцессором
 ivector AuxCh;
 if (LAACh.Size() != 0L) {GetAuxCh(AuxCh); LAACh = AuxCh;}
 DirectElim = rvector(); lBaseChInRDEUnit = OFF;
 //"Отключение" AuxChRDEUnit от предпроцессора
 if (RDEUnit != NULL) {delete RDEUnit; RDEUnit = NULL;}
}
//****************************************************************************************
//СТАТУС: II.4., private, TPreProcessorSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetAuxCh(const ivector& Channel)
//НАЗНАЧЕНИЕ: Подключение каналов LAA к предпроцессору пространственного адаптивного фильтра
//с выделенным каналом, используемые как ВСПОМОГАТЕЛЬНЫЕ КАНАЛЫ фильтра. Индексы каналов
//передаются в векторе Channel. Элементы вектора Channel проверяются на уникальность и на
//принадлежность допустимому диапазону значений каналов. Допустимый диапазон выбора номеров
//каналов LAA занимает интервал - [0..OutLAA->Elem()]. Кроме того, если BaseChannel исполь-
//зует ОДИН КАНАЛ LAA, то индекс этого канала также исключается из указанного интервала.
//Если вектор Channel - вектор нулевого размера, то в  качестве ВСПОМОГАТЕЛЬНЫХ каналов
//фильтра используется количество каналов LAA равное числу активных источников помех из
//допустимого множества индексов каналов. Сформированные индексы каналов LAA используемые
//в качестве ВСПОМОГАТЕЛЬНЫХ каналов хранятся в LAACh.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const ivector& Channel - ссылка на вектор с индексами каналов LAA,
//используемые как ВСПОМОГАТЕЛЬНЫЕ каналы пространственного фильтра.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessorSpaceFilterBaseCh::SetAuxCh(const ivector& Channel)
{ulong size;
 //Копируем в вектор AuxChannel только неповторяющиеся индексы каналов LAA
 LAACh = Channel.Unique();
 //Фильтрация индексов каналов, которые не входят в допустимое множество каналов LAA,
 //подключаемых к ВСПОМОГАТЕЛЬНЫМ каналам фильтра
 if (LAACh.Size() != 0L)
 {size = (BaseChannel.UsageBFC()) ? 2 : 3;
  ivector param(size, COL);
  param[0] = 0; param[1] = OutLAA->LAAElem()-1;
  if (param.Size() == 3) param[2] = BaseChannel.IndexLAACh(0);
  TClosedIntervalWithDiscontPoints<long, ivector> Predicate(param);
  LAACh = LAACh.SubVector(Predicate);
  //LAACh.BubbleSort();//Сортировка индексов каналов по возрастанию
 }
 //Автоматическая установка индексов каналов LAA как ВСПОМОГАТЕЛЬНЫХ КАНАЛОВ адаптивного
 //пространственного фильтра по числу активных помех
 if (LAACh.Size() == 0L)
 {ulong JamCount = OutLAA->ActiveJammers();
  if (JamCount == 0L) JamCount = 1L;
  ulong FreeCh = OutLAA->LAAElem();
  if (!BaseChannel.UsageBFC()) FreeCh--;
  size = (FreeCh < JamCount) ? FreeCh : JamCount;
  LAACh.Resize(size);
  if (BaseChannel.UsageBFC()) //Основной канал - СИНТЕЗИРОВАННЫЙ
   for (ulong i = 0L; i < LAACh.Size(); i++) LAACh.Put(i,i);
  else //Основной канал использует ОДИН канал LAA
  {ulong index = BaseChannel.IndexLAACh(0L);
   ulong j = 0L;
   ulong i = 0L;
   do
   {if (i != index) LAACh.Put(j++,i);
    i++;
   } while (j < size);
  }
 }
}
//****************************************************************************************
//СТАТУС: II.5., private, TPreProcessorSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong AmountLAAChForRDEUnit() const
//НАЗНАЧЕНИЕ: Определение числа каналов LAA, которые могут быть использованы AuxChRDEUnit
//как РАБОЧИЕ КАНАЛЫ.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong amount - число каналов LAA, которые можно использовать как
//РАБОЧИЕ КАНАЛЫ AuxChRDEUnit
//****************************************************************************************
ulong TPreProcessorSpaceFilterBaseCh::AmountLAAChForRDEUnit() const
{ulong amount = 0L;
 if (IsReady()) //Проверка "РАБОТОСПОСОБНОСТИ" предпроцессора
 {amount = OutLAA->LAAElem()-AuxChCount();
  if ((!BaseChannel.UsageBFC()) && (amount != 0L)) amount--;
 }
 return amount;
}
//****************************************************************************************
//СТАТУС: II.6., private, TPreProcessorSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong GetFreeChForRDEUnit(ivector& RDECh) const
//НАЗНАЧЕНИЕ: Формирование индексов каналов LAA в векторе RDECh, передаваемом по ссылке,
//которые можно использовать как РАБОЧИЕ КАНАЛЫ AuxChRDEUnit. Из всего множества каналов
//LAA исключаются каналы, используемые как ДОПОЛНИТЕЛЬНЫЕ каналы адаптивного пространствен-
//ного фильтра, а также номер канала LAA, используемый в качестве ОСНОВНОГО канала, если
//BaseChannel НЕ ФОРМИРУЕТ синтезированный основной канал. Функция возвращает число каналов
//LAA, которые можно использовать как РАБОЧИЕ КАНАЛЫ AuxRDEUnit. Функция изменяет вектор
//RDECh. Если свободных каналов нет, функция возвращает 0 и вектор RDECh нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const ivector& RDECh - ссылка на вектор с индексами каналов LAA,
//которые можно использовать как РАБОЧИЕ КАНАЛЫ AuxChRDEUnit
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong amount - число каналов LAA, которые можно использовать как
//РАБОЧИЕ КАНАЛЫ AuxChRDEUnit
//****************************************************************************************
ulong TPreProcessorSpaceFilterBaseCh::GetFreeChForRDEUnit(ivector& RDECh) const
{ulong amount = AmountLAAChForRDEUnit();
 //Проверка на наличие "свободных" каналов
 if (amount == 0L) {RDECh.Resize(0L); return amount;}
 //-------------------------------------------------------------------------------
 //Формирование индексов "свободных" каналов LAA для использования в AuxChRDEUnit
 //-------------------------------------------------------------------------------
 RDECh.Resize(amount);
 ulong j = 0L;
 //Получение индексов ДОПОЛНИТЕЛЬНЫХ каналов фильтра
 ivector AuxCh = LAACh;
 if (BaseChannel.UsageBFC()) //Синтезированный ОСНОВНОЙ канал
 {for (ulong i = 0L; i < OutLAA->LAAElem(); i++)
  {if (!AuxCh.Find(i)) {RDECh.Put(j++,i); if (j == amount) break;}
  }
 }
 else //ОСНОВНОЙ КАНАЛ - не синтезированный
 {ulong BaseChIndex = BaseChannel.IndexLAACh(0);
  for (ulong i = 0L; i < OutLAA->LAAElem(); i++)
  {if ((!AuxCh.Find(i)) && (i != BaseChIndex))
   {RDECh.Put(j++,i); if (j == amount) break;}
  }
 }
return amount;
}
//******************************************************************************
//СТАТУС: II.7., private, TPreProcessorSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SetDirectElim(const rvector& Directs);
//НАЗНАЧЕНИЕ: Установка направлений исключения приема сигналов  вспомогательными
//каналами  пространственного  фильтра. Направления  исключения передаются через
//вектор Directs. Из одинаковых направления исключения остается только одно, все
//значения направлений исключения вне интервала [-90..+90] градусов исключаются.
//Если вектор Directs() - нулевого размера, то AuxChRDEUnit не используется пре-
//процессором пространственного фильтра. Возможное количество направлений исклю-
//чения ограничивается общим количеством  каналов LAA за  вычетом AuxCh и одного
//канала, если BaseChannel не формирует СИНТЕЗИРОВАННЫЙ основной канал.
//Функция возвращает true - при успешном задании направлений исключения и false,
//если AuxChRDEUnit не может быть использована. Условий при которых AuxChRDEUnit
//не может быть использована три:
//1) Directs == rvector() - направления исключения не заданы;
//2) DirectElim == rvector(). После присваивания Directs DirectElim и фильтрации
//   корректных значений направлений исключения, последних найдено не было;
//3) Свободных каналов LAA для их использования в AuxChRDEUnit в качестве
//   РАБОЧИХ КАНАЛОВ нет. Это возможно в случае, если все каналы LAA используют-
//   ся как ДОПОЛНИТЕЛЬНЫЕ каналы адаптивного пространственного фильтра и ОСНОВ-
//   НОЙ КАНАЛ не задействуется в AuxChRDEUnit.
//При  формировании вектора направлений исключения DirectElim возможна ситуация,
//когда  не все  корректные направления исключения из Directs могут быть внесены
//в  данный  вектор. Это  может произойти, когда максимальное число каналов LAA,
//которые  могут  быть задействованы  в качестве РАБОЧИХ КАНАЛОВ AuxChRDEUnit, с
//учетом ОСНОВНОГО КАНАЛА (при его подключении к AuxChRDEUnit), меньше количест-
//ва корректных  направлений  исключения. В этом случае "избыточные" направления
//исключения  исключаются из  вектора DirectElim последовательно слева и справа,
//пока их количество не станет равным максимальному числу направлений исключения,
//которые могут быть реализованы при такой конфигурации адаптивной LAA.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const rvector& Directs - ссылка на вектор с направле-
//ниями исключения приема сигналов ВСПОМОГАТЕЛЬНЫМИ каналами пространственного
//фильтра c ОСНОВНЫМ каналом.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - возможность подключения AuxChRDEUnit
//к адаптивной LAA
//******************************************************************************
bool TPreProcessorSpaceFilterBaseCh::SetDirectElim(const rvector& Directs)
{DirectElim = Directs;
 //AuxChRDEUnit не используется - направления исключения не заданы
 if (DirectElim.Size() == 0L) {ResetRDEUnit(); return false;}
 //Определение максимально возможного числа каналов, которые можно использовать
 //как РАБОЧИЕ КАНАЛЫ AuxChRDEUnit
 ulong Amount = AmountLAAChForRDEUnit();
 if (IsBaseChInRDEUnit()) Amount++;
 //Нет "свободных" каналов для AuxChRDEUnit
 if (Amount == 0L) {ResetRDEUnit(); return false;}
 //-----------------------------------------------------------------------------
 //Фильтрация корректных направлений исключения
 //-----------------------------------------------------------------------------
 //1. Исключение одинаковых значений из вектора DirectElim
 DirectElim = DirectElim.Unique();
 //2. Исключение направлений исключений вне интервала [-90..+90] градусов
 rvector param(2,COL); param[0] = -90.0; param[1] = 90.0;
 TBelongClosedInterval<double, rvector> Predicate(param);
 DirectElim = DirectElim.SubVector(Predicate);
 //Нет ни одного корректного направления исключения
 if (DirectElim.Size() == 0L) {ResetRDEUnit(); return false;}
 //Отбрасываем "избыточные" направления исключения при их наличии
 if (Amount < DirectElim.Size())
 {ulong Overage = DirectElim.Size()-Amount;
  ulong left = 0L, right = DirectElim.Size()-1L;
  bool lFlag = true;
  do {if (!lFlag) left++; else right--;} while (--Overage != 0L);
  DirectElim = DirectElim.SubVector(left,right);
 }
return true;
}
//****************************************************************************************
//СТАТУС: II.8., private, TPreProcessorSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong AutoDefineRDECh(ivector& RDECh) const
//НАЗНАЧЕНИЕ: Формирует индексы каналов LAA, которые могут использоваться в AuxChRDEUnit
//как рабочие с учетом использования BaseChannel и общего числа направлений исключения.
//Возвращает количество каналов LAA, подключаемых к AuxChRDEUnit в качестве рабочих. Индексы
//РАБОЧИХ КАНАЛОВ с LAA формируются в векторе RDECh, передаваемом по ссылке. Функция должна
//вызываться после вызова функции SetDirectElim(...), так как число направлений исключения,
//которые будет формировать данная схема, будет известно только после ее работы.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ivector& RDECh - ссылка на вектор, в котором будут формироваться
//индексы РАБОЧИХ КАНАЛОВ AuxChRDEUnit с LAA.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong Amount - число каналов LAA, используемые как рабочие каналы
//****************************************************************************************
ulong TPreProcessorSpaceFilterBaseCh::AutoDefineRDECh(ivector& RDECh) const
{ulong Amount = RDEChCount();
 if ((IsBaseChInRDEUnit()) && (Amount != 0L)) Amount--;
 //AuxChRDEUnit не используется или задано одно направление исключения и
 //AuxChRDEUnit использует ОСНОВНОЙ канал пространственного фильтра
 if (Amount == 0L) {RDECh.Resize(0L); return Amount;}
 //Определяем каналы LAA, которые можно использовать как РАБОЧИЕ КАНАЛЫ RDEUnit
 GetFreeChForRDEUnit(RDECh);
 RDECh = RDECh.SubVector(0,Amount-1);
 return Amount;
}
//******************************************************************************
//СТАТУС: II.9., private, TPreProcessorSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong SetRDECh(ivector& RDECh = ivector())
//НАЗНАЧЕНИЕ: Формирование рабочих каналов AuxChRDEUnit (при ее подключении к
//адаптивной LAA) на основе индексов каналов LAA, передаваемых вектором RDECh и
//учетом подключения к схеме ОСНОВНОГО КАНАЛА. Функция проверяет на корректность
//значения индексов каналов LAA в векторе RDECh и при необходимости модифицирует
//его содержимое и размеры с целью правильной работы AuxChRDECh. После этого
//вектор RDECh присоединяется к вектору LAACh (до этой операции LAACh содержит
//индексы каналов LAA, используемых как ДОПОЛНИТЕЛЬНЫЕ каналы пространственного
//адаптивного фильтра с ОСНОВНЫМ каналом) слева. В результате вектор LAACh будет
//содержать индексы каналов LAA, используемых как РАБОЧИЕ КАНАЛЫ AuxChRDEUnit
//(без ОСНОВНОГО канала при его использовании схемой) и как ДОПОЛНИТЕЛЬНЫЕ кана-
//лы Adaptive SpaceFilter with BaseCh.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ivector& RDECh - ссылка на вектор, с индексами каналов
//LAA, которые могут быть использованы как РАБОЧИЕ КАНАЛЫ AuxChRDEUnit.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong Amount - количество рабочих каналов AuxChRDEUnit
//******************************************************************************
ulong TPreProcessorSpaceFilterBaseCh::SetRDECh(ivector& RDECh)
{//AuxChRDEUnit не используется препроцессором
 if (!UsageRDEUnit()) return RDEChCount();
 //Проверка на необходимость подключения каналов LAA в качестве РАБОЧИХ каналов
 ulong Amount = RDEChCount();
 if (IsBaseChInRDEUnit()) Amount--;
 if (Amount == 0L) return RDEChCount();
 //-----------------------------------------------------------------------------
 //Установка РАБОЧИХ каналов AuxChRDEUnit c LAA
 //-----------------------------------------------------------------------------
 //a) RDECh - вектор нулевого размера
 if (RDECh.Size() == 0L)
 {AutoDefineRDECh(RDECh); LAACh = RDECh || LAACh; return RDEChCount();}
 //b) Фильтрация корректных значений индексов в RDECh
 RDECh = RDECh.Unique();//Исключение одинаковых значений из вектора RDECh
 //Получение множества каналов LAA, которые можно использовать как РАБОЧИЕ каналы
 ivector FreeCh; GetFreeChForRDEUnit(FreeCh);
 //Исключение некорректных индексов каналов из RDECh
 RDECh = RDECh && FreeCh;
 //Анализ RDECh на вектор нулевого размера
 if (RDECh.Size() == 0L)
 {AutoDefineRDECh(RDECh); LAACh = RDECh || LAACh; return RDEChCount();}
 //Проверка на соответствие количества каналов RDECh и направлений исключения
 if (RDECh.Size() > Amount) RDECh = RDECh.SubVector(0,Amount-1);
 else if (RDECh.Size() < Amount) //Добавляем каналы к RDECh
 {FreeCh = FreeCh ^ RDECh;
  FreeCh = FreeCh.SubVector(0,Amount-RDECh.Size()-1);
  RDECh = RDECh || FreeCh;
 }
 LAACh = RDECh || LAACh;
return RDEChCount();
}
//******************************************************************************
//СТАТУС: II.10., private, TPreProcessorSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: uint SetTypeRDEUnit(uint UnitType)
//НАЗНАЧЕНИЕ: Установка типа устройства компенсации приема сигналов с заданных
//направлений в дополнительных каналах адаптивного пространственного фильтра с
//BaseCh. Функция устанавливает два типа режекторных пространственных фильтра:
//MultiStageUnit или SingleStageUnit. При неверном задании типа фильтра устанав-
//ливается SingleStageUnit. Функция возвращает тип установленного AuxChRDEUnit.
//Данная функция всегда должна вызываться последней при установке параметров
//AuxChRDEUnit в случае его подключения к предпроцессору адаптивного пространст-
//венного фильтра.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//uint UnitType -  тип пространственного режекторного фильтра для дополнтитель-
//ных каналов АДАПТИВНОГО ПРОСТРАНСТВЕННОГО ФИЛЬТРА с BaseChannel.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint Type - установленный тип AuxChRDEUnit
//******************************************************************************
uint TPreProcessorSpaceFilterBaseCh::SetTypeRDEUnit(uint UnitType)
{if (!UsageRDEUnit()) return 0;//AuxChRDEUnit не используется препроцессором
 //Формирование "обучающей" матрицы L для расчета коэффициентов AuxChRDEUnit
 cmatrix L; TestSignal(L, DirectElim, OFF);
 //*****************************************************************************
 //Выбор типа AuxChRDEUnit и конструирование его исполнительного устройства
 //*****************************************************************************
 //Удаление прежнего режекторного фильтра
 if (RDEUnit != NULL) {delete RDEUnit; RDEUnit = NULL;}
 switch (UnitType)
 {case MultiStageUnit: //Выбор многоступенчатого режекторного фильтра
   RDEUnit = new TMultiStageAuxChSRF(L);//Конструирование фильтра
   break;
  case SingleStageUnit: //Выбор одноступенчатого режекторного фильтра
   RDEUnit = new TSingleStageAuxChSRF(L); //Конструирование фильтра
   break;
  default: //По умолчанию создается одноступенчатый режекторный фильтр
   RDEUnit = new TSingleStageAuxChSRF(L); //Конструирование фильтра
 }
return RDEUnit->Type();//Тип пространственного режекторного фильтра
}
//******************************************************************************
//СТАТУС: II.11; TPreProcessorSpaceFilterBaseCh class private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void PolarEdit()
//НАЗНАЧЕНИЕ: Ввод поляризационной составляющей входного воздействия, принимае-
//мой препроцессором AdaptiveLAA с ОСНОВНЫМ каналом. Формат ввода ПОЛЯРИЗАЦИИ:
//------------------------------------------------------------------------------
//Polarization: <Input polarization type>
// 1. Vertical polarization;
// 2. Horizontal polarization.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TPreProcessorSpaceFilterBaseCh::PolarEdit()
{//Рабочие переменные
 int choice, y_start = wherey(); char c;
 string s, title, line(78,'-');
 bool Polar, flag;
 STR_UINT ListPolarComponent[2] = {
  {VP_SIGNAL,  "Vertical polarization"  },
  {HP_SIGNAL,  "Horizontal polarization" } };
 TB_STR_UINT TbPolarComponent = {2, ListPolarComponent};
 string head =  " Choice polarizing component of input signal:";
 //----------------------------------------------------------------------------
 //Ввод поляризационной составляющей входного сигнала, поступающей на вход
 //адаптивного пространственного фильтра
 //----------------------------------------------------------------------------
 gotoxy(1,y_start); clreol();
 do
 {cout << line << endl;
  cout << "POLARIZATION: < Input polarization type >" << endl;
  choice = ConsoleChoice(TbPolarComponent, VP_SIGNAL, head.c_str(), 4);
  switch (choice)
  { case VP_SIGNAL: Polar = VP_SIGNAL; break;
    case HP_SIGNAL: Polar = HP_SIGNAL; break;
  }
  SetPolar(Polar);
  //Отображение результатов ввода поляризационной составляющей
  ClrScr(1,y_start);//Очистка экрана
  this->Polarization(s,title);
  cout << line << endl << s << line << endl;

  //----------------------------------------------------------------------------
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
 //Вывод результатов консольного ввода ПОЛЯРИЗАЦИОННОЙ СОСТАВЛЯЮЩЕЙ
 cout << s;
}
//******************************************************************************
//СТАТУС: II.12; TPreProcessorSpaceFilterBaseCh class private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void AuxChEdit()
//НАЗНАЧЕНИЕ: Ввод индексов каналов LAA, используемых как ВСПОМОГАТЕЛЬНЫЕ КАНАЛЫ
//пространственного фильтра через стандартный поток ввода cin (>>). Проверка на
//возможность ввода AuxChannel производится функцией Edit() данного класса.
//Перед вводом дополнительных каналов выводится информация о допустимом диапазо-
//не номеров каналов LAA, которые можно использовать как ВСПОМОГАТЕЛЬНЫЕ, коли-
//честве каналов не задействованных для формирования ОСНОВНОГО КАНАЛА и их индек-
//сах (до 15). Формат ввода ВСПОМОГАТЕЛЬНЫХ КАНАЛОВ:
//------------------------------------------------------------------------------
//AUXILIARY CHANNELs: <Input LAA channel indexes>
// Channel LAA: <LAA indexes interval can used by AuxChannel>
// Independent: <Count & Independent Channel Indexes (<= 15)>
// Input LAA indexes: ________________________________________
//------------------------------------------------------------------------------
//Введенные ВСПОМОГАТЕЛЬНЫЕ КАНАЛЫ заносятся в вектор LAACh. Функция использует-
//ся  функцией  Edit() для  установки новых параметров объекта через стандартный
//поток ввода cin.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TPreProcessorSpaceFilterBaseCh::AuxChEdit()
{ivector LAAChannel;
 //-----------------------------------------------------------------------------
 //1. Ввод индексов каналов LAA, подключаемых к Auxiliary Channels
 //-----------------------------------------------------------------------------
 //Рабочие переменные
 int y_start = wherey();
 char c;
 string s, line(78,'-');
 bool flag;
 char buffer[80];
 ostrstream text (buffer, sizeof(buffer));
 //-----------------------------------------------------------------------------
 //Формирование интервала каналов LAA, которые можно подключать к AuxChannel
 string interval;
 interval.append(" LAA Channels: ");
 ulong LastLAAElem = OutLAA->LAAElem()-1;
 if (BaseChannel.UsageBFC()) //Основной канал - синтезированный
  text << "[0.." << LastLAAElem << "]" << endl << ends;
 else //Основной канал - не синтезированный
 {ulong index = BaseChannel.IndexLAACh(0);
  if (index == 0)
   text << "[1.." << LastLAAElem << "]" << endl << ends;
  else if (index == LastLAAElem)
   text << "[0.." << (LastLAAElem-1) << "]" << endl << ends;
  else
   text << "[0.." << LastLAAElem << "], except " << index << endl << ends;
 }
 interval.append(text.str()); text.seekp(0);
 //-----------------------------------------------------------------------------
 //Формирование информации о независимых каналах LAA - каналы, которые не подклю-
 //чены к схеме формирования ОСНОВНОГО КАНАЛА
 string independent;
 //Формирование вектора индексов всех каналов LAA
 ivector LAAIndexes(LastLAAElem+1);
 for (ulong i = 0L; i < LAAIndexes.Size(); i++) LAAIndexes[i] = i;
 ivector IndepChannel = LAAIndexes ^ BaseChannel.Channels();
 independent.append(" Independent: ");
 text << IndepChannel.Size() << ends;
 independent.append(text.str()); text.seekp(0);
 text << " [" << IndepChannel.ConvertToString(s,15) << "]" << endl << ends;
 independent.append(text.str()); text.seekp(0);
 //-----------------------------------------------------------------------------
 gotoxy(1,y_start); clreol();
 do //Цикл ввода индексов каналов LAA
 {//----------------------------------------------------------------------------
  cout << line << endl;
  cout << "AUXILIARY CHANNELs: < Input LAA channel indexes >" << endl;
  cout << interval << independent;
  //Ввод строки индексов каналов LAA из стандартного потока ввода cin
  cout << "LAA indexes: "; cin.ignore(); getline(cin,s,'\n');
  LAAChannel.GetDataFromString(s,true);
  SetAuxCh(LAAChannel);
  //Отображение результатов ввода номеров каналов LAA, подключенных к AuxChannel
  ClrScr(1,y_start);//Очистка экрана
  cout << line << endl << AuxChProp(s,STR_NULL) << line << endl;
  //----------------------------------------------------------------------------
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
 //Вывод результатов консольного ввода индексов ВСПОМОГАТЕЛЬНЫХ КАНАЛОВ
 cout << s;
}
//****************************************************************************************
//СТАТУС: II.13; TPreProcessorSpaceFilterBaseCh class private member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void AuxChRDEUnitEdit();
//НАЗНАЧЕНИЕ: Ввод параметров схемы исключения направлений приема сигналов вспомогательными
//каналами пространственного фильтра через поток ввода cin (>>). Проверка на возможность
//ввода параметров производится функцией Edit() данного класса. Формат ввода параметров:
//----------------------------------------------------------------------------------------
//AuxChReceptDirectsElimination Unit: <Input parameters>
// Usage BaseChannel [y/n]: ____
// Elimination Directs [-90..+90 deg]: ____
// Channels [<amount>]: _____
// Unit Type: {Menu}
//----------------------------------------------------------------------------------------
//Если  направления  исключения не заданы или выходят из интервала от -90 до +90 градусов,
//то AuxChRDEUnit не используется предпроцессором. Функция используется функцией Edit() для
//установки новых параметров объекта через стандартный поток ввода cin.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TPreProcessorSpaceFilterBaseCh::AuxChRDEUnitEdit()
{rvector Directs;
 bool lUsage;
 //Рабочие переменные
 int y, y_start = wherey();
 char c;
 string s, t, line(78,'-');
 string sep(1,' '), etc("...");
 bool flag;
 gotoxy(1,y_start); clreol();
 do //Цикл ввода характеристик схемы исключения направлений приема сигналов
 {//----------------------------------------------------------------------------
  cout << line << endl;
  cout << "Space Rejection Filter for AuxCh: < Input parameters >" << endl;
  cout << line << endl;
  //----------------------------------------------------------------------------
  //Ввод опции использования ОСНОВНОГО канала в AuxChRDEUnit
  //----------------------------------------------------------------------------
  y = wherey();
  cout << "Usage BaseChannel [y/n]: "; cin >> c;
  lUsage = (c == 'Y' || c == 'y') ? ON : OFF; SetUsageBaseChInRDEUnit(lUsage);
  t = (lUsage) ? "< Yes >" : "< No >";
  ClrScr(1,y);//Очистка экрана
  cout << "Usage BaseChannel: " << t << endl;
  //----------------------------------------------------------------------------
  //Ввод направлений исключения приема сигналов вспомогательными каналами
  //пространственного фильтра
  //----------------------------------------------------------------------------
  y = wherey();
  cout << "Elimination Directs [-90..+90 deg]: ";
  cin.ignore(); getline(cin,s,'\n'); Directs.GetDataFromString(s,true);
  lUsage = SetDirectElim(Directs);
  if (lUsage)
  {//Вывод направлений исключения
   ClrScr(1,y);//Очистка экрана
   cout << "Directs: " << DirectElim.Size();
   cout << " [" << DirectElim.ConvertToString(t,sep,etc,15) << "]" << endl;
   //---------------------------------------------------------------------------
   //Ввод индексов рабочих каналов AuxChRDEUnit
   //---------------------------------------------------------------------------
   ivector RDECh;
   ulong amount = DirectElim.Size();//Необходимое число рабочих каналов
   if (IsBaseChInRDEUnit()) amount--;
   if (amount != 0L)
   {y = wherey();
    //Ввод строки индексов каналов LAA из стандартного потока ввода cin
    cout << "RDECh [" << amount << "]: "; getline(cin,s,'\n');
    RDECh.GetDataFromString(s,true);
    ClrScr(1,y);//Очистка экрана
   }
   SetRDECh(RDECh);//Установка рабочих каналов AuxChRDEUnit
   //Отображение результатов ввода номеров каналов LAA, подключенных к
   //AuxChRDEUnit в качестве рабочих
   GetRDECh(RDECh);
   cout << "Channels: " << RDEChCount() << " [" << RDECh.ConvertToString(t, 15) << "];"
        << endl;
   //---------------------------------------------------------------------------
   //Ввод cхемной реализации AuxChRDEUnit
   //---------------------------------------------------------------------------
   STR_UINT ListRDEUnit[2] = {
   {MultiStageUnit,  "MultiStage Unit"  },
   {SingleStageUnit,  "SingleStage Unit" } };
   TB_STR_UINT TbRDEUnit = {2, ListRDEUnit};
   string head =  " Choice AuxChRDEUnit type:";
   uint UnitType = ConsoleChoice(TbRDEUnit, SingleStageUnit, head.c_str(), 4);
   cout << "Wait..." << endl;
   SetTypeRDEUnit(UnitType);
  }
  //Отображение результатов ввода параметров AuxChRDEUnit
  ClrScr(1,y_start);//Очистка экрана
  cout << line << endl << RDEUnitProp(s,STR_NULL) << line << endl;
  //----------------------------------------------------------------------------
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
 //Вывод результатов консольного ввода индексов ВСПОМОГАТЕЛЬНЫХ КАНАЛОВ
 cout << s;
}
//==============================================================================
//III. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TPreProcessorSpaceFilterBaseCh
//     PROTECTED MEMBER-FUNCTION OF TPreProcessorSpaceFilterBaseCh CLASS
//==============================================================================
//******************************************************************************
//СТАТУС: III.1.,protected,TPreProcessorSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Reset();
//НАЗНАЧЕНИЕ: Сброс  параметров предпроцессора обработки входного сигнала прост-
//ранственного адаптивного фильтра с выделенным каналом при разрушении объекта
//данного класса или изменении его характеристик. Установка характеристик:
//------------------------------------------------------------------------------
//I. СХЕМА ФОРМИРОВАНИЯ ОСНОВНОГО (ВЫДЕЛЕННОГО) КАНАЛА - BaseChannel
// 1. ivector Channel - вектор нулевого размера;
// 2. double ScanAngle = 0 [deg];
// 3. cvector B - вектор нулевого размера;
// 4. InSignal* OutLAA = NULL;
//II. ВСПОМОГАТЕЛЬНЫЕ КАНАЛЫ ФИЛЬТРА (AuxChannel) и РАБОЧИЕ КАНАЛЫ AuxChRDEUnit
//    (при ее использовании) с LAA
// 1. ivector LAACh - вектор нулевого размера;
//III. ПАРАМЕТРЫ СХЕМЫ ИСКЛЮЧЕНИЯ НАПРАВЛЕНИЙ ПРИЕМА ДОПОЛНИТЕЛЬНЫМИ КАНАЛАМИ
// 1. rvector DirectElim - вектор нулевого размера;
// 2. lBaseChInRDEUnit = OFF;
// 3. TAuxChSpaceRejectFilter* RDEUnit = NULL;
//IV. ВХОДНОЙ СИГНАЛ С КАНАЛОВ LAA, К КОТОРЫМ ПОДКЛЮЧЕН ФИЛЬТР
// 1. TInputSignal* OutLAA = NULL;
// 2. bool PolarType = VP_SIGNAL;
// 3. cvector Signal - вектор нулевого размера;
// 4. cvector Noise  - вектор нулевого размера;
// 5. cmatrix\cvector Jammer - матрица\вектор нулевого размера;
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TPreProcessorSpaceFilterBaseCh::Reset()
{//Начальная установка всех параметров предпроцессора
 BaseChannel = TBaseChannel();
 LAACh = ivector();
 ResetRDEUnit();//Начальная установка характеристик AuxChRDEUnit
 OutLAA = NULL;//"Отключение" предпроцессора от LAA
 PolarType = VP_SIGNAL;
}
//********* Конец реализации класса TPreProcessorSpaceFilterBaseCh *************

//******************************************************************************
//               РЕАЛИЗАЦИЯ КЛАССА TAnalPreProcSFilterBaseCh
//Аналитическая  модель предпроцессора обработки входного сигнала пространствен-
//ного адаптивного фильтра с выделенным каналом на основе LAA.
//******************************************************************************
//------------------------------------------------------------------------------
//   ФУНКЦИИ, ИСПОЛЬЗУЕМЫЕ ПРИ МОДЕЛИРОВАНИИ ПРЕПРОЦЕССОРА АДАПТИВНОЙ LAA
//           c ПРОСТРАНСТВЕННЫМ АДАПТИВНЫМ ФИЛЬТРОМ с ОСНОВНЫМ КАНАЛОМ
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1., public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool Update(bool lSignal = ON, bool lJammer = ON, bool lNoise = ON)
//НАЗНАЧЕНИЕ: Расчет компонент внешнего воздействия (полезного сигнала, аддитив-
//ной помехи и внутреннего шума) на входе предпроцессора адаптивного пространст-
//венного  фильтра с ОСНОВНЫМ каналом на основе LAA. Обновление компонент произ-
//водится, в том случае, если  опция для соответсвующей компоненты входного сиг-
//нала установлена (ON). При аналитическом моделировании данные опции позволяют
//ускорить вычисления, так как для стационарной компоненты входного воздействия
//(как правило для АДДИТИВНОЙ ПОМЕХИ и ВНУТРЕННЕГО ШУМА) нет необходимости пере-
//считывать данные для каждого шага моделирования, за исключением первого шага
//(Time == 0). По умолчанию, все компоненты входного воздействия обновляются.
//Функция возвращает false, если ПРЕДПРОЦЕССОР неработоспособен.
//Функция корректно работает только при моделировании, когда InSignal изменяется
//в процессе моделирования.
//Для ускорения работы функции, она непосредственно обращается к членам-данным
//объекта класса InSignal, где хранятся мгновенные комплексные значения напряже-
//ний на выходах приемных каналов LAA с поляризацией заданного вида.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//bool lSignal (ON) - опция расчета ПОЛЕЗНОГО СИГНАЛА;
//bool lJammer (ON) - опция расчета АДДИТИВНОЙ ПОМЕХИ;
//bool lNoise  (ON) - опция расчета ВНУТРЕННЕГО ШУМА.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
bool TAnalPreProcSFilterBaseCh::Update(bool lSignal, bool lJammer, bool lNoise)
{//Проверка работоспособности предпроцессора
 if (!IsReady()) return false;
 //-----------------------------------------------------------------------------
 //Расчет компонент входного воздействия на входе предпроцессора
 //-----------------------------------------------------------------------------
 //1. Расчет ПОЛЕЗНОГО СИГНАЛА на входе предпроцессора
 //-----------------------------------------------------------------------------
 if (lSignal == ON)
 {const cvector* Polar =
  (Polarization() == VP_SIGNAL) ? OutLAA->GetVPSignal() : OutLAA->GetHPSignal();
  ulong First = (IsBaseChInRDEUnit()) ? 1L : 0L;
  ulong Last = Signal.Size()-1;
  ulong OffSet = (IsBaseChInRDEUnit()) ? 1L : 0L;
  //Формирование вектора ПОЛЕЗНОГО СИГНАЛА
  for (ulong i = First; i < Last; i++)
   Signal.Put(i,Polar->Get(LAACh.Get(i-OffSet)));
  complex Ubase = BaseChannel.CalcSignal(Polarization());
  Signal.Put(Last,Ubase);
  //AuxChRDEUnit подключено к предпроцессору и ОСНОВНОЙ канал используется как
  //РАБОЧИЙ канал RDEUnit
  if (IsBaseChInRDEUnit()) Signal.Put(0,Ubase);
 }
 //-----------------------------------------------------------------------------
 //2. Расчет АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ на входе предпроцессора
 //-----------------------------------------------------------------------------
 if (lJammer == ON)
 {const cmatrix* Polar =
  (Polarization() == VP_SIGNAL) ? OutLAA->GetVPJammer() : OutLAA->GetHPJammer();
  ulong First = (IsBaseChInRDEUnit()) ? 1L : 0L;
  ulong Last = Jammer.Rows()-1;
  ulong OffSet = (IsBaseChInRDEUnit()) ? 1L : 0L;
  ulong index;
  //-----------------------------------------------------------------------------
  //Формирование матрицы компонент АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ для каналов LAA,
  //подключенных к пространственному фильтру
  for (ulong i = First; i < Last; i++) //По каналам LAA
  {index = LAACh.Get(i-OffSet);//Номер канала LAA, подключенного к фильтру
   for (ulong j = 0L; j < Jammer.Cols(); j++) //По компонентам активной помехи
    Jammer.Put(i,j,Polar->Get(index,j));
  }
  //Формирование вектора компонент АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ с ОСНОВНОГО КАНАЛА
  //пространственного фильтра
  cvector Jams;
  BaseChannel.CalcJammers(Jams, Polarization());
  //Копирование значений компонент АКТИВНОЙ ПОМЕХИ с ОСНОВНОГО канала в матрицу
  //Jammer
  for (ulong j = 0L; j < Jammer.Cols(); j++) Jammer.Put(Last,j,Jams.Get(j));
  //AuxChRDEUnit подключено к предпроцессору и ОСНОВНОЙ канал используется как
  //РАБОЧИЙ канал RDEUnit
  if (IsBaseChInRDEUnit())
   for (ulong j = 0L; j < Jammer.Cols(); j++) Jammer.Put(0L,j,Jams.Get(j));
 }
 //-----------------------------------------------------------------------------
 //3. Расчет ВНУТРЕННЕГО ШУМА на входе предпроцессора
 //-----------------------------------------------------------------------------
 if (lNoise == ON)
 {const cvector* Polar =
  (Polarization() == VP_SIGNAL) ? OutLAA->GetVPNoise() : OutLAA->GetHPNoise();
  ulong First = (IsBaseChInRDEUnit()) ? 1L : 0L;
  ulong Last = Noise.Size()-1;
  ulong OffSet = (IsBaseChInRDEUnit()) ? 1L : 0L;
  //Формирование вектора ВНУТРЕННЕГО ШУМА
  for (ulong i = First; i < Last; i++)
   Noise.Put(i,Polar->Get(LAACh.Get(i-OffSet)));
  complex Ubase = BaseChannel.CalcNoise(Polarization());
  Noise.Put(Last,Ubase);
  //AuxChRDEUnit подключено к предпроцессору и ОСНОВНОЙ канал используется как
  //РАБОЧИЙ канал RDEUnit
  if (IsBaseChInRDEUnit()) Noise.Put(0,Ubase);
 }
return true;
}
//******************************************************************************
//СТАТУС: I.2., public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector& InSignal(cvector& U, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование  вектора напряжений ПОЛЕЗНОГО СИГНАЛА на входах пред-
//процессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор напряжений полезного сигнала формируется в векторе U, пе-
//редаваемый в данную функцию по ссылке. Функция использует вектор Signal.
//Опция lExtend указывает на включение в вектор U напряжения полезного сигнала
//на входе ОСНОВНОГО канала (при lExtend == ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& U - ссылка на вектор, в котором формируется выборка полезного сиг-
//   нала на входах предпроцессора AdaptLAA (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор U значения полезного сигнала
//   на входе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector& U - ссылка на выборку полезного сигнала на
//входах предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
cvector& TAnalPreProcSFilterBaseCh::InSignal(cvector& U, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {U.Resize(0L); return U;}
 //----------------------------------------------------------------------------
 //Формирование входного вектора ПОЛЕЗНОГО СИГНАЛА
 //----------------------------------------------------------------------------
 //Формирование вектора U необходимого размера
 ulong size = (lExtend == ON) ? Signal.Size() : Signal.Size()-1;
 U.Resize(size);
 //Цикл формирования значений элементов вектора U
 for (ulong i = 0L; i < size; i++) U.Put(i,Signal.Get(i));
return U;
}
//******************************************************************************
//СТАТУС: I.3., public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix& InJammer(cmatrix& A, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование матрицы напряжений АДДИТИВНОЙ ПОМЕХИ на входах пред-
//процессора (до поступления сигнала в AuxChRDEUnit при ее использовании) для
//каждой компоненты помехи.
//Если предпроцессор не активен (IsReady() == OFF), то возвращается матрица нуле-
//вого размера. Покомпонентная  матрица напряжений аддитивной помехи формируется
//в матрице A, передаваемая в функцию по ссылке. Функция использует матрицу
//Jammer.
//Опция lExtend указывает на включение в матрицу A значений аддитивной помехи на
//входе ОСНОВНОГО канала (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& A - ссылка на матрицу, в которой формируется значения аддитивной
//   помехи на входах предпроцессора AdaptLAA (до схемы AuxChRDEUnit) для каждой
//   компоненты помехи;
//2. bool lExtend (ON) - опция включения в матрицу A значений аддитивной помехи
//   на входе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix& A - ссылка на матрицу значений  аддитивной по-
//мехи на входе предпроцессора (до схемы AuxChRDEUnit) для каждой ее компоненты.
//*****************************************************************************
cmatrix& TAnalPreProcSFilterBaseCh::InJammer(cmatrix& A, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {A.Set(0L,0L,false); return A;}
 //-----------------------------------------------------------------------------
 //Формирование входного матрицы АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ (покомпонентно)
 //-----------------------------------------------------------------------------
 //Формирование матрицы A необходимого размера
 ulong rows = (lExtend == ON) ? Jammer.Rows() : Jammer.Rows()-1;
 A.Set(rows,Jammer.Cols(),C_ZERO);
 //Цикл формирования значений элементов матрицы A
 for (ulong i = 0L; i < rows; i++)
  for (ulong k = 0L; k < Jammer.Cols(); k++)//Цикл по компонентам АКТИВНОЙ ПОМЕХИ
   A.Put(i,k,Jammer.Get(i,k));
return A;
}
//******************************************************************************
//СТАТУС: I.4., public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector& InNoise(cvector& U, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора напряжений ВНУТРЕННЕГО ШУМА на входах
//предпроцессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор значений внутреннего шума  формируется в векторе U, пере-
//даваемый в функцию по ссылке. Функция использует вектор Noise.
//Опция lExtend указывает на включение в вектор U значения внутреннего шума на
//входе ОСНОВНОГО канала (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& U - ссылка на вектор, в котором формируется выборка внутреннего
//   шума для входов предпроцессора AdaptLAA (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор U значения внутреннего шума
//   на входе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector& U - ссылка на вектор значений внутреннего шума
//на входах предпроцессора (до схемы AuxChRDEUnit).
//******************************************************************************
cvector& TAnalPreProcSFilterBaseCh::InNoise(cvector& U, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {U.Resize(0L); return U;}
 //-----------------------------------------------------------------------------
 //Формирование входного вектора ВНУТРЕННЕГО ШУМА
 //-----------------------------------------------------------------------------
 //Формирование вектора U необходимого размера
 ulong size = (lExtend == ON) ? Noise.Size() : Noise.Size()-1;
 U.Resize(size);
 //Цикл формирования значений элементов вектора U
 for (ulong i = 0L; i < size; i++) U.Put(i,Noise.Get(i));
return U;
}
//******************************************************************************
//СТАТУС: I.5., public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:cvector& OutSignal(cvector& Uout, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора напряжений ПОЛЕЗНОГО СИГНАЛА на выходах пред-
//процессора (после AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор напряжений полезного сигнала формируется в векторе Uout,
//передаваемый в данную функцию по ссылке. Функция использует вектор Signal.
//Опция lExtend указывает на включение в вектор Uout напряжения полезного сигна-
//ла на выходе ОСНОВНОГО канала (при lExtend == ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& Uout - ссылка на вектор, в котором формируется выборка полезного
//   сигнала на выходах предпроцессора AdaptLAA (после схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор Uout значения полезного сигнала
//   на выходе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector& Uout - ссылка на выборку полезного сигнала на
//выходах предпроцессора (после схемы AuxChRDEUnit).
//*****************************************************************************
cvector& TAnalPreProcSFilterBaseCh::OutSignal(cvector& Uout, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {Uout.Resize(0L); return Uout;}
 //----------------------------------------------------------------------------
 //Формирование выходного вектора ПОЛЕЗНОГО СИГНАЛА
 //----------------------------------------------------------------------------
 if (UsageRDEUnit() == ON) //AuxChRDEUnit используется предпроцессором
 {RDEUnit->TFunc(Signal,Uout);
  if (lExtend == OFF) //Основной канал не включать
   Uout.Resize(Uout.Size()-1,ON);
 }
 else InSignal(Uout,lExtend); //AuxChRDEUnit не используется предпроцессором
return Uout;
}
//******************************************************************************
//СТАТУС: I.6., public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:cmatrix& OutJammer(cmatrix& Aout, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование матрицы напряжений АДДИТИВНОЙ ПОМЕХИ на выходах пред-
//процессора (после AuxChRDEUnit при ее использовании) для каждой компоненты
//помехи.
//Если предпроцессор не активен (IsReady() == OFF), то возвращается матрица нуле-
//вого размера. Покомпонентная  матрица напряжений аддитивной помехи формируется
//в матрице Aout, передаваемая в функцию по ссылке. Функция  использует  матрицу
//Jammer.
//Опция lExtend указывает на включение в матрицу Aout значений аддитивной помехи
//на выходе ОСНОВНОГО канала (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& Aout - ссылка на матрицу, в которой формируются значения аддитивной
//   помехи на входах предпроцессора AdaptLAA (после AuxChRDEUnit) для каждой
//   компоненты помехи;
//2. bool lExtend (ON) - опция  включения в матрицу Aout значений аддитивной по-
//   мехи на входе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix& Aout - ссылка на матрицу значений аддитивной
//помехи на выходе предпроцессора (после AuxChRDEUnit) для каждой ее компоненты.
//*****************************************************************************
cmatrix& TAnalPreProcSFilterBaseCh::OutJammer(cmatrix& Aout, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {Aout.Set(0L,0L,false); return Aout;}
 //----------------------------------------------------------------------------
 //Формирование выходной матрицы АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ (покомпонентно)
 //----------------------------------------------------------------------------
 if (UsageRDEUnit() == ON) //AuxChRDEUnit используется предпроцессором
 {//Формирование матрицы A необходимого размера
  cvector Uin(Jammer.Rows(),COL);
  cvector Uout;
  ulong rows = (lExtend == ON) ? Out() : Out()-1;
  Aout.Set(rows,Jammer.Cols(),C_ZERO);
  //Цикл формирования значений элементов матрицы Aout
  for (ulong k = 0L; k < Jammer.Cols(); k++)//Цикл по компонентам АКТИВНОЙ ПОМЕХИ
  {for (ulong i = 0L; i < Jammer.Rows(); i++) Uin.Put(i,Jammer.Get(i,k));
   RDEUnit->TFunc(Uin,Uout);
   for (ulong i = 0L; i < Aout.Rows(); i++) Aout.Put(i,k,Uout.Get(i));
  }
 }
 else InJammer(Aout,lExtend);//AuxChRDEUnit не используется предпроцессором
return Aout;
}
//******************************************************************************
//СТАТУС: I.7., public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double InPsignal() const
//НАЗНАЧЕНИЕ: Формирование мощности ПОЛЕЗНОГО СИГНАЛА на входе ОСНОВНОГО канала
//предпроцессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Для вычислений используется вектор Signal.
//Если предпроцессор не активен (IsReady() == OFF), то возвращается 0.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: P - мощность полезного сигнала на входе ОСНОВНОГО кана-
//ла предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
double TAnalPreProcSFilterBaseCh::InPsignal() const
{double P = 0;
 if (!IsReady()) return P;//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 //----------------------------------------------------------------------------
 //Определение мощности ПОЛЕЗНОГО СИГНАЛА на входе ОСНОВНОГО канала
 //предпроцессора (до схемы AuxChRDEUnit)
 //----------------------------------------------------------------------------
 ulong Last = Signal.Size()-1;
 P = norm(Signal.Get(Last));
return P;
}
//******************************************************************************
//СТАТУС: I.8., public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double InPjammer() const
//НАЗНАЧЕНИЕ: Формирование мощности АДДИТИВНОЙ ПОМЕХИ на входе ОСНОВНОГО канала
//предпроцессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Для вычислений используется матрица Jammer.
//Если предпроцессор не активен (IsReady() == OFF), то возвращается 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: P - мощность аддитивной помехи на входе ОСНОВНОГО кана-
//ла предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
double TAnalPreProcSFilterBaseCh::InPjammer() const
{double P = 0;
 if (!IsReady()) return P;//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 //----------------------------------------------------------------------------
 //Определение мощности АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ на входе ОСНОВНОГО канала
 //предпроцессора (до схемы AuxChRDEUnit)
 //----------------------------------------------------------------------------
 ulong Last = Jammer.Rows()-1;
 //Цикл расчета аддитивной активной помехи P
 for (ulong k = 0L; k < Jammer.Cols(); k++)//Цикл по компонентам АКТИВНОЙ ПОМЕХИ
  P += norm(Jammer.Get(Last,k));
return P;
}
//******************************************************************************
//СТАТУС: I.9., public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double InPnoise() const
//НАЗНАЧЕНИЕ: Формирование мощности ВНУТРЕННЕГО ШУМА на входе ОСНОВНОГО канала
//предпроцессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Для вычислений используется вектор Noise.
//Если предпроцессор не активен (IsReady() == OFF), то возвращается 0.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double P - мощность внутреннего шума на входе ОСНОВНОГО
//канала предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
double TAnalPreProcSFilterBaseCh::InPnoise() const
{double P = 0;
 if (!IsReady()) return P; //Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 //----------------------------------------------------------------------------
 //Определение мощности ВНУТРЕННЕГО ШУМА на входе ОСНОВНОГО канала
 //предпроцессора (до схемы AuxChRDEUnit)
 //----------------------------------------------------------------------------
 ulong Last = Noise.Size()-1;
 P = norm(Noise.Get(Last));
return P;
}
//******************************************************************************
//СТАТУС: I.10., public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& InPsignal(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ПОЛЕЗНОГО СИГНАЛА на входах предпро-
//цессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор мощности полезного сигнала формируется в векторе P, пере-
//даваемый в данную функцию по ссылке. Для вычислений используется вектор Signal.
//Опция lExtend указывает на включение в вектор P мощности полезного сигнала на
//входе ОСНОВНОГО канала (при lExtend == ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор, в котором формируется мощность полезного сиг-
//   нала на входах предпроцессора AdaptLAA (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор P мощности полезного сигнала
//   на входе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей полезного сиг-
//нала на входах предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
rvector& TAnalPreProcSFilterBaseCh::InPsignal(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {P.Resize(0L); return P;}
 //----------------------------------------------------------------------------
 //Формирование входного вектора мощности ПОЛЕЗНОГО СИГНАЛА
 //----------------------------------------------------------------------------
 //Формирование вектора P необходимого размера
 ulong Size = (lExtend == ON) ? Signal.Size() : Signal.Size()-1;
 P.Resize(Size);
 //Цикл формирования значений элементов вектора P
 for (ulong i = 0L; i < Size; i++) P.Put(i,norm(Signal.Get(i)));
return P;
}
//******************************************************************************
//СТАТУС: I.11., public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& InPjammer(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности АДДИТИВНОЙ ПОМЕХИ на входах предпро-
//цессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор мощности аддитивной помехи формируется в векторе P, пере-
//даваемый в данную функцию по ссылке. Для вычислений используется матрица Jammer.
//Опция lExtend указывает на включение в вектор P мощности аддитивной помехи на
//входе ОСНОВНОГО канала (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор, в котором формируется мощность аддитивной
//   помехи на входах предпроцессора AdaptLAA (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор P мощности аддитивной помехи
//   на входе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей аддитивной по-
//мехи на входе предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
rvector& TAnalPreProcSFilterBaseCh::InPjammer(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {P.Resize(0L); return P;}
 //----------------------------------------------------------------------------
 //Формирование входного вектора мощности АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ
 //----------------------------------------------------------------------------
 //Формирование вектора P необходимого размера
 ulong Size = (lExtend == ON) ? Jammer.Rows() : Jammer.Rows()-1;
 P.Resize(Size);
 //Цикл расчета значений элементов вектора P
 P = 0;//Обнуление элементов вектора
 for (ulong i = 0L; i < Size; i++)
  for (ulong k = 0L; k < Jammer.Cols(); k++)//Цикл по компонентам АКТИВНОЙ ПОМЕХИ
   P.Put(i,P.Get(i)+norm(Jammer.Get(i,k)));
return P;
}
//******************************************************************************
//СТАТУС: I.12., public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& InPnoise(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ВНУТРЕННЕГО ШУМА на входах предпроцес-
//сора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор мощности внутреннего шума  формируется в векторе P, пере-
//даваемый в данную функцию по ссылке. Для вычислений используется вектор Noise.
//Опция lExtend указывает на включение в вектор P мощности внутреннего шума на
//входе ОСНОВНОГО канала (при lExtend == ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка  на вектор, в  котором формируется мощность внутреннего
//   шума для входов предпроцессора AdaptLAA (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор P мощности внутреннего шума
//   на входе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей внутреннего
//шума на входах предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
rvector& TAnalPreProcSFilterBaseCh::InPnoise(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {P.Resize(0L); return P;}
 //----------------------------------------------------------------------------
 //Формирование входного вектора мощности ВНУТРЕННЕГО ШУМА
 //----------------------------------------------------------------------------
 //Формирование вектора P необходимого размера
 ulong Size = (lExtend == ON) ? Noise.Size() : Noise.Size()-1;
 P.Resize(Size);
 //Используем вектор Noise
 //Цикл расчета значений элементов вектора P
 for (ulong i = 0L; i < Size; i++) P.Put(i,norm(Noise.Get(i)));
return P;
}
//******************************************************************************
//СТАТУС: I.13., public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& OutPsignal(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ПОЛЕЗНОГО СИГНАЛА на выходах предпро-
//цессора (после схемы AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор мощности полезного сигнала формируется в векторе P, пере-
//даваемый в данную функцию по ссылке. Функция использует вызов OutSignal(...).
//Опция lExtend указывает на включение в вектор P мощности полезного сигнала на
//выходе ОСНОВНОГО канала (при lExtend == ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор, в котором формируется мощность полезного сиг-
//   нала на выходах предпроцессора AdaptLAA (после схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор P мощности полезного сигнала
//   на выходе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей полезного сиг-
//нала на выходах предпроцессора (после схемы AuxChRDEUnit).
//*****************************************************************************
rvector& TAnalPreProcSFilterBaseCh::OutPsignal(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {P.Resize(0L); return P;}
 //----------------------------------------------------------------------------
 //Формирование выходного вектора мощности ПОЛЕЗНОГО СИГНАЛА
 //----------------------------------------------------------------------------
 cvector Uout; OutSignal(Uout,lExtend);
 //Формирование вектора P необходимого размера
 P.Resize(Uout.Size());
 //Цикл формирования значений элементов вектора P
 for (ulong i = 0L; i < P.Size(); i++) P.Put(i,norm(Uout.Get(i)));
return P;
}
//******************************************************************************
//СТАТУС: I.14., public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& OutPjammer(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности АДДИТИВНОЙ ПОМЕХИ на выходах предпро-
//цессора (после схемы AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор мощности аддитивной помехи формируется в векторе P, пере-
//даваемый в данную функцию по ссылке. Функция использует вызов OutJammer(...).
//Опция lExtend указывает на включение в вектор P мощности аддитивной помехи на
//выходе ОСНОВНОГО канала (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор, в котором формируется мощность аддитивной
//   помехи на выходах предпроцессора AdaptLAA (после схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор P мощности аддитивной помехи
//   на выходе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей аддитивной по-
//мехи на выходе предпроцессора (после схемы AuxChRDEUnit).
//*****************************************************************************
rvector& TAnalPreProcSFilterBaseCh::OutPjammer(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {P.Resize(0L); return P;}
 //----------------------------------------------------------------------------
 //Формирование выходного вектора мощности АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ
 //----------------------------------------------------------------------------
 cmatrix Uout; OutJammer(Uout,lExtend);
 //Формирование вектора P необходимого размера
 P.Resize(Uout.Rows());
 //Цикл расчета значений элементов вектора P
 P = 0;//Обнуление элементов вектора
 for (ulong i = 0L; i < Uout.Rows(); i++)
  for (ulong k = 0L; k < Uout.Cols(); k++)//Цикл по компонентам АКТИВНОЙ ПОМЕХИ
   P.Put(i,P.Get(i)+norm(Uout.Get(i,k)));
return P;
}
//******************************************************************************
//СТАТУС: I.15., public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& OutPnoise(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ВНУТРЕННЕГО ШУМА на выходах предпро-
//цессора (после схемы AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор мощности внутреннего шума  формируется в векторе P, пере-
//даваемый в данную функцию по ссылке. Функция использует вызов OutNoise(...).
//Опция lExtend указывает на включение в вектор P мощности внутреннего шума на
//выходе ОСНОВНОГО канала (при lExtend == ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка  на вектор, в  котором формируется мощность внутреннего
//   шума для выходов предпроцессора AdaptLAA (после схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор P мощности внутреннего шума
//   на выходе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей внутреннего
//шума на выходах предпроцессора (после схемы AuxChRDEUnit).
//*****************************************************************************
rvector& TAnalPreProcSFilterBaseCh::OutPnoise(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {P.Resize(0L); return P;}
 //----------------------------------------------------------------------------
 //Формирование выходного вектора мощности ВНУТРЕННЕГО ШУМА
 //----------------------------------------------------------------------------
 cmatrix Uout; GetOutRnn(Uout,lExtend);
 //Формирование вектора P необходимого размера
 P.Resize(Uout.Rows());
 //Цикл расчета значений элементов вектора P
 for (ulong i = 0L; i < P.Size(); i++) P.Put(i,norm(Uout.Get(i,i)));
return P;
}
//******************************************************************************
//СТАТУС: I.16.,public,TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix& GetInRss(cmatrix& R, bool lExtend = ON) const;
//НАЗНАЧЕНИЕ: Формирование  корреляционной  матрицы  ПОЛЕЗНОГО СИГНАЛА  на входе
//предпроцессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается  матрица ну-
//левого размера. Данная корреляционная матрица формируется в матрице R, переда-
//ваемой в данную функцию по ссылке. Функция использует вектор Signal.
//Опция lExtend указывает на включение в матрицу R корреляционных отношений меж-
//ду ОСНОВНЫМ и другими каналами предпроцессора (при lExtend == ON).
//АЛГОРИТМ расчета  входной корреляционной матрицы полезного сигнала между ВСЕМИ
//каналами  LAA, включая  ОСНОВНОЙ  КАНАЛ, которые  подключены  к предпроцессору
//пространственного адаптивного фильтра с выделенным каналом. Rss является ЭРМИ-
//ТОВОЙ матрицей. Элементы корреляционной матрицы расчитываются по формуле:
// Rss(i,j) = Ui * conj[Uj] = Fi(angle)*Fj(angle)*Ps*EXP(jDELTA(i,j)), где
//1. i, j - номера каналов адаптивной антенной решетки;
//2. Rss(i,j) - коэффициент корреляции полезного сигнала между i-ым и j-ым каналами;
//3. angle - пространственное положение источника полезного сигнала (по азимуту
//   либо углу места в зависимости от расположения LAA);
//4. Fi(angle), Fj(angle) - значение диаграммы направленности i-го (j-го) элемен-
//   та LAA в направлении на угол angle;
//5. Ps - мощность полезного сигнала;
//6. DELTA(i,j) = 2*PI*(Li - Lj)*sin(angle) - фазовый набег (расстояние) между
//   i-ым и j-ым элементами LAA.
//7. Li, Lj - относительное расстояние между i-ым (j-ым) и нулевым элементами LAA.
//Если адаптивная LAA имеет СИНТЕЗИРОВАННЫЙ ОСНОВНОЙ КАНАЛ, то считается что он
//пространственно совпадает с нулевым элементом антенной решетки.
//Все диагональные элементы матрицы Rss являются ВЕЩЕСТВЕННЫМИ ВЕЛИЧИНАМИ, так
//DELTA(i,i) = 0. Элементы матрицы Rss(i,j) & Rss(j,i) являются комплексно-сопря-
//женными, так как DELTA(i,j) = -DELTA(j,i).
//   Корреляционная  матрица полезного сигнала получается путем умножения векто-
//ра-столбца  напряжений  Us на  каналах адаптивной LAA, подключенных к весовому
//параллельно-последовательному сумматору на транспонированно-сопряженный вектор
//к вектору Us.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет формироваться входная
//   корреляционная матрица полезного сигнала (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в матрицу R корреляционных отношений
//   между ОСНОВНЫМ и другими каналами предпроцессора.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix& R - ссылка на сформированную корреляционную
//матрицу полезного сигнала на входе предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
cmatrix& TAnalPreProcSFilterBaseCh::GetInRss(cmatrix& R, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {R.Set(0L,0L,false); return R;}
 //----------------------------------------------------------------------------
 //Формирование входной корреляционной матрицы ПОЛЕЗНОГО СИГНАЛА
 //----------------------------------------------------------------------------
 //Формирование матрицы R необходимой размерности
 ulong size = (lExtend == ON) ? Signal.Size() : Signal.Size()-1;
 R.Set(size,size,C_ZERO);
 //Цикл расчета диагональных и наддиагональных элементов R
 for (ulong i = 0L; i < R.Rows(); i++)
  for (ulong j = i; j < R.Cols(); j++)
  {if (i == j) R.Put(i,j,norm(Signal.Get(i)));
   else R.Put(i,j,Signal.Get(i)*conj(Signal.Get(j)));
  }
 //Цикл расчета поддиагональных элементов R
 for (ulong i = 1L; i < R.Rows(); i++)
  for (ulong j = 0L; j < i; j++)
   R.Put(i,j,conj(R.Get(j,i)));
return R;
}
//******************************************************************************
//СТАТУС: I.17,public,TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix& GetInRjj(cmatrix& R, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование  корреляционной  матрицы  АДДИТИВНОЙ ПОМЕХИ  на входе
//предпроцессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается  матрица ну-
//левого размера. Данная корреляционная матрица формируется в матрице R, переда-
//ваемой в данную функцию по ссылке. Функция использует матрицу Jammer.
//Опция lExtend указывает на включение в матрицу R корреляционных отношений меж-
//ду ОСНОВНЫМ и другими каналами предпроцессора (при lExtend == ON).
//АЛГОРИТМ расчета входной корреляционной матрицы аддитивной помехи между ВСЕМИ
//каналами LAA, подключенными к адаптивному  фильтру, включая ОСНОВНОЙ КАНАЛ.
//Rjj - ЭРМИТОВА матрица. Элементы матрицы Rjj расчитываются по формуле:
// Rjj(i,j) = SUM{Ui*conj[Uj]} by k =
//            SUM{Fi(angle(k))*Fj(angle(k))*Pk*EXP(jDELTA(i,j))} by k, где
//1. i, j - номера каналов адаптивной LAA;
//2. k - номер активной внешней помехи;
//2. Rjj(i,j) - коэффициент корреляции аддитивной помехи между i-ым и j-ым кана-
//   лами;
//3. angle(k) - пространственное положение k-го источника помехи (по азимуту
//   либо углу места в зависимости от расположения LAA);
//4. Fi(angle(k)), Fj(angle(k)) - значение диаграммы направленности i-го (j-го)
//   элемента LAA в направлении на k-ый источник помехи;
//5. Pk - мощность k-го источника помехи;
//6. DELTA(i,j) = 2*PI*(Li - Lj)*sin(angle(k)) - фазовый набег (расстояние) между
//   i-ым и j-ым элементами LAA.
//7. Li, Lj - относительное расстояние между i-ым (j-ым) и нулевым элементами LAA.
//Если адаптивная LAA имеет СИНТЕЗИРОВАННЫЙ ОСНОВНОЙ КАНАЛ, то считается что он
//пространственно совпадает с нулевым элементом антенной решетки.
//Все диагональные элементы матрицы Rjj являются ВЕЩЕСТВЕННЫМИ ВЕЛИЧИНАМИ, так
//DELTA(i,i) = 0. Элементы матрицы Rjj(i,j) & Rjj(j,i) являются комплексно-сопря-
//женными, так как DELTA(i,j) = -DELTA(j,i).
//   Корреляционная  матрица аддитивной помехи получается путем умножения векто-
//ра-столбца напряжений Ujam k-ой помехи на каналах адаптивной LAA, подключенных
//к  весовому параллельно-последовательному сумматору на транспонированно-сопря-
//женный  вектор к вектору Ujam k-ой помехи и последующим сложением корреляцион-
//ных матриц, рассчитаных для каждой k-ой помехи.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет формироваться входная
//   корреляционная матрица аддитивной помехи (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в матрицу R корреляционных отношений
//   между ОСНОВНЫМ и другими каналами предпроцессора.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix& R - ссылка на сформированную корреляционную
//матрицу аддитивной помехи на входе предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
cmatrix& TAnalPreProcSFilterBaseCh::GetInRjj(cmatrix& R, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {R.Set(0L,0L,false); return R;}
 //----------------------------------------------------------------------------
 //Формирование входной корреляционной матрицы АДДИТИВНОЙ ПОМЕХИ
 //----------------------------------------------------------------------------
 //Формирование матрицы R необходимой размерности
 ulong size = (lExtend == ON) ? Jammer.Rows() : Jammer.Rows()-1;
 R.Set(size,size,C_ZERO);
 complex sum, r;
 //Формирование диагональных и наддиагональных элементов R
 for (ulong k = 0L; k < Jammer.Cols(); k++)//Цикл по компонентам АКТИВНОЙ ПОМЕХИ
  for (ulong i = 0L; i < R.Rows(); i++)
   for (ulong j = i; j < R.Cols(); j++)
   {if (i == j) r = norm(Jammer.Get(i,k));
    else r = Jammer.Get(i,k)*conj(Jammer.Get(j,k));
    sum = R.Get(i,j) + r;
    R.Put(i,j,sum);
   }
  //Цикл расчета поддиагональных элементов R
  for (ulong i = 1L; i < R.Rows(); i++)
   for (ulong j = 0L; j < i; j++)
    R.Put(i,j,conj(R.Get(j,i)));
return R;
}
//******************************************************************************
//СТАТУС: I.18,public,TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix& GetInRnn(cmatrix& R, bool lExtend = ON) const;
//НАЗНАЧЕНИЕ: Формирование  корреляционной  матрицы  ВНУТРЕННЕГО  ШУМА  на входе
//предпроцессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается  матрица ну-
//левого размера. Данная корреляционная матрица формируется в матрице R, переда-
//ваемой в данную функцию по ссылке. Функция использует вектор Noise.
//Опция lExtend указывает на включение в матрицу R корреляционных отношений меж-
//ду ОСНОВНЫМ и другими каналами предпроцессора (при lExtend == ON).
//АЛГОРИТМ расчета  входной  корреляционной матрицы внутреннего шума между ВСЕМИ
//каналами LAA, включая  ОСНОВНОЙ  КАНАЛ, которые  подключены  к  предпроцессору
//пространственного адаптивного фильтра с выделенным каналом. Rnn - ДИАГОНАЛЬНАЯ
//матрица, так как внутренний шум считается НЕКОРРЕЛИРОВАННЫМ, межканальная кор-
//реляция внутреннего шума равна нулю. На главной диагонали Rnn получаются уров-
//ни мощности внутреннего шума в каналах LAA, подключенных к фильтру. Мощность
//внутреннего шума ОСНОВНОГО канала складывается из мощностей внутреннего шума
//каналов LAA, подключенных к схеме формирования ОСНОВНОГО КАНАЛА. Элементы кор-
//реляционной матрицы Rnn расчитываются по формуле:
// Rnn(i,j) = Ui * conj[Uj], при i = j
// Rnn(i,j) = 0, при i != j, где
//1. i, j - номера каналов адаптивной антенной решетки;
//2. Rnn(i,j) - коэффициент корреляции внутреннего шума между i-ым и j-ым каналами;
//Все диагональные элементы матрицы Rnn - ВЕЩЕСТВЕННЫЕ ЧИСЛА, внедиагональные
//элементы Rnn равны 0.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет формироваться входная
//   корреляционная матрица внутреннего шума (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в матрицу R корреляционных отношений
//   между ОСНОВНЫМ и другими каналами предпроцессора.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix& R - ссылка на сформированную корреляционную
//матрицу внутреннего шума на входе предпроцессора (до схемы AuxChRDEUnit).
//******************************************************************************
cmatrix& TAnalPreProcSFilterBaseCh::GetInRnn(cmatrix& R, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {R.Set(0L,0L,false); return R;}
 //-----------------------------------------------------------------------------
 //Формирование входной корреляционной матрицы ВНУТРЕННЕГО ШУМА
 //-----------------------------------------------------------------------------
 //Формирование матрицы R необходимой размерности
 ulong size = (lExtend == ON) ? Noise.Size() : Noise.Size()-1;
 R.Set(size,size,C_ZERO);
 //Цикл расчета диагональных элементов A (внутренний шум некоррелированный!)
 for (ulong i = 0L; i < R.Rows(); i++)
  R.Put(i,i,norm(Noise.Get(i)));
return R;
}
//******************************************************************************
//СТАТУС: I.19.,public,TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix& GetOutRss(cmatrix& R, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование корреляционной  матрицы  ПОЛЕЗНОГО СИГНАЛА  на выходе
//предпроцессора (после схемы AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается  матрица ну-
//левого размера. Данная корреляционная матрица формируется в матрице R, переда-
//ваемой в данную функцию по ссылке.
//Опция lExtend указывает на включение в матрицу R корреляционных отношений меж-
//ду ОСНОВНЫМ и другими каналами предпроцессора (при lExtend == ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет формироваться выходная
//   корреляционная матрица полезного сигнала (после схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в матрицу R корреляционных отношений
//   между ОСНОВНЫМ и другими каналами предпроцессора.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix& R - ссылка на сформированную корреляционную
//матрицу полезного сигнала на выходе предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
cmatrix& TAnalPreProcSFilterBaseCh::GetOutRss(cmatrix& R, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {R.Set(0L,0L,false); return R;}
 //----------------------------------------------------------------------------
 //Формирование входной корреляционной матрицы ПОЛЕЗНОГО СИГНАЛА
 //----------------------------------------------------------------------------
 if (UsageRDEUnit() == ON) //AuxChRDEUnit используется предпроцессором
 {//Формирование выходного вектора ПОЛЕЗНОГО СИГНАЛА
  cvector Uout; OutSignal(Uout, lExtend);
  //Формирование матрицы R необходимой размерности
  R.Set(Uout.Size(),Uout.Size(),C_ZERO);
  //Цикл расчета диагональных и наддиагональных элементов R
  for (ulong i = 0L; i < R.Rows(); i++)
   for (ulong j = i; j < R.Cols(); j++)
   {if (i == j) R.Put(i,j,norm(Uout.Get(i)));
    else R.Put(i,j,Uout.Get(i)*conj(Uout.Get(j)));
   }
  //Цикл расчета поддиагональных элементов R
  for (ulong i = 1L; i < R.Rows(); i++)
   for (ulong j = 0L; j < i; j++)
    R.Put(i,j,conj(R.Get(j,i)));
 }
 else GetInRss(R,lExtend);//AuxChRDEUnit не используется предпроцессором
return R;
}
//******************************************************************************
//СТАТУС: I.20,public,TAnalPreProcSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix& GetOutRjj(cmatrix& R, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование корреляционной  матрицы  АДДИТИВНОЙ ПОМЕХИ  на выходе
//предпроцессора (после схемы AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается  матрица ну-
//левого размера. Данная корреляционная матрица формируется в матрице R, переда-
//ваемой в данную функцию по ссылке.
//Опция lExtend указывает на включение в матрицу R корреляционных отношений меж-
//ду ОСНОВНЫМ и другими каналами предпроцессора (при lExtend == ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет формироваться выходная
//   корреляционная матрица аддитивной помехи (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в матрицу R корреляционных отношений
//   между ОСНОВНЫМ и другими каналами предпроцессора.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix& R - ссылка на сформированную корреляционную
//матрицу аддитивной помехи на выходе предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
cmatrix& TAnalPreProcSFilterBaseCh::GetOutRjj(cmatrix& R, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {R.Set(0L,0L,false); return R;}
 //----------------------------------------------------------------------------
 //Формирование входной корреляционной матрицы АДДИТИВНОЙ ПОМЕХИ
 //----------------------------------------------------------------------------
 if (UsageRDEUnit() == ON) //AuxChRDEUnit используется предпроцессором
 {//Формирование выходной выборки АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ (по каждой помехе)
  cmatrix Uout; OutJammer(Uout, lExtend);
  //Формирование матрицы R необходимой размерности
  R.Set(Uout.Rows(),Uout.Rows(),C_ZERO);
  complex sum, r;
  //Формирование диагональных и наддиагональных элементов R
  for (ulong k = 0L; k < Jammer.Cols(); k++)//Цикл по компонентам АКТИВНОЙ ПОМЕХИ
   for (ulong i = 0L; i < R.Rows(); i++)
    for (ulong j = i; j < R.Cols(); j++)
    {if (i == j) r = norm(Uout.Get(i,k));
     else r = Uout.Get(i,k)*conj(Uout.Get(j,k));
     sum = R.Get(i,j) + r;
     R.Put(i,j,sum);
    }
   //Цикл расчета поддиагональных элементов R
   for (ulong i = 1L; i < R.Rows(); i++)
    for (ulong j = 0L; j < i; j++)
     R.Put(i,j,conj(R.Get(j,i)));
 }
 else GetInRjj(R,lExtend);//AuxChRDEUnit не используется предпроцессором
return R;
}
//******************************************************************************
//СТАТУС: I.21, public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix& GetOutRnn(cmatrix& R, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование корреляционной  матрицы  ВНУТРЕННЕГО  ШУМА  на выходе
//предпроцессора (после схемы AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается  матрица ну-
//левого размера. Данная корреляционная матрица формируется в матрице R, переда-
//ваемой в данную функцию по ссылке.
//Опция lExtend указывает на включение в матрицу R корреляционных отношений меж-
//ду ОСНОВНЫМ и другими каналами предпроцессора (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет формироваться выходная
//   корреляционная матрица внутреннего шума (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в матрицу R корреляционных отношений
//   между ОСНОВНЫМ и другими каналами предпроцессора.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix& R - ссылка на сформированную корреляционную
//матрицу внутреннего шума на выходе предпроцессора (до схемы AuxChRDEUnit).
//******************************************************************************
cmatrix& TAnalPreProcSFilterBaseCh::GetOutRnn(cmatrix& R, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {R.Set(0L,0L,false); return R;}
 //-----------------------------------------------------------------------------
 //Формирование входной корреляционной матрицы ВНУТРЕННЕГО ШУМА
 //-----------------------------------------------------------------------------
 if (UsageRDEUnit() == ON) //AuxChRDEUnit используется предпроцессором
 {cmatrix Rnn; GetInRnn(Rnn,ON);
  RDEUnit->TFuncDM(Rnn, R);
  if (lExtend == OFF) //Основной канал не включать
  {Rnn = R;
   R.Set(R.Rows()-1,R.Rows()-1,C_ZERO);
   for (ulong i = 0L; i < R.Rows(); i++)
    for (ulong j = 0L; j < R.Cols(); j++)
     R.Put(i,j,Rnn.Get(i,j));
  }
 }
 else GetInRnn(R,lExtend);//AuxChRDEUnit не используется предпроцессором
return R;
}
//******************************************************************************
//СТАТУС: I.22, public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix& GetInR(cmatrix& R, bool lSignal = ON, bool lJammer = ON,
//                 bool lNoise = ON, bool lExtend = ON) const;
//НАЗНАЧЕНИЕ: Формирование корреляционной матрицы компонент ВХОДНОГО ВОЗДЕЙСТВИЯ
//на входе предпроцессора (до схемы AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается  матрица ну-
//левого размера. Данная корреляционная матрица формируется в матрице R, переда-
//ваемой в данную функцию по ссылке.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет формироваться входная
//   корреляционная матрица компонент входного воздействия (до схемы AuxChRDEUnit);
//2. bool lSignal (ON) - опция включения в матрицу ПОЛЕЗНОГО СИГНАЛА;
//3. bool lJammer (ON) - опция включения в матрицу АДДИТИВНОЙ ПОМЕХИ;
//4. bool lNoise (ON)  - опция включения в матрицу ВНУТРЕННЕГО ШУМА;
//5. bool lExtend (ON) - опция включения в матрицу R корреляционных отношений
//   между ОСНОВНЫМ и другими каналами предпроцессора.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix& R - ссылка на сформированную корреляционную
//матрицу компонент входного сигнала на входе предпроцессора (до AuxChRDEUnit).
//******************************************************************************
cmatrix& TAnalPreProcSFilterBaseCh::GetInR(cmatrix& R, bool lSignal,
         bool lJammer, bool lNoise, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {R.Set(0L,0L,false); return R;}
 //-----------------------------------------------------------------------------
 //Формирование входной корреляционной матрицы компонент входного сигнала
 //-----------------------------------------------------------------------------
 //Формирование матрицы R необходимой размерности
 ulong size = (lExtend == ON) ? In() : In()-1;
 R.Set(size,size,C_ZERO);
 cmatrix Temp;
 if (lSignal) R = R + GetInRss(Temp, lExtend);
 if (lJammer) R = R + GetInRjj(Temp, lExtend);
 if (lNoise)  R = R + GetInRnn(Temp, lExtend);
 return R;
}
//******************************************************************************
//СТАТУС: I.23, public, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix& GetOutR(cmatrix& R, bool lSignal = ON, bool lJammer = ON,
//                  bool lNoise = ON, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование корреляционной матрицы компонент ВХОДНОГО ВОЗДЕЙСТВИЯ
//на выходе предпроцессора (после схемы AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается  матрица ну-
//левого размера. Данная корреляционная матрица формируется в матрице R, переда-
//ваемой в данную функцию по ссылке.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет формироваться выходная
//   корреляционная матрица компонент входного воздействия (после схемы
//   AuxChRDEUnit);
//2. bool lSignal (ON) - опция включения в матрицу ПОЛЕЗНОГО СИГНАЛА;
//3. bool lJammer (ON) - опция включения в матрицу АДДИТИВНОЙ ПОМЕХИ;
//4. bool lNoise (ON)  - опция включения в матрицу ВНУТРЕННЕГО ШУМА;
//5. bool lExtend (ON) - опция включения в матрицу R корреляционных отношений
//   между ОСНОВНЫМ и другими каналами предпроцессора.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix& R - ссылка на сформированную корреляционную
//матрицу компонент входного сигнала на выходе предпроцессора (после схемы
//AuxChRDEUnit).
//******************************************************************************
cmatrix& TAnalPreProcSFilterBaseCh::GetOutR(cmatrix& R, bool lSignal,
         bool lJammer, bool lNoise, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {R.Set(0L,0L,false); return R;}
 //-----------------------------------------------------------------------------
 //Формирование выходной корреляционной матрицы компонент входного сигнала
 //после схемы AuxChRDECh
 //-----------------------------------------------------------------------------
 //Формирование матрицы R необходимой размерности
 ulong size = (lExtend == ON) ? Out() : Out()-1;
 R.Set(size,size,C_ZERO);
 cmatrix Temp;
 if (lSignal) R = R + GetOutRss(Temp, lExtend);
 if (lJammer) R = R + GetOutRjj(Temp, lExtend);
 if (lNoise)  R = R + GetOutRnn(Temp, lExtend);
 return R;
}
//==============================================================================
//II. РЕАЛИЗАЦИЯ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TAnalPreProcSFilterBaseCh
//    PRIVATE MEMBER-FUNCTION OF TAnalPreProcSFilterBaseCh CLASS
//==============================================================================
//******************************************************************************
//СТАТУС: II.1., private, TAnalPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetSJNData();
//НАЗНАЧЕНИЕ: Установка размеров членов-данных класса, в которых формируются
//входные выборки ПОЛЕЗНОГО СИГНАЛА, АДДИТИВНОЙ ПОМЕХИ и ВНУТРЕННЕГО ШУМА.
//------------------------------------------------------------------------------
//1. cvector Signal: size = [BaseCh = 1] + LAACh.Size() + 1;
//2. cvector Noise:  size = [BaseCh = 1] + LAACh.Size() + 1;
//3. cmatrix Jammer: rows = [BaseCh = 1] + LAACh.Size() + 1
//                   cols = OutLAA->ActiveJammers() || 1
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TAnalPreProcSFilterBaseCh::SetSJNData()
{ulong channels = LAACh.Size()+1;
 ulong jams = OutLAA->ActiveJammers();
 if (jams == 0) jams = 1;
 if (IsBaseChInRDEUnit()) channels += 1;
 Signal.Resize(channels); Noise.Resize(channels);
 Jammer.Set(channels,jams,C_ZERO);
 Signal = C_ZERO; Noise = C_ZERO;
}

//******************************************************************************
//               РЕАЛИЗАЦИЯ КЛАССА TStatPreProcSFilterBaseCh
//Статистическая  модель предпроцессора обработки входного сигнала пространствен-
//ного адаптивного фильтра с выделенным каналом на основе LAA.
//******************************************************************************
//------------------------------------------------------------------------------
//   ФУНКЦИИ, ИСПОЛЬЗУЕМЫЕ ПРИ МОДЕЛИРОВАНИИ ПРЕПРОЦЕССОРА АДАПТИВНОЙ LAA
//           c ПРОСТРАНСТВЕННЫМ АДАПТИВНЫМ ФИЛЬТРОМ с ОСНОВНЫМ КАНАЛОМ
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Update()
//НАЗНАЧЕНИЕ: Расчет компонент внешнего воздействия (полезного сигнала, аддитив-
//ной помехи и внутреннего шума) на входе предпроцессора адаптивного пространст-
//венного  фильтра с ОСНОВНЫМ каналом на основе LAA. Обновление компонент произ-
//водится на каждом шаге моделирования.
//Функция возвращает false, если ПРЕДПРОЦЕССОР неработоспособен.
//Функция корректно работает только при моделировании, когда InSignal изменяется
//в процессе моделирования.
//Для ускорения работы функции, она непосредственно обращается к членам-данным
//объекта класса InSignal, где хранятся мгновенные комплексные значения напряже-
//ний на выходах приемных каналов LAA с поляризацией заданного вида.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
bool TStatPreProcSFilterBaseCh::Update()
{if (!IsReady()) return false;//Проверка работоспособности предпроцессора
 ulong First = (IsBaseChInRDEUnit()) ? 1L : 0L;
 ulong Last = Signal.Size()-1;
 ulong index;
 complex Usum;
 //-----------------------------------------------------------------------------
 //Расчет компонент входного воздействия на входе предпроцессора
 //-----------------------------------------------------------------------------
 //1. Расчет ПОЛЕЗНОГО СИГНАЛА на входе предпроцессора
 //-----------------------------------------------------------------------------
 const cvector* pSPolar =
  (Polarization() == VP_SIGNAL) ? OutLAA->GetVPSignal() : OutLAA->GetHPSignal();
 //Формирование вектора ПОЛЕЗНОГО СИГНАЛА
 for (ulong i = First; i < Last; i++)
  Signal.Put(i,pSPolar->Get(LAACh.Get(i-First)));
 Usum = BaseChannel.CalcStatSignal(Polarization());
 Signal.Put(Last,Usum);
 //AuxChRDEUnit подключено к предпроцессору и ОСНОВНОЙ канал используется как
 //РАБОЧИЙ канал RDEUnit
 if (IsBaseChInRDEUnit()) Signal.Put(0L,Usum);
 //-----------------------------------------------------------------------------
 //2. Расчет АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ на входе предпроцессора
 //-----------------------------------------------------------------------------
 const cmatrix* pJPolar =
  (Polarization() == VP_SIGNAL) ? OutLAA->GetVPJammer() : OutLAA->GetHPJammer();
 //-----------------------------------------------------------------------------
 //Формирование вектора компонент АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ для каналов LAA,
 //подключенных к пространственному фильтру
 for (ulong i = First; i < Last; i++) //По каналам LAA
 {index = LAACh.Get(i-First);//Номер канала LAA, подключенного к фильтру
  Usum = C_ZERO;
  //По компонентам активной помехи
  for (ulong j = 0L; j < pJPolar->Cols(); j++) Usum += pJPolar->Get(index,j);
  Jammer.Put(i,Usum);
 }
 //Расчет АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ с ОСНОВНОГО КАНАЛА пространственного фильтра
 Usum = BaseChannel.CalcStatJammer(Polarization());
 //Копирование значения АКТИВНОЙ ПОМЕХИ с ОСНОВНОГО канала в вектор Jammer
 Jammer.Put(Last,Usum);
 //AuxChRDEUnit подключено к предпроцессору и ОСНОВНОЙ канал используется как
 //РАБОЧИЙ канал RDEUnit
 if (IsBaseChInRDEUnit()) Jammer.Put(0L,Usum);
 //-----------------------------------------------------------------------------
 //3. Расчет ВНУТРЕННЕГО ШУМА на входе предпроцессора
 //-----------------------------------------------------------------------------
 const cvector* pNPolar =
 (Polarization() == VP_SIGNAL) ? OutLAA->GetVPNoise() : OutLAA->GetHPNoise();
 //Формирование вектора ВНУТРЕННЕГО ШУМА
 for (ulong i = First; i < Last; i++)
  Noise.Put(i,pNPolar->Get(LAACh.Get(i-First)));
 Usum = BaseChannel.CalcStatNoise(Polarization());
 Noise.Put(Last,Usum);
 //AuxChRDEUnit подключено к предпроцессору и ОСНОВНОЙ канал используется как
 //РАБОЧИЙ канал RDEUnit
 if (IsBaseChInRDEUnit()) Noise.Put(0L,Usum);
return true;
}
//******************************************************************************
//СТАТУС: I.2., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector& InSignal(cvector& U, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование  вектора напряжений ПОЛЕЗНОГО СИГНАЛА на входах пред-
//процессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор напряжений полезного сигнала формируется в векторе U, пе-
//редаваемый в данную функцию по ссылке. Функция использует вектор Signal.
//Опция lExtend указывает на включение в вектор U напряжения полезного сигнала
//на входе ОСНОВНОГО канала (при lExtend == ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& U - ссылка на вектор, в котором формируется выборка полезного сиг-
//   нала на входах предпроцессора AdaptLAA (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор U значения полезного сигнала
//   на входе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector& U - ссылка на выборку полезного сигнала на
//входах предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
cvector& TStatPreProcSFilterBaseCh::InSignal(cvector& U, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {U.Resize(0L); return U;}
 //----------------------------------------------------------------------------
 //Формирование входного вектора ПОЛЕЗНОГО СИГНАЛА
 //----------------------------------------------------------------------------
 //Формирование вектора U необходимого размера
 ulong size = (lExtend == ON) ? Signal.Size() : Signal.Size()-1;
 U.Resize(size);
 //Цикл формирования значений элементов вектора U
 for (ulong i = 0L; i < size; i++) U.Put(i,Signal.Get(i));
return U;
}
//******************************************************************************
//СТАТУС: I.3., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector& InJammer(cvector& U, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора напряжений  АДДИТИВНОЙ ПОМЕХИ на входах пред-
//процессора (до поступления сигнала в AuxChRDEUnit при ее использовании) для
//каждой компоненты помехи.
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор напряжений аддитивной помехи формируется в векторе U, пе-
//редаваемый в функцию по ссылке. Функция использует вектор Jammer.
//Опция lExtend указывает на включение в вектор U значений аддитивной помехи на
//входе ОСНОВНОГО канала (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& U - ссылка на вектор, в которой формируется значения аддитивной
//   помехи на входах предпроцессора AdaptLAA (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор U значений аддитивной помехи
//   на входе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector& U - ссылка на вектор значений аддитивной поме-
//хи на входе предпроцессора (до схемы AuxChRDEUnit) для каждой ее компоненты.
//******************************************************************************
cvector& TStatPreProcSFilterBaseCh::InJammer(cvector& U, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {U.Resize(0L); return U;}
 //----------------------------------------------------------------------------
 //Формирование входного вектора АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ
 //----------------------------------------------------------------------------
 //Формирование вектора U необходимого размера
 ulong size = (lExtend == ON) ? Jammer.Size() : Jammer.Size()-1;
 U.Resize(size);
 //Цикл формирования значений элементов вектора U
 for (ulong i = 0L; i < size; i++) U.Put(i,Jammer.Get(i));
return U;
}
//******************************************************************************
//СТАТУС: I.4., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector& InNoise(cvector& U, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора напряжений ВНУТРЕННЕГО ШУМА на входах
//предпроцессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор значений внутреннего шума  формируется в векторе U, пере-
//даваемый в функцию по ссылке. Функция использует вектор Noise.
//Опция lExtend указывает на включение в вектор U значения внутреннего шума на
//входе ОСНОВНОГО канала (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& U - ссылка на вектор, в котором формируется выборка внутреннего
//   шума для входов предпроцессора AdaptLAA (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор U значения внутреннего шума
//   на входе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector& U - ссылка на вектор значений внутреннего шума
//на входах предпроцессора (до схемы AuxChRDEUnit).
//******************************************************************************
cvector& TStatPreProcSFilterBaseCh::InNoise(cvector& U, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {U.Resize(0L); return U;}
 //-----------------------------------------------------------------------------
 //Формирование входного вектора ВНУТРЕННЕГО ШУМА
 //-----------------------------------------------------------------------------
 //Формирование вектора U необходимого размера
 ulong size = (lExtend == ON) ? Noise.Size() : Noise.Size()-1;
 U.Resize(size);
 //Цикл формирования значений элементов вектора U
 for (ulong i = 0L; i < size; i++) U.Put(i,Noise.Get(i));
return U;
}
//******************************************************************************
//СТАТУС: I.5., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:cvector& OutSignal(cvector& Uout, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора напряжений ПОЛЕЗНОГО СИГНАЛА на выходах пред-
//процессора (после AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор напряжений полезного сигнала формируется в векторе Uout,
//передаваемый в данную функцию по ссылке. Функция использует вектор Signal.
//Опция lExtend указывает на включение в вектор Uout напряжения полезного сигна-
//ла на выходе ОСНОВНОГО канала (при lExtend == ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& Uout - ссылка на вектор, в котором формируется выборка полезного
//   сигнала на выходах предпроцессора AdaptLAA (после схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор Uout значения полезного сигнала
//   на выходе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector& Uout - ссылка на выборку полезного сигнала на
//выходах предпроцессора (после схемы AuxChRDEUnit).
//*****************************************************************************
cvector& TStatPreProcSFilterBaseCh::OutSignal(cvector& Uout, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {Uout.Resize(0L); return Uout;}
 //----------------------------------------------------------------------------
 //Формирование выходного вектора ПОЛЕЗНОГО СИГНАЛА
 //----------------------------------------------------------------------------
 if (UsageRDEUnit() == ON) //AuxChRDEUnit используется предпроцессором
 {RDEUnit->TFunc(Signal,Uout);
  if (lExtend == OFF) //Основной канал не включать
   Uout.Resize(Uout.Size()-1,ON);
 }
 else InSignal(Uout,lExtend); //AuxChRDEUnit не используется предпроцессором
return Uout;
}
//******************************************************************************
//СТАТУС: I.6., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:cvector& OutJammer(cmatrix& Aout, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора напряжений АДДИТИВНОЙ ПОМЕХИ на выходах пред-
//процессора (после AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого  размера. Вектор напряжений аддитивной помехи формируется в векторе Uout,
//передаваемый в функцию по ссылке. Функция использует вектор Jammer.
//Опция lExtend указывает на включение в вектор Uout значений аддитивной помехи
//на выходе ОСНОВНОГО канала (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& Uout - ссылка на вектор, в котором формируются значения аддитивной
//   помехи на выходах предпроцессора AdaptLAA (после AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор Uout значений аддитивной поме-
//   хи на выходе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector& Uout - ссылка на вектор значений аддитивной
//помехи на выходе предпроцессора (после AuxChRDEUnit).
//*****************************************************************************
cvector& TStatPreProcSFilterBaseCh::OutJammer(cvector& Uout, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {Uout.Resize(0L); return Uout;}
 //----------------------------------------------------------------------------
 //Формирование выходного вектора АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ
 //----------------------------------------------------------------------------
 if (UsageRDEUnit() == ON) //AuxChRDEUnit используется предпроцессором
 {RDEUnit->TFunc(Jammer,Uout);
  //Основной канал не включать
  if (lExtend == OFF) Uout.Resize(Uout.Size()-1,ON);
 }
 else InJammer(Uout,lExtend);//AuxChRDEUnit не используется предпроцессором
return Uout;
}
//******************************************************************************
//СТАТУС: I.7., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:cvector& OutNoise(cvector& Uout, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование  вектора напряжений ВНУТРЕННЕГО ШУМА на выходах пред-
//процессора (после AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор значений внутреннего шума формируется в векторе Uout, пе-
//редаваемый в функцию по ссылке. Функция использует вектор Noise.
//Опция lExtend указывает на включение в вектор Uout значения внутреннего шума на
//выходе ОСНОВНОГО канала (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& Uout - ссылка на вектор, в котором формируется выборка внутреннего
//   шума для выходов предпроцессора AdaptLAA (после схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор Uout значения внутреннего шума
//   на выходе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector& Uout - ссылка на вектор значений внутреннего
//шума на выходах предпроцессора (после схемы AuxChRDEUnit).
//******************************************************************************
cvector& TStatPreProcSFilterBaseCh::OutNoise(cvector& Uout, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {Uout.Resize(0L); return Uout;}
 //-----------------------------------------------------------------------------
 //Формирование выходного вектора ВНУТРЕННЕГО ШУМА
 //-----------------------------------------------------------------------------
 if (UsageRDEUnit() == ON) //AuxChRDEUnit используется предпроцессором
 {RDEUnit->TFunc(Noise,Uout);
  //Основной канал не включать
  if (lExtend == OFF) Uout.Resize(Uout.Size()-1,ON);
 }
 else InNoise(Uout,lExtend); //AuxChRDEUnit не используется предпроцессором
return Uout;
}
//******************************************************************************
//СТАТУС: I.8., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double InPsignal() const
//НАЗНАЧЕНИЕ: Формирование мощности ПОЛЕЗНОГО СИГНАЛА на входе ОСНОВНОГО канала
//предпроцессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Для вычислений используется вектор Signal.
//Если предпроцессор не активен (IsReady() == OFF), то возвращается 0.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: P - мощность полезного сигнала на входе ОСНОВНОГО кана-
//ла предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
double TStatPreProcSFilterBaseCh::InPsignal() const
{double P = 0;
 if (!IsReady()) return P;//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 //----------------------------------------------------------------------------
 //Определение мощности ПОЛЕЗНОГО СИГНАЛА на входе ОСНОВНОГО канала
 //предпроцессора (до схемы AuxChRDEUnit)
 //----------------------------------------------------------------------------
 ulong Last = Signal.Size()-1; P = norm(Signal.Get(Last));
return P;
}
//******************************************************************************
//СТАТУС: I.9., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double InPjammer() const
//НАЗНАЧЕНИЕ: Формирование мощности АДДИТИВНОЙ ПОМЕХИ на входе ОСНОВНОГО канала
//предпроцессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Для вычислений используется вектор Jammer.
//Если предпроцессор не активен (IsReady() == OFF), то возвращается 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: P - мощность аддитивной помехи на входе ОСНОВНОГО кана-
//ла предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
double TStatPreProcSFilterBaseCh::InPjammer() const
{double P = 0;
 if (!IsReady()) return P;//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 //----------------------------------------------------------------------------
 //Определение мощности АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ на входе ОСНОВНОГО канала
 //предпроцессора (до схемы AuxChRDEUnit)
 //----------------------------------------------------------------------------
 ulong Last = Jammer.Size()-1; P = norm(Jammer.Get(Last));
return P;
}
//******************************************************************************
//СТАТУС: I.10., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double InPnoise() const
//НАЗНАЧЕНИЕ: Формирование мощности ВНУТРЕННЕГО ШУМА на входе ОСНОВНОГО канала
//предпроцессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Для вычислений используется вектор Noise.
//Если предпроцессор не активен (IsReady() == OFF), то возвращается 0.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double P - мощность внутреннего шума на входе ОСНОВНОГО
//канала предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
double TStatPreProcSFilterBaseCh::InPnoise() const
{double P = 0;
 if (!IsReady()) return P; //Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 //----------------------------------------------------------------------------
 //Определение мощности ВНУТРЕННЕГО ШУМА на входе ОСНОВНОГО канала
 //предпроцессора (до схемы AuxChRDEUnit)
 //----------------------------------------------------------------------------
 ulong Last = Noise.Size()-1; P = norm(Noise.Get(Last));
return P;
}
//******************************************************************************
//СТАТУС: I.11., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& InPsignal(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ПОЛЕЗНОГО СИГНАЛА на входах предпро-
//цессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор мощности полезного сигнала формируется в векторе P, пере-
//даваемый в данную функцию по ссылке. Для вычислений используется вектор Signal.
//Опция lExtend указывает на включение в вектор P мощности полезного сигнала на
//входе ОСНОВНОГО канала (при lExtend == ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор, в котором формируется мощность полезного сиг-
//   нала на входах предпроцессора AdaptLAA (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор P мощности полезного сигнала
//   на входе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей полезного сиг-
//нала на входах предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
rvector& TStatPreProcSFilterBaseCh::InPsignal(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {P.Resize(0L); return P;}
 //----------------------------------------------------------------------------
 //Формирование входного вектора мощности ПОЛЕЗНОГО СИГНАЛА
 //----------------------------------------------------------------------------
 //Формирование вектора P необходимого размера
 ulong Size = (lExtend == ON) ? Signal.Size() : Signal.Size()-1;
 P.Resize(Size);
 //Цикл формирования значений элементов вектора P
 for (ulong i = 0L; i < Size; i++) P.Put(i,norm(Signal.Get(i)));
return P;
}
//******************************************************************************
//СТАТУС: I.12., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& InPjammer(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности АДДИТИВНОЙ ПОМЕХИ на входах предпро-
//цессора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор мощности аддитивной помехи формируется в векторе P, пере-
//даваемый в данную функцию по ссылке. Для вычислений используется вектор Jammer.
//Опция lExtend указывает на включение в вектор P мощности аддитивной помехи на
//входе ОСНОВНОГО канала (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор, в котором формируется мощность аддитивной
//   помехи на входах предпроцессора AdaptLAA (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор P мощности аддитивной помехи
//   на входе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей аддитивной по-
//мехи на входе предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
rvector& TStatPreProcSFilterBaseCh::InPjammer(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {P.Resize(0L); return P;}
 //----------------------------------------------------------------------------
 //Формирование входного вектора мощности АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ
 //----------------------------------------------------------------------------
 //Формирование вектора P необходимого размера
 ulong Size = (lExtend == ON) ? Jammer.Size() : Jammer.Size()-1;
 P.Resize(Size);
 //Цикл расчета значений элементов вектора P
 for (ulong i = 0L; i < Size; i++) P.Put(i,norm(Jammer.Get(i)));
return P;
}
//******************************************************************************
//СТАТУС: I.13., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& InPnoise(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ВНУТРЕННЕГО ШУМА на входах предпроцес-
//сора (до поступления сигнала в AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор мощности внутреннего шума  формируется в векторе P, пере-
//даваемый в данную функцию по ссылке. Для вычислений используется вектор Noise.
//Опция lExtend указывает на включение в вектор P мощности внутреннего шума на
//входе ОСНОВНОГО канала (при lExtend == ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка  на вектор, в  котором формируется мощность внутреннего
//   шума для входов предпроцессора AdaptLAA (до схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор P мощности внутреннего шума
//   на входе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей внутреннего
//шума на входах предпроцессора (до схемы AuxChRDEUnit).
//*****************************************************************************
rvector& TStatPreProcSFilterBaseCh::InPnoise(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {P.Resize(0L); return P;}
 //----------------------------------------------------------------------------
 //Формирование входного вектора мощности ВНУТРЕННЕГО ШУМА
 //----------------------------------------------------------------------------
 //Формирование вектора P необходимого размера
 ulong Size = (lExtend == ON) ? Noise.Size() : Noise.Size()-1;
 P.Resize(Size);
 //Используем вектор Noise
 //Цикл расчета значений элементов вектора P
 for (ulong i = 0L; i < Size; i++) P.Put(i,norm(Noise.Get(i)));
return P;
}
//******************************************************************************
//СТАТУС: I.14., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& OutPsignal(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ПОЛЕЗНОГО СИГНАЛА на выходах предпро-
//цессора (после схемы AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор мощности полезного сигнала формируется в векторе P, пере-
//даваемый в данную функцию по ссылке. Функция использует вызов OutSignal(...).
//Опция lExtend указывает на включение в вектор P мощности полезного сигнала на
//выходе ОСНОВНОГО канала (при lExtend == ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор, в котором формируется мощность полезного сиг-
//   нала на выходах предпроцессора AdaptLAA (после схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор P мощности полезного сигнала
//   на выходе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей полезного сиг-
//нала на выходах предпроцессора (после схемы AuxChRDEUnit).
//*****************************************************************************
rvector& TStatPreProcSFilterBaseCh::OutPsignal(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {P.Resize(0L); return P;}
 //----------------------------------------------------------------------------
 //Формирование выходного вектора мощности ПОЛЕЗНОГО СИГНАЛА
 //----------------------------------------------------------------------------
 cvector Uout; OutSignal(Uout,lExtend);
 //Формирование вектора P необходимого размера
 P.Resize(Uout.Size());
 //Цикл формирования значений элементов вектора P
 for (ulong i = 0L; i < P.Size(); i++) P.Put(i,norm(Uout.Get(i)));
return P;
}
//******************************************************************************
//СТАТУС: I.15., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& OutPjammer(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности АДДИТИВНОЙ ПОМЕХИ на выходах предпро-
//цессора (после схемы AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор мощности аддитивной помехи формируется в векторе P, пере-
//даваемый в данную функцию по ссылке. Функция использует вызов OutJammer(...).
//Опция lExtend указывает на включение в вектор P мощности аддитивной помехи на
//выходе ОСНОВНОГО канала (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор, в котором формируется мощность аддитивной
//   помехи на выходах предпроцессора AdaptLAA (после схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор P мощности аддитивной помехи
//   на выходе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей аддитивной по-
//мехи на выходе предпроцессора (после схемы AuxChRDEUnit).
//*****************************************************************************
rvector& TStatPreProcSFilterBaseCh::OutPjammer(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {P.Resize(0L); return P;}
 //----------------------------------------------------------------------------
 //Формирование выходного вектора мощности АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ
 //----------------------------------------------------------------------------
 cvector Uout; OutJammer(Uout,lExtend);
 P.Resize(Uout.Size()); //Формирование вектора P необходимого размера
 //Цикл расчета значений элементов вектора P
 for (ulong i = 0L; i < Uout.Size(); i++) P.Put(i,norm(Uout.Get(i)));
return P;
}
//******************************************************************************
//СТАТУС: I.16., public, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& OutPnoise(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ВНУТРЕННЕГО ШУМА на выходах предпро-
//цессора (после схемы AuxChRDEUnit при ее использовании).
//Если предпроцессор не активен (IsReady() == OFF), то возвращается вектор нуле-
//вого размера. Вектор мощности внутреннего шума  формируется в векторе P, пере-
//даваемый в данную функцию по ссылке. Функция использует вызов OutNoise(...).
//Опция lExtend указывает на включение в вектор P мощности внутреннего шума на
//выходе ОСНОВНОГО канала (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка  на вектор, в  котором формируется мощность внутреннего
//   шума для выходов предпроцессора AdaptLAA (после схемы AuxChRDEUnit);
//2. bool lExtend (ON) - опция включения в вектор P мощности внутреннего шума
//   на выходе ОСНОВНОГО канала предпроцессора AdaptLAA with BaseCh.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей внутреннего
//шума на выходах предпроцессора (после схемы AuxChRDEUnit).
//******************************************************************************
rvector& TStatPreProcSFilterBaseCh::OutPnoise(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ предпроцессора
 if (!IsReady()) {P.Resize(0L); return P;}
 //-----------------------------------------------------------------------------
 //Формирование выходного вектора мощности ВНУТРЕННЕГО ШУМА
 //-----------------------------------------------------------------------------
 cvector Uout; OutNoise(Uout,lExtend);
 //Формирование вектора P необходимого размера
 P.Resize(Uout.Size());
 //Цикл расчета значений элементов вектора P
 for (ulong i = 0L; i < P.Size(); i++) P.Put(i,norm(Uout.Get(i)));
return P;
}
//==============================================================================
//II. РЕАЛИЗАЦИЯ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TStatPreProcSFilterBaseCh
//    PRIVATE MEMBER-FUNCTION OF TStatPreProcSFilterBaseCh CLASS
//==============================================================================
//******************************************************************************
//СТАТУС: II.1., private, TStatPreProcSFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetSJNData();
//НАЗНАЧЕНИЕ: Установка размеров членов-данных класса, в которых формируются
//входные выборки ПОЛЕЗНОГО СИГНАЛА, АДДИТИВНОЙ ПОМЕХИ и ВНУТРЕННЕГО ШУМА.
//------------------------------------------------------------------------------
//1. cvector Signal: size = [BaseCh = 1] + LAACh.Size() + 1;
//2. cvector Noise:  size = [BaseCh = 1] + LAACh.Size() + 1;
//3. cvector Jammer: size = [BaseCh = 1] + LAACh.Size() + 1
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TStatPreProcSFilterBaseCh::SetSJNData()
{ulong channels = LAACh.Size()+1;
 if (IsBaseChInRDEUnit()) channels += 1;
 Signal.Resize(channels); Noise.Resize(channels); Jammer.Resize(channels);
 Signal = C_ZERO; Noise = C_ZERO; Jammer = C_ZERO;
}

//*****************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TAnalInSignalProperty
//Класс содержит свойства аналитической модели входного воздействия, принимаемого
//адаптивным пространственным фильтром, подключенным к LAA.
//*****************************************************************************
//****************************************************************************
// I. ОПИСАНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРОВ КЛАССА TAnalInSignalProperty
//****************************************************************************
//*****************************************************************************
//СТАТУС: I.1; public; TAnalInSignalProperty constructor by default
//НАИМЕНОВАНИЕ ФУНКЦИИ: TAnalInSignalProperty()
//НАЗНАЧЕНИЕ: Конструктор  по умолчанию класса TAnalInSignalProperty - свойства
//аналитической модели входного воздействия. Начальная инициализация членов-дан-
//ных класса осуществляется функцией Reset(). Значения членов-данных объекта по
//умолчанию следующие:
//1. SignalStat = OFF - ПОЛЕЗНЫЙ СИГНАЛ не стационарный;
//2. JammerStat = OFF - АДДИТИВНАЯ ПОМЕХА не стационарная;
//3. NoiseStat  = OFF - ВНУТРЕННИЙ ШУМ не стационарный;
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TAnalInSignalProperty::TAnalInSignalProperty()
{Reset(); //Начальная установка свойств входного сигнала
}
//*****************************************************************************
//СТАТУС: I.2; public; TAnalInSignalProperty constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// TAnalInSignalProperty(bool lSignal, bool lJammer, bool lNoise);
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TAnalInSignalProperty. Функция
//создает экземпляр класса через вызов функции Set(...).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. bool lSignal - признак "стационарности" ПОЛЕЗНОГО СИГНАЛА;
//2. bool lJammer - признак "стационарности" АДДИТИВНОЙ ПОМЕХИ;
//3. bool lNoise  - признак "стационарности" ВНУТРЕННЕГО ШУМА;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TAnalInSignalProperty::
 TAnalInSignalProperty(bool lSignal, bool lJammer, bool lNoise)
{//Устанавливаем характеристики экземпляра класса
 Set(lSignal, lJammer, lNoise);
}
//*****************************************************************************
//СТАТУС: I.3; public; TAnalInSignalProperty class destructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: TAnalInSignalProperty
//НАЗНАЧЕНИЕ: Деструктор класса TAnalInSignalProperty - разрушает объект.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TAnalInSignalProperty::~TAnalInSignalProperty()
{Reset(); //Сброс свойств аналитической модели входного воздействия
}
//=============================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TAnalInSignalProperty
//    PUBLIC MEMBER-FUNCTION OF TAnalInSignalProperty CLASS
//=============================================================================
//*****************************************************************************
//СТАТУС: I.1; public; TAnalInSignalProperty class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Set(bool lSignal, bool lJammer, bool lNoise)
//НАЗНАЧЕНИЕ: Установка свойств аналитической модели входного сигнала.
//Старые характеристики перед установкой новых уничтожаются функцией Reset().
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. bool lSignal - признак "стационарности" ПОЛЕЗНОГО СИГНАЛА;
//2. bool lJammer - признак "стационарности" АДДИТИВНОЙ ПОМЕХИ;
//3. bool lNoise  - признак "стационарности" ВНУТРЕННЕГО ШУМА;
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TAnalInSignalProperty::Set(bool lSignal, bool lJammer, bool lNoise)
{Reset(); //Начальная установка свойств объекта
 //Установка новых параметров
 SignalStat = lSignal; JammerStat = lJammer; NoiseStat = lNoise;
}
//****************************************************************************************
//СТАТУС: I.2; public member-function of class TAnalInSignalProperty
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//string& Properties(string& s, string& title, uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирование характеристик объекта TInDataBaseCh в виде строки.
//Свойства аналитической модели входного сигнала в виде строки представляются:
//----------------------------------------------------------------------------------------
//PROPERTIES OF INPUT SIGNAL ANALYTICAL MODEL:
// 1. Stationarity: SIGNAL = <ON||OFF>; JAMMER = <ON||OFF>; NOISE = <ON||OFF>;
//----------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект
//2. string& title - ссылка на строку с заголовком объекта;
//3. uint indent - начальное смещение строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами объекта.
//****************************************************************************************
string& TAnalInSignalProperty::Properties(string& s, string& title, uint indent)
const
{string space(indent,' ');
 s.resize(0);
 //Формирование заголовка объекта
 s.append(space);
 if (title.empty()) s.append("INSIGNAL ANALYTICAL MODEL PROPERTIES:");
 else s.append(title);
 s.append("\n");
 //-----------------------------------------------------------------------------
 //1. Стационарность
 s.append(space);
 s.append(" Stationarity: ");
 if (GetSignalStat()) s.append("SIGNAL = <On> ");
 else s.append("SIGNAL = <Off> ");
 if (GetJammerStat()) s.append("JAMMER = <On> ");
 else s.append("JAMMER = <Off> ");
 if (GetNoiseStat()) s.append("NOISE = <On>\n");
 else s.append("NOISE = <Off>\n");
return s;
}
//*****************************************************************************
//СТАТУС: I.3; public function TAnalInSignalProperty class
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit();
//НАЗНАЧЕНИЕ: Установка новых параметров объекта класса через стандартный поток
//ввода cin (>>). Формат ввода параметров аналитической модели входного сигнала
//------------------------------------------------------------------------------
//ANALYTICAL MODEL of INPUT SIGNAL: <Input Properties>
// Stationarity: Signal = <On||Off>; Jammer = <On||Off>; Noise = <On||Off>;
//------------------------------------------------------------------------------
//После ввода новых свойств аналитической модели входного сигнала осуществляется
//их отображение.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TAnalInSignalProperty::Edit()
{//Рабочие переменные
 int y, row_start = wherey();
 char c;
 string s, line(78,'-');
 bool flag;
 gotoxy(1,row_start); clreol();
 do //Цикл ввода свойств аналитической модели входного сигнала
 {//----------------------------------------------------------------------------
  cout << line << endl;
  cout << "Analytical Model of Input Signal: < Input Properties >" << endl;
  //----------------------------------------------------------------------------
  //1. Ввод признаков "стационарности" для каждого компонента входного
  //   воздействия - ПОЛЕЗНОГО СИГНАЛА, АДДИТИВНОЙ ПОМЕХИ и ВНУТРЕННЕГО ШУМА
  //----------------------------------------------------------------------------
  s = " Stationarity: "; y = wherey();
  cout << s << endl;
  cout << "   Stationarity of DESIRED SIGNAL [y/n]: "; cin >> c;
  if ((c == 'y') || (c == 'Y')) {SignalStat = ON; s.append("Signal = <On> ");}
  else {SignalStat = OFF; s.append("Signal = <Off> ");}
  ClrScr(1,y);//Очистка экрана
  cout << s << endl;
  cout << "   Stationarity of ADDITIVE JAMMER [y/n]: "; cin >> c;
  if ((c == 'y') || (c == 'Y')) {JammerStat = ON; s.append("Jammer = <On> ");}
  else {JammerStat = OFF; s.append("Jammer = <Off> ");}
  ClrScr(1,y);//Очистка экрана
  cout << s << endl;
  cout << "   Stationarity of NOISE [y/n]: "; cin >> c;
  if ((c == 'y') || (c == 'Y')) {NoiseStat = ON; s.append("Noise = <On>");}
  else {NoiseStat = OFF; s.append("Noise = <Off>");}
  ClrScr(1,y);//Очистка экрана
  cout << s << endl;
  //----------------------------------------------------------------------------
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
 cout << Properties(s,STR_NULL);
}
//*****************************************************************************
//СТАТУС: I.4; public; TAnalInSignalProperty class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: operator =(const TAnalInSignalProperty& InSignal)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ  класса TAnalInSignalProperty.
//Функция осуществляет копирование свойств одного объекта  TAnalInSignalProperty
//в другой.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TAnalInSignalProperty& InSignal - ссылка на копируемый объект.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TAnalInSignalProperty::operator =(const TAnalInSignalProperty& InSignal)
{//Предотвращение попытки присваивания объекта самому себе
 if (this == &InSignal) return;
 Reset();//Сброс ранее установленных характеристик объекта
 SignalStat = InSignal.GetSignalStat();
 JammerStat = InSignal.GetJammerStat();
 NoiseStat = InSignal.GetNoiseStat();
}
//==============================================================================
//II. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TAnalInSignalProperty
//    PROTECTED MEMBER-FUNCTION OF TAnalInSignalProperty CLASS
//==============================================================================
//*****************************************************************************
//СТАТУС: II.1., protected, TAnalInSignalProperty class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Reset();
//НАЗНАЧЕНИЕ: Начальная установка свойств аналитической модели входного сигнала.
//Начальная установка характеристик следующая:
//------------------------------------------------------------------------------
//1. SignalStat = OFF - ПОЛЕЗНЫЙ СИГНАЛ не стационарный;
//2. JammerStat = OFF - АДДИТИВНАЯ ПОМЕХА не стационарная;
//3. NoiseStat  = OFF - ВНУТРЕННИЙ ШУМ не стационарный;
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TAnalInSignalProperty::Reset()
{SignalStat = OFF;//ПОЛЕЗНЫЙ СИГНАЛ не стационарный;
 JammerStat = OFF;//АДДИТИВНАЯ ПОМЕХА не стационарная;
 NoiseStat  = OFF;//ВНУТРЕННИЙ ШУМ не стационарный;
}
//************** Конец реализации класса TAnalInSignalProperty *****************


//*****************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TInDataBaseCh
//   Класс содержит исходные данные (входные параметры) для схемы формирования
//                ОСНОВНОГО КАНАЛА на основе элементов LAA
//*****************************************************************************
//****************************************************************************
// I. ОПИСАНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРОВ КЛАССА TInDataBaseCh
//****************************************************************************
//*****************************************************************************
//СТАТУС: I.1; public; TInDataBaseCh constructor by default
//НАИМЕНОВАНИЕ ФУНКЦИИ: TInDataBaseCh()
//НАЗНАЧЕНИЕ: Конструктор  по умолчанию класса TInDataBaseCh - ВХОДНЫЕ ПАРАМЕТРЫ
//схемы  формирования  ОСНОВНОГО КАНАЛА  на основе  LAA. После завершения работы
//конструктора необходимо  УСТАНОВИТЬ  ВСЕ параметры объекта, в противном случае
//созданный  объект  класса TInDataBaseCh будет НЕРАБОТОСПОСОБЕН. Начальная ини-
//циализация членов-данных класса осуществляется функцией Reset().
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TInDataBaseCh::TInDataBaseCh()
{Reset(); //Начальная установка входных параметров ОСНОВНОГО КАНАЛА
}
//*****************************************************************************
//СТАТУС: I.2; public; TInDataBaseCh constructor with argument
//НАИМЕНОВАНИЕ ФУНКЦИИ: TInDataBaseCh(TInputSignal* InSignal)
//НАЗНАЧЕНИЕ: Конструктор с аргументами  класса TInDataBaseCh. Объект класса по-
//лучает указатель на свойства LAA, с которой он будет связан. Конструктор через
//вызов  функции Set(...) создает  исходные параметры ОСНОВНОГО КАНАЛА c подклю-
//чением ВСЕХ элементов LAA и углом сканирования ScanAngle = 0 градусов.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TInputSignal* InSignal - указатель на входное воздействие с LAA
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TInDataBaseCh::TInDataBaseCh(TInputSignal* InSignal)
{//Устанавливаем характеристики объекта с проверкой параметров
 Set(InSignal,ivector(),0,ON);
}
//*****************************************************************************
//СТАТУС: I.3; public; TInDataBaseCh constructor with argument
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// TInDataBaseCh(TInputSignal* InSignal, const ivector& Index, double Angle = 0)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TInDataBaseCh. Функция создает
//экземпляр класса TBaseChannel через вызов функции Set(...).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TInputSignal* InSignal - указатель на входное воздействие с LAA;
//2. const ivector& Index - индексы каналов LAA, подключаемые к BASE CHANNEL;
//3. double Angle (0) - положение главного лепестка относительно раскрыва LAA в
//   случае использования BFC.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TInDataBaseCh::TInDataBaseCh(TInputSignal* InSignal, const ivector& Index, double Angle)
{//Устанавливаем характеристики экземпляра класса с проверкой передаваемых
 //параметров
 Set(InSignal,Index,Angle,ON);
}
//*****************************************************************************
//СТАТУС: I.4; public; TInDataBaseCh class destructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: TInDataBaseCh
//НАЗНАЧЕНИЕ: Деструктор класса TInDataBaseCh - разрушает объект. Функция осво-
//бождает память, выделенную под хранение исходных параметров ОСНОВНОГО КАНАЛА
//на основе LAA.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TInDataBaseCh::~TInDataBaseCh()
{//Удаление всех характеристик ОСНОВНОГО КАНАЛА на основе LAA
 Reset();
}
//=============================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TInDataBaseCh
//    PUBLIC MEMBER-FUNCTION OF TInDataBaseCh CLASS
//=============================================================================
//*****************************************************************************
//СТАТУС: I.1; public; TInDataBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// void Set(TInputSignal* InSignal, const ivector& Index = ivector(),
//          double Angle = 0, bool Check = OFF);
//НАЗНАЧЕНИЕ: Установка исходных параметров ОСНОВНОГО КАНАЛА на основе LAA.
//Функция проверяет устанавливаемые параметры объекта класса при Check = ON.
//Старые характеристики перед установкой новых уничтожаются функцией Reset().
//Если указатель InSignal = NULL, то объект класса будет НЕРАБОТОСПОСОБЕН. При
//проверке передаваемых параметров (Check = ON) допускаются следующие параметры:
//1. ivector Index - НЕНУЛЕВОЙ вектор, в противном случае все элементы LAA
//   подключаются к ОСНОВНОМУ КАНАЛУ; ВСЕ ИНДЕКСЫ каналов LAA должны принадлежать
//   допустимому диапазону от 0 до OutLAA->LAAElem(), индексы не входящие в
//   указанный диапазон исключаются.
//2. Angle: -90 <= ScanAngle <= +90, в противном случае ScanAngle = 0.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TInputSignal* InSignal - указатель на входной сигнал с каналов LAA, которые
//   используются схемой формирования ОСНОВНОГО КАНАЛА;
//2. const ivector& Index (ivector()) - ссылка на вектор с индексами каналов LAA,
//   подключенных к ОСНОВНОМУ КАНАЛУ;
//3. double Angle - угол сканирования в случае использования BFC. BFC используется
//   в случае подключения нескольких каналов LAA к ОСНОВНОМУ КАНАЛУ.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TInDataBaseCh::Set(TInputSignal* InSignal, const ivector& Index, double Angle, bool Check)
{//Проверка указателя на входной сигнал с каналов LAA на NULL
 if (InSignal == NULL) return;
 //Начальная установка исходных параметров ОСНОВНОГО КАНАЛА на основе LAA
 Reset();
 //Установка новых параметров без проверки
 if (Check == OFF) {OutLAA = InSignal; Channel = Index; ScanAngle = Angle;}
 //Установка новых параметров c проверкой на корректность
 else
 {//Указатель на входное воздействие принимаемого элементами адаптивной LAA
  OutLAA = InSignal;
  //----------------------------------------------------------------------------
  //Установка индексов каналов LAA, подключенных к ОСНОВНОМУ КАНАЛУ
  //----------------------------------------------------------------------------
  Channel = Index.Unique();
  //Проверка на корректность индексов каналов LAA, подключенных к ОСНОВНОМУ КАНАЛУ
  //Установка фильтра корректных индексов
  ivector interval(2,0L); interval[1] = OutLAA->LAAElem()-1;
  TBelongClosedInterval<long,ivector> Predicate(interval);
  Channel = Channel.SubVector(Predicate);
  if (Channel.Size() == 0L) //Подключить все каналы LAA к BFC
  {Channel.Resize(OutLAA->LAAElem());
   for (ulong i = 0L; i < Channel.Size(); i++) Channel[i] = i;
  }
  //----------------------------------------------------------------------------
  //Установка угла сканирования при использовании BFC
  //----------------------------------------------------------------------------
  if (UsageBFC())
  {if ((Angle < -90.0) || (Angle > 90.0)) ScanAngle = 0;
   else ScanAngle = Angle;
  }
 }
}
//****************************************************************************************
//СТАТУС: I.2; public member-function of class TInDataBaseCh
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Properties(string& s, string& title, uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирование характеристик объекта TInDataBaseCh в строке s. Свойства ОСНОВ-
//НОГО КАНАЛА представляются в виде:
//1. ОСНОВНОЙ КАНАЛ НЕРАБОТОСПОСОБЕН - OutLAA == NULL: BASE CHANNEL: <OFF>;
//----------------------------------------------------------------------------------------
//2. К ОСНОВНОМУ КАНАЛУ подключен один элемент LAA - UsageBFC() == OFF:
// BASE CHANNEL: <SINGLE ELEMENT LAA>
//  CHANNEL = <index LAA>;
//----------------------------------------------------------------------------------------
//3. ОСНОВНОЙ КАНАЛ - СИНТЕЗИРОВАННЫЙ - UsageBFC() == ON:
// BASE CHANNEL: <SYNTHESIZED>
//  CHANNELS = <ulong value [LAA indexes switched to BFC <= 20]>;
//  SCANNING ANGLE = <real value>;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой формируются характеристики объекта;
//2. string& title - ссылка на строку с заголовком объекта;
//3. uint indent - начальное смещение строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка с исходными данными ОСНОВНОГО КАНАЛА
//****************************************************************************************
string& TInDataBaseCh::Properties(string& s, string& title, uint indent) const
{char buffer[80];
 ostrstream text (buffer, sizeof(buffer));
 string t;
 s.resize(0);
 string space(' ',indent);
 //Формирование заголовка объекта
 s.append(space);
 if (title.empty()) s.append("BASE CHANNEL: ");
 else s.append(title);
 //-----------------------------------------------------------------------------
 //1. ОСНОВНОЙ КАНАЛ НЕРАБОТОСПОСОБЕН - OutLAA == NULL:
 if (!IsReady()) {s.append("< Unconnect with Antenna Array >;\n"); return s;}
 //-----------------------------------------------------------------------------
 //2. ОСНОВНОЙ КАНАЛ использует один элемент LAA - UsageBFC() == OFF:
 if (UsageBFC() == OFF)
 {s.append("< Single element LAA >\n"); s.append(space);
  text << " CHANNEL = " << Channel[0] << ";" << endl << ends;
  s.append(text.str()); text.seekp(0);
 }
 //------------------------------------------------------------------------------
 //3. ОСНОВНОЙ КАНАЛ - СИНТЕЗИРОВАННЫЙ - UsageBFC() == ON:
 else if (UsageBFC() == ON)
 {s.append("< Synthesized >\n"); s.append(space);
  //Количество элементов LAA, подключенных к ОСНОВНОМУ КАНАЛУ
  text << " CHANNELs: " << Channel.Size() << ends;
  s.append(text.str()); text.seekp(0);
  //Формирование порядковых номеров элементов LAA, подключенных к BFC
  //(до 15 каналов)
  t = Channels(t, 15);
  s.append(" ["); s.append(t); s.append("];\n");
  //Угол сканирования СИНТЕЗИРОВАННОГО КАНАЛА
  s.append(space);
  s.append(" SCANNING ANGLE: ");
  text << ScanAngle << " [deg];" << endl << ends;
  s.append(text.str()); text.seekp(0);
 }
return s;
}
//*****************************************************************************
//СТАТУС: I.3; public function TInDataBaseCh class
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Edit();
//НАЗНАЧЕНИЕ: Установка новых параметров объекта класса через стандартный поток
//ввода cin (>>). Для ввода новых характеристик функция вызывает функцию
//GetDataFromConsole(...). Формат ввода параметров ОСНОВНОГО КАНАЛА:
//------------------------------------------------------------------------------
//BASE CHANNEL: <Input Performance>
// 1. Channel LAA [0..LAAElem()-1]:<LAA indexes switched to Base Channel>;
// 2. Scanning Angle: <0 || -90 <= Angle <= +90>.
//------------------------------------------------------------------------------
//После успешного ввода новых параметров вызывается функция SetPerformance(...)
//для установки новых значений членов-данных объекта. После ввода новых исходных
//параметров схемы формирования ОСНОВНОГО КАНАЛА осуществляется их отображение.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool Success - признак успешного ввода новых параметров
//*****************************************************************************
bool TInDataBaseCh::Edit()
{ivector LAAChannel;//Индексы каналов LAA, подключаемые к ОСНОВНОМУ КАНАЛУ
 double Angle;//Угол сканирования при использовании BeamFormer Circuit
 bool lSuccess = GetDataFromConsole(LAAChannel, Angle);
 if (lSuccess)
 {//Установка новых характеристик ОСНОВНОГО КАНАЛА
  Set(OutLAA,LAAChannel,Angle,OFF);
  string s;
  cout << Properties(s,STR_NULL);
 }
return lSuccess;
}
//*****************************************************************************
//СТАТУС: I.4; public; TInDataBaseCh class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: operator =(const TInDataBaseCh& InDataBaseCh)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ класса TInDataBaseCh.
//Функция осуществляет копирование исходных параметров схемы ОСНОВНОГО КАНАЛА из
//одного  объекта  TInDataBaseCh в другой. Осуществляется корректное копирование
//членов-данных с целью  недопущения ссылок указателей разных объектов класса на
//одно и то же место памяти.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TInDataBaseCh& Data - ссылка на копируемый объект.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TInDataBaseCh::operator =(const TInDataBaseCh& InDataBaseCh)
{//Предотвращение попытки присваивания объекта самому себе
 if (this == &InDataBaseCh) return;
 Reset();//Сброс ранее установленных характеристик объекта
 OutLAA = InDataBaseCh.GetLAA();
 Channel = InDataBaseCh.Channels();
 ScanAngle = InDataBaseCh.GetScanAngle();
}

//==============================================================================
//II. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TInDataBaseCh
//    PROTECTED MEMBER-FUNCTION OF TInDataBaseCh CLASS
//==============================================================================
//*****************************************************************************
//СТАТУС: II.1., protected, class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Reset();
//НАЗНАЧЕНИЕ: Начальная установка исходных данных схемы формирования ОСНОВНОГО
//КАНАЛА фильтра на основе LAA при конструировании и изменении его характеристик.
//Всем указателям на данные присваивается NULL. Освобождается вся динамическая
//память выделенная под хранение свойств объекта класса TInDataBaseCh.
//ПРЕДУПРЕЖДЕНИЕ: По окончании работы функции объект TInDataBaseCh становится
//НЕРАБОТОСПОСОБНЫМ. Начальная установка характеристик следующая:
//------------------------------------------------------------------------------
//1. ivector Channel - вектор нулевого размера;
//2. double ScanAngle = 0 [deg];
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TInDataBaseCh::Reset()
{//-----------------------------------------------------------------------------
 //Начальная установка исходных параметров схемы формирования ОСНОВНОГО КАНАЛА
 //-----------------------------------------------------------------------------
 OutLAA = NULL;//"Отключение" ОСНОВНОГО КАНАЛА от LAA
 ScanAngle = 0.0;
 Channel = ivector();//Номера элементов LAA основного канала фильтра
}
//*****************************************************************************
//СТАТУС: I.2; protected function TInDataBaseCh class
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetDataFromConsole(ivector& LAAChannel, double& Angle)
//НАЗНАЧЕНИЕ: Ввод новых параметров объекта класса через стандартный поток ввода
//cin (>>). Если ОСНОВНОЙ КАНАЛ не подключен к LAA (OutLAA == NULL), то ввод но-
//вых параметров объекта НЕВОЗМОЖЕН. В этом случае функция заканчивает работу с
//выдачей следующего сообщения:
//<Input Initial Data of BASE CHANNEL is impossible: Object Unconnect with LAA>.
//Для отображения результатов ввода данных используется стандартный поток вывода
//cout. При вводе характеристик ОСНОВНОГО КАНАЛА осуществляется их семантический
//анализ (проверка на корректность), исходя из следующих правил:
//1. ivector Channel - индексы каналов LAA, подключенных к ОСНОВНОМУ КАНАЛУ
//  a) 1 <= Channel.Size() <= OutLAA.LAAElem();
//  b) 0 <= Channel[i] < OutLAA.LAAElem(), для любого i.
//2. double ScanAngle - угол сканирования ОСНОВНОГО СИНТЕЗИРОВАННОГО КАНАЛА
//  a) ScanAngle = 0, если Channel.Size() == 1 - для ОДНОГО КАНАЛА;
//  b) -90 <= ScanAngle <= +90, если Channel.Size() > 1.
//Формат ввода параметров ОСНОВНОГО КАНАЛА:
//------------------------------------------------------------------------------
//BASE CHANNEL: <Input Performance>
// 1. Channel LAA [0..LAAElem()-1]:<LAA indexes switched to Base Channel>;
// 2. Scanning Angle: <0 || -90 <= Angle <= +90>.
//------------------------------------------------------------------------------
//Введенные исходные параметры ОСНОВНОГО КАНАЛА записываются в вектор IndexLAA и
//вещественную переменную Angle, передаваемые в функцию по ссылке. Функция ис-
//пользуется как вспомогательная для установки новых параметров объекта через
//стандартный поток ввода cin.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ivector& LAAChannel - ссылка на вектор с индексами каналов LAA, подключенными
//   к схеме формирования ОСНОВНОГО КАНАЛА;
//2. double& Angle - значение угла сканирования при использовании лучеобразующей
//   схемы в устройстве формирования ОСНОВНОГО КАНАЛА.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool Success - признак успешного ввода новых параметров
//*****************************************************************************
bool TInDataBaseCh::GetDataFromConsole(ivector& LAAChannel, double& Angle)
{LAAChannel = ivector(); Angle = 0;
 //-----------------------------------------------------------------------------
 //ОСНОВНОЙ КАНАЛ НЕРАБОТОСПОСОБЕН - OutLAA == NULL:
 //-----------------------------------------------------------------------------
 if (IsReady() == OFF)
 {gotoxy(1,wherey()); clreol();
  cout << "\aInput Initial Data of BASE CHANNEL is impossible !!!" << endl;
  cout << "Cause: BASE CHANNEL unconnect with LAA." << endl;
  return false;
 }
 //---------------------  ОСНОВНОЙ КАНАЛ СОЕДИНЕН С LAA ------------------------
 //1. Ввод индексов каналов LAA, подключаемых к Base Channel
 //-----------------------------------------------------------------------------
 //Рабочие переменные
 int y, row_start = wherey();
 char c;
 string s, line(78,'-');
 bool flag;

 gotoxy(1,row_start); clreol();
 do //Цикл ввода характеристик ОСНОВНОГО КАНАЛА
 {//----------------------------------------------------------------------------
  cout << line << endl;
  cout << "BASE CHANNEL: < Input Initial Data >" << endl;
  //Установка фильтра ввода номеров каналов LAA, подключаемых к BaseChannel
  bool unique = true;
  ivector interval(2,0L); interval[1] = OutLAA->LAAElem()-1;
  //Фильтр ввода индексов элементов LAA
  TBelongClosedInterval<long,ivector> Predicate(interval);
  y = wherey();
  cout << " 1. Channels LAA [0.." << interval[1] << "]: ";
  //Ввод строки индексов каналов LAA из стандартного потока ввода cin
  cin.ignore(); getline(cin,s,'\n');
  LAAChannel.GetDataFromString(s,unique,&Predicate);
  LAAChannel.BubbleSort();//Сортировка номеров каналов LAA по возрастанию
  if (LAAChannel.Size() == 0L)//Подключить все каналы LAA к ОСНОВНОМУ КАНАЛУ
  {LAAChannel.Resize(OutLAA->LAAElem());
   for (ulong i = 0L; i < LAAChannel.Size(); i++) LAAChannel[i] = i;
  }
  //Отображение результатов ввода номеров каналов LAA, подключенных к BaseChannel
  //Выводятся номера первых 20 элементов LAA и их общее количество
  ClrScr(1,y);//Очистка экрана
  if (LAAChannel.Size() == 1) cout << " 1. Channel = ";
  else cout << " 1. Channel = ";
  cout << LAAChannel.Size() << " [" << LAAChannel.ConvertToString(s,20) << "];"
       << endl;
  //----------------------------------------------------------------------------
  //1. Ввод угла сканирования для СИНТЕЗИРОВАННОГО ОСНОВНОГО КАНАЛА
  //----------------------------------------------------------------------------
  if (LAAChannel.Size() == 1L) //Основной канал не синтезированный
  {Angle = 0.0;
   cout << " 2. Scanning Angle = " << Angle << ";" << endl;
  }
  else //Основной канал - синтезированный
  {//Ввод угла сканирования
   y = wherey();
   cout << " 2. Scanning Angle [-90..+90]: "; cin >> Angle;
   //Проверка введенного значения угла сканирования
   if((Angle < -90.0) || (Angle > 90.0)) Angle = 0.0;
   ClrScr(1,y);//Очистка экрана
   cout << " 2. Scanning Angle = " << Angle << ";" << endl;
  }
  //----------------------------------------------------------------------------
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else flag = true;//Повторный ввод данных
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
return true;
}
//****************** Конец реализации класса TInDataBaseCh *********************


//*****************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TBaseChannel
//*****************************************************************************
//****************************************************************************
// I. ОПИСАНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРОВ КЛАССА TBaseChannel
//****************************************************************************
//*****************************************************************************
//СТАТУС: I.1; public; TBaseChannel constructor by default
//НАИМЕНОВАНИЕ ФУНКЦИИ: TBaseChannel()
//НАЗНАЧЕНИЕ: Конструктор по умолчанию класса TBaseChannel - ОСНОВНОЙ КАНАЛ на
//основе LAA. После завершения работы конструктора необходимо УСТАНОВИТЬ ВСЕ па-
//раметры ОСНОВНОГО КАНАЛА, в противном случае объект будет НЕРАБОТОСПОСОБЕН:
//при подаче на вход ОСНОВНОГО КАНАЛА любого входного воздействия на выходе будет
//всегда НУЛЕВОЕ ЗНАЧЕНИЕ. Начальная инициализация членов-данных класса осущест-
//вляется функцией Reset().
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TBaseChannel::TBaseChannel() : TInDataBaseCh()
{Reset(); //Начальная установка характеристик ОСНОВНОГО КАНАЛА
}
//*****************************************************************************
//СТАТУС: I.2; public; TBaseChannel constructor with argument
//НАИМЕНОВАНИЕ ФУНКЦИИ: TBaseChannel(TInputSignal* InSignal)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TBaseChannel. Объект класса полу-
//чает указатель  на  входное  воздействие с LAA. Конструктор посредством вызова
//функции  Set(...)  создает  ОСНОВНОЙ КАНАЛ c подключением ВСЕХ элементов LAA и
//углом сканирования ScanAngle = 0 градусов.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TInputSignal* InSignal - указатель на входное воздействие с LAA
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TBaseChannel::TBaseChannel(TInputSignal* InSignal) : TInDataBaseCh()
{//Устанавливаем характеристики объекта с проверкой параметров
 Set(InSignal,ivector(),0,ON);
}
//*****************************************************************************
//СТАТУС: I.3; public; constructor with argument
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// TBaseChannel(TInputSignal* InSignal, const ivector& Index, double Angle = 0)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TBaseChannel. Функция создает
//экземпляр класса TBaseChannel через вызов функции Set(...).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TInputSignal* InSignal - указатель на входное воздействие с LAA;
//2. const ivector& Index;
//3. double Angle (0) - положение главного лепестка относительно раскрыва LAA в
//   случае использования BFC.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TBaseChannel::TBaseChannel(TInputSignal* InSignal, const ivector& Index,
              double Angle) : TInDataBaseCh()
{//Устанавливаем характеристики экземпляра класса с проверкой передаваемых
 //параметров
 Set(InSignal,Index,Angle,ON);
}
//*****************************************************************************
//СТАТУС: I.4; public; TBaseChannel class destructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: TBaseChannel
//НАЗНАЧЕНИЕ: Деструктор класса TBaseChannel.
//Функция предназначена для разрушения класса. При работе функции освобождается
//память выделяемая под хранение характеристик ОСНОВНОГО КАНАЛА адаптивного
//пространственного фильтра на основе LAA.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TBaseChannel::~TBaseChannel()
{//Удаление всех характеристик ОСНОВНОГО КАНАЛА адаптивного пространственного
 //фильтра на основе LAA
 Reset();
}
//=============================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TBaseChannel
//    PUBLIC MEMBER-FUNCTION OF TBaseChannel CLASS
//=============================================================================
//*****************************************************************************
//СТАТУС: I.1; public; TBaseChannel class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// void Set(TInputSignal* InSignal, const ivector& Index = ivector(),
//          double Angle = 0, bool Check = OFF);
//НАЗНАЧЕНИЕ: Установка параметров ОСНОВНОГО КАНАЛА адаптивного пространственного
//фильтра на основе LAA. Функция позволяет проверять устанавливаемые параметры
//объекта класса при Check = ON. Старые характеристики перед установкой новых
//уничтожаются функцией Reset(). Если указатель InSignal = NULL, то объект класса
//будет НЕРАБОТОСПОСОБЕН: при любом входном воздействии на выходе ОСНОВНОГО КАНАЛА
//будет формироваться нулевая величина или вектор нулевого размера. При проверке
//передаваемых параметров (Check = ON) допускаются следующие параметры:
//1. ivector Index - НЕНУЛЕВОЙ вектор, в противном случае все элементы LAA
//   подключаются к ОСНОВНОМУ КАНАЛУ; ВСЕ ИНДЕКСЫ каналов LAA должны принадлежать
//   допустимому диапазону от 0 до OutLAA->LAAElem(), индексы не входящие в
//   указанный диапазон исключаются.
//2. Angle: -90 <= ScanAngle <= +90, в противном случае ScanAngle = 0.
//Если количество каналов LAA, подключенных к ОСНОВНОМУ КАНАЛУ, больше 1, то
//задействуется схема формирования синтезированного ОСНОВНОГО КАНАЛА. Для этой
//схемы рассчитывается лучеобразующий вектор B, который формирует пространствен-
//ное расположение основного лепестка луча в зависимости от угла Angle. При под-
//ключении к ОСНОВНОМУ КАНАЛУ одного канала LAA BFC не задействуется.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TInputSignal* InSignal - указатель на входной сигнал с каналов LAA, которые
//   используются схемой формирования ОСНОВНОГО КАНАЛА;
//2. const ivector& Index (ivector()) - ссылка на вектор с индексами каналов LAA,
//   подключенных к ОСНОВНОМУ КАНАЛУ;
//3. double Angle - угол сканирования в случае использования BFC. BFC используется
//   в случае подключения нескольких каналов LAA к ОСНОВНОМУ КАНАЛУ.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TBaseChannel::Set(TInputSignal* InSignal, const ivector& Index,
                       double Angle, bool Check)
{TInDataBaseCh::Set(InSignal,Index,Angle,Check);
 //Конструирование вектора коэффициентов лучеобразующей схемы и их расчет
 //при подключении к ОСНОВНОМУ КАНАЛУ нескольких элементов LAA
 if (UsageBFC()) CalcBeamFormerFactor();
}
//*****************************************************************************
//СТАТУС: I.2; public member-function of class TBaseChannel
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//rvector AntPatterns(double InitAngle = -90.0, double EndAngle = 90.0,
//                    double Step = 0.1, bool Deg = DEG, bool Norm = ON) const;
//НАЗНАЧЕНИЕ: Вычисление диаграммы направленности ОСНОВНОГО КАНАЛА, подключенного
//к антенной решетки в зависимости от плоскости расположения LAA (в меридиональ-
//ной или экваториальной) в секторе от InitAngle до EndAngle. Углы отсчитываются
//относительно нормали к раскрыву LAA. При расчете диаграммы направленности (ДН)
//используется функция TestSignal(...) класса InSignal, формирующая вектор напря-
//жений на элементах LAA, подключенных к ОСНОВНОМУ КАНАЛУ, при действии с задан-
//ного  направления  (по  азимуту или углу места в зависимости от положения LAA)
//источника сигнала ЕДИНИЧНОЙ МОЩНОСТИ. Изменяя положение источника сигнала в за-
//данном секторе строится ДН ОСНОВНОГО КАНАЛА. При использовании лучеобразующей
//схемы ОСНОВНЫМ КАНАЛОМ задается пространственное положение СИНТЕЗИРОВАННОГО
//ЛУЧА. В этом случае осуществляется поэлементное умножение элементов вектора B
//схемы BFC на соответствующие значения комплексных напряжений с каналов LAA,
//подключенных к ОСНОВНОМУ КАНАЛУ, затем полученные произведения СУММИРУЮТСЯ.
//Далее вычисляется норма от суммарного комплексного напряжения и определяется
//мощность сигнала на выходе ОСНОВНОГО КАНАЛА при действии источника сигнала
//ЕДИНИЧНОЙ МОЩНОСТИ. Если к ОСНОВНОМУ КАНАЛУ подключен один канал LAA, то в этом
//случае вычисляется диаграмма направленности одного элемента LAA, подключенного
//к каналу, так как угол сканирования в этом случае всегда равен 0 градусов.
// ДИАГРАММА НАПРАВЛЕННОСТИ ОСНОВНОГО КАНАЛА A(q) вычисляется:
// A(q) = SUM{ARF[i]*F(q)[i]*EXP(j(i-1)Ph[i]*B[i]) by i = 1..N},
// 1. i - i-ый элемент LAA, подключенного к ОСНОВНОМУ КАНАЛУ;
// 2. ARF[i] - относительный коэфф-т усиления i-го элемента LAA
// 3. F(q)[i] - значение нормированной диаграммы направленности i-го элемента АР
//    в направлении источника сигнала
// 4. Ph[i] - фазовый набег (сдвиг) в i-ом элементе АР по сравнению с ОСНОВНЫМ.
// Ph[i] = 2*PI*(L[i])*sin(q), L[i] - относительное расстояние между i-ым и 0-ым
// элементами АР.
// 5. B[i] - лучеобразующий коэффициент, соответствующий i-му элементу LAA. Для
//    ScanAngle = 0, B[i] = 1.
//------------------------------------------------------------------------------
//Функция может рассчитывать НОРМИРОВАННУЮ или НЕНОРМИРОВАННУЮ ДИАГРАММУ НАПРАВ-
//ЛЕННОСТИ ОСНОВНОГО КАНАЛА в зависимости от аргумента Norm. Ненормированная ДН
//- значения в единицах мощности на выходе канала, нормированная ДН вычисляется
//по формуле: G(q) = 10*log10{A(q)/Amax} [Db] - в децибелах,
// 1. q - угол между источником сигнала и нормалью к оси решетки, проходящая
//    через ОСНОВНОЙ элемент АР.
// 2. A(q) - диаграмма направленности адаптивной АР в направлении на угол q
// 3. Amax - МАКСИМАЛЬНОЕ значение диаграммы направленности адаптивной АР в сек-
//    торе от InitAngle до EndAngle.
//Все значения характеристики направленности в заданном секторе размещаются в
//векторе Data. Структура хранимых данных в векторе Data:
//Data[0] - InitAngle; Data[1] - EndAngle; Data[2] - Step; Data[3]...Data[n] -
//данные.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double InitAngle (-90 deg) - начальный угол, построения ДН ОСНОВНОГО КАНАЛА;
//2. double EndAngle (+90 deg) - конечный угол, построения ДН ОСНОВНОГО КАНАЛА;
//3. double Step - приращение угла;
//4. bool Deg (DEG) - представление угла (в градусах - DEG или радианах - RAD);
//5. bool Norm (ON) - опция нормирования ДН ОСНОВНОГО КАНАЛА в dB.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rvector Data - диаграмма направленности ОСНОВНОГО КАНАЛА
//*****************************************************************************
rvector TBaseChannel::AntPatterns(double InitAngle, double EndAngle, double Step,
                                  bool Deg, bool Norm) const
{rvector Data;
 //Проверка на возможность вычисления ДН ОСНОВНОГО КАНАЛА
 if (!IsReady()) return Data;
 ulong Total; //Количество данных, которое необходимо разместить в списке data
 if (EndAngle < InitAngle)
 {double Value = InitAngle; InitAngle = EndAngle; EndAngle = Value;}
 //Приращение угла может быть только положительным значением
 Step = fabs(Step);
 if (Step == 0.0) Step = (Deg == DEG) ? 0.1 : 0.1*DegRad;
 //Определяем количество данных, которые будут размещены в списке data
 Total = ceil((EndAngle-InitAngle)/Step);
 if (((EndAngle-InitAngle)/Step) != 0.0) Total += 1;
 //Создаем вектор Data для хранения данных
 Data.Set(Total+3,COL,0.0);
 //Заносим в список сектор определения диаграммы направленности адаптивного
 //фильтра в градусах
 if (Deg == RAD) //Перевод из радиан в градусы
 {InitAngle = InitAngle*RadDeg;
  EndAngle = EndAngle*RadDeg;
  Step = Step*RadDeg;
 }
 Data.Put(0,InitAngle); Data.Put(1,EndAngle); Data.Put(2,Step);
 double Angle = InitAngle;
 complex Usum;
 //Векторы сигнала единичной мощности (тест-сигнала) с элементов LAA, подключен-
 //ных к ОСНОВНОМУ КАНАЛУ
 cvector U(Channel.Size(),COL,OFF);
 //Определение диаграммы направленности BaseChannel в заданном секторе обзора
 for (ulong index = 3; index < Data.Size(); index++)
 {Usum = C_ZERO;
  //Входной тест-сигнал с элементов LAA, подключенных к BFC
  U = OutLAA->TestSignal(Channel,Angle,DEG,OFF);
  if (UsageBFC()) //Подключена лучеобразующая схема
  //Поэлементное умножение входного тест-сигнала с элементов LAA, подключенных
  //к BFC, на соответствующие каждому элементу фазосдвигающие коэффициенты век-
  //тора B
   for (ulong i = 0L; i < Channel.Size(); i++) Usum += U[i]*B[i];
  //К ОСНОВНОМУ КАНАЛУ подключен один элемент LAA
  else Usum = U.Get(0);
  Data.Put(index,norm(Usum));//Записываем результат в вектор Data
  Angle = Angle+Step; //Вычисляем новую величину угла
  if (fabs(Angle) < EPS) Angle = 0.0;
 } //Конец цикла по index - сектору определения ДН ОСНОВНОГО КАНАЛА
 if (Norm == ON) //Вычисление НОРМИРОВАННОЙ ДН
 {double Max = Data.Get(3);
  //Поиск максимального значения
  for (ulong index = 4; index < Data.Size(); index++)
   {if (Max < Data[index]) Max = Data.Get(index);}
  //Нормирование диаграммы направленности ОСНОВНОГО КАНАЛА
  for (ulong index = 3; index < Data.Size(); index++)
   Data.Put(index,10*log10(Data[index]/Max));
 }
return Data;
}
//*****************************************************************************
//СТАТУС: I.3,public class member-function TBaseChannel
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//rvector& DirectPattern(rvector& P, const TEvenCloseInterval& Sector,
// bool Norm = ON, bool Db = ON, double MinDb = -60.0) const;
//НАЗНАЧЕНИЕ: Вычисление диаграммы направленности ОСНОВНОГО КАНАЛА, подключенного
//к антенной решетки в плоскости расположения LAA относительно Земли (по ЭКВАТОРУ
//или МЕРИДИАНУ) в секторе Sector. Углы отсчитываются относительно нормали к рас-
//крыву LAA. При расчете диаграммы направленности (ДН) используется функция Test-
//Signal(...) класса InSignal, формирующая  вектор  напряжений на элементах LAA,
//подключенных к ОСНОВНОМУ КАНАЛУ, при действии с заданного направления (по ази-
//муту или углу места) источника  сигнала ЕДИНИЧНОЙ МОЩНОСТИ. Изменяя  положение
//источника сигнала в заданном секторе строится ДН ОСНОВНОГО КАНАЛА. При исполь-
//зовании лучеобразующей схемы ОСНОВНЫМ КАНАЛОМ задается пространственное  поло-
//жение СИНТЕЗИРОВАННОГО ЛУЧА. В этом случае осуществляется поэлементное умноже-
//ние элементов вектора B схемы BFC на соответствующие значения комплексных нап-
//ряжений с каналов LAA, подключенных к ОСНОВНОМУ КАНАЛУ, затем полученные произ-
//ведения СУММИРУЮТСЯ. Далее вычисляется норма от суммарного комплексного напря-
//жения  и определяется мощность сигнала на выходе ОСНОВНОГО КАНАЛА при действии
//источника сигнала ЕДИНИЧНОЙ МОЩНОСТИ. При подключении к ОСНОВНОМУ КАНАЛУ одного
//канала LAA вычисляется ДН одного элемента LAA, подключенного к BaseChannel,
//так как угол сканирования в этом случае всегда равен 0 градусов.
// ДИАГРАММА НАПРАВЛЕННОСТИ ОСНОВНОГО КАНАЛА A(q) вычисляется:
// A(q) = SUM{ARF[i]*F(q)[i]*EXP(j(i-1)Ph[i]*B[i]) by i = 1..N},
// 1. i - i-ый элемент LAA, подключенного к ОСНОВНОМУ КАНАЛУ;
// 2. ARF[i] - относительный коэфф-т усиления i-го элемента LAA
// 3. F(q)[i] - значение нормированной диаграммы направленности i-го элемента АР
//    в направлении источника сигнала
// 4. Ph[i] - фазовый набег (сдвиг) в i-ом элементе АР по сравнению с ОСНОВНЫМ.
// Ph[i] = 2*PI*(L[i])*sin(q), L[i] - относительное расстояние между i-ым и 0-ым
// элементами АР.
// 5. B[i] - лучеобразующий коэффициент, соответствующий i-му элементу LAA. Для
//    ScanAngle = 0, B[i] = 1.
//------------------------------------------------------------------------------
//Функция может рассчитывать НОРМИРОВАННУЮ или НЕНОРМИРОВАННУЮ ДИАГРАММУ НАПРАВ-
//ЛЕННОСТИ ОСНОВНОГО КАНАЛА в зависимости от аргумента Norm. Ненормированная ДН
//- значения в единицах мощности на выходе канала, нормированная ДН вычисляется
//по формуле: G(q) = 10*log10{A(q)/Amax} [Db] - в децибелах,
// 1. q - угол между источником сигнала и нормалью к оси решетки, проходящая
//    через ОСНОВНОЙ элемент АР.
// 2. A(q) - диаграмма направленности адаптивной АР в направлении на угол q
// 3. Amax - МАКСИМАЛЬНОЕ значение диаграммы направленности адаптивной АР в сек-
//    торе от InitAngle до EndAngle.
//Значения ДН ОСНОВНОГО КАНАЛА в заданном секторе размещаются в векторе P.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор мощностей основного канала в заданном секторе;
//2. const TEvenCloseInterval& Sector - сектор по углу места (азимуту), в  кото-
//   ром рассчитывается диаграмма направленности BaseChannel (в градусах);
//3. bool Norm (ON) - опция нормирования выходных мощностей канала [0..1];
//4. bool Db (ON) - опция нормирования в децибелах (действует при Norm = ON);
//5. double MinDb - минимальный уровень в децибелах (действует при Db = ON).
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rvector& P - распределение мощности ОСНОВНОГО КАНАЛА в заданном секторе.
//*****************************************************************************
rvector& TBaseChannel::DirectPattern(rvector& P, const TEvenCloseInterval& Sector,
         bool Norm, bool Db, double MinDb) const
{//Проверка на возможность вычисления ДН ОСНОВНОГО КАНАЛА
 if (!IsReady()) {P.Resize(0); return P;}
 //Создаем вектор P для хранения данных
 P.Resize(Sector.Size());
 complex Usum;
 //Векторы сигнала единичной мощности (тест-сигнала) с элементов LAA, подключен-
 //ных к ОСНОВНОМУ КАНАЛУ
 cvector U(Channel.Size(),COL,OFF);
 //Определение диаграммы направленности BaseChannel в заданном секторе обзора
 for (ulong k = 0L; k < P.Size(); k++)
 {Usum = C_ZERO;
  //Входной тест-сигнал с элементов LAA, подключенных к BFC
  U = OutLAA->TestSignal(Channel,Sector(k),DEG,OFF);
  if (UsageBFC()) //Подключена лучеобразующая схема
  //Поэлементное умножение входного тест-сигнала с элементов LAA, подключенных
  //к BFC, на соответствующие каждому элементу фазосдвигающие коэффициенты век-
  //тора B
   for (ulong i = 0L; i < Channel.Size(); i++) Usum += U.Get(i)*B.Get(i);
  //К ОСНОВНОМУ КАНАЛУ подключен один элемент LAA
  else Usum = U.Get(0);
  P.Put(k,norm(Usum));//Записываем результат в вектор P
 } //Конец цикла по k - сектору определения ДН ОСНОВНОГО КАНАЛА

 if (Norm == ON) //Вычисление НОРМИРОВАННОЙ ДН
 {//Поиск максимального значения
  double MaxPower = P.Get(0);
  for (ulong i = 1L; i < P.Size(); i++)
  {if (MaxPower < P.Get(i)) MaxPower = P.Get(i);}
  //Нормирование диаграммы направленности ОСНОВНОГО КАНАЛА [0..1]
  if (MaxPower != 0.0)
   for (ulong i = 0L; i < P.Size(); i++) P.Put(i, P.Get(i)/MaxPower);
  //Нормирование ДН ОСНОВНОГО КАНАЛА в децибелах [0..MinDb]
  if (Db == ON)
  {double Power;
   MinDb = (MinDb >= 0.0) ? -60.0 : MinDb;
   for (ulong i = 0L; i < P.Size(); i++)
   {Power = 10*log10(P.Get(i));
    Power = (Power < MinDb) ? MinDb : Power;
    P.Put(i,Power);
   }
  }
 }
return P;
}
//*****************************************************************************
//СТАТУС: I.4; public member-function of class TBaseChannel
//НАИМЕНОВАНИЕ ФУНКЦИИ: double Directivity(double Angle, bool Deg = DEG) const
//НАЗНАЧЕНИЕ: Вычисление направленности ОСНОВНОГО КАНАЛА, подключенного к LAA в
//зависимости от плоскости ее расположения в направлении на Angle. Угол отсчиты-
//вается относительно нормали к раскрыву LAA. При расчете направленности исполь-
//зуется функция TestSignal(...) класса InSignal, формирующая вектор напряжений
//на элементах LAA, подключенных к ОСНОВНОМУ КАНАЛУ, при действии с заданного
//направления Angle (по  азимуту или углу места в зависимости от положения LAA)
//источника сигнала ЕДИНИЧНОЙ МОЩНОСТИ. При использовании лучеобразующей схемы
//ОСНОВНЫМ КАНАЛОМ задается пространственное положение СИНТЕЗИРОВАННОГО ЛУЧА. В
//этом случае осуществляется поэлементное умножение элементов вектора B схемы BFC
//на соответствующие значения комплексных напряжений с каналов LAA, подключенных
//к ОСНОВНОМУ КАНАЛУ, затем полученные произведения СУММИРУЮТСЯ. Далее вычисляет-
//ся норма от суммарного комплексного напряжения и определяется мощность сигнала
//на выходе ОСНОВНОГО КАНАЛА при действии источника сигнала ЕДИНИЧНОЙ МОЩНОСТИ.
//Если к ОСНОВНОМУ КАНАЛУ подключен один канал LAA, то вычисляется направленность
//одного элемента LAA, подключенного к каналу, так как угол сканирования в этом
//случае всегда равен 0 градусов, то умножение на лучеобразующий коэффициент не
//требуется. НАПРАВЛЕННОСТЬ ОСНОВНОГО КАНАЛА A(q) вычисляется:
// A(q) = SUM{ARF[i]*F(q)[i]*EXP(j(i-1)Ph[i]*B[i]) by i = 1..N},
// 1. q - угол Angle, для которого рассчитывается направленность основного канала
// 2. i - i-ый элемент LAA, подключенного к ОСНОВНОМУ КАНАЛУ;
// 3. ARF[i] - относительный коэфф-т усиления i-го элемента LAA
// 4. F(q)[i] - значение нормированной диаграммы направленности i-го элемента АР
//    в направлении источника сигнала
// 5. Ph[i] - фазовый набег (сдвиг) в i-ом элементе АР по сравнению с ОСНОВНЫМ.
// Ph[i] = 2*PI*(L[i])*sin(q), L[i] - относительное расстояние между i-ым и 0-ым
// элементами АР.
// 6. B[i] - лучеобразующий коэффициент, соответствующий i-му элементу LAA. Для
//    ScanAngle = 0, B[i] = 1.
//Направленность ОСНОВНОГО КАНАЛА рассчитывается в единицах мощности.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double Angle - угол относительно раскрыва LAA, для которого вычисляется
//   направленность ОСНОВНОГО КАНАЛА;
//2. bool Deg (DEG) - представление угла (в градусах - DEG или радианах - RAD)
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// double Power - направленность ОСНОВНОГО КАНАЛА в направлении на угол Angle
//*****************************************************************************
double TBaseChannel::Directivity(double Angle, bool Deg) const
{double Power = 0;
 //Проверка на возможность вычисления значения направленности ОСНОВНОГО КАНАЛА
 //в направлении на угол Angle
 if (!IsReady()) return Power;
 complex Usum = C_ZERO;
 //Вектор сигнала единичной мощности (тест-сигнал) с элементов LAA, подключен-
 //ных к ОСНОВНОМУ КАНАЛУ
 cvector U(Channel.Size(),COL,OFF);
 //Определение значения направленности BaseChannel
 //Входной тест-сигнал с элементов LAA, подключенных к BFC
 U = OutLAA->TestSignal(Channel,Angle,Deg,OFF);
 if (UsageBFC()) //Подключена лучеобразующая схема
 //Поэлементное умножение входного тест-сигнала с элементов LAA, подключенных
 //к BFC, на соответствующие каждому элементу фазосдвигающие коэффициенты B
 for (ulong i = 0L; i < Channel.Size(); i++) Usum += U.Get(i)*B.Get(i);
 //К ОСНОВНОМУ КАНАЛУ подключен один элемент LAA
 else Usum = U.Get(0);
 Power = norm(Usum);//Значение направленности
return Power;
}
//------------------------------------------------------------------------------
//             ПЕРЕДАТОЧНЫЕ ФУНКЦИИ ОСНОВНОГО КАНАЛА
// Реализация функций расчета выходных значений комплексных напряжений и
//    их векторов ОСНОВНОГО КАНАЛА в зависимости от входных значений
//------------------------------------------------------------------------------
//*****************************************************************************
//СТАТУС: I.5; public member-function of class TBaseChannel
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool TFunc(cvector& Out, const rvector& Angle, bool Abs = ON) const
//НАЗНАЧЕНИЕ: Вычисление передаточной функции ОСНОВНОГО канала при действии сиг-
//нала ЕДИНИЧНОЙ мощности с заданных направлений. Направления источников сигнала
//передаются в векторе Angle в градусах. Для каждого направления рассчитывается
//передаточная функция, результаты заносятся в комплексный вектор Out. Размеры
//вектора Out соответствуют размерам вектора Angle. Содержимое и размеры вектора
//Out изменяются в ходе работы функции.
//Функция возвращает false, если ОСНОВНОЙ канал НЕРАБОТОСПОСОБЕН либо, когда
//вектор Angle - вектор нулевого размера. Во всех остальных случаях функция воз-
//вращает true и формирует в результирующем векторе Out выходные комплексные
//значения напряжений ОСНОВНОГО канала для заданных в векторе Angle направлений
//расположения источников сигналов относительно раскрыва LAA в градусах.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& Out - ссылка на результирующий вектор;
//2. rvector& Angle - вектор с направлениями на источники сигналов относительно
//   раскрыва LAA, для которого вычисляется передаточная функция ОСНОВНОГО КАНАЛА.
//3. bool Abs (ON) - опция вычисления направленности синтезированного ОСНОВНОГО
//   КАНАЛА по абсолютному значению (направленность антенны)
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат вычислений
//*****************************************************************************
bool TBaseChannel::TFunc(cvector& Out, const rvector& Angle, bool Abs) const
{//Проверка на возможность вычисления значений направленности ОСНОВНОГО КАНАЛА
 if ((!IsReady()) || (Angle.Size() == 0L))
 {Out.Resize(0L); return false;}
 //Создаем результирующий вектор Out необходимой размерности
 Out.Resize(Angle.Size());
 //Вектор сигнала единичной мощности (тест-сигнал) с элементов LAA, подключен-
 //ных к ОСНОВНОМУ КАНАЛУ
 cvector U(Channel.Size(),COL,OFF);
 complex Uout;
 //Определение значения направленностей BaseChannel для всех направлений в Angle
 for (ulong k = 0L; k < Angle.Size(); k++)
 {//Входной тест-сигнал с элементов LAA, подключенных к BFC
  U = OutLAA->TestSignal(Channel,Angle.Get(k),DEG,OFF);
  Uout = C_ZERO;
  if (UsageBFC()) //Подключена лучеобразующая схема
  {for (ulong i = 0L; i < Channel.Size(); i++) Uout += U.Get(i)*B.Get(i);
   if (Abs == ON) Uout = complex(abs(Uout),0);
  }
  else Uout = U.Get(0); //К ОСНОВНОМУ КАНАЛУ подключен один элемент LAA
  Out.Put(k,Uout);
 }
return true;
}
//*****************************************************************************
//СТАТУС: I.6; public member-function of class TBaseChannel
//OVERLOAD CALL FUNCTION OPERATION ()
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// complex operator() (double Angle, bool Deg = DEG, bool Abs = ON) const
//НАЗНАЧЕНИЕ: Вычисление передаточной функции ОСНОВНОГО канала при действии сиг-
//нала ЕДИНИЧНОЙ мощности с заданного направления. Работа функции аналогична
//функции Directivity(...). Результат работы функции - комплексная величина Uout
//(выходное значение ОСНОВНОГО КАНАЛА).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double Angle - угол относительно раскрыва LAA, для которого вычисляется
//   передаточная функция ОСНОВНОГО КАНАЛА;
//2. bool Deg (DEG) - представление угла (в градусах - DEG или радианах - RAD)
//3. bool Abs (ON) - опция вычисления направленности синтезированного ОСНОВНОГО
//   КАНАЛА по абсолютному значению (направленность антенны)
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex Uout - выходное значение ОСНОВНОГО КАНАЛА
//*****************************************************************************
complex TBaseChannel::operator() (double Angle, bool Deg, bool Abs) const
{complex Uout = C_ZERO;
 //Проверка на возможность вычисления значения направленности ОСНОВНОГО КАНАЛА
 //в направлении на угол Angle
 if (!IsReady()) return Uout;
 //Вектор сигнала единичной мощности (тест-сигнал) с элементов LAA, подключен-
 //ных к ОСНОВНОМУ КАНАЛУ
 cvector U(Channel.Size(),COL,OFF);
 //Определение значения направленности BaseChannel
 //Входной тест-сигнал с элементов LAA, подключенных к BFC
 U = OutLAA->TestSignal(Channel,Angle,Deg,OFF);
 if (UsageBFC()) //Подключена лучеобразующая схема
 {//Поэлементное умножение входного тест-сигнала с элементов LAA, подключенных
  //к BFC, на соответствующие каждому элементу фазосдвигающие коэффициенты B
  for (ulong i = 0L; i < Channel.Size(); i++) Uout += U.Get(i)*B.Get(i);
  if (Abs == ON) Uout = complex(abs(Uout),0);
 }
 //К ОСНОВНОМУ КАНАЛУ подключен один элемент LAA
 else Uout = U.Get(0);
return Uout;
}
//*****************************************************************************
//СТАТУС: I.7; public member-function of class TBaseChannel
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex CalcSignal(bool PolarType) const
//НАЗНАЧЕНИЕ: Расчет ПОЛЕЗНОГО СИГНАЛА на выходе ОСНОВНОГО КАНАЛА, подключенного
//к LAA, для  заданного вида поляризации PolarType. Функция за счет прямого дос-
//тупа к векторам входного сигнала позволяет сократить время расчета выходных
//значений полезного сигнала ОСНОВНОГО КАНАЛА. Функция используeтся только в
//аналитической модели адаптивной LAA с выделенным каналом.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: bool PolarType - поляризационная составляющая ПОЛЕЗНОГО
// СИГНАЛА, которую необходимо рассчитать на выходе ОСНОВНОГО КАНАЛА.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex Us - полезный сигнал на выходе ОСНОВНОГО КАНАЛА
// с заданным видом поляризации
//*****************************************************************************
complex TBaseChannel::CalcSignal(bool PolarType) const
{complex Us = C_ZERO;
 //Проверка работоспособности ОСНОВНОГО КАНАЛА
 if (!IsReady()) return Us;
 const cvector* Signal =
 (PolarType == VP_SIGNAL) ? OutLAA->GetVPSignal() : OutLAA->GetHPSignal();
 if (UsageBFC()) //Подключена лучеобразующая схема
 {for (ulong i = 0L; i < Channel.Size(); i++)
   Us += Signal->Get(Channel.Get(i))*B.Get(i);
  Us = complex(abs(Us),0);
 }
 //К ОСНОВНОМУ КАНАЛУ подключен один элемент LAA
 else Us = Signal->Get(Channel.Get(0));
return Us;
}
//*****************************************************************************
//СТАТУС: I.8; public member-function of class TBaseChannel
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex CalcNoise(bool PolarType) const
//НАЗНАЧЕНИЕ: Расчет ВНУТРЕННЕГО ШУМА на  выходе ОСНОВНОГО КАНАЛА, подключенного
//к LAA, для  заданного вида поляризации PolarType. Функция за счет прямого дос-
//тупа к векторам входного сигнала позволяет сократить время расчета выходных
//значений внутреннего шума ОСНОВНОГО КАНАЛА. Функция используется только в
//аналитической модели адаптивной LAA с выделенным каналом.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: bool PolarType - поляризационная составляющая ВНУТРЕН-
// НЕГО ШУМА, которую необходимо рассчитать на выходе ОСНОВНОГО КАНАЛА.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex Us - внутренний шум на выходе ОСНОВНОГО КАНАЛА
// с заданным видом поляризации
//*****************************************************************************
complex TBaseChannel::CalcNoise(bool PolarType) const
{complex Unoise = C_ZERO;
 //Проверка работоспособности ОСНОВНОГО КАНАЛА
 if (!IsReady()) return Unoise;
 const cvector* Noise =
 (PolarType == VP_SIGNAL) ? OutLAA->GetVPNoise() : OutLAA->GetHPNoise();
 if (UsageBFC()) //Подключена лучеобразующая схема
 {for (ulong i = 0L; i < Channel.Size(); i++)
   Unoise += Noise->Get(Channel.Get(i)); //Noise->Get(index)*B.Get(i)
  Unoise = complex(sqrt(abs(Unoise)),0);
 }
 //К ОСНОВНОМУ КАНАЛУ подключен один элемент LAA
 else Unoise = Noise->Get(Channel.Get(0));
return Unoise;
}
//*****************************************************************************
//СТАТУС: I.9; public member-function of class TBaseChannel
//НАИМЕНОВАНИЕ ФУНКЦИИ: void CalcJammers(cvector& Jammers, bool PolarType) const
//НАЗНАЧЕНИЕ: Покомпонентный  расчет АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ на выходе ОСНОВ-
//НОГО КАНАЛА, подключенного к LAA, для заданного вида поляризации PolarType.
//Функция за счет прямого доступа  к матрицам аддитивной помехи позволяет сокра-
//тить время расчета всех компонент  помехи на выходе ОСНОВНОГО КАНАЛА. Вычислен-
//ные значения помещаются в вектор Jammers, передаваемый по ссылке. Размерность
//вектора должна соответствовать количеству активных помех (число столбцов мат-
//риц HPJammer & VPJammer). Функция используется аналитической модели адаптивной
//LAA.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: bool PolarType - поляризационная составляющая компонент
// активной помехи, которые необходимо рассчитать на выходе ОСНОВНОГО КАНАЛА.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TBaseChannel::CalcJammers(cvector& Jammers, bool PolarType) const
{//Проверка работоспособности ОСНОВНОГО КАНАЛА
 if (!IsReady()) {Jammers = C_ZERO; return;}
 const cmatrix* Jammer =
 (PolarType == VP_SIGNAL) ? OutLAA->GetVPJammer() : OutLAA->GetHPJammer();
 //Проверка соответствия размерности вектора Jammers количеству компонент
 //аддитивной активной помехи
 if (Jammers.Size() != Jammer->Cols()) Jammers.Resize(Jammer->Cols());
 ulong index = Channel.Get(0);
 complex sum;
 if (UsageBFC()) //Подключена лучеобразующая схема
  for (ulong j = 0L; j < Jammers.Size(); j++)
  {sum = C_ZERO;
   for (ulong i = 0L; i < Channel.Size(); i++)
   {index = Channel.Get(i); sum += Jammer->Get(index,j)*B.Get(i);}
   sum = complex(abs(sum),0);
   Jammers.Put(j,sum);
  }
 else //К ОСНОВНОМУ КАНАЛУ подключен один элемент LAA
  for (ulong j = 0L; j < Jammers.Size(); j++)
   Jammers.Put(j,Jammer->Get(index,j));
}
//*****************************************************************************
//СТАТУС: I.10; public member-function of class TBaseChannel
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex CalcStatSignal(bool PolarType) const
//НАЗНАЧЕНИЕ: Расчет ПОЛЕЗНОГО СИГНАЛА на выходе ОСНОВНОГО КАНАЛА, подключенного
//к LAA, для  заданного вида поляризации PolarType. Функция за счет прямого дос-
//тупа к векторам входного сигнала позволяет сократить время расчета выходных
//значений полезного сигнала ОСНОВНОГО КАНАЛА. Функция используeтся только в
//статистической модели адаптивной LAA с выделенным каналом.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: bool PolarType - поляризационная составляющая ПОЛЕЗНОГО
// СИГНАЛА, которую необходимо рассчитать на выходе ОСНОВНОГО КАНАЛА.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex Us - полезный сигнал на выходе ОСНОВНОГО КАНАЛА
// с заданным видом поляризации
//*****************************************************************************
complex TBaseChannel::CalcStatSignal(bool PolarType) const
{complex Us = C_ZERO;
 //Проверка работоспособности ОСНОВНОГО КАНАЛА
 if (!IsReady()) return Us;
 const cvector* Signal =
 (PolarType == VP_SIGNAL) ? OutLAA->GetVPSignal() : OutLAA->GetHPSignal();
 if (UsageBFC()) //Подключена лучеобразующая схема
  for (ulong i = 0L; i < Channel.Size(); i++)
   Us += Signal->Get(Channel.Get(i))*B.Get(i);
 //К ОСНОВНОМУ КАНАЛУ подключен один элемент LAA
 else Us = Signal->Get(Channel.Get(0));
return Us;
}
//*****************************************************************************
//СТАТУС: I.11; public member-function of class TBaseChannel
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex CalcNoise(bool PolarType) const
//НАЗНАЧЕНИЕ: Расчет ВНУТРЕННЕГО ШУМА на  выходе ОСНОВНОГО КАНАЛА, подключенного
//к LAA, для  заданного вида поляризации PolarType. Функция за счет прямого дос-
//тупа к векторам входного сигнала позволяет сократить время расчета выходных
//значений внутреннего шума ОСНОВНОГО КАНАЛА. Функция используется только в
//статистической модели адаптивной LAA с выделенным каналом.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: bool PolarType - поляризационная составляющая ВНУТРЕН-
// НЕГО ШУМА, которую необходимо рассчитать на выходе ОСНОВНОГО КАНАЛА.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex Us - внутренний шум на выходе ОСНОВНОГО КАНАЛА
// с заданным видом поляризации
//*****************************************************************************
complex TBaseChannel::CalcStatNoise(bool PolarType) const
{complex Unoise = C_ZERO;
 //Проверка работоспособности ОСНОВНОГО КАНАЛА
 if (!IsReady()) return Unoise;
 const cvector* Noise =
 (PolarType == VP_SIGNAL) ? OutLAA->GetVPNoise() : OutLAA->GetHPNoise();
 if (UsageBFC()) //Подключена лучеобразующая схема
  for (ulong i = 0L; i < Channel.Size(); i++)
   Unoise += Noise->Get(Channel.Get(i)); //Noise->Get(index)*B.Get(i)
 //К ОСНОВНОМУ КАНАЛУ подключен один элемент LAA
 else Unoise = Noise->Get(Channel.Get(0));
return Unoise;
}
//*****************************************************************************
//СТАТУС: I.12; public member-function of class TBaseChannel
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex CalcStatJammer(bool PolarType) const
//НАЗНАЧЕНИЕ: Расчет суммарного действия АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ на выходе
//ОСНОВНОГО КАНАЛА, подключенного к LAA, с заданным видом поляризации PolarType.
//Функция за счет прямого доступа  к матрицам аддитивной помехи позволяет сокра-
//тить время расчета суммарного действия аддитивной помехи на выходе ОСНОВНОГО
//КАНАЛА. Функция используется только в СТАТИСТИЧЕСКИХ моделях адаптивных LAA.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:bool PolarType - поляризационная составляющая аддитивной
// активной помехи, которую необходимо рассчитать на выходе ОСНОВНОГО КАНАЛА.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
complex TBaseChannel::CalcStatJammer(bool PolarType) const
{complex Ujam = C_ZERO;
 //Проверка работоспособности ОСНОВНОГО КАНАЛА
 if (!IsReady()) return Ujam;
 const cmatrix* Jammer =
 (PolarType == VP_SIGNAL) ? OutLAA->GetVPJammer() : OutLAA->GetHPJammer();
 ulong index = Channel.Get(0);
 if (UsageBFC()) //Подключена лучеобразующая схема
 {complex Usum;
  for (ulong i = 0L; i < Channel.Size(); i++)
  {Usum = C_ZERO; index = Channel.Get(i);
   //Сложение всех активных помех для i-го канала LAA, подключенного к BFC
   for (ulong j = 0L; j < Jammer->Cols(); j++) Usum += Jammer->Get(index,j);
   Ujam += Usum*B.Get(i);
  }
 }
 else //К ОСНОВНОМУ КАНАЛУ подключен один элемент LAA
  for (ulong j = 0L; j < Jammer->Cols(); j++) Ujam += Jammer->Get(index,j);
return Ujam;
}
//****************************************************************************************
//СТАТУС: I.13; public function TBaseChannel class
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Edit();
//НАЗНАЧЕНИЕ: Редактирование свойств объекта класса через стандартный поток ввода cin (>>).
//Для ввода новых характеристик функция вызывает функцию GetDataFromConsole(...). Формат
//ввода параметров ОСНОВНОГО КАНАЛА:
//----------------------------------------------------------------------------------------
//BASE CHANNEL: <Input Performance>
// 1. Channel LAA [0..LAAElem()-1]:<LAA indexes switched to Base Channel>;
// 2. Scanning Angle: <0 || -90 <= Angle <= +90>.
//----------------------------------------------------------------------------------------
//После успешного ввода свойств объекта вызывается функция Set(...) для установки новых
//значений членов-данных объекта. После ввода новых исходных параметров схемы формирования
//ОСНОВНОГО КАНАЛА осуществляется их отображение.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool Success - признак успешного ввода новых параметров
//****************************************************************************************
bool TBaseChannel::Edit()
{ivector LAAChannel;//Индексы каналов LAA, подключаемые к ОСНОВНОМУ КАНАЛУ
 double Angle;//Угол сканирования при использовании BeamFormer Circuit
 bool lSuccess = GetDataFromConsole(LAAChannel, Angle);
 if (lSuccess)
 {//Установка новых характеристик ОСНОВНОГО КАНАЛА
  Set(OutLAA,LAAChannel,Angle,OFF);
  string s;
  cout << Properties(s,STR_NULL);
 }
return lSuccess;
}
//*****************************************************************************
//СТАТУС: I.14; public; TBaseChannel class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: operator =(const TBaseChannel& BaseCh)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ класса BaseChannel.
//Функция  осуществляет  копирование  характеристик схемы формирования ОСНОВНОГО
//КАНАЛА из одного объекта TBaseChannel  в другой. Осуществляется корректное ко-
//пирование членов-данных с целью  недопущения ссылок указателей разных объектов
//класса на одно и то же место памяти.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TBaseChannel& BaseCh - ссылка на копируемый объект.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TBaseChannel::operator =(const TBaseChannel& BaseCh)
{//Предотвращение попытки присваивания объекта самому себе
 if (this == &BaseCh) return;
 Reset();//Сброс ранее установленных характеристик объекта
 OutLAA = BaseCh.GetLAA();
 Channel = BaseCh.Channels();
 ScanAngle = BaseCh.GetScanAngle();
 if (BaseCh.UsageBFC()) B = BeamFormerVector();
}
//*****************************************************************************
//СТАТУС: I.15; public; TBaseChannel class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: operator =(const TInDataBaseCh& InData)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ классу BaseChannel исходных
//параметров через класс TInDataBaseCh. В начале работы функция вызывает функцию
//Reset(), сбрасывая установленные ранее характеристики ОСНОВНОГО КАНАЛА, а за-
//тем вызывается функция Set(...).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TInDataBaseCh& InData - ссылка на объект TInDataBaseCh c исходными
//   параметрами схемы формирования ОСНОВНОГО КАНАЛА на основе LAA.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TBaseChannel::operator =(const TInDataBaseCh& InData)
{Reset();//Сброс ранее установленных характеристик объекта
 //Установка характеристик ОСНОВНОГО КАНАЛА с новыми исходными параметрами
 Set(InData.GetLAA(), InData.Channels(), InData.GetScanAngle(), OFF);
}

//==============================================================================
//II. РЕАЛИЗАЦИЯ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TBaseChannel
//    PRIVATE MEMBER-FUNCTION OF TBaseChannel CLASS
//==============================================================================
//*****************************************************************************
//СТАТУС: II.1., private, class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Reset();
//НАЗНАЧЕНИЕ: Начальная  установка характеристик ОСНОВНОГО КАНАЛА LAA при конст-
//руировании и  изменении его  характеристик. Всем указателям на данные присваи-
//вается  NULL. Освобождается  вся  динамическая  память выделенная под хранение
//свойств объекта класса TBaseChannel.
//ПРЕДУПРЕЖДЕНИЕ: После  выполнения данной функции объект TBaseChannel становится
//НЕРАБОТОСПОСОБНЫМ. Начальная установка характеристик следующая:
//------------------------------------------------------------------------------
//1. ivector Channel - вектор нулевого размера;
//2. double ScanAngle = 0 [deg];
//3. cvector B - вектор нулевого размера;
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
void TBaseChannel::Reset()
{TInDataBaseCh::Reset();
 B = cvector();//Коэффициенты лучеобразующей схемы - BeamFormer Circuit
}
//****************************************************************************************
//СТАТУС: II.2., private, TBaseChannel class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void CalcBeamFormerFactor();
//НАЗНАЧЕНИЕ: Расчет коэффициентов лучеобразующей схемы ОСНОВНОГО КАНАЛА при ее использо-
//вании. Коэффициенты задают положение главного лепестка СИНТЕЗИРОВАННОГО ОСНОВНОГО КАНАЛА.
//Комплексно-сопряженные коэффициенты хранятся в векторе B. Функция рассчитывает фазосдви-
//гающие коэффициенты для элементов LAA, подключаемые к схеме формирования ОСНОВНОГО КАНАЛА
//адаптивного пространственного фильтра на основе LAA. Индексы элементов LAA, подключаемые
//к BaseChannel хранятся в векторе Channel.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TBaseChannel::CalcBeamFormerFactor()
{//Установка характеристик лучеобразующего вектора
 B.Set(Channel.Size(),COL,false);
 //Расчет коэффициентов лучеобразующего вектора
 if (ScanAngle == 0.0)
  for (ulong i = 0; i < B.Size(); i++) B.Put(i,C_ONE);
 else
 {double Const = -TwoPI * sin(ScanAngle * DegRad);
  for (ulong i = 0; i < B.Size(); i++)
   B.Put(i,polar(1, Const * OutLAA->GetL(Channel[i])));
 }
}
//****************** Конец реализации класса TBaseChannel **********************
//******************************************************************************
//                РЕАЛИЗАЦИЯ КЛАССА TASpaceFilterBaseCh
//      Численная модель адаптивной антенной линейной антенной решетки с
//               пространственным фильтром и ОСНОВНЫМ каналом.
//******************************************************************************
//==============================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TASpaceFilterBaseCh
//   PUBLIC MEMBER-FUNCTION OF TASpaceFilterBaseCh CLASS
//==============================================================================
//*****************************************************************************
//СТАТУС: I.1; TASpaceFilterBaseCh public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//string& Properties(string& s, string& title = string(), uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта TASpaceFilterBaseCh в виде строки.
//Функция формирует строковое представление свойств аналитической модели фильтра
//с предпроцессором и свойств входного воздействия. Информация заносится в строку
//s, передаваемую в функцию по ссылке, предыдущее содержимое строки уничтожается.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& title - ссылка на строку с заголовком объекта;
//3. uint indent - начальное смещение строки.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//*****************************************************************************
string& TASpaceFilterBaseCh::Properties(string& s, string& title, uint indent)
const
{string t;
 string header;
 string space(' ',indent);
 s.resize(0);
 //Формирование заголовка объекта
 s.append(space);
 if (title.empty())
  s.append("ANALYTICAL ADAPTIVE LINEAR ANTENNA ARRAY with BASE CHANNEL: ");
 else s.append(title);
 //-----------------------------------------------------------------------------
 //Анализ работоспособности адаптивной LAA
 //-----------------------------------------------------------------------------
 if (!IsReady()) s.append("< Off >\n"); //АДАПТИВНАЯ LAA НЕРАБОТОСПОСОБНА
 else s.append("< On >\n");
 //-----------------------------------------------------------------------------
 //1. Формирование свойств аналитической модели предпроцессора
 header = "I. Adaptive LAA Preprocessor ";
 s.append(TAnalPreProcSFilterBaseCh::Properties(t,header,indent+1));
 //-----------------------------------------------------------------------------
 //2. Формирование свойств пространственного фильтра (весового сумматора)
 header = "II. Space Filter";
 if (Filter == NULL) //Фильтр не подключен к адаптивной LAA
 {s.append(space);s.append(1,' ');
  s.append(header+": < Off >\n"); s.append(space);
  s.append("  Cause: Filter didn't switched to Adaptive LAA.\n");
 }
 else s.append(Filter->Properties(t,header,indent+1)); //Фильтр подключен
 //------------------------------------------------------------------------------
 //3. Формирование свойств входного воздействия
 header = "III. Input Signal ";
 s.append(TAnalInSignalProperty::Properties(t,header,indent+1));
return s;
}
//******************************************************************************
//СТАТУС: I.2; TASpaceFilterBaseCh public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit()
//НАЗНАЧЕНИЕ: Редактирование свойств объекта класса через стандартный поток
//ввода cin (консольный ввод данных).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TASpaceFilterBaseCh::Edit()
{//-----------------------------------------------------------------------------
 //ПРЕДПРОЦЕССОР ПРОСТРАНСТВЕННОГО ФИЛЬТРА НЕРАБОТОСПОСОБЕН:
 //редактирование свойств объекта нецелесообразно
 //-----------------------------------------------------------------------------
 if (!IsPreProcessorReady())
 {gotoxy(1,wherey()); clreol();
  cout << "Edition ANALYTICAL MODEL of ADAPTIVE LAA is impossible !!!\a\n";
  TInputSignal* LAA = GetLAA();
  if (LAA == NULL)
   cout << "Cause: PREPROCESSOR unconnect with LAA." << endl;
  else if (LAA->LAAElem() < 2)
   cout << "Cause: LAA channels less than 2." << endl;
  return;
 }
 STR_UINT Option[5] = {
  {1, "Edit < Preprocessor >" },
  {2, "Edit < Space Filter >" },
  {3, "Edit < InPut Signal >" },
  {4, "View < Properties   >" },
  {5, "Exit                 " } };
 TB_STR_UINT Menu = {5, Option};
 string head = " Choice menu option [1-5]: ";
 //Рабочие переменные
 int y_start = wherey();
 string line(78,'-');
 const string msg = "Press any key...";
 const string s = "Analytical Model of ADAPTIVE LAA: < Editing >";
 string t;
 bool flag = true;
 gotoxy(1,y_start); clreol();
 do
 {cout << line << endl << s << endl << line << endl;
  uint choice = ConsoleChoice(Menu, 4, head.c_str(), 2);
  switch (choice)
  {case 1: //Редактирование свойств аналитической модели предпроцессора
    TAnalPreProcSFilterBaseCh::Edit();
    Set();//Установка размерности адаптивного фильтра и корреляционных матриц
    cout << msg << endl; getch();
    break;
   case 2: //Редактирование свойств пространственного фильтра
    EditFilter();
    break;
   case 3: //Редактирование свойств входного воздействия
    TAnalInSignalProperty::Edit();
    cout << msg << endl; getch();
    break;
   case 4: //Свойства адаптивной LAA
    cout << Properties(t,STR_NULL);
    cout << msg << endl; getch();
    break;
   case 5: flag = false; break;//Выход из режима редактирования
  }
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
}
//******************************************************************************
//СТАТУС: I.3; TASpaceFilterBaseCh public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditFilter()
//НАЗНАЧЕНИЕ: Редактирование свойств / выбор пространственного фильтра адаптивной
//LAA через стандартный поток ввода cin (консольный ввод данных).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TASpaceFilterBaseCh::EditFilter()
{STR_UINT Option[8] = {
  {1, "Select < MultiStage_SteepestDescentMethod_Filter >" },
  {2, "Select < MultiStage_SDM_ENCCStabCircuit_Filter >" },
  {3, "Select < MultiStage_SDM_DMPEStabCircuit_Filter >" },
  {4, "Select < MultiStage_SDM_DIPEStabCircuit_Filter >" },
  {5, "Select < SingleStage_SteepestDescentMethod_Filter >" },
  {6, "Edit < Internal Properties >"},
  {7, "View < Properties >" },
  {8, "Exit" } };
 TB_STR_UINT Menu = {8, Option};
 string head = " Choice menu option [1-8]: ";
 //Рабочие переменные
 int y_start = wherey();
 string line(78,'-');
 const string msg = "Press any key...";
 const string s = "Adaptive Space Filter: < Editing/Choosing >";
 string t;
 bool flag = true;
 gotoxy(1,y_start); clreol();
 do
 {cout << line << endl << s << endl << line << endl;
  uint choice = ConsoleChoice(Menu, 7, head.c_str(), 2);
  switch (choice)
  {case 1: //Выбор MS_SDM_MISO_WeightSum
    if (Filter != NULL) {delete Filter; Filter = NULL;}
    //Конструирование фильтра
    Filter = new TMultiStageSDAlgMISOWSum(FilterSize());
    //Редактирование внутренних параметров фильтра
    Filter->Edit(OFF);
    break;
   case 2: //Выбор MS_SDM_ENCCStabCircuit_MISO_WeightSum
    if (Filter != NULL) {delete Filter; Filter = NULL;}
    //Конструирование фильтра
    Filter = new TMultiStageSDA_ENCC_MISOWSum(FilterSize());
    //Редактирование внутренних параметров фильтра
    Filter->Edit(OFF);
    break;
   case 3: //Выбор MS_SDM_DMPEStabCircuit_MISO_WeightSum
    if (Filter != NULL) {delete Filter; Filter = NULL;}
    //Конструирование фильтра
    Filter = new TMultiStageSDA_DMPE_MISOWSum(FilterSize());
    //Редактирование внутренних параметров фильтра
    Filter->Edit(OFF);
    break;
   case 4: //Выбор MS_SDM_DIPEStabCircuit_MISO_WeightSum
    if (Filter != NULL) {delete Filter; Filter = NULL;}
    //Конструирование фильтра
    Filter = new TMultiStageSDA_DIPE_MISOWSum(FilterSize());
    //Редактирование внутренних параметров фильтра
    Filter->Edit(OFF);
    break;
   case 5: //Выбор SS_SDM_MISO_WeightSum
    if (Filter != NULL) {delete Filter; Filter = NULL;}
    //Конструирование фильтра
    Filter = new TSingleStageSDAlgMISOWSum(FilterSize());
    //Редактирование внутренних параметров фильтра
    Filter->Edit(OFF);
    break;
   case 6: //Редактирование внутренних параметров фильтра
    if (Filter != NULL) Filter->Edit(OFF);
    else
    {cout << "Space Filter didn't switched to AdaptLAA !!!" << endl;
     cout << msg << endl; getch();
    }
    break;
   case 7: //Свойства пространственного фильтра
    if (Filter != NULL) cout << Filter->Properties(t,STR_NULL);
    else cout << "Space Filter didn't switched to AdaptLAA !!!" << endl;
    cout << msg << endl; getch();
    break;
   case 8: flag = false; break;//Выход из режима редактирования
  }
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
}
//***********************************************************************************
//СТАТУС: I.4,public,class member-function TASpaceFilterBaseCh
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//rvector& TFunc(rvector& P, const TEvenCloseInterval& Sector, bool Norm = ON,
//               bool Db = ON, double MinDb = -60.0) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ AdaptLAA .
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор со значениями мощности на выходе ОСНОВНОГО
//   канала AdaptLAA при перемещении источника сигнала ЕДИНИЧНОЙ мощности в заданном
//   секторе Sector;
//2. const TEvenCloseInterval& Sector - сектор по углу места (азимуту), в котором
//   рассчитывается передаточная функция AdaptLAA (в градусах);
//3. bool Norm (ON) - опция нормирования выходной мощностей ОСНОВНОГО канала;
//4. bool Db (ON) - опция нормирования в децибелах (действует при Norm = ON);
//5. double MinDb - минимальный уровень в децибелах (действует при Db = ON).
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rvector& P - значения ПЕРЕДАТОЧНОЙ ФУНКЦИИ AdaptLAA в единицах мощности в заданном
//секторе по углу места (азимуту) в зависимости от расположения LAA
//***********************************************************************************
rvector& TASpaceFilterBaseCh::TFunc(rvector& P, const TEvenCloseInterval& Sector,
                                    bool Norm, bool Db, double MinDb) const
{//Проверка работоспособности Adaptive LAA:
 if (!IsReady()) {P.Resize(0L); return P;}
 //ulong size = FilterSize();
 //cvector V(size,COL);
 cmatrix R;
 //Создание вектора P необходимых размеров: P.Size() = Sector.Size();
 P.Resize(Sector.Size());
 //Определение мощности на выходе AdaptLAA в заданном секторе
 for (ulong k = 0L; k < P.Size(); k++)
 {//---------------------------------------------------------------------------------
  //1. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ ПРЕДПРОЦЕССОРА AdaptiveLAA
  //---------------------------------------------------------------------------------
  //TAnalPreProcSFilterBaseCh::TFunc(V,Sector(k),ON);
  TAnalPreProcSFilterBaseCh::TFunc(R,Sector(k));
  //---------------------------------------------------------------------------------
  //2. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ пространственного фильтра AdaptiveLAA
  //---------------------------------------------------------------------------------
  //P.Put(k,Filter->TestFunc(V));
  P.Put(k,Filter->TF_WSum(R));
 }
 //----------------------------------------------------------------------------------
 //Нормирование выходных значений мощности ОСНОВНОГО канала
 //----------------------------------------------------------------------------------
 if (Norm == ON)
 {double MaxPower = 0.0;
  for (ulong i = 0L; i < P.Size(); i++) //Поиск максимума
   MaxPower = (MaxPower < P.Get(i)) ? P.Get(i) : MaxPower;
  //Нормирование в пределах от [0..1]
  for (ulong i = 0L; i < P.Size(); i++) P.Put(i,P.Get(i)/MaxPower);
  if (Db == ON) //Нормирование в децибелах [MinDb..0]
  {double Power;
   MinDb = (MinDb >= 0.0) ? -60.0 : MinDb;//Минимальное значение в Db
   for (ulong i = 0L; i < P.Size(); i++)
   {Power = (P.Get(i) == 0.0) ? MinDb : 10*log10(P.Get(i));
    Power = (Power < MinDb) ? MinDb : Power;
    P.Put(i,Power);
   }
  }
 }
return P;
}
//***********************************************************************************
//СТАТУС: I.5,public,class member-function TASpaceFilterBaseCh
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool TF_Potential(rvector& P, double Time, const TEvenCloseInterval& Sector,
//                  bool Norm = ON, bool dB = ON, double MindBb = -60.0)
//НАЗНАЧЕНИЕ: ПОТЕНЦИАЛЬНАЯ ПЕРЕДАТОЧНАЯ ФУНКЦИЯ однолучевой AdaptLAA с пространствен-
//ным адаптивным фильтром типа N x N при заданной помеховой ситуации. Помеховая ситуа-
//ция задается корреляционной матрицей Rjn, формируемой в момент времени Time. Rjn -
//корреляционная матрица аддитивной активной помехи и внутреннего шума на входе адап-
//тивной LAA в момент времени Time. Если аддитивная активная помеха и внутренний шум
//стационарны, то значение Time не cущественно для расчетов.
//Методика расчета ПОТЕНЦИАЛЬНОЙ ПЕРЕДАТОЧНОЙ функции адаптивной однолучевой LAA с
//N-канальным пространственным фильтром и схемой формирования основного канала (луча)
//на входе пространственного фильтра:
//           trA x InvRjn x R(q) x InvRjn x A
//   P(q) = ----------------------------------;
//                 trA x InvRjn x A
// q - угловое положение источника сигнала единичной мощности;
// P(q) - потенциальное значение отношения сигнал/шум на выходе адаптивной LAA при
// угловом положении источника сигнала единичной мощности равном q относительно
// раскрыва LAA;
// R(q) - корреляционная матрица источника сигнала едиичной мощности, расположенного
// под углом q относительно раскрыва LAA
// InvRjn - обратная матрица к корреляционной матрице Rjn помеховой обстановки
// A - вектор-cтолбец вида [0 0 0 ... 0 1];
// trA - вектор-строка транспонированная к вектору-столбцу A.
// С помощью векторов A и trA реализуется операция извлечения из матрицы InvRjn
// вектора-строки и вектора-столбца соответственно взаимных корреляций между основным
// и вспомогательными каналами адаптивного фильтра (векторам взаимных корреляций
// соответствуют последняя строка и столбец матрицы Rjn).
// С целью сокращения количества вычислений перед циклом изменения углового положения
// тест-сигнала вычисляются:
// 1. InvRjn - матрица обратная к матрице Rjn;
// 2. trA x InvRjn & InvRjn x A - извлечение вектора-строки и вектора-столбца взаимных
//    корреляций между ОСНОВНЫМ и вспомогательными каналами из матрицы InvRjn;
// 3. Знаменатель выражения P(q) - trA x InvRjn x A (данное значение равно последнему
//    элементу матрицы InvRjn).
// В цикле формируется матрица R(q), если положение источника сигнала q совпадет с
// положением источника помехи, то P(q) примет минимальное значение. Это вызвано тем,
// что адаптивная LAA формирует провалы в направлениях расположения источников активных
// помех.
// Таким образом, функция позволяет оценить ПОТЕНЦИАЛЬНУЮ ЭФФЕКТИВНОСТЬ адаптивной LAA
// c N-канальным пространственным фильтром и схемой формирования ОСНОВНОГО канала (луча)
// на входе фильтра.
// Если препроцессор AdaptLAA не работоспособен, то возвращается false и вектор P ну-
// левого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на выходной вектор мощностей (активной помехи + внутренний
//   шум) в заданном секторе;
//2. double Time - момент времени при котором производятся расчеты;
//3. const TEvenCloseInterval& Sector - сектор по углу места (азимуту), в  котором
//   рассчитывается передаточная функция (в градусах);
//4. bool Norm - опция нормирования выходных мощностей [0..1];
//5. bool dB (ON) - опция нормирования в децибелах (действует при Norm = ON);
//6. double MindB - минимальный уровень в децибелах (действует при dB = ON).
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//***********************************************************************************
bool TASpaceFilterBaseCh::TF_Potential(rvector& P, double Time,
     const TEvenCloseInterval& Sector, bool Norm, bool dB, double MindB)
{//Проверка работоспособности препроцессора Adaptive LAA:
 if (!IsPreProcessorReady()) {P.Set(0L,false); return false;}
 //Моделирование входного воздействия в момент времени Time и формирование
 //корреляционной матрицы Rjn
 cmatrix Rjn, R;
 TInputSignal* pLAA = GetLAA();
 pLAA->Update(Time,false); Update(0);
 GetInR(Rjn,OFF,ON,ON);
 //----------------------------------------------------------------------------------
 //Создаем вектор P для хранения данных
 P.Set(Sector.Size(),false);
 //----------------------------------------------------------------------------------
 // Расчет InvRjn, вычисление trA x InvRjn x A; trA x InvRjn; InvRjn x A
 //----------------------------------------------------------------------------------
 ulong index = Rjn.Rows()-1;
 cmatrix InvRjn = Rjn.INV_Krauth();
 //Проверка операции обращения матрицы
 if (InvRjn.IsZeroSize()) {P.Set(0L,false); return false;}
 cvector V(InvRjn.Rows(),COL,false), trV(InvRjn.Rows(),ROW,false);
 double Divisor = real(InvRjn.Get(index,index));
 //Формирование векторов взаимных корреляций между ОСНОВНЫМ и вспомогательными
 //каналами для обратной матрицы InvRjn
 for (ulong i = 0L; i < V.Size(); i++)
 {V.Put(i,InvRjn.Get(i,index)); trV.Put(i,InvRjn.Get(index,i));}
 //----------------------------------------------------------------------------------
 // Расчет P(q) в цикле
 //----------------------------------------------------------------------------------
 for (ulong q = 0L; q < P.Size(); q++) //По углам сектора
 {//---------------------------------------------------------------------------------
  //1. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ ПРЕДПРОЦЕССОРА AdaptiveLAA
  //---------------------------------------------------------------------------------
  TAnalPreProcSFilterBaseCh::TFunc(R,Sector(q));
  //---------------------------------------------------------------------------------
  //2. Вычисление числителя P(q) = trA x InvRjn x R(q) x InvRjn x A
  //---------------------------------------------------------------------------------
  complex Numerator(0,0);
  for (ulong i = 0L; i < InvRjn.Rows(); i++)
  {complex sum(0,0);
   for (ulong j = 0L; j < InvRjn.Cols(); j++) sum += R.Get(i,j)*V.Get(j);
   Numerator += trV.Get(i)*sum;
  }
  P.Put(q,real(Numerator)/Divisor);
 } //Конец цикла по i-му углу сектора
 //----------------------------------------------------------------------------------
 // Нормирование диаграмм направленностей ЛУЧЕЙ
 //----------------------------------------------------------------------------------
 if (Norm != ON) return true;
 else
 {//Нормирование в децибелах [-MindB..0]
  if (dB == ON) P.NormalizeToDB(true,MindB);
  //Нормирование в единицах мощности (0..1]
  else P.Normalization(FIRST_NORM);
 }
 return true;
}

//***********************************************************************************
//СТАТУС: I.5, TASpaceFilterBaseCh public class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Update(double Time);
//НАЗНАЧЕНИЕ: Расчет корреляционных матриц ПОЛЕЗНОГО СИГНАЛА Rss, АДДИТИВНОЙ ПО-
//МЕХИ Rjj и ВНУТРЕННЕГО ШУМА Rnn на входе аналитической модели адаптивного
//пространственного фильтра с ОСНОВНЫМ КАНАЛОМ в момент времени Time.
//Если какая-либо компонента входного  воздействия (полезный  сигнал, внутренний
//шум или аддитивная помеха) является стационарной, то соответствующая ей корре-
//ляционная матрица (Rss, Rjj, Rnn)  рассчитывается один раз, только в  начале
//процесса моделирования работы адаптивного фильтра (Time == 0).
//Если предпроцессор неработоспособен, то функция завершает свою работу и
//возвращает значение false (OFF) - признак неудачного завершения работы.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: double Time - модельное время
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак успешного/неуспешного завершения работы функции
//*****************************************************************************
bool TASpaceFilterBaseCh::Update(double Time)
{//Проверка РАБОТОСПОСОБНОСТИ препроцессора адаптивного фильтра
 if (!IsPreProcessorReady()) return OFF;
 bool ZeroTimeReference = OFF;//Индикатор начало отсчета времени
 if (Time < EPS) ZeroTimeReference = ON;
 //----------------------------------------------------------------------------
 //Расчет корреляционных матриц
 //----------------------------------------------------------------------------
 //В начальный момент времени
 if (ZeroTimeReference == ON)
 {TAnalPreProcSFilterBaseCh::Update();
  TAnalPreProcSFilterBaseCh::GetOutRss(Rss,ON);
  TAnalPreProcSFilterBaseCh::GetOutRjj(Rjj,ON);
  TAnalPreProcSFilterBaseCh::GetOutRnn(Rnn,ON);
 }
 else //В другие моменты времени
 {bool lSignal = !GetSignalStat();
  bool lJammer = !GetJammerStat();
  bool lNoise = !GetNoiseStat();
  TAnalPreProcSFilterBaseCh::Update(lSignal,lJammer,lNoise);
  if (GetSignalStat() == OFF)
   TAnalPreProcSFilterBaseCh::GetOutRss(Rss,ON);
  if (GetJammerStat() == OFF)
   TAnalPreProcSFilterBaseCh::GetOutRjj(Rjj,ON);
  if (GetNoiseStat() == OFF)
   TAnalPreProcSFilterBaseCh::GetOutRnn(Rnn,ON);
 }
 //Формирование выходной корреляционной матрица предпроцессора полезного сигнала,
 //аддитивной помехи и внутреннего шума размерности FilterSize()=AuxChCount()+1
 complex Sum;
  for (ulong i = 0L; i < R.Rows(); i++)
   for (ulong j = 0L; j < R.Cols(); j++)
   {Sum = Rss.Get(i,j) + Rjj.Get(i,j) + Rnn.Get(i,j);
    R.Put(i,j,Sum);
   }
return ON;
}
//******************************************************************************
//СТАТУС: I.6., public, TASpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix& GetInRss(cmatrix& R, bool lExtend = ON) const;
//НАЗНАЧЕНИЕ: Формирование  корреляционной  матрицы  ПОЛЕЗНОГО СИГНАЛА  на входе
//адаптивного фильтра (после предпроцессора).
//Если адаптивный фильтр не активен (IsReady() == OFF), то возвращается  матрица
//нулевого размера. Корреляционная матрица формируется в матрице R, передаваемой
//в функцию по ссылке. Функция использует матрицу Rss.
//Опция lExtend указывает на включение в матрицу R корреляционных отношений меж-
//ду ОСНОВНЫМ и вспомогательными каналами адаптивного фильтра (при lExtend==ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет формироваться входная
//   корреляционная матрица полезного сигнала адаптивного фильтра;
//2. bool lExtend (ON) - опция включения в матрицу R корреляционных отношений
//   между ОСНОВНЫМ и вспомогательными каналами адаптивного фильтра.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix& R - ссылка на сформированную корреляционную
//матрицу полезного сигнала на входе адаптивного фильтра (после предпроцессора).
//******************************************************************************
cmatrix& TASpaceFilterBaseCh::GetInRss(cmatrix& R, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsPreProcessorReady()) {R.Set(0L,0L,false); return R;}
 //-----------------------------------------------------------------------------
 //Формирование входной корреляционной матрицы ПОЛЕЗНОГО СИГНАЛА
 //-----------------------------------------------------------------------------
 if (lExtend == ON) R = Rss;
 else //Формирование матрицы R необходимой размерности
 {ulong size = Rss.Rows()-1; R.Set(size,size,C_ZERO);
  //Копирование значений матрицы Rss в R
  for (ulong i = 0L; i < size; i++)
   for (ulong j = 0L; j < size; j++)
    R.Put(i,j,Rss.Get(i,j));
 }
return R;
}
//******************************************************************************
//СТАТУС: I.7, public, TASpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix& GetInRjj(cmatrix& R, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование  корреляционной  матрицы  АДДИТИВНОЙ ПОМЕХИ  на входе
//адаптивного фильтра (после предпроцессора).
//Если адаптивный фильтр не активен (IsReady() == OFF), то возвращается  матрица
//нулевого размера. Корреляционная матрица формируется в матрице R, передаваемой
//в функцию по ссылке. Функция использует матрицу Rjj.
//Опция lExtend указывает на включение в матрицу R корреляционных отношений меж-
//ду ОСНОВНЫМ и вспомогательными каналами адаптивного фильтра (при lExtend==ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет формироваться входная
//   корреляционная матрица аддитивной помехи адаптивного фильтра;
//2. bool lExtend (ON) - опция включения в матрицу R корреляционных отношений
//   между ОСНОВНЫМ и вспомогательными каналами адаптивного фильтра.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix& R - ссылка на сформированную корреляционную
//матрицу аддитивной помехи на входе адаптивного фильтра (после предпроцессора).
//*****************************************************************************
cmatrix& TASpaceFilterBaseCh::GetInRjj(cmatrix& R, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsPreProcessorReady()) {R.Set(0L,0L,false); return R;}
 //----------------------------------------------------------------------------
 //Формирование входной корреляционной матрицы АДДИТИВНОЙ ПОМЕХИ
 //----------------------------------------------------------------------------
 if (lExtend == ON) R = Rjj;
 else //Формирование матрицы R необходимой размерности
 {ulong size = Rjj.Rows()-1; R.Set(size,size,C_ZERO);
  //Копирование значений матрицы Rjj в R
  for (ulong i = 0L; i < size; i++)
   for (ulong j = 0L; j < size; j++)
    R.Put(i,j,Rjj.Get(i,j));
 }
return R;
}
//******************************************************************************
//СТАТУС: I.8, public, TASpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix& GetInRnn(cmatrix& R, bool lExtend = ON) const;
//НАЗНАЧЕНИЕ: Формирование  корреляционной  матрицы  ВНУТРЕННЕГО  ШУМА  на входе
//адаптивного фильтра (после предпроцессора).
//Если адаптивный фильтр не активен (IsReady() == OFF), то возвращается  матрица
//нулевого размера. Корреляционная матрица формируется в матрице R, передаваемой
//в функцию по ссылке. Функция использует матрицу Rnn.
//Опция lExtend указывает на включение в матрицу R корреляционных отношений меж-
//ду ОСНОВНЫМ и вспомогательными каналами адаптивного фильтра (при lExtend==ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет формироваться входная
//   корреляционная матрица внутреннего шума адаптивного фильтра;
//2. bool lExtend (ON) - опция включения в матрицу R корреляционных отношений
//   между ОСНОВНЫМ и вспомогательными каналами адаптивного фильтра.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix& R - ссылка на сформированную корреляционную
//матрицу внутреннего шума на входе адаптивного фильтра (после предпроцессора).
//*****************************************************************************
cmatrix& TASpaceFilterBaseCh::GetInRnn(cmatrix& R, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsPreProcessorReady()) {R.Set(0L,0L,false); return R;}
 //----------------------------------------------------------------------------
 //Формирование входной корреляционной матрицы ВНУТРЕННЕГО ШУМА
 //----------------------------------------------------------------------------
 if (lExtend == ON) R = Rnn;
 else //Формирование матрицы R необходимой размерности
 {ulong size = Rnn.Rows()-1; R.Set(size,size,C_ZERO);
  //Копирование значений матрицы Rnn в R
  for (ulong i = 0L; i < size; i++)
   for (ulong j = 0L; j < size; j++)
    R.Put(i,j,Rnn.Get(i,j));
 }
return R;
}
//******************************************************************************
//СТАТУС: I.9, public, TASpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix& GetInR(cmatrix& R, bool lSignal = ON, bool lJammer = ON,
//                 bool lNoise = ON, bool lExtend = ON) const;
//НАЗНАЧЕНИЕ: Формирование корреляционной матрицы компонент ВХОДНОГО ВОЗДЕЙСТВИЯ
//на входе адаптивного фильтра (после предпроцессора).
//Если адаптивный фильтр не активен (IsReady() == OFF), то возвращается  матрица
//нулевого размера. Корреляционная матрица формируется в матрице R, передаваемой
//в функцию по ссылке.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет формироваться входная
//   корреляционная матрица компонент входного воздействия адаптивного фильтра;
//2. bool lSignal (ON) - опция включения в матрицу ПОЛЕЗНОГО СИГНАЛА;
//3. bool lJammer (ON) - опция включения в матрицу АДДИТИВНОЙ ПОМЕХИ;
//4. bool lNoise (ON)  - опция включения в матрицу ВНУТРЕННЕГО ШУМА;
//5. bool lExtend (ON) - опция включения в матрицу R корреляционных отношений
//   между ОСНОВНЫМ и вспомогательными каналами адаптивного фильтра.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix& R - ссылка на сформированную корреляционную
//матрицу компонент входного сигнала на входе адаптивного фильтра.
//*****************************************************************************
cmatrix& TASpaceFilterBaseCh::GetInR(cmatrix& R, bool lSignal, bool lJammer,
         bool lNoise, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ препроцессора адаптивного фильтра
 if (!IsPreProcessorReady()) {R.Set(0L,0L,false); return R;}
 //----------------------------------------------------------------------------
 //Формирование входной корреляционной матрицы компонент входного сигнала
 //----------------------------------------------------------------------------
 //Формирование матрицы R необходимой размерности
 ulong size = (lExtend == ON) ? Rss.Rows() : Rss.Rows()-1;
 R.Set(size,size,C_ZERO);
 cmatrix Temp;
 if (lSignal) R = R + GetInRss(Temp, lExtend);
 if (lJammer) R = R + GetInRjj(Temp, lExtend);
 if (lNoise)  R = R + GetInRnn(Temp, lExtend);
return R;
}
//******************************************************************************
//СТАТУС: I.10., public, TASpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& InPsignal(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ПОЛЕЗНОГО СИГНАЛА на входах адаптив-
//ного фильтра (после предпроцессора).
//Если адаптивный фильтр не активен (IsReady() == OFF), то возвращается вектор
//нулевого размера. Вектор мощности полезного сигнала формируется в векторе P,
//передаваемый в функцию по ссылке. Для вычислений используется матрица Rss.
//Опция lExtend указывает на включение в вектор P мощности полезного сигнала на
//входе ОСНОВНОГО канала адаптивного фильтра (при lExtend == ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор, в котором формируется мощность полезного сиг-
//   нала на входах адаптивного фильтра (после предпроцессора);
//2. bool lExtend (ON) - опция включения в вектор P мощности полезного сигнала
//   на входе ОСНОВНОГО канала адаптивного фильтра.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей полезного сиг-
//нала на входах адаптивного фильтра (после предпроцессора).
//*****************************************************************************
rvector& TASpaceFilterBaseCh::InPsignal(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {P.Resize(0L); return P;}
 //----------------------------------------------------------------------------
 //Формирование входного вектора мощности ПОЛЕЗНОГО СИГНАЛА
 //----------------------------------------------------------------------------
 //Формирование вектора P необходимого размера
 ulong Size = (lExtend == ON) ? Rss.Rows() : Rss.Rows()-1;
 P.Resize(Size);
 //Цикл формирования значений элементов вектора P
 for (ulong i = 0L; i < Size; i++) P.Put(i,real(Rss.Get(i,i)));
 return P;
}
//******************************************************************************
//СТАТУС: I.11., public, TASpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& InPjammer(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности АДДИТИВНОЙ ПОМЕХИ на входах адаптив-
//ного фильтра (после предпроцессора).
//Если адаптивный  фильтр не  активен (IsReady() == OFF), то возвращается вектор
//нулевого  размера. Вектор  мощности аддитивной помехи формируется в векторе P,
//передаваемый в функцию по ссылке. Для вычислений используется матрица Rjj.
//Опция lExtend указывает на включение в вектор P мощности аддитивной помехи на
//входе ОСНОВНОГО канала адаптивного фильтра (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор, в котором формируется мощность аддитивной
//   помехи на входах адаптивного фильтра (после предпроцессора);
//2. bool lExtend (ON) - опция включения в вектор P мощности аддитивной помехи
//   на входе ОСНОВНОГО канала адаптивного фильтра.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей аддитивной по-
//мехи на входе адаптивного фильтра (после предпроцессора).
//*****************************************************************************
rvector& TASpaceFilterBaseCh::InPjammer(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {P.Resize(0L); return P;}
 //----------------------------------------------------------------------------
 //Формирование входного вектора мощности АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ
 //----------------------------------------------------------------------------
 //Формирование вектора P необходимого размера
 ulong Size = (lExtend == ON) ? Rjj.Rows() : Rjj.Rows()-1;
 P.Resize(Size);
 //Цикл формирования значений элементов вектора P
 for (ulong i = 0L; i < Size; i++) P.Put(i,real(Rjj.Get(i,i)));
 return P;
}
//******************************************************************************
//СТАТУС: I.12., public, TASpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& InPnoise(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование  вектора мощности ВНУТРЕННЕГО ШУМА на входах адаптив-
//ного фильтра (после предпроцессора).
//Если  адаптивный фильтр не активен (IsReady() == OFF), то возвращается  вектор
//нулевого  размера. Вектор  мощности  внутреннего шума формируется в векторе P,
//передаваемый в функцию по ссылке. Для вычислений используется матрица Rnn.
//Опция lExtend указывает на включение в вектор P мощности внутреннего шума на
//входе ОСНОВНОГО канала адаптивного фильтра (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка  на вектор, в  котором формируется мощность внутреннего
//   шума для входов адаптивного фильтра (после предпроцессора);
//2. bool lExtend (ON) - опция включения в вектор P мощности внутреннего шума
//   на входе ОСНОВНОГО канала адаптивного фильтра.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей внутреннего
//шума на входах адаптивного фильтра (после предпроцессора).
//******************************************************************************
rvector& TASpaceFilterBaseCh::InPnoise(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {P.Resize(0L); return P;}
 //-----------------------------------------------------------------------------
 //Формирование входного вектора мощности ВНУТРЕННЕГО ШУМА
 //-----------------------------------------------------------------------------
 //Формирование вектора P необходимого размера
 ulong Size = (lExtend == ON) ? Rnn.Rows() : Rnn.Rows()-1;
 P.Resize(Size);
 //Цикл формирования значений элементов вектора P
 for (ulong i = 0L; i < Size; i++) P.Put(i,real(Rnn.Get(i,i)));
 return P;
}
//******************************************************************************
//СТАТУС: I.13., public, TASpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& OutPsignal(rvector& P) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ПОЛЕЗНОГО СИГНАЛА на выходах адаптив-
//ного фильтра.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: rvector& P - ссылка  на вектор, в котором формируется
//мощность ПОЛЕЗНОГО СИГНАЛА на выходах адаптивного фильтра
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей ПОЛЕЗНОГО
//СИГНАЛА на выходах адаптивного фильтра.
//*****************************************************************************
rvector& TASpaceFilterBaseCh::OutPsignal(rvector& P) const
{if (!IsReady()) {P.Resize(0); return P;} //Адаптивный фильтр НЕРАБОТОСПОСОБЕН
 cmatrix A;
 GetOutRss(A);//Формирование выходной матрицы ПОЛЕЗНОГО СИГНАЛА
 P.Resize(A.Rows());
 for (ulong i = 0L; i < P.Size(); i++) P.Put(i,abs(A.Get(i,i)));
 return P;//Мощность ПОЛЕЗНОГО СИГНАЛА на выходах фильтра
};
//******************************************************************************
//СТАТУС: I.14., public, TASpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& OutPjammer(rvector& P) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности АДДИТИВНОЙ ПОМЕХИ на выходах адаптив-
//ного фильтра.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: rvector& P - ссылка  на вектор, в котором формируется
//мощность АДДИТИВНОЙ ПОМЕХИ на выходах адаптивного фильтра
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей АДДИТИВНОЙ
//ПОМЕХИ на выходах адаптивного фильтра.
//******************************************************************************
rvector& TASpaceFilterBaseCh::OutPjammer(rvector& P) const
{if (!IsReady()) {P.Resize(0); return P;} //Адаптивный фильтр НЕРАБОТОСПОСОБЕН
 cmatrix A;
 GetOutRjj(A);//Формирование выходной матрицы АДДИТИВНОЙ ПОМЕХИ
 P.Resize(A.Rows());
 for (ulong i = 0L; i < P.Size(); i++) P.Put(i,abs(A.Get(i,i)));
 return P;//Мощность АДДИТИВНОЙ ПОМЕХИ на выходах фильтра
};
//******************************************************************************
//СТАТУС: I.15., public, TASpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& OutPnoise(rvector& P) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ВНУТРЕННЕГО ШУМА на выходах адаптив-
//ного фильтра.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: rvector& P - ссылка  на вектор, в котором формируется
//мощность ВНУТРЕННЕГО ШУМА на выходах адаптивного фильтра
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка на вектор мощностей ВНУТРЕННЕГО
//ШУМА на выходах адаптивного фильтра.
//******************************************************************************
rvector& TASpaceFilterBaseCh::OutPnoise(rvector& P) const
{if (!IsReady()) {P.Resize(0); return P;} //Адаптивный фильтр НЕРАБОТОСПОСОБЕН
 cmatrix A;
 GetOutRnn(A);//Формирование выходной матрицы ВНУТРЕННЕГО ШУМА
 P.Resize(A.Rows());
 for (ulong i = 0L; i < P.Size(); i++) P.Put(i,abs(A.Get(i,i)));
 return P;//Мощность ПОЛЕЗНОГО СИГНАЛА на выходах фильтра
};

//******************************************************************************
//                РЕАЛИЗАЦИЯ КЛАССА TSpaceFilterBaseCh
//     Статистическая модель адаптивной антенной линейной антенной решетки с
//               пространственным фильтром и ОСНОВНЫМ каналом.
//******************************************************************************
//==============================================================================
//I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TSpaceFilterBaseCh
//   PUBLIC MEMBER-FUNCTION OF TSpaceFilterBaseCh CLASS
//==============================================================================
//*****************************************************************************
//СТАТУС: I.1; TSpaceFilterBaseCh public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//string& Properties(string& s, string& title = string(), uint indent = 0) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта TSpaceFilterBaseCh в виде строки.
//Функция формирует строковое представление свойств статистической модели фильтра
//с предпроцессором. Информация заносится в строку s, передаваемую в функцию по
//ссылке, предыдущее содержимое строки уничтожается.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& title - ссылка на строку с заголовком объекта;
//3. uint indent - начальное смещение строки.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//*****************************************************************************
string& TSpaceFilterBaseCh::Properties(string& s, string& title, uint indent)
const
{string t;
 string header;
 string space(' ',indent);
 s.resize(0);
 //Формирование заголовка объекта
 s.append(space);
 if (title.empty())
  s.append("STATISTICAL ADAPTIVE LINEAR ANTENNA ARRAY with BASE CHANNEL: ");
 else s.append(title);
 //-----------------------------------------------------------------------------
 //Анализ работоспособности адаптивной LAA
 //-----------------------------------------------------------------------------
 if (!IsReady()) s.append("< Off >\n"); //АДАПТИВНАЯ LAA НЕРАБОТОСПОСОБНА
 else s.append("< On >\n");
 //-----------------------------------------------------------------------------
 //1. Формирование свойств аналитической модели предпроцессора
 header = "I. Adaptive LAA Preprocessor ";
 s.append(TStatPreProcSFilterBaseCh::Properties(t,header,indent+1));
 //-----------------------------------------------------------------------------
 //2. Формирование свойств пространственного фильтра (весового сумматора)
 header = "II. Space Filter";
 if (Filter == NULL) //Фильтр не подключен к адаптивной LAA
 {s.append(space);s.append(1,' ');
  s.append(header+": < Off >\n"); s.append(space);
  s.append("  Cause: Filter didn't switched to Adaptive LAA.\n");
 }
 else s.append(Filter->Properties(t,header,indent+1)); //Фильтр подключен
return s;
}
//******************************************************************************
//СТАТУС: I.2; TSpaceFilterBaseCh public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit()
//НАЗНАЧЕНИЕ: Редактирование свойств объекта класса через стандартный поток
//ввода cin (консольный ввод данных).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TSpaceFilterBaseCh::Edit()
{//-----------------------------------------------------------------------------
 //ПРЕДПРОЦЕССОР ПРОСТРАНСТВЕННОГО ФИЛЬТРА НЕРАБОТОСПОСОБЕН:
 //редактирование свойств объекта нецелесообразно
 //-----------------------------------------------------------------------------
 if (!IsPreProcessorReady())
 {gotoxy(1,wherey()); clreol();
  cout << "Edition STATISTICAL MODEL of ADAPTIVE LAA is impossible !!!\a\n";
  TInputSignal* LAA = GetLAA();
  if (LAA == NULL)
   cout << "Cause: PREPROCESSOR unconnect with LAA." << endl;
  else if (LAA->LAAElem() < 2)
   cout << "Cause: LAA channels less than 2." << endl;
  return;
 }
 STR_UINT Option[4] = {
  {1, "Edit < Preprocessor >" },
  {2, "Edit < Space Filter >" },
  {3, "View < Properties   >" },
  {4, "Exit                 " } };
 TB_STR_UINT Menu = {4, Option};
 string head = " Choice menu option [1-4]: ";
 //Рабочие переменные
 int y_start = wherey();
 string line(78,'-');
 const string msg = "Press any key...";
 const string s = "Statistical Model of ADAPTIVE LAA: < Editing >";
 string t;
 bool flag = true;
 gotoxy(1,y_start); clreol();
 do
 {cout << line << endl << s << endl << line << endl;
  uint choice = ConsoleChoice(Menu, 3, head.c_str(), 2);
  switch (choice)
  {case 1: //Редактирование свойств предпроцессора
    TStatPreProcSFilterBaseCh::Edit();
    Set();//Установка размерности адаптивного фильтра и входных выборок
    cout << msg << endl; getch();
    break;
   case 2: //Редактирование свойств пространственного фильтра
    EditFilter();
    break;
   case 3: //Свойства адаптивной LAA
    cout << Properties(t,STR_NULL);
    cout << msg << endl; getch();
    break;
   case 4: flag = false; break;//Выход из режима редактирования
  }
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
}
//******************************************************************************
//СТАТУС: I.3; TSpaceFilterBaseCh public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditFilter()
//НАЗНАЧЕНИЕ: Редактирование свойств / выбор пространственного фильтра адаптивной
//LAA через стандартный поток ввода cin (консольный ввод данных).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TSpaceFilterBaseCh::EditFilter()
{STR_UINT Option[8] = {
  {1, "Select < MultiStage_SteepestDescentMethod_Filter >" },
  {2, "Select < MultiStage_SDM_ENCCStabCircuit_Filter >" },
  {3, "Select < MultiStage_SDM_DMPEStabCircuit_Filter >" },
  {4, "Select < MultiStage_SDM_DIPEStabCircuit_Filter >" },
  {5, "Select < SingleStage_SteepestDescentMethod_Filter >" },
  {6, "Edit < Internal Properties >"},
  {7, "View < Properties >" },
  {8, "Exit" } };
 TB_STR_UINT Menu = {8, Option};
 string head = " Choice menu option [1-8]: ";
 //Рабочие переменные
 int y_start = wherey();
 string line(78,'-');
 const string msg = "Press any key...";
 const string s = "Adaptive Space Filter: < Editing/Choosing >";
 string t;
 bool flag = true;
 gotoxy(1,y_start); clreol();
 do
 {cout << line << endl << s << endl << line << endl;
  uint choice = ConsoleChoice(Menu, 7, head.c_str(), 2);
  switch (choice)
  {case 1: //Выбор MS_SDM_MISO_WeightSum
    if (Filter != NULL) {delete Filter; Filter = NULL;}
    //Конструирование фильтра
    Filter = new TMultiStageSDAlgMISOWSum(FilterSize());
    //Редактирование внутренних параметров фильтра
    Filter->Edit(OFF);
    break;
   case 2: //Выбор MS_SDM_ENCCStabCircuit_MISO_WeightSum
    if (Filter != NULL) {delete Filter; Filter = NULL;}
    //Конструирование фильтра
    Filter = new TMultiStageSDA_ENCC_MISOWSum(FilterSize());
    //Редактирование внутренних параметров фильтра
    Filter->Edit(OFF);
    break;
   case 3: //Выбор MS_SDM_DMPEStabCircuit_MISO_WeightSum
    if (Filter != NULL) {delete Filter; Filter = NULL;}
    //Конструирование фильтра
    Filter = new TMultiStageSDA_DMPE_MISOWSum(FilterSize());
    //Редактирование внутренних параметров фильтра
    Filter->Edit(OFF);
    break;
   case 4: //Выбор MS_SDM_DIPEStabCircuit_MISO_WeightSum
    if (Filter != NULL) {delete Filter; Filter = NULL;}
    //Конструирование фильтра
    Filter = new TMultiStageSDA_DIPE_MISOWSum(FilterSize());
    //Редактирование внутренних параметров фильтра
    Filter->Edit(OFF);
    break;
   case 5: //Выбор SS_SDM_MISO_WeightSum
    if (Filter != NULL) {delete Filter; Filter = NULL;}
    //Конструирование фильтра
    Filter = new TSingleStageSDAlgMISOWSum(FilterSize());
    //Редактирование внутренних параметров фильтра
    Filter->Edit(OFF);
    break;
   case 6: //Редактирование внутренних параметров фильтра
    if (Filter != NULL) Filter->Edit(OFF);
    else
    {cout << "Space Filter didn't switched to AdaptLAA !!!" << endl;
     cout << msg << endl; getch();
    }
    break;
   case 7: //Свойства пространственного фильтра
    if (Filter != NULL) cout << Filter->Properties(t,STR_NULL);
    else cout << "Space Filter didn't switched to AdaptLAA !!!" << endl;
    cout << msg << endl; getch();
    break;
   case 8: flag = false; break;//Выход из режима редактирования
  }
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
}
//******************************************************************************
//СТАТУС: I.4,public,class member-function TSpaceFilterBaseCh
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//rvector& TFunc(rvector& P, const TEvenCloseInterval& Sector, bool Norm = ON,
//               bool Db = ON, double MinDb = -60.0) const
//НАЗНАЧЕНИЕ: ПЕРЕДАТОЧНАЯ ФУНКЦИЯ AdaptLAA .
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор со значениями мощности на выходе ОСНОВНОГО
//   канала AdaptLAA при перемещении источника сигнала ЕДИНИЧНОЙ мощности в
//   заданном секторе Sector;
//2. const TEvenCloseInterval& Sector - сектор по углу места (азимуту), в  кото-
//   ром рассчитывается передаточная функция AdaptLAA (в градусах);
//3. bool Norm (ON) - опция нормирования выходной мощностей ОСНОВНОГО канала;
//4. bool Db (ON) - опция нормирования в децибелах (действует при Norm = ON);
//5. double MinDb - минимальный уровень в децибелах (действует при Db = ON).
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rvector& P - значения ПЕРЕДАТОЧНОЙ ФУНКЦИИ AdaptLAA в единицах мощности в
//заданном секторе по углу места (азимуту) в зависимости от расположения LAA
//******************************************************************************
rvector& TSpaceFilterBaseCh::TFunc(rvector& P, const TEvenCloseInterval& Sector,
                                   bool Norm, bool Db, double MinDb) const
{//Проверка работоспособности Adaptive LAA:
 if (!IsReady()) {P.Resize(0L); return P;}
 cvector V(FilterSize(),COL);
 //Создание вектора P необходимых размеров: P.Size() = Sector.Size();
 P.Resize(Sector.Size());
 bool lAbs = OFF;
 //Определение мощности на выходе AdaptLAA в заданном секторе
 for (ulong i = 0L; i < P.Size(); i++)
 {//----------------------------------------------------------------------------
  //1. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ ПРЕДПРОЦЕССОРА AdaptiveLAA
  //----------------------------------------------------------------------------
  TStatPreProcSFilterBaseCh::TFunc(V,Sector(i),lAbs);
  //----------------------------------------------------------------------------
  //2. ПЕРЕДАТОЧНАЯ ФУНКЦИЯ пространственного фильтра AdaptiveLAA
  //----------------------------------------------------------------------------
  P.Put(i,Filter->TF_WSum(V));
 }
 //-----------------------------------------------------------------------------
 //Нормирование выходных значений мощности ОСНОВНОГО канала
 //-----------------------------------------------------------------------------
 if (Norm == ON)
 {double MaxPower = 0.0;
  for (ulong i = 0L; i < P.Size(); i++) //Поиск максимума для каждого канала
   MaxPower = (MaxPower < P.Get(i)) ? P.Get(i) : MaxPower;
  //Нормирование в пределах от [0..1]
  for (ulong i = 0L; i < P.Size(); i++) P.Put(i,P.Get(i)/MaxPower);
  if (Db == ON) //Нормирование в децибелах [MinDb..0]
  {double Power;
   MinDb = (MinDb >= 0.0) ? -60.0 : MinDb;//Минимальное значение в Db
   for (ulong i = 0L; i < P.Size(); i++)
   {Power = (P.Get(i) == 0.0) ? MinDb : 10*log10(P.Get(i));
    Power = (Power < MinDb) ? MinDb : Power;
    P.Put(i,Power);
   }
  }
 }
return P;
}
//*****************************************************************************
//СТАТУС: I.5, TSpaceFilterBaseCh public class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Update();
//НАЗНАЧЕНИЕ: Расчет входных выборок ПОЛЕЗНОГО СИГНАЛА Us, АДДИТИВНОЙ ПОМЕХИ Ujam
//и  ВНУТРЕННЕГО  ШУМА  Unoise на входе статистической модели адаптивного прост-
//ранственного фильтра с ОСНОВНЫМ КАНАЛОМ в момент времени Time.
//Если адаптивный фильтр неработоспособен, то функция завершает свою работу и
//возвращает значение false (OFF) - признак неудачного завершения работы.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак успешного/неуспешного завершения работы функции
//*****************************************************************************
bool TSpaceFilterBaseCh::Update()
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) return OFF;
 //----------------------------------------------------------------------------
 //Расчет выборок компонент входного воздействия на входе адаптивного фильтра
 //----------------------------------------------------------------------------
 TStatPreProcSFilterBaseCh::Update();
 TStatPreProcSFilterBaseCh::OutSignal(Us,ON);
 TStatPreProcSFilterBaseCh::OutJammer(Ujam,ON);
 TStatPreProcSFilterBaseCh::OutNoise(Unoise,ON);
 //Формирование выходной выборки полезного сигнала, аддитивной помехи и внутрен-
 //него шума размерности FilterSize()=AuxChCount()+1 с предпроцессора
 complex Sum;
 for (ulong i = 0L; i < Usum.Size(); i++)
 {Sum = Us.Get(i) + Ujam.Get(i) + Unoise.Get(i); Usum.Put(i,Sum);}
return ON;
}
//*****************************************************************************
//СТАТУС: I.8., public, TSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool AverageW(uint Realization)
//НАЗНАЧЕНИЕ: Усреднение значений весовых коэффициентов адаптивного весового
//сумматора, которые накапливаются в матрице AvW. Функция должна вызываться на
//каждом последнем шаге i-ой реализации, когда весовые коэффициенты окончательно
//настраиваются на помеховую обстановку. При первой реализации (Realization = 0)
//весовые  коэффициенты весового сумматора присваиваются матрице AvW, при после-
//дующих реализациях осуществляется операция усреднения. Реализации должны начи-
//наться с 0.
//Если адаптивный пространственный фильтр НЕ РАБОТОСПОСОБЕН, функция возвращает
//false.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint Realization - порядковый номер реализации
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
bool TSpaceFilterBaseCh::AverageW(uint Realization)
{//Проверка работоспособности адаптивного фильтра
 if (!IsReady()) return false;
 //Проверка порядкового номера реализации
 if (Realization != 0) //Усреднение
 {cmatrix W; Filter->GetW(W);//Получение текущих весовых коэффициентов сумматора
  for(ulong i = 0L; i < AvW.Rows(); i++)
   for (ulong j = 0L; j < AvW.Cols(); j++)
    AvW.Put(i,j,0.5*(AvW.Get(i,j)+W.Get(i,j)));
 }
 else Filter->GetW(AvW); //Присвоение при первой реализации
return true;
}
//******************************************************************************
//СТАТУС: I.7., public, TSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& InPsignal(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности ПОЛЕЗНОГО СИГНАЛА на входах адаптив-
//ного фильтра (после предпроцессора).
//Если адаптивный фильтр не активен (IsReady() == OFF), то возвращается вектор
//нулевого размера. Вектор мощности полезного сигнала формируется в векторе P,
//передаваемый в функцию по ссылке. Для вычислений используется вектор Us.
//Опция lExtend указывает на включение в вектор P мощности полезного сигнала на
//входе ОСНОВНОГО канала адаптивного фильтра (при lExtend == ON).
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор, в котором формируется мощность полезного сиг-
//   нала на входах адаптивного фильтра (после предпроцессора);
//2. bool lExtend (ON) - опция включения в вектор P мощности полезного сигнала
//   на входе ОСНОВНОГО канала адаптивного фильтра.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей полезного сиг-
//нала на входах адаптивного фильтра (после предпроцессора).
//*****************************************************************************
rvector& TSpaceFilterBaseCh::InPsignal(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {P.Resize(0L); return P;}
 //----------------------------------------------------------------------------
 //Формирование входного вектора мощности ПОЛЕЗНОГО СИГНАЛА
 //----------------------------------------------------------------------------
 //Формирование вектора P необходимого размера
 ulong size = (lExtend == ON) ? Us.Size() : Us.Size()-1;
 P.Resize(size);
 //Цикл формирования значений элементов вектора P
 for (ulong i = 0L; i < size; i++) P.Put(i,norm(Us.Get(i)));
 return P;
}
//******************************************************************************
//СТАТУС: I.8., public, TSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& InPjammer(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование вектора мощности АДДИТИВНОЙ ПОМЕХИ на входах адаптив-
//ного фильтра (после предпроцессора).
//Если адаптивный  фильтр не  активен (IsReady() == OFF), то возвращается вектор
//нулевого  размера. Вектор  мощности аддитивной помехи формируется в векторе P,
//передаваемый в функцию по ссылке. Для вычислений используется вектор Ujam.
//Опция lExtend указывает на включение в вектор P мощности аддитивной помехи на
//входе ОСНОВНОГО канала адаптивного фильтра (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка на вектор, в котором формируется мощность аддитивной
//   помехи на входах адаптивного фильтра (после предпроцессора);
//2. bool lExtend (ON) - опция включения в вектор P мощности аддитивной помехи
//   на входе ОСНОВНОГО канала адаптивного фильтра.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей аддитивной по-
//мехи на входе адаптивного фильтра (после предпроцессора).
//*****************************************************************************
rvector& TSpaceFilterBaseCh::InPjammer(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {P.Resize(0L); return P;}
 //----------------------------------------------------------------------------
 //Формирование входного вектора мощности АДДИТИВНОЙ АКТИВНОЙ ПОМЕХИ
 //----------------------------------------------------------------------------
 //Формирование вектора P необходимого размера
 ulong size = (lExtend == ON) ? Ujam.Size() : Ujam.Size()-1;
 P.Resize(size);
 //Цикл формирования значений элементов вектора P
 for (ulong i = 0L; i < size; i++) P.Put(i,norm(Ujam.Get(i)));
 return P;
}
//******************************************************************************
//СТАТУС: I.9., public, TSpaceFilterBaseCh class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& InPnoise(rvector& P, bool lExtend = ON) const
//НАЗНАЧЕНИЕ: Формирование  вектора мощности ВНУТРЕННЕГО ШУМА на входах адаптив-
//ного фильтра (после предпроцессора).
//Если  адаптивный фильтр не активен (IsReady() == OFF), то возвращается  вектор
//нулевого  размера. Вектор  мощности  внутреннего шума формируется в векторе P,
//передаваемый в функцию по ссылке. Для вычислений используется вектор Unoise.
//Опция lExtend указывает на включение в вектор P мощности внутреннего шума на
//входе ОСНОВНОГО канала адаптивного фильтра (при lExtend == ON).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& P - ссылка  на вектор, в  котором формируется мощность внутреннего
//   шума для входов адаптивного фильтра (после предпроцессора);
//2. bool lExtend (ON) - опция включения в вектор P мощности внутреннего шума
//   на входе ОСНОВНОГО канала адаптивного фильтра.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector& P - ссылка  на вектор мощностей внутреннего
//шума на входах адаптивного фильтра (после предпроцессора).
//******************************************************************************
rvector& TSpaceFilterBaseCh::InPnoise(rvector& P, bool lExtend) const
{//Проверка РАБОТОСПОСОБНОСТИ адаптивного фильтра
 if (!IsReady()) {P.Resize(0L); return P;}
 //-----------------------------------------------------------------------------
 //Формирование входного вектора мощности ВНУТРЕННЕГО ШУМА
 //-----------------------------------------------------------------------------
 //Формирование вектора P необходимого размера
 ulong size = (lExtend == ON) ? Unoise.Size() : Unoise.Size()-1;
 P.Resize(size);
 //Цикл формирования значений элементов вектора P
 for (ulong i = 0L; i < size; i++) P.Put(i,norm(Unoise.Get(i)));
 return P;
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

