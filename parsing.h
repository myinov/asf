//Parsing.h
//Copyright (c) JohnSoft 2001. All rights reserved. Borland C++ 5.02.
//Initial date: October,2,2001. Final date:
//Объявление классов для синтаксического анализа и грамматического разбора строк
#if !defined(__PARSING_H)
#define __PARSING_H

#include "const.h"
#pragma hdrstop

#include "mvector.h"

//----------------------------------------------------------------------------------------
//Объявление функций, используемых классами
//----------------------------------------------------------------------------------------
//Пропуск символов в строке s, которые содержатся в строке symbols
const char* SkipSymbols(const char* s, const char* symbols);

//Импорт из строки имени файла, заключенного между маркерами с игнорированием начальных
//и конечных пробельных символов. Формат: [ws]<StartMarker>[ws]<FileName>[ws]<EndMarker>.
//В случае безошибочного разбора имя файла записывается в строку fname и возвращается true
bool ImportFileName(string& fname, const char* s, char StartMarker, char EndMarker);

//Импорт из строки s аргумента типа double с предшествующим ему обязательным идентификато-
//ром из набора IdentColl и символом-разделителем из строки Sep. Синтаксис разбора:
//<IDENT>[ws]<SEP>[ws]<DOUBLE_VALUE>
bool ImportDoubleArg(double& value, const char* s, const StringSet& IdentColl,
     const char* Sep = NULL);

//****************************************************************************************
// Определение типов скобок
//****************************************************************************************
enum BRACKETS {brROUND=1, brSQUARE, brBRACES, brANGLE};
//****************************************************************************************
// Определение классов символов представления чисел
//****************************************************************************************
enum DigToken {dtEmpty=0,dtDigit, dtSign, dtSpace, dtOther, dtEOS, dtPoint, dtExp};
//****************************************************************************************
// Определение состояний преобразователя символов строки в десятичные цифры
//****************************************************************************************
enum DigMode {dmIdle=0, dmSign, dmInteger, dmPoint, dmReal, dmExp, dmExpSign, dmExpVal,
              dmError};
//****************************************************************************************
// Определение классов лексем
//****************************************************************************************
enum TOKEN {tEOS=0, tOther, tDelim, tBeginMarker, tEndMarker, tNumber, tWS};

//****************************************************************************************
//Предварительное объявление имен классов
//****************************************************************************************
class TPairBrackets;
class TStrToDouble;//Преобразование символов строки в вещественное число
class TStrToDoubleList;//Извлечение из строки вещественных чисел

//!!! New
class TStrToDoubleArgs;//Извлечение из строки вещественных чисел, заключенных в скобки

//Преобразование последовательности целых чисел типа long в строку с распознаванием цепочек
//чисел, образующих арифметическую прогрессию, и представлением их в строке в виде замкну-
//того интервала: [begin, begin+d .. end]
class TLongValsToStr;

//template <class T> class TStrToReal;

//****************************************************************************************
//                     Объявление класса TLongValsToStr
//Преобразование последовательности целых чисел типа long в строку с распознаванием цепочек
//чисел, образующих арифметическую прогрессию, и представлением их в строке в виде замкну-
//того интервала: [begin, begin+d .. end], где
//1) <long> begin - начальное значение арифметической прогрессии;
//2) <long> end - последнее значение арифметической прогрессии;
//3) <long> d - приращение арифметической прогрессии.
//Выделение из контейнера целых чисел последовательности, образующих арифметическую прогрес-
//сию позволяет представить содержимое контейнера в виде строке в краткой форме. Минимальное
//количество чисел, образующих интервал равно 3. Если d = 1, то интервал в строке имеет
//вид: [begin .. end]. Класс управляется тремя public-функциями: Start(), Add(long value),
//Stop() и реализуется в виде конечного автомата с пятью внутренними состояниями: WAIT, FIRST,
//SECOND, INTERVAL и IDLE. Функция Start() переводит атомат в начальное состояние WAIT,
//сбрасывая ранее полученные результаты. Функция Stop() переводит автомат в конечное состояние
//IDLE. В этом состоянии класс завершает преобразование чисел в строчное представление и
//накопление их в строковом буфере, позволяет владельцу класса получить результат преобразо-
//вания целых чисел в строку с распознаванием интервальных цепочек, узнать количество обрабо-
//танных чисел и число обнаруженных интервалов с помощью дополнительных сервисных функций,
//реализуемых в классе. Функция Add(long value) добавляет в объект класса очередное число и
//в зависимости от состояния автомата и значения числа может переводить его в три состояния:
//FIRST, SECOND и INTERVAL.
//****************************************************************************************
class TLongValsToStr {
private:
//**************************************************************************************
//Состояния класса
//**************************************************************************************
 enum MODE {WAIT = 0, FIRST, SECOND, INTERVAL, IDLE};
//----------------------------------------------------------------------------------------
// Объявление закрытых членов-данных класса TLongValsToStr
//----------------------------------------------------------------------------------------
 MODE _State;//Номер текущего состояния
 string _Buf;//Строка с результатами преобразования
 ulong _Count;//Число целых чисел, переданных классу
 ulong _Intervals;//Количество обнаруженных интервалов
 ulong _Vals_in_Interval;//Количество чисел в текущем интервале
 long _begin;//Начальное значение интервала
 long _end;//Конечное значение интервала
 long _d;//Приращение в текущей арифметической прогрессии

//----------------------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРА и ДЕСТРУКТОРА КЛАССА TLongValsToStr
//----------------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TLongValsToStr() {Start();};
 //Объявление деструктора класса
 ~TLongValsToStr() {Start();};

 //---------------------------------------------------------------------------------------
 // Объявление общедоступных членов-функций класса TLongValsToStr
 //---------------------------------------------------------------------------------------
 void Start();//Установка автомата в начальное состояние WAIT
 bool Add(long value);//Передача числа на вход автомата
 ulong Stop();//Установка автомата в конечное состояние IDLE

 //---------------------------------------------------------------------------------------
 //Получение свойства класса TLongValsToStr
 //---------------------------------------------------------------------------------------
 //Присвоение s строки-результата _Buf с возвращением количесвта обработанных чисел
 ulong GetResult(string& s) const {s.assign(_Buf); return this->GetValCount();};
 //Общее число, обнаруженных интервалов
 ulong GetIntervals() const {return this->_Intervals;};
 //Количество чисел, переданных объекту класса на обработку
 ulong GetValCount() const {return this->_Count;};

};//Завершение объявления класса TLongValsToStr
//--------------------------- Завершение класса TLongValsToStr ---------------------------

//****************************************************************************************
//      Объявление класса TStrToDouble - ПРЕОБРАЗОВАНИЕ СТРОКИ В ВЕЩЕСТВЕННОЕ ЧИСЛО
//Класс TStrToDouble позволяет преобразовывать символьное представление вещественного числа
//в значение типа double. Символьная строка должна представлять из себя последовательность
//символов, которые могут быть интерпретированы как вещественное число.
//Формат представления вещественных чисел:
// [ws] [sn] [ddd] [.] [ddd] [fmt[sn]ddd], где
// [ws]	= optional whitespace <TAB,SPACE>
// [sn]	= optional sign <+->
// [ddd]= optional digits <0123456789>
// [fmt]= optional exponent <eE>
// [.]	= optional decimal point <.>
//Класс приспособлен для извлечения последовательности вещественных чисел из строки и
//способен обнаруживать ошибки в символьном предствлении вещественных чисел.
//****************************************************************************************
class TStrToDouble {
private:
//Определение указателя pHndlMode на функцию-член класса TStrToDouble
typedef bool (TStrToDouble::*pHndlMode)();

//-----------------------------------------------------------------------------------
// Объявление закрытых членов-данных класса TStrToDouble
//-----------------------------------------------------------------------------------
double Value;//значение вещественного числа, извлеченного из строки

int Exponent;//значение порядка числа
uchar DigAfterPoint;//счетчик количества цифр после десятичной точки
uchar Digits;//счетчик количества цифр до и после запятой
uchar DigExpPart;//счетчик количества цифр в порядке числа
uchar RightZeros;//счетчик правых нулей в числе
bool  lNonZeroValue;//индикатор ненулевого значения числа
bool  lNonZeroExp;//индикатор ненулевого значения порядка числа

bool lSuccess;//индикатор извлечения из строки числа <true - ДА, false - НЕТ>

bool lSignNum;//знак числа <true +, false ->
bool lIsSignNum;//наличие знака числа в явном виде <true - ЕСТЬ, false - НЕТ>
bool lSignExp;//знак порядка <true +, false ->
bool lIsSignExp;//наличие знака порядка числа в явном виде <true - ЕСТЬ, false - НЕТ>

const char* pStr;//указатель на начало строки
const char* pCur;//указатель на текущий обрабатываемый символ строки

DigToken TokenClass;//класс литеры (символа) <SPACE,SIGN,DIGIT,POINT,EXP,OTHER,EOS,EMPTY>
ulong TokenValue;//значение (идентификатор) литеры в классе

bool lIdentSign; //опция распознавания символов знака числа <-+>
bool lIdentPoint;//опция распознавания символа десятичной точки <.>
bool lIdentExp;  //опция распознавания символа порядка числа <eE>

DigMode State;//номер текущего состояния преобразователя строки в вещественное число

//Таблица указателей на функции-обработчики состояния класса
pHndlMode Table[8];

//-----------------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРА и ДЕСТРУКТОРА КЛАССА TStrToDouble
//-----------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TStrToDouble() {Init(); SetHndlModeTable();};
 //Объявление деструктора класса
 ~TStrToDouble() {Init();};
//-----------------------------------------------------------------------------------
// Объявление общедоступных членов-функций класса TStrToDouble
//-----------------------------------------------------------------------------------
 //Перегрузка оператора вызова функции ()
 bool operator ()(const string& s, ulong& pos, double& value);
 bool operator ()(const string& s, ulong& pos);
 bool operator ()(const char* s, ulong& pos, double& value);
 bool operator ()(const char* s, ulong& pos);
 //Получение значения, извлеченного из строки
 double GetValue() const {return Value;};
 //Определение текущего состояния класса
 DigMode GetMode() const {return State;};
 //Определение состояния "ОШИБКА" при преобразованиии строки в число
 bool IsError() const {return (State == dmError) ? true : false;};
 //Определение класса символа, на котором завершилось преобразование
 DigToken GetTokenClass() const {return TokenClass;};
 //Определение символа "КОНЕЦ СТРОКИ"
 bool IsEOS() const {return (TokenClass == dtEOS) ? true : false;};
 //Определение является ли извлеченное значение целым числом
 bool IsInteger() const
 {return (Exponent-DigAfterPoint+RightZeros >= 0) ? true : false;};

 //OVERLOAD THE ASSIGNMENT OPERATOR
 //Объявление перегруженного оператора присваивания operator =
 double operator =(const TStrToDouble& stod) {return stod.GetValue();};

private:
//----------------------------------------------------------------------------------------
// Объявление закрытых членов-функций класса TStrToDouble
//----------------------------------------------------------------------------------------
 void Init();//Начальная инициализация всех членов-данных класса
 void SetHndlModeTable();//Инициализация таблицы указателей на функции-обработчики состояний
 void LexicalBlock();//Блок лексического анализа
 bool Extract();//Извлечение из строки вещественного числа

 //Объявление функций-обработчиков состояний класса TStrToDouble
 bool HndlIdleMode();//Обработчик состояния dmIdle - "НАЧАЛЬНОЕ СОСТОЯНИЕ"
 bool HndlSignMode();//Обработчик состояния dmSign - "ЗНАК ЧИСЛА"
 bool HndlIntegerMode();//Обработчик состояния dmInteger - "ЦИФРЫ ДО ЗАПЯТОЙ"
 bool HndlPointMode();//Обработчик состояния dmPoint - "ДЕСЯТИЧНАЯ ТОЧКА"
 bool HndlRealMode();//Обработчик состояния dmReal - "ЦИФРЫ ПОСЛЕ ЗАПЯТОЙ"
 bool HndlExpMode();//Обработчик состояния dmExp - "ПОРЯДОК ЧИСЛА"
 bool HndlExpSignMode();//Обработчик состояния dmExpSign - "ЗНАК ПОРЯДКА ЧИСЛА"
 bool HndlExpValMode();//Обработчик состояния dmExpVal - "ЗНАЧЕНИЕ ПОРЯДКА ЧИСЛА"

 //Объявление дополнительных функций для преобразования строки в вещественное число
 void AddDigitToValue();
 void CompleteConversion();

};//Завершение объявления класса TStrToDouble
//------------------------- Завершение класса TStrToDouble --------------------------


//****************************************************************************************
// Класс TStrToDoubleArgs - ИЗВЛЕЧЕНИЕ ИЗ СТРОКИ ВЕЩЕСТВЕННЫХ ЧИСЕЛ, ЗАКЛЮЧЕННЫХ В СКОБКИ
//Класс TStrToDoubleArgs извлекает из строки вещественные числа, заключенные в скобки и
//преобразует их в числа типа double. Операция извлечения работает от начала маркера
//tBeginMarker (открывающейся скобки) до маркера конца блока tEndMarkerrker (закрывающейся
//скобки). Данные накапливаются в списке list<double> Data.
//Синтаксическая структура строки из которой извлекаются числа имеет следующий вид:
//<DOUBLE ARGS> = [<WS>]<LBR>[<NUMBER><DELIMETER>[WS]<NUMBER><DELIMETER>[<WS>]]<RBR>
//<WS> - пробельные ("пустые") символы (whitespaces) - " \t\n" (Space,Tab,CRLF) etc. После
//       DELIMETER и перед LBR количество WS не ограничивается.
//<LBR> - символ левой (открывающейся) скобки аналог tBeginMarker, символы - "({[" etc.;
//<NUMBER> - вещественное число;
//<DELIMETER> - символ-разделитель между числами, как правило, символы - " \t,;" etc.;
//<RBR> - символ правой (закрывающей) скобки аналог tEndMarker, символы - ")}]" etc.
//Символы, образующие вышеперечисленные лексемы (tokens), должны быть уникальными (не дуб-
//лироваться для двух или более лексем). Операция извлечения из строки списка вещественных
//аргументов считается успешной только при нахождении как левой так и правой скобок. Между
//скобками числа могут отсутствовать, что соответствует пустому списку вещественных чисел.
//Достижение конца строки <EOS> без обнаружения <RBR> считается ошибкой.
//Если при грамматическом разборе строки встречаются лексемы не принадлежащие вышеуказанным
//множествам или происходит синтаксическая ошибка, то разбор строки останавливается на данной
//лексеме и устанавливается состояние "СИНТАКСИЧЕСКАЯ ОШИБКА". При этом числа, извлеченные
//из строки в список типа list<double> не уничтожаются и доступны пользователю для дальнейшей
//обработки. Объект класса хранит указатель на последний извлеченный символ и содержит его
//классификационное значение согласно переменной перечислимого типа TOKEN. Для нераспознанных
//классом лексем устанавливается значение tOther.
//Класс работает с классом string и с const char*, не изменяя их содержимое. Класс может
//извлекать за один раз как один, так и произвольное кол-во списков аргументов вещ-х чисел,
//которые могут присутствовать в строке. Так как кол-во чисел в разных списках может варьи-
//роваться от 0 (для пустого списка) и выше, то в списке list<int> Info хранится кол-во
//чисел, извлеченных между каждой парой скобок, найденных в данной строке. Кроме того,
//предусмотрена возможность накапливать списки вещ-х аргументов для разных строк.
//****************************************************************************************
class TStrToDoubleArgs {
private:
//****************************************************************************************
//Состояния класса по извлечению вещественных чисел, заключенных в скобки, из строки
//****************************************************************************************
enum MODE {IdleMode=0, LBrMode, NumberMode, DelimMode, RBrMode, ErrorMode, StandByMode};
//Определение указателя pHndlMode на функцию-член класса TStrToDoubleArgs
typedef bool (TStrToDoubleArgs::*pHndlMode)();

//----------------------------------------------------------------------------------------
// Объявление закрытых членов-данных класса TStrToDoubleArgs
//----------------------------------------------------------------------------------------
TStrToDouble stod;//класс преобразования строки в вещественное число

list<double> Data;//значения вещественных чисел, извлеченных из строки
list<int> Info;//кол-во вещественных чисел между каждой парой извлеченных скобок

const char* pStr;//указатель на начало строки
const char* pCur;//указатель на текущий обрабатываемый символ строки

char cDelimeter;//символ-разделитель чисел в списке - tDelim
char cLBr;//символ левой скобки - tBeginMarker
char cRBr;//символ правой скобки - tEndMarker
string sWS;//множество пробельных символов - tWS

TOKEN TokenClass;//класс лексемы <tEOS,tOther,tDelim,tBeginMarker,tEndMarker,tNumber>
ulong TokenValue;//значение (идентификатор) лексемы в классе

bool lIdentLBr;//опция распознавания маркера начала списка
bool lIdentRBr;//опция распознавания маркера конца списка
bool lIdentNumber;//опция распознавания вещественного числа
bool lIdentDelim;//опция распознавания символа-разделителя соседних чисел

MODE State;//Номер текущего состояния
pHndlMode Table[5];//Таблица указателей на функции-обработчики состояния класса

//Таблица строковых сообщений состояния объекта класса и наименований состояний
deque<string> MsgTable;
deque<string> ModeTitles;
uchar MsgNumber;//Порядковый номер текущего сообщения состояния объекта класса

//----------------------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРА и ДЕСТРУКТОРА КЛАССА TStrToDoubleArgs
//----------------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TStrToDoubleArgs();
 //Конструктор с аргументами
 TStrToDoubleArgs(char LBr, char RBr, char Delim, const char* ws);
 //Объявление деструктора класса
 ~TStrToDoubleArgs() {Init();};

 //---------------------------------------------------------------------------------------
 // Объявление общедоступных членов-функций класса TStrToDoubleArgs
 //---------------------------------------------------------------------------------------
 //Перегрузка оператора вызова функции ()
 //Извлечение из строки одного списка вещ-х аргументов, заключенного в скобки
 long operator ()(const char* s, ulong& pos, bool lClear = true);
 long operator ()(const string& s, ulong& pos, bool lClear = true)
 {return this->operator ()(s.c_str(),pos,lClear);};
 //Извлечение из строки всех возможных списков вещ-х аргументов, заключенных в скобки
 long operator ()(const char* s, bool lClear = true);
 long operator ()(const string& s, bool lClear = true)
 {return this->operator ()(s.c_str(),lClear);};

 long GetFirstChain(rvector& V) const;//Получение первого списка аргументов
 long GetLastChain(rvector& V) const;//Получение последнего списка аргументов
 long GetAllChains(rvector& V) const;//Получение всех вещ-х аргументов, хранящихся в Data
 //Получение всех списков аргументов с заданным числом аргументов arg_num
 long GetAllChains(list<double>& d_list, long arg_num) const;

 //---------------------------------------------------------------------------------------
 //Установка свойств класса
 //---------------------------------------------------------------------------------------
 //Установка маркера конца списка аргументов - правая скобка
 char SetEndMarker(char RBracket) {return cRBr = RBracket;};
 //Установка маркера начала списка аргументов - левая скобка
 char SetBeginMarker(char LBracket) {return cLBr = LBracket;};
 //Установка символа-разделителя соседних чисел
 char SetDelim(char Delim) {return cDelimeter = Delim;};
 //Установка множества пробельных символов
 long SetWS(const string& ws) {sWS = ws; return sWS.size();};
 long SetWS(const char* ws) {sWS = ws; return sWS.size();};
 //Установка объекта класса в режим "ОЖИДАНИЯ"
 void SetStandByMode(bool lClear = true);

 //---------------------------------------------------------------------------------------
 //Получение свойства класса
 //---------------------------------------------------------------------------------------
 char GetDelim() const {return cDelimeter;};//Cимвол-разделитель соседних чисел
 char GetBeginMarker() const {return cLBr;};//Cимвол маркера начала списка - левая скобка
 char GetEndMarker() const {return cRBr;};//Cимвол маркера конца списка - правая скобка
 string& GetWS(string& s) const {return s = sWS;};//Пробельные символы

 //Определение текущего состояния класса
 string& GetMode(string& s) const  {return s = ModeTitles[State]+' '+MsgTable[MsgNumber];};
 //Определение текущего состояния класса
 MODE GetMode() const {return State;};
 //Определение состояния "ОШИБКА" при преобразованиии строки в число
 bool IsError() const {return (State == ErrorMode) ? true : false;};

 //Общее количество вещественных чисел, извлеченных из строки (строк) за все время
 long TotalCount() const {return Data.size();};
 //Количество списков вещественных чисел, извлеченных за все время
 long Series() const {return Info.size();};

 const char* GetCurPtr() const {return pCur;};//Указатель на последний символ
 //Определение класса лексемы, на которой завершилось преобразование
 TOKEN GetTokenClass() const {return TokenClass;};
 //Определение символа "КОНЕЦ СТРОКИ"
 bool IsEOS() const {return (TokenClass == tEOS) ? true : false;};



 //string& Properties(string& s) const;

 //OVERLOAD THE STREAM INSERTION OPERATOR
 //Перегрузка операции потокового вывода (<<) свойств класса
 //friend ostream& operator <<(ostream& out, const TStrToDoubleArgs& T)
 //{string s; return out << T.Properties(s);};

private:
//----------------------------------------------------------------------------------------
// Объявление закрытых членов-функций класса TStrToDoubleArgs
//----------------------------------------------------------------------------------------
 void Init();//Начальная инициализация всех членов-данных класса
 void ClearList();//Очистка списков
 //Инициализация таблицы указателей на функции-обработчики состояний, таблиц наименований
 //состояний объекта и состояний
 void SetTables();
 void SetIdleMode();//Установка объекта класса в режим "НАЧАЛЬНОЕ СОСТОЯНИЕ"

 void LexicalBlock();//Блок лексического анализа
 long Extract();//Извлечение из строки вещественных чисел, заключенных в скобки


 //Объявление функций-обработчиков состояний класса TStrToDoubleArgs
 bool HndlIdleMode();//Обработчик состояния IdleMode - "НАЧАЛЬНОЕ СОСТОЯНИЕ"
 bool HndlLBrMode();//Обработчик состояния LBrMode - "МАРКЕР НАЧАЛА СПИСКА"
 bool HndlNumberMode();//Обработчик состояния NumberMode - "ВЕЩЕСТВЕННОЕ ЧИСЛО"
 bool HndlDelimMode();//Обработчик состояния DelimMode - "СИМВОЛ-РАЗДЕЛИТЕЛЬ"
 bool HndlRBrMode();//Обработчик состояния RBrMode - "МАРКЕР КОНЦА СПИСКА"

};//Завершение объявления класса TStrToDoubleArgs
//------------------------- Завершение класса TStrToDoubleArgs ---------------------------

//****************************************************************************************
// Объявление класса TStrToDoubleList - ПРЕОБРАЗОВАНИЕ СТРОКИ В СПИСОК ВЕЩЕСТВЕННЫХ ЧИСЕЛ
//Класс TStrToDoubleList извлекает из строки вещественные числа и преобразует их в числа
//типа double. Операция извлечения работает до конца строки или до маркера конца блока
//(tEndMarker - End-of-Data Marker). Данные накапливаются в списке list<double>.
//Синтаксическая структура строки из которой извлекаются числа имеет следующий вид:
//<DOUBLE LIST> = <SPACES><NUMBER><DELIMETER>...<NUMBER><DELIMETER>[<ENDMARKER>|<EOS>]
//<SPACES> - начальные пробелы, как правило, символы - ПРОБЕЛ, ТАБУЛЯЦИЯ
//<NUMBER> - вещественное число
//<DELIMETER> - символ(ы)-разделитель(и) между числами, как правило, символы - " \t,;"
//и другие. Количество пробелов и табуляций между двумя символами не ограничивается.
//<ENDMARKER> - маркер(ы) конца списка (например, "\n.;" и другие). Желательно чтобы мно-
//жество <DELIMETER> и <ENDMARKER> не пересекалось. При их пересечении символ, принадлежащий
//обоим множествам, будет интерпретироваться как <ENDMARKER>. Если маркер(ы) конца списка
//отсутствуют, то извлечение чисел из строки будет происходить до конца строки.
//<EOS> - символ конца строки (терминальный символ по умолчанию).
//Если при грамматическом разборе строки встречаются лексемы не принадлежащие вышеуказанным
//множествам или происходит синтаксическая ошибка, то разбор строки останавливается на данной
//лексеме и устанавливается состояние "СИНТАКСИЧЕСКАЯ ОШИБКА". При этом числа, извлеченные
//из строки в список типа list<double> не уничтожаются и доступны пользователю для дальнейшей
//обработки. Объект класса хранит указатель на последний извлеченный символ и содержит его
//классификационное значение согласно переменной перечислимого типа TOKEN. Для нераспознанных
//классом лексем устанавливается значение tOther.
//Класс работает с классом string и с const char* и не изменяет их содержимое. Класс поз-
//воляет накапливать и хранить списки вещественных чисел, считанных за более чем одну сессию
//(за один раз). Каждый элемент списка list<int> Lines хранит кол-во чисел, считанных за
//одну сессию. Размер списка Lines равна количеству сессий. В списке Lines накапливаются
//данные только о тех сессиях, в которых произошло считывание хотя бы одного числа. Таким
//образом, класс TStrToDoubleList может быть приспособлен для считывания двумерного массива
//вещественных чисел из символьной строки. Одна сессия может рассматриваться как одна строка
//(столбец) двумерной матрицы, а каждый элемент списка Session будет информировать о кол-ве
//вещественных чисел в данной строке.
//****************************************************************************************
class TStrToDoubleList {
private:
//***********************************************************************************
//Определение состояний класса при извлечении вещественных чисел из строки символов
//***********************************************************************************
enum MODE {IdleMode=0, NumberMode, DelimMode, ErrorMode, StandByMode};
//Определение указателя pHndlMode на функцию-член класса TStrToDoubleList
typedef bool (TStrToDoubleList::*pHndlMode)();

//-----------------------------------------------------------------------------------
// Объявление закрытых членов-данных класса TStrToDoubleList
//-----------------------------------------------------------------------------------
TStrToDouble stod;//класс преобразования строки в вещественное число

std::list<double> Data;//значения вещественных чисел, извлеченных из строки
std::list<int> Lines;//кол-во вещественных чисел, хранимых в каждом ненулевом списке

string sDelimeter;//строка символов-разделителей
string sEndMarker;//строка символов маркера конца списка

const char* pStr;//указатель на начало строки
const char* pCur;//указатель на текущий обрабатываемый символ строки

TOKEN TokenClass;//класс литеры (символа) <tEOS,tOther,tDelim,tEndMarker,tNumber>
ulong TokenValue;//значение (идентификатор) литеры в классе

bool lIdentNumber;//опция распознавания вещественных чисел
bool lIdentDelim;//опция распознавания символа-разделителя между двумя числами
bool lIdentEndMarker;//опция распознавания маркера конца списка

MODE State;//Номер текущего состояния

pHndlMode Table[3];//Таблица указателей на функции-обработчики состояния класса
//Таблица строковых сообщений состояния объекта класса и наименований состояний
std::deque<string> MsgTable;
std::deque<string> ModeTitles;
uchar MsgNumber;//Порядковый номер текущего сообщения состояния объекта класса

//-----------------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРА и ДЕСТРУКТОРА КЛАССА TStrToDoubleList
//-----------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TStrToDoubleList() {Init(); SetTables(); SetDelim(" \t");};
 //Конструктор с аргументами
 TStrToDoubleList(const string& Delimeters, const string& EndMarkers)
 {Init(); SetTables(); SetDelim(Delimeters); SetEndMarker(EndMarkers);};

 TStrToDoubleList(const char* Delimeters, const char* EndMarkers)
 {Init(); SetTables(); SetDelim(Delimeters); SetEndMarker(EndMarkers);};
 //Объявление деструктора класса
 ~TStrToDoubleList() {Init();};
//-----------------------------------------------------------------------------------
// Объявление общедоступных членов-функций класса TStrToDoubleList
//-----------------------------------------------------------------------------------
 //Перегрузка оператора вызова функции ()
 ulong operator ()(const string& s, ulong& pos, bool lClearList = true);
 ulong operator ()(const char* s, ulong& pos, bool lClearList = true);
 rmatrix& operator()(rmatrix& A, const string& s, ulong& pos, double DefValue = 0.0)
 {StrToMultiList(s,pos); GetData(A,DefValue); return A;};
 //Извлечение последовательности списков вещественных чисел из строки, разделенных
 //символами конца списка
 ulong StrToMultiList(const string& s, ulong& pos, bool lClearList = true);
 ulong StrToMultiList(const char* s, ulong& pos, bool lClearList = true);
 //Общее количество вещественных чисел, извлеченных из строки (строк) за все время
 ulong TotalCount() const {return Data.size();};
 //Количество ненулевых списков вещественных чисел, извлеченных за все время
 ulong ListCount() const {return Lines.size();};
 //Получение значений, извлеченных из строки (строк) за все время
 ulong GetData(rvector& V) const;
 ulong GetData(rmatrix& A, double DefValue = 0.0) const;
 //Определение текущего состояния класса
 MODE GetMode() const {return State;};
 //Указатель на последний символ
 const char* GetCurPtr() const {return pCur;};
 //Определение состояния "ОШИБКА" при преобразованиии строки в число
 bool IsError() const {return (State == ErrorMode) ? true : false;};
 //Определение класса символа, на котором завершилось преобразование
 TOKEN GetTokenClass() const {return TokenClass;};
 //Определение символа "КОНЕЦ СТРОКИ"
 bool IsEOS() const {return (TokenClass == tEOS) ? true : false;};
 //Определение символа "End-of-Data Marker"
 bool IsEndMarker() const {return (TokenClass == tEndMarker) ? true : false;};
 //Установка символов-разделителей
 ulong SetDelim(const string& s)
 {sDelimeter = (s.length() != 0) ? s : string(" \t"); return sDelimeter.length();};
 ulong SetDelim(const char* s)
 {sDelimeter = (strlen(s) != 0) ? s : " \t"; return sDelimeter.length();};
 //Установка символов маркера конца блока данных
 ulong SetEndMarker(const string& s) {sEndMarker = s; return sEndMarker.length();};
 ulong SetEndMarker(const char* s) {sEndMarker = s; return sEndMarker.length();};

 void SetStandByMode();//Установка объекта класса в режим "ОЖИДАНИЯ"
 void ClearList() {Data.resize(0L); Lines.resize(0L);}//Удалить все числа из списка

 //----------------------------------------------------------------------------------
 //Формирование свойств класса в виде символьной строки (строковых сообщений)
 //----------------------------------------------------------------------------------
 //Определение текущего состояния класса
 string& GetMode(string& s) const
 {return s = ModeTitles[State]+' '+MsgTable[MsgNumber];};
 //Формирование строки с символами-разделителями
 string& GetDelim(string& s) const {return s = sDelimeter;};
 //Формирование строки с символами маркера конца блока (списка)
 string& GetEndMarker(string& s) const {return s = sEndMarker;};

 //string& Properties(string& s, string& head = string(), uint indent = 0) const;

 //OVERLOAD THE STREAM INSERTION OPERATOR
 //Перегрузка операции потокового вывода (<<) свойств класса
 //friend ostream& operator <<(ostream& out, const TGaussDistortionOperator& Operator)
 //{string s; return out << Operator.Properties(s);};

 //OVERLOAD THE ASSIGNMENT OPERATOR
 //Объявление перегруженного оператора присваивания operator =
 //friend ostream& operator <<(ostream& out, const TStrToDoubleList& DList);

private:
//-----------------------------------------------------------------------------------
// Объявление закрытых членов-функций класса TStrToDoubleList
//-----------------------------------------------------------------------------------
 void Init();//Начальная инициализация всех членов-данных класса
 //Инициализация таблицы указателей на функции-обработчики состояний, таблиц наименований
 //состояний объекта и состояний
 void SetTables();
 void LexicalBlock();//Блок лексического анализа
 ulong Extract();//Извлечение из строки вещественных чисел

 //Объявление функций-обработчиков состояний класса TStrToDoubleList
 bool HndlIdleMode();//Обработчик состояния IdleMode - "НАЧАЛЬНОЕ СОСТОЯНИЕ"
 bool HndlNumberMode();//Обработчик состояния NumberMode - "ВЕЩЕСТВЕННОЕ ЧИСЛО"
 bool HndlDelimMode();//Обработчик состояния DelimMode - "СИМВОЛ-РАЗДЕЛИТЕЛЬ"

 //Объявление дополнительных функций
 void SetIdleMode();//Установка объекта класса в режим "НАЧАЛЬНОЕ СОСТОЯНИЕ"

};//Завершение объявления класса TStrToDoubleList
//------------------------- Завершение класса TStrToDoubleList ---------------------------

/*
//***********************************************************************************
//    Объявление класса TStrToReal - ПРЕОБРАЗОВАНИЕ СТРОКИ В ВЕЩЕСТВЕННОЕ ЧИСЛО
//Шаблонный класс TStrToReal позволяет преобразовывать символьное представление
//вещественного числа в значение типа float, double или long double. Символьная строка
//должна представлять из себя последовательность символов, которые могут быть
//интерпретированы как вещественное число. Формат представления вещественных чисел:
// [ws] [sn] [ddd] [.] [ddd] [fmt[sn]ddd], где
// [ws]	=	optional whitespace <TAB,SPACE>
// [sn]	=	optional sign <+->
// [ddd]	=	optional digits <0123456789>
// [fmt]	=	optional exponent <eE>
// [.]	=	optional decimal point <.>
//Класс приспособлен для извлечения последовательности вещественных чисел из строки и
//способен обнаруживать ошибки в символьном предствлении вещественных чисел.
//***********************************************************************************
template <class T> class TStrToReal {
private:
//-----------------------------------------------------------------------------------
// Объявление закрытых членов-данных класса TStrToReal
//-----------------------------------------------------------------------------------
T Value;//значение вещественного числа, извлеченного из строки

int Exponent;//значение порядка числа
uchar DigAfterPoint;//счетчик количества цифр после десятичной точки
uchar Digits;//счетчик количества цифр до и после запятой
uchar DigExpPart;//счетчик количества цифр в порядке числа

bool lSuccess;//индикатор извлечения из строки числа <true - ДА, false - НЕТ>
bool lError;//индикатор обнаружения ошибки в символьном представлении числа <true>

bool lSignNum;//знак числа <true +, false ->
bool lIsSignNum;//наличие знака числа в явном виде <true - ЕСТЬ, false - НЕТ>
bool lSignExp;//знак порядка <true +, false ->
bool lIsSignExp;//наличие знака порядка числа в явном виде <true - ЕСТЬ, false - НЕТ>

const char* pStr;//указатель на начало строки
ulong szStr;//длина строки ???
ulong nPos;//указатель на текущий обрабатываемый символ в строке ???

DigToken TokenClass;//класс литеры (символа) <SPACE,SIGN,DIGIT,POINT,EXP,OTHER,EOS,EMPTY>
uchar TokenValue;//значение (идентификатор) литеры в классе

bool lIdentSpace;//опция распознавания пробельных символов
bool lIdentSign; //опция распознавания символов знака числа <-+>
bool lIdentPoint;//опция распознавания символа десятичной точки <.>
bool lIdentExp;  //опция распознавания символа порядка числа <eE>

DigMode State;//номер текущего состояния преобразователя строки в вещественное число

//Определение указателя pHndlMode на функцию-член шаблонного класса TStrToReal<T>
typedef bool (TStrToReal<T>::*pHndlMode)();
//Таблица указателей на функции-обработчики состояния класса
pHndlMode Table[8];

//-----------------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРА и ДЕСТРУКТОРА КЛАССА TStrToReal
//-----------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TStrToReal() {Init(); SetHndlModeTable();};
 //Объявление деструктора класса
 ~TStrToReal() {Init();};
//-----------------------------------------------------------------------------------
// Объявление общедоступных членов-функций класса TStrToReal
//-----------------------------------------------------------------------------------
 //Перегрузка оператора вызова функции ()
 bool operator ()(const string& s, ulong& pos, T& value);
 bool operator ()(const char* s, ulong& pos, T& value);
 //Получение значения, извлеченного из строки
 T GetValue() const {return Value;};

private:
//-----------------------------------------------------------------------------------
// Объявление закрытых членов-функций класса TStrToReal
//-----------------------------------------------------------------------------------
 Init();//Начальная инициализация всех членов-данных класса
 SetHndlModeTable();//Инициализация таблицы указателей на функции-обработчики состояний
 LexicalBlock();//Блок лексического анализа
 bool Extract();//Извлечение из строки вещественного числа

 //Объявление функций-обработчиков состояний класса TStrToReal
 bool HndlIdleMode();//Обработчик состояния dmIdle - "НАЧАЛЬНОЕ СОСТОЯНИЕ"
 bool HndlSignMode();//Обработчик состояния dmSign - "ЗНАК ЧИСЛА"
 bool HndlIntegerMode();//Обработчик состояния dmInteger - "ЧИСЛА ДО ЗАПЯТОЙ"
 bool HndlPointMode();//Обработчик состояния dmPoint - "ДЕСЯТИЧНАЯ ТОЧКА"
 bool HndlRealMode();//Обработчик состояния dmReal - "ЧИСЛА ПОСЛЕ ЗАПЯТОЙ"
 bool HndlExpMode();//Обработчик состояния dmExp - "ПОРЯДОК ЧИСЛА"
 bool HndlExpSignMode();//Обработчик состояния dmExpSign - "ЗНАК ПОРЯДКА ЧИСЛА"
 bool HndlExpValMode();//Обработчик состояния dmExpVal - "ЗНАЧЕНИЕ ПОРЯДКА ЧИСЛА"

};//Завершение объявления класса TStrToReal
//-------------------------- Завершение класса TStrToReal ---------------------------
*/


//***********************************************************************************
//             Объявление класса TPairBrackets - ПАРНЫЕ СКОБКИ
//Класс осуществляет хранение позиций левой и правой парных скобок в строке, а
//также номер уровня вложенности для данной пары скобок.
//ЗАМЕЧАНИЯ:
//1. При Left == Right - скобка пустая и Left <= Right.
//2. Уровень вложенности Level начинается с 1.
//ОПЕРАЦИИ ОТНОШЕНИЯ МЕЖДУ ДВУМЯ КЛАССАМИ типа TPairBrackets:
//1. Brk1 == Brk2, Brk1.Level() == Brk2.Level()
//2. Brk1 < Brk2, Brk1.Level() < Brk2.Level()
//3. Brk1 > Brk2, Brk1.Level() > Brk2.Level()
//***********************************************************************************
class TPairBrackets {
//-----------------------------------------------------------------------------------
// Объявление защищенных членов-данных класса TPairBrackets
//-----------------------------------------------------------------------------------
protected:
 ulong _Left; //Позиция левой скобки в строке
 ulong _Right;//Позиция правой скобки в строке
 ulong _Level;//Уровень вложенности данной пары скобок
//-----------------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TPairBrackets
//-----------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TPairBrackets() {Set(0L,0L,0L);};
 //Конструктор с аргументами
 TPairBrackets(ulong left, ulong right, ulong level) {Set(left,right,level);};
 //Объявление конструктора копирования
 TPairBrackets(const TPairBrackets &Bracket) {*this = Bracket;};
 //Объявление деструктора класса
 ~TPairBrackets() {Set(0L,0L,0L);};
//------------------------------------------------------------------------------
// Объявление общедоступных членов-функций класса TPairBrackets
//------------------------------------------------------------------------------
 //Получение свойств класса
 ulong Left() const  {return _Left;};//Позиция левой скобки
 ulong Right() const {return _Right;};//Позиция правой скобки
 ulong Level() const {return _Level;};//Уровень вложенности пары скобок
 //-----------------------------------------------------------------------------
 //Установка свойств класса
 bool Set(ulong left, ulong right, ulong level);
 //Установка позиции левой скобки
 bool SetLeft(ulong left) {return Set(left,Right(),Level());};
 //Установка позиции правой скобки
 bool SetRight(ulong right) {return Set(Left(),right,Level());};
 //Установка уровня вложенности пары скобок
 void SetLevel(ulong level) {_Level = level;};
 //-----------------------------------------------------------------------------
 //Формирование свойств класса в виде символьной строки
 string& Properties(string& s, string& head, uint indent = 0) const;
 //OVERLOAD THE STREAM INSERTION OPERATOR
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator <<(ostream& out, const TPairBrackets& Brackets);

 //-----------------------------------------------------------------------------
 //ПЕРЕГРУЗКА ОПЕРАТОРОВ для класса TPairBrackets
 //Перегрузка оператора присваивания (=)
 TPairBrackets& operator =(const TPairBrackets& Brackets);
 //Перегрузка оператора равенства (==)
 bool operator ==(const TPairBrackets& Brackets) const;
 //Перегрузка оператора "меньше" (<)
 bool operator <(const TPairBrackets& Brackets) const;
 //Перегрузка оператора "больше" (>)
 bool operator >(const TPairBrackets& Brackets) const;
};//Завершение объявления класса TPairBrackets

//--------------------- Завершение класса TPairBrackets ------------------------


//--------------------- The end of file "parsing.h" ---------------------------
#endif //ЗАВЕРШЕНИЕ ОБЪЯВЛЕНИЯ ЗАГОЛОВОЧНОГО ФАЙЛА "PARSING.H"
