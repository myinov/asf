//Image.cpp
//Copyright (c) JohnSoft 2002. All rights reserved. Borland C++ 5.02.
//Initial date: January,20,2002. Final date:
//Реализация классов по обработке дискретного изображения
#include "image.h"

//***********************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TImpulseResponse
//***********************************************************************************

//===================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TImpulseResponse
//    PUBLIC MEMBER-FUNCTION OF TImpulseResponse CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetHSamples(imatrix& H_1, imatrix& H_2) const
//НАЗНАЧЕНИЕ: Функция формирует в матрицах H_1 & H_2, передаваемых по ссылке, значения
//отсчетов по первой и второй координатам соответственно, по которым строится матрица
//импульсного отклика системы обработки двумерных сигналов (изображений). При нулевых
//размерах входной или выходной выборки функция возвращает false, H_1 & H_2 становятся
//матрицами нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& H_1 - ссылка на матрицу целых чисел, в которой формируются значения
//   отсчетов по первой координате (по горизонтали);
//2. imatrix& H_2 - ссылка на матрицу целых чисел, в которой формируются значения
//   отсчетов по второй координате (по вертикали);
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак построения матриц со значениями
//выборок для построения матрицы импульсного отклика двумерной системы обработки
//дискретных изображений
//***********************************************************************************
bool TImpulseResponse::GetHSamples(imatrix& H_1, imatrix& H_2) const
{if (IsReady() == false)
 {H_1.Set(0L,false); H_2.Set(0L,false); return false;}
 //Формирование матриц H_1 & H_2 необходимой размерности в соответствии с размерами
 //входного и выходного изображения
 ulong In = GetInSize();//Кол-во отсчетов входного сигнала (изображения)
 ulong Out = GetOutSize();//Кол-во отсчетов выходного сигнала (изображения)
 if (H_1.Set(Out,In,false) == false) {H_2.Set(0L,false); return false;}
 if (H_2.Set(Out,In,false) == false) {H_1.Set(0L,false); return false;}
 //Вычисление значений выборок для первой и второй координаты
 ulong hY = 0L, hX, wY = 0L;
 long dW = GetInW0()-GetOutW0();
 long dH = GetOutH0()-GetInH0();
 long n1, n2;

 for (ulong i = 0L; i < Out; i++)
 {hX = 0L; n2 = dH-hY; n1 = wY+dW;
  for (ulong j = 0L; j < In; j++)
  {H_1.Put(i,j,n1); H_2.Put(i,j,n2);
   if (++hX == GetInHeight()) {hX = 0L; n1--; n2 = dH-hY;}
   else n2++;
  }
  if (++hY == GetOutHeight()) {hY = 0L; wY++;}
 }
 return true;
}
//***********************************************************************************
//СТАТУС: I.2; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetTrHSamples(imatrix& trH_1, imatrix& trH_2) const
//НАЗНАЧЕНИЕ: Формирование в матрицах trH_1 & trH_2, передаваемых по ссылке, значений
//отсчетов по первой и второй координатам соответственно, по которым строится транспо-
//нированная матрица импульсного отклика системы обработки двумерных сигналов (изобра-
//жений). В случае равенства 0 размеров входной или выходной выборки, то функция возв-
//ращает false и возвращаются матрицы trH_1 & trH_2 нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//1. imatrix& trH_1 - ссылка на матрицу целых чисел, в которой формируются значения
//   отсчетов по первой координате (по горизонтали);
//2. imatrix& trH_2 - ссылка на матрицу целых чисел, в которой формируются значения
//   отсчетов по второй координате (по вертикали);
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак построения матриц со значениями
//выборок для построения транспонированной матрицы импульсного отклика двумерной сис-
//темы обработки дискретных изображений
//***********************************************************************************
bool TImpulseResponse::GetTrHSamples(imatrix& trH_1, imatrix& trH_2) const
{if (IsReady() == false)
 {trH_1.Set(0L,false); trH_2.Set(0L,false); return false;}
 //Формирование матриц trH_1 & trH_2 необходимой размерности в соответствии с размерами
 //входного и выходного изображения
 ulong In = GetInSize();//Кол-во отсчетов входного сигнала (изображения)
 ulong Out = GetOutSize();//Кол-во отсчетов выходного сигнала (изображения)
 if (trH_1.Set(In,Out,false) == false) {trH_2.Set(0L,false); return false;}
 if (trH_2.Set(In,Out,false) == false) {trH_1.Set(0L,false); return false;}
 //Вычисление значений выборок для первой и второй координаты транспонированной
 //матрицы импульсного отклика
 ulong hY = 0L, hX, wY = 0L;
 long dW = GetInW0()-GetOutW0();
 long dH = GetOutH0()-GetInH0();
 long n1, n2;

 for (ulong i = 0L; i < Out; i++)
 {hX = 0L; n2 = dH-hY; n1 = wY+dW;
  for (ulong j = 0L; j < In; j++)
  {trH_1.Put(j,i,n1); trH_2.Put(j,i,n2);
   if (++hX == GetInHeight()) {hX = 0L; n1--; n2 = dH-hY;}
   else n2++;
  }
  if (++hY == GetOutHeight()) {hY = 0L; wY++;}
 }
 return true;
}
//***********************************************************************************
//СТАТУС: I.3; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetInSize(string& s) const
//НАЗНАЧЕНИЕ: Формирование размеров входной двумерной выборки (изображения) в s, пере-
//даваемой в функцию по ссылке. Функция возвращает ссылку на строку s. Формат:
//<Input = GetInSize() [HeightX x_WidthX]>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строку, в которой формиуется входной размер выборки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, с сформированными размером входной двумерной выборки
//***********************************************************************************
string& TImpulseResponse::GetInSize(string& s) const
{char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 //Формирование числа отсчетов и размеров входной двумерной выборки в виде строки
 text << "Input Sample = " << GetInSize();
 text << " [" << GetInHeight() << 'x' << GetInWidth() << "]" << ends;
 s.assign(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.4; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetOutSize(string& s) const
//НАЗНАЧЕНИЕ: Формирование размеров выходной двумерной выборки (изображения) в s, пе-
//редаваемой в функцию по ссылке. Функция возвращает ссылку на строку s. Формат:
//<Output = GetOutSize() [HeightY x_WidthY]>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строку, в которой формиуется выходной размер выборки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, с сформированными размером выходной двумерной выборки
//***********************************************************************************
string& TImpulseResponse::GetOutSize(string& s) const
{char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 //Формирование числа отсчетов и размеров выходной двумерной выборки в виде строки
 text << "Output Sample = " << GetOutSize();
 text << " [" << GetOutHeight() << 'x' << GetOutWidth() << "]" << ends;
 s.assign(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.5; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetHSamplesSize(string& s, uint left_indent = 0) const
//НАЗНАЧЕНИЕ: Формирование размеров входного и выходного изображений в строке s, пере-
//даваемой в функцию по ссылке. Функция возвращает ссылку на строку s. Формат:
//<Samples Size: Input [_HeightX x _WidthX], OutPut [_HeightY x _WidthY];>
//
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой формиуются размеры выборок;
//2. uint left_indent - отступ слева.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, с сформированными размерами входного и выходного
//изображений.
//***********************************************************************************
string& TImpulseResponse::GetHSamplesSize(string& s, uint left_indent) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 string space(left_indent,' ');
 s.assign(space+"Samples Size: ");
 //----------------------------------------------------------------------------------
 //Формирование размеров выборок входного и выходного изображений в виде строки
 text << "Input = " << GetInSize();
 text << " [" << GetInHeight() << 'x' << GetInWidth() << "], " << ends;
 s.append(text.str()); text.seekp(0);
 text << "Output = " << GetOutSize();
 text << " [" << GetOutHeight() << 'x' << GetOutWidth() << "];" << endl << ends;
 s.append(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.6; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetInOrigin(string& s) const
//НАЗНАЧЕНИЕ: Формирование начала координат отсчетов входной двумерной выборки (изоб-
//ражения) в s, передаваемой в функцию по ссылке. Функция возвращает ссылку на s.
//Формат: <(_OriginHX, _OriginWX)>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строку, в которой формируется начало
//координат отсчетов входной выборки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, с началом координат отсчетов входной двумерной выборки
//***********************************************************************************
string& TImpulseResponse::GetInOrigin(string& s) const
{char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 //Формирование числа отсчетов и размеров входной двумерной выборки в виде строки
 text << '(' << GetInH0() << ',' << GetInW0() << ')' << ends;
 s.assign(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.7; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetInOrigin(string& s) const
//НАЗНАЧЕНИЕ: Формирование начала координат отсчетов выходной двумерной выборки (изоб-
//ражения) в s, передаваемой в функцию по ссылке. Функция возвращает ссылку на s.
//Формат: <OutOrigin: (_OriginHY, _OriginWY)>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строку, в которой формируется начало
//координат отсчетов выходной выборки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, с началом координат отсчетов выходной двумерной выборки
//***********************************************************************************
string& TImpulseResponse::GetOutOrigin(string& s) const
{char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 //Формирование числа отсчетов и размеров входной двумерной выборки в виде строки
 text << '(' << GetOutH0() << ',' << GetOutW0() << ')' << ends;
 s.assign(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.8; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetOrigins(string& s, uint left_indent = 0) const
//НАЗНАЧЕНИЕ: Формирование начала отсчетов входного и выходного изображений в строке s,
//передаваемой в функцию по ссылке. Функция возвращает ссылку на строку s. Формат:
//<Origins: IN (_OriginHX, _OriginWX), OUT (_OriginHY, _OriginWY);\n>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой формиуются координаты начала отсчетов;
//2. uint left_indent - отступ слева.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку, с сформированными координаты
//начала отсчетов входного и выходного изображений.
//***********************************************************************************
string& TImpulseResponse::GetOrigins(string& s, uint left_indent) const
{string space(left_indent,' ');
 string t;
 s.assign(space+"Origins: ");
 //----------------------------------------------------------------------------------
 //Формирование координат начала отсчетов выборок входного и выходного изображений
 s.append("IN "); s.append(GetInOrigin(t));
 s.append(", OUT "); s.append(GetOutOrigin(t));
 s.append(1,'\n');
 return s;
}
//***********************************************************************************
//СТАТУС: I.9; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetInSettings(string& s) const
//НАЗНАЧЕНИЕ: Формирование размеров входной двумерной выборки и координат начала отс-
//четов в строке s, передаваемой в функцию по ссылке. Функция возвращает ссылку на
//строку s. Формат вывода: <HeightX x_WidthX;_OriginHX,_OriginWX>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строку, в которой формируется размер
//и координаты начала отсчетов входной выборки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку, с сформированными размерами и
//координатами начала отсчетов входной двумерной выборки
//***********************************************************************************
string& TImpulseResponse::GetInSettings(string& s) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 //Формирование размеров и координат начала отсчетов входной двумерной выборки в строке
 text << GetInHeight() << 'x' << GetInWidth() << ';'
      << GetInH0() << ',' << GetInW0() << ends;
 s.assign(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.10; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetOutSettings(string& s) const
//НАЗНАЧЕНИЕ: Формирование размеров выходной двумерной выборки и координат начала
//отсчетов в строке s, передаваемой в функцию по ссылке. Функция возвращает ссылку на
//строку s. Формат вывода: <HeightY x_WidthY;_OriginHY,_OriginWY>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строку, в которой формируется размеры
//и координаты начала отсчетов выходной выборки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку, с сформированными размерами и
//координатами начала отсчетов выходной двумерной выборки
//***********************************************************************************
string& TImpulseResponse::GetOutSettings(string& s) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 //Формирование размеров и координат начала отсчетов выходной двумерной выборки в строке
 text << GetOutHeight() << 'x' << GetOutWidth() << ';'
      << GetOutH0() << ',' << GetOutW0() << ends;
 s.assign(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.11; TImpulseResponse class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& GetHSamples(string& s, const string& delim = string(''),
//                    uint left_indent = 0) const;
//НАЗНАЧЕНИЕ: Функция размещает в строке s, передаваемой по ссылке, значения отсчетов
//матрицы импульсного отклика по двум координатам. Формат вывода значений:
// <h11<delim>h12<delim>h13<delim>...h1P\n>
// <h21<delim>h22<delim>h23<delim>...h2P\n>
// < ...................................\n>
// <hQ1<delim>hQ2<delim>hQ3<delim>...hQP\n>
// Каждый элемент hij представляется в следующем виде: <(q,p)>
// P - количество отсчетов входного двумерного сигнала (изображения)
// Q - количество отсчетов выходного двумерного сигнала (изображения)
// p - значение первой координаты отсчета для элемента hij
// q - значение второй координаты отсчета для элемента hij
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которую заносятся значения отсчетов;
//2. string& delim - строка символов-разделителей между двумя соседними элементами;
//3. uint left_indent - отступ слева.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку со значениями отсчетов.
//***********************************************************************************
string& TImpulseResponse::GetHSamples(string& s, const string& delim, uint left_indent) const
{string space(left_indent,' ');
 if (IsReady() == false)
  return s.assign(space+"Samples Size are Zero in Input or Output Images.\n");
 //Формирование матриц значений отсчетов для первой и второй координаты
 imatrix H1, H2;
 if (GetHSamples(H1,H2) == false)
  return s.assign(space+"Can't create matrixes with sample values.\n");
 //----------------------------------------------------------------------------------
 //Расчет ширины каждого столбца матриц H1 & H2 для форматированного вывода значений
 ivector WColsH1, WColsH2;
 H1.WidthCols(WColsH1); H2.WidthCols(WColsH2);

 char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 text.setf(ios::right);//Выравнивание по правому краю.
 s.resize(0);
 //Вывод значений элементов матриц H1 & H2 в строку s
 for (ulong i = 0L; i < H1.Rows(); i++)
 {s.append(space);
  for (ulong j = 0L; j < H1.Cols(); j++)
  {//Формирование символьного представления вещественного числа
   text << '(' << setw(WColsH1.Get(j)) << H1.Get(i,j) << ','
        << setw(WColsH2.Get(j)) << H2.Get(i,j) << ')';
   if ((H1.Cols()-j) > 1) text << delim << ends;
   else text << endl << ends;//Каждая строка матрицы выводится с новой строки
   s.append(text.str()); text.seekp(0);
  }
 }
return s;
}
//***********************************************************************************
//СТАТУС: I.12; TImpulseResponse class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& GetTrHSamples(string& s, const string& delim = string(''),
//                       uint left_indent = 0) const;
//НАЗНАЧЕНИЕ: Функция размещает в строке s, передаваемой по ссылке, значения отсчетов
//транспонированной матрицы импульсного отклика по двум координатам. Формат вывода:
// <h11<delim>h12<delim>h13<delim>...h1Q\n>
// <h21<delim>h22<delim>h23<delim>...h2Q\n>
// < ...................................\n>
// <hP1<delim>hP2<delim>hP3<delim>...hPQ\n>
// Каждый элемент hij представляется в следующем виде: <(p,q)>
// P - количество отсчетов входного двумерного сигнала (изображения)
// Q - количество отсчетов выходного двумерного сигнала (изображения)
// p - значение первой координаты отсчета для элемента hij
// q - значение второй координаты отсчета для элемента hij
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которую заносятся значения отсчетов;
//2. string& delim - строка символов-разделителей между двумя соседними элементами;
//3. uint left_indent - отступ слева.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку со значениями отсчетов.
//***********************************************************************************
string& TImpulseResponse::GetTrHSamples(string& s, const string& delim, uint left_indent) const
{string space(left_indent,' ');
 if (IsReady() == false)
  return s.assign(space+"Samples Size are Zero in Input or Output Images.\n");
 //Формирование матриц значений отсчетов для первой и второй координаты
 imatrix trH1, trH2;
 if (GetTrHSamples(trH1,trH2) == false)
  return s.assign(space+"Can't create matrixes with sample values.\n");
 //----------------------------------------------------------------------------------
 //Расчет ширины каждого столбца матриц H1 & H2 для форматированного вывода значений
 ivector WColsH1, WColsH2;
 trH1.WidthCols(WColsH1); trH2.WidthCols(WColsH2);

 char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 text.setf(ios::right);//Выравнивание по правому краю.
 s.resize(0);
 //Вывод значений элементов матриц H1 & H2 в строку s
 for (ulong i = 0L; i < trH1.Rows(); i++)
 {s.append(space);
  for (ulong j = 0L; j < trH1.Cols(); j++)
  {//Формирование символьного представления вещественного числа
   text << '(' << setw(WColsH1.Get(j)) << trH1.Get(i,j) << ','
        << setw(WColsH2.Get(j)) << trH2.Get(i,j) << ')';
   if ((trH1.Cols()-j) > 1) text << delim << ends;
   else text << endl << ends;//Каждая строка матрицы выводится с новой строки
   s.append(text.str()); text.seekp(0);
  }
 }
return s;
}
//***********************************************************************************
//СТАТУС: I.13; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//string& Info(string& s, string& head = string(), uint left_indent = 0) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта TImpulseResponse в виде строки.
//Свойства объекта заносятся в строку s, передаваемую в функцию по ссылке, предыдущее
//содержимое строки уничтожается.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& head - ссылка на строку с заголовком объекта;
//3. uint indent - отступ слева.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//***********************************************************************************
string& TImpulseResponse::Info(string& s, string& head, uint left_indent) const
{string t;
 string space(left_indent,' ');
 s.resize(0);
 //Формирование заголовка объекта
 s.append(space);
 if (head.empty()) s.append(GetType(t));
 else s.append(head);
 s.append(":\n");
 //----------------------------------------------------------------------------------
 //1. Формирование размеров входного и выходного изображения
 s.append(GetHSamplesSize(t,left_indent+1));
 //----------------------------------------------------------------------------------
 //2. Формирование координат начала отсчетов входного и выходного изображения
 s.append(GetOrigins(t,left_indent+1));
 //----------------------------------------------------------------------------------
 //3. Формирование сведений о функции импульсного отклика и ее параметрах
 s.append(GetConvKernel(t,left_indent+1));
 //----------------------------------------------------------------------------------
 //4. Формирование отсчетов матрицы импульсного отклика по двум координатам
 if (IsReady()) s.append(GetHSamples(t,"|",left_indent+1));
return s;
}
//***********************************************************************************
//СТАТУС: I.14; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//string& BriefInfo(string& s, string& head = string(), uint left_indent = 0) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта TImpulseResponse в виде строки. Функция не
//формирует матрицу отсчетов импульсного отклика. Свойства объекта заносятся в строку
//s, передаваемую в функцию по ссылке, предыдущее содержимое строки не сохраняется.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. string& head - ссылка на строку с заголовком объекта;
//3. uint indent - отступ слева.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//***********************************************************************************
string& TImpulseResponse::BriefInfo(string& s, string& head, uint left_indent) const
{string t;
 string space(left_indent,' ');
 //Формирование заголовка объекта
 s.assign(space);
 if (head.empty()) s.append(GetType(t));
 else s.append(head);
 s.append(":\n");
 //----------------------------------------------------------------------------------
 //1. Формирование размеров входного и выходного изображения
 s.append(GetHSamplesSize(t,left_indent+1));
 //----------------------------------------------------------------------------------
 //2. Формирование координат начала отсчетов входного и выходного изображения
 s.append(GetOrigins(t,left_indent+1));
 //----------------------------------------------------------------------------------
 //3. Формирование сведений о функции импульсного отклика и ее параметрах
 s.append(GetConvKernel(t,left_indent+1));
return s;
}
//***********************************************************************************
//СТАТУС: I.15; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditInSampleSize(uint left_indent = 0)
//НАЗНАЧЕНИЕ: Консольный ввод входных размеров двумерной выборки с проверкой парамет-
//ров [HeightX & WidthX] и подтверждением ввода. Допускается задание произвольных раз-
//меров входной двумерной выборки.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint left_indent - начальное смещение строки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TImpulseResponse::EditInSampleSize(uint left_indent)
{bool flag = true; int y = wherey(), x = wherex(); char c; ulong h, w;
 //Формирование заголовка
 string space = string(left_indent,' ');//Начальный отступ
 string s(space+"Edit <Input Sample Size>:");
 string t;
 do //Цикл ввода размеров входной двумерной выборки
 {cout << s << endl;
  cout << space << " Enter HEIGHT size: "; cin >> h;
  cout << space << " Enter WIDTH size: "; cin >> w;
  SetInSize(h,w);//Установка кол-ва входных отсчетов по вертикали и горизонтали
  ClrScr(x,y);//Очистка экрана
  //Отображение введенного значения и запрос на подтверждение ввода
  cout << space << GetInSize(t) << endl; gotoxy(x,wherey());
  cout << space << "Confirm data input, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  ClrScr(x,y);//Очистка экрана
 } while (flag);
}
//***********************************************************************************
//СТАТУС: I.16; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditOutSampleSize(uint left_indent = 0)
//НАЗНАЧЕНИЕ: Консольный ввод выходных размеров двумерной выборки с проверкой парамет-
//ров [HeightX & WidthX] и подтверждением ввода. Допускается задание произвольных раз-
//меров выходной двумерной выборки.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint left_indent - начальное смещение строки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TImpulseResponse::EditOutSampleSize(uint left_indent)
{bool flag = true; int y = wherey(), x = wherex(); char c; ulong h, w;
 //Формирование заголовка
 string t;
 string space = string(left_indent,' ');//Начальный отступ
 string s(space+"Edit <Output Sample Size>:");
 do //Цикл ввода размеров выходной двумерной выборки
 {cout << s << endl;
  cout << space << " Enter HEIGHT size: "; cin >> h;
  cout << space << " Enter WIDTH size: "; cin >> w;
  SetOutSize(h,w);//Установка кол-ва выходных отсчетов по вертикали и горизонтали
  ClrScr(x,y);//Очистка экрана
  //Отображение введенного значения и запрос на подтверждение ввода
  cout << space << GetOutSize(t) << endl; gotoxy(x,wherey());
  cout << space << "Confirm data input, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  ClrScr(x,y);//Очистка экрана
 } while (flag);
}
//***********************************************************************************
//СТАТУС: I.17; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditInOrigin(uint left_indent = 0)
//НАЗНАЧЕНИЕ: Консольный ввод координат начала отсчетов входной двумерной выборки с
//проверкой параметров [_OriginHX, _OriginWX] и подтверждением ввода. Допускается за-
//дание начала координат отсчетов входной двумерной выборки в диапазоне:
//1) 0 <= OriginHX < GetInHeight();
//2) 0 <= OriginWX < GetInWidth().
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint left_indent - начальное смещение строки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TImpulseResponse::EditInOrigin(uint left_indent)
{bool flag = true; int y = wherey(), x = wherex(); char c; ulong h0, w0;
 //Формирование заголовка
 string t;
 string space = string(left_indent,' ');//Начальный отступ
 string s(space+"Edit <IN Origin>:");
 do //Цикл ввода координат начала отсчетов входной двумерной выборки
 {cout << s << endl;
  cout << space << "HEIGHT Origin [0.." << GetInHeight() << "): "; cin >> h0;
  cout << space << "WIDTH Origin [0.." <<  GetInWidth() << "): "; cin >> w0;
  SetInOrigin(h0,w0);//Установка начала координат отсчетов входной выборки
  ClrScr(x,y);//Очистка экрана
  //Отображение введенных значений и запрос на подтверждение ввода
  cout << space << "IN Origin: " << GetInOrigin(t) << endl; gotoxy(x,wherey());
  cout << space << "Confirm data input, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  ClrScr(x,y);//Очистка экрана
 } while (flag);
}
//***********************************************************************************
//СТАТУС: I.18; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditOutOrigin(uint left_indent = 0)
//НАЗНАЧЕНИЕ: Консольный ввод координат начала отсчетов выходной двумерной выборки с
//проверкой параметров [_OriginHY, _OriginWY] и подтверждением ввода. Допускается за-
//дание начала координат отсчетов выходной двумерной выборки в диапазоне:
//1) 0 <= OriginHY < GetOutHeight();
//2) 0 <= OriginWY < GetOutWidth().
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint left_indent - начальное смещение строки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TImpulseResponse::EditOutOrigin(uint left_indent)
{bool flag = true; int y = wherey(), x = wherex(); char c; ulong h0, w0;
 //Формирование заголовка
 string t;
 string space = string(left_indent,' ');//Начальный отступ
 string s(space+"Edit <OUT Origin>:");
 do //Цикл ввода координат начала отсчетов выходной двумерной выборки
 {cout << s << endl;
  cout << space << "HEIGHT Origin [0.." << GetOutHeight() << "): "; cin >> h0;
  cout << space << "WIDTH Origin [0.." <<  GetOutWidth() << "): "; cin >> w0;
  SetOutOrigin(h0,w0);//Установка начала координат отсчетов выходной выборки
  ClrScr(x,y);//Очистка экрана
  //Отображение введенных значений и запрос на подтверждение ввода
  cout << space << "OUT Origin: " << GetOutOrigin(t) << endl; gotoxy(x,wherey());
  cout << space << "Confirm data input, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  ClrScr(x,y);//Очистка экрана
 } while (flag);
}
//***********************************************************************************
//СТАТУС: I.19; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit(bool lEditInSample = true)
//НАЗНАЧЕНИЕ: Консольное редактирование всех свойств объекта класса. Функция работает
//в режиме подтверждения и отображения введенных параметров объекта. Формат ввода:
//1. InputSampleSize (Размеры входной двумерной выборки);
//2. OutputSampleSize (Размеры выходной двумерной выборки);
//3. InOrigin (Координаты начала отсчетов входной двумерной выборки);
//4. OutOrigin (Координаты начала отсчетов выходной двумерной выборки);
//5. ConvolutionKernel Function Arguments (Ввод параметров функции ядра свертки)
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//bool lEditInSample [true] - опция разрешения/запрещения редактирования InSampleSize.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TImpulseResponse::Edit(bool lEditInSample)
{//Рабочие переменные
 int row_start = wherey();
 string s, line(78,'-');
 bool flag = true;
 char c;
 gotoxy(1,row_start); clreol();
 do //Цикл ввода параметров весового сумматора
 {cout << line << endl;
  cout << GetType(s) << ": < Edit Properties >" << endl;
  cout << line << endl;
  //---------------------------------------------------------------------------------
  //Редактирование размеров входной выборки
  //---------------------------------------------------------------------------------
  if (lEditInSample) EditInSampleSize(1);
  cout << " 1. " << GetInSize(s) << endl;
  //---------------------------------------------------------------------------------
  //Редактирование размеров выходной выборки
  //---------------------------------------------------------------------------------
  EditOutSampleSize(1);
  cout << " 2. " << GetOutSize(s) << endl;
  //---------------------------------------------------------------------------------
  //Редактирование координат начала отсчетов входной выборки
  //---------------------------------------------------------------------------------
  EditInOrigin(1);
  cout << " 3. IN Origin: " << GetInOrigin(s) << endl;
  //---------------------------------------------------------------------------------
  //Редактирование координат начала отсчетов выходной выборки
  //---------------------------------------------------------------------------------
  EditOutOrigin(1);
  cout << " 4. OUT Origin: " << GetOutOrigin(s) << endl;
  //---------------------------------------------------------------------------------
  //Редактирование параметров функции ядра свертки
  //---------------------------------------------------------------------------------
  EditConvKernel(1);
  cout << " 5. " << GetConvKernel(s);
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data input, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  ClrScr(1,row_start);//Очистка экрана
 } while (flag);
};
//***********************************************************************************
//СТАТУС: I.20; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool operator() (const rmatrix& X, rmatrix& Y, ulong hY = 0L, ulong wY = 0L)
//НАЗНАЧЕНИЕ: Расчет импульсного отклика системы обработки двумерных дискретных сигна-
//лов (изображений) по заданному входному воздействию X. Выходной сигнал (изображение)
//формируется в матрице Y, передаваемой по ссылке, количество отсчетов по вертикали и
//горизонтали задается величинами hY & wY соответственно. По умолчанию размерности
//входной и выходной выборок совпадают. Коэффициенты матрицы импульсного отклика сис-
//темы формируются "на лету", что позволяет избежать формирования матрицы импульсного
//отклика H в явном виде (формирование матрицы H приводит к большим затратам памяти,
//так как ее размерность для X(M,N) & Y(K*L) будет равна: H(Q,P), где Q=K*L, P=M*N).
//Матрица входного сигнала X не изменяется функцией.
//Функция возвращает true, если свертку удалось построить и false в противоположном
//случае. Возможные причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Не удалось выделить память под размещение элементов выходного сигнала Y.
//Операция построения импульсного отклика системы обработки двумерных дискретных сиг-
//налов по заданным входному сигналу X, функции ядра свертки (Convolution kernel) и
//размерам (количеству отсчетов) по вертикали и горизонтали реализуется АЛГОРИТМОМ:
//1. По размерам входного двумерного сигнала X и задаваемым размерам выходного сигнала
//   hY & wY формируется размерность матрицы импульсного отклика H(Q,P): Q=K*L, P=M*N
//   Q - количество строк матрицы импульсного отклика H;
//   P - количество столбцов матрицы импульсного отклика H;
//   M = X.rows() - количество отсчетов входного сигнала X по вертикали;
//   N = X.cols() - количество отсчетов входного сигнала X по горизонтали;
//   K = Y.rows() = hY - количество отсчетов выходного сигнала Y по вертикали;
//   L = Y.cols() = wY - количество отсчетов выходного сигнала Y по горизонтали;
//2. Формируется матрица выходного сигнала Y(hY,wY)
//3. В двойном цикле по Q и P вычисляется два значения отсчетов i & j для H(q,p) эле-
//   мента матрицы импульсного отклика системы: i = I - J; j = k-m
//   0 <= q < Q, 0 <= p < P
//   I - номер строчного блока матрицы H (0 <= I < L)
//   J - номер столбцового блока матрицы H (0 <= J < N)
//   k - вертикальный отсчет внутри блока (0 <= k < K)
//   m - горизонтальный отсчет внутри блока (0 <= m < M)
//   Когда значения k или m достигают своих предельных значений K или M соответственно,
//   они обнуляются, а значения I или J соответственно увеличиваются на единицу.
//4. Вычисленные значения i & j для H(q,p) элемента матрицы H являются аргументами
//   функции ядра свертки (Convolution kernel). По аргументам i & j, в соответствии
//   с функцией ядра и значению X(m,J) вычислятся величина sum во внутреннем цикле:
//   sum += ConvolutionKernel(i,j)*X(m,J). При выходе из внутреннего цикла величина
//   sum присваивается Y(k,I). При входе во внутренний цикл sum обнуляется.
//   Таким образом, формируются все элементы выходного двумерного сигнала (изображения)
//   без формирования матрицы H в явном виде.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& X - константная ссылка на входной двумерный дискретный сигнал;
//2. rmatrix& Y - ссылка на матрицу, в которой формируется выходной двумерный
//   дискретный сигнал (изображение);
//3. ulong hY (0L) - количество отсчетов формируемого выходного сигнала Y по вертикали;
//4. ulong wY (0L) - количество отсчетов формируемого выходного сигнала Y по горизонтали.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции свертки
//***********************************************************************************
bool TImpulseResponse::operator() (const rmatrix& X, rmatrix& Y, ulong hY, ulong wY)
{//----------------------------------------------------------------------------------
 //Проверка на возможность осуществления операции двумерной свертки
 //----------------------------------------------------------------------------------
 hY = (hY == 0L) ? X.Rows() : hY;
 wY = (wY == 0L) ? X.Cols() : wY;
 Set(X.Rows(),X.Cols(),hY,wY);
 if (!IsReady()) {Y.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Формирование матрицы выходного двумерного сигнала размерности hY x wY и
 //расчет двумерной дискретной свертки
 //----------------------------------------------------------------------------------
 return Convolute(X,Y);
}
//***********************************************************************************
//СТАТУС: I.21; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool operator() (const rmatrix& X, rvector& Y, ulong hY = 0L, ulong wY = 0L)
//НАЗНАЧЕНИЕ: Расчет импульсного отклика системы обработки двумерных дискретных сигна-
//лов (изображений) по заданному входному воздействию X. Выходной сигнал (изображение)
//формируется в векторе Y, передаваемый по ссылке, количество отсчетов по вертикали и
//горизонтали задается величинами hY & wY соответственно. Работа функции аналогична:
//bool operator() (const rmatrix& X, rmatrix& Y, ulong hY, ulong wY)
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& X - константная ссылка на входной двумерный дискретный сигнал;
//2. rvector& Y - ссылка на вектор, в котором формируется выходной двумерный
//   дискретный сигнал (изображение);
//3. ulong hY (0L) - количество отсчетов формируемого выходного сигнала Y по вертикали;
//4. ulong wY (0L) - количество отсчетов формируемого выходного сигнала Y по горизонтали.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции свертки
//***********************************************************************************
bool TImpulseResponse::operator() (const rmatrix& X, rvector& Y, ulong hY, ulong wY)
{//----------------------------------------------------------------------------------
 //Проверка на возможность осуществления операции двумерной свертки
 //----------------------------------------------------------------------------------
 hY = (hY == 0L) ? X.Rows() : hY;
 wY = (wY == 0L) ? X.Cols() : wY;
 Set(X.Rows(),X.Cols(),hY,wY);
 if (!IsReady()) {Y.Set(0L,COL,false); return false;}
 //----------------------------------------------------------------------------------
 //Формирование вектора выходного двумерного сигнала размерности hY x wY и
 //расчет двумерной дискретной свертки
 //----------------------------------------------------------------------------------
 return Convolute(X,Y);
}
//***********************************************************************************
//СТАТУС: I.22; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ImpulseResponse(rmatrix& H) const
//НАЗНАЧЕНИЕ: Формирование матрицы импульсного отклика системы обработки двумерных
//дискретных сигналов (изображений) по заданным размерам входной и выходной выборки и
//ядра свертки (Convolution kernel). Рассчитанные коэффициенты матрицы заносятся в
//матрицу H, передаваемую по ссылке. Функция не изменяет внутренних установок объекта
//класса. Функция возвращает true, если матрицу импульсного отклика удалось построить
//и false в противоположном случае. Возможные причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Не удалось выделить память под размещение элементов матрицы H.
//                               А Л Г О Р И Т М
//Построение матрицы импульсного отклика системы обработки двумерных дискретных сиг-
//налов по заданным входному сигналу X, функции ядра свертки (Convolution kernel) и
//размерам (количеству отсчетов) по вертикали и горизонтали реализуется АЛГОРИТМОМ:
//1. По размерам входного двумерного сигнала X и размерам выходного сигнала Y создается
//   матрица импульсного отклика H размерности QxP: Q=K*L, P=M*N
//   Q - количество строк матрицы импульсного отклика H;
//   P - количество столбцов матрицы импульсного отклика H;
//   M = HeightX - количество отсчетов входного сигнала X по вертикали;
//   N = WidthX  - количество отсчетов входного сигнала X по горизонтали;
//   K = HeightY - количество отсчетов выходного сигнала Y по вертикали;
//   L = WidthY  - количество отсчетов выходного сигнала Y по горизонтали;
//2. В двойном цикле по Q и P вычисляются два значения отсчетов i & j для H(q,p) эле-
//   мента матрицы импульсного отклика системы: i = I - J; j = k-m
//   0 <= q < Q, 0 <= p < P
//   I - номер строчного блока матрицы H (0 <= I < L)
//   J - номер столбцового блока матрицы H (0 <= J < N)
//   k - вертикальный отсчет внутри блока (0 <= k < K)
//   m - горизонтальный отсчет внутри блока (0 <= m < M)
//   Когда значения k или m достигают своих предельных значений K или M соответственно,
//   они обнуляются, а значения I или J соответственно увеличиваются на единицу.
//3. Вычисленные значения i & j для H(q,p) элемента матрицы H являются аргументами
//   функции ядра свертки (Convolution kernel). По аргументам i & j, в соответствии
//   с функцией ядра вычисляются коэффициенты матрицы импульсного отклика:
//   H(q,p) = ConvolutionKernel(i,j).
//   Таким образом, формируются все элементы матрицы импульсного отклика системы обра-
//   ботки двумерного дискретного сигнала (изображения) в явном виде.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: rmatrix& H - ссылка на матрицу в которой формируются
//                        коэффициенты матрицы импульсного отклика системы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак построения матрицы H
//***********************************************************************************
bool TImpulseResponse::ImpulseResponse(rmatrix& H) const
{//----------------------------------------------------------------------------------
 //Проверка на возможность построения матрицы импульсного отклика
 //----------------------------------------------------------------------------------
 if (!IsReady()) {H.Set(0L,false); return false;}
 //Формирование матрицы импульсного отклика необходимой размерности
 ulong In = GetInSize();//Кол-во отсчетов входного сигнала (изображения)
 ulong Out = GetOutSize();//Кол-во отсчетов выходного сигнала (изображения)
 if (!H.Set(Out,In,false)) return false;
 //----------------------------------------------------------------------------------
 //Расчет двумерной дискретной свертки
 //----------------------------------------------------------------------------------
 ulong hY = 0L, hX, wY = 0L;
 long dW = GetInW0()-GetOutW0();
 long dH = GetOutH0()-GetInH0();
 long n1, n2;

 for (ulong i = 0L; i < Out; i++)
 {hX = 0L; n2 = dH-hY; n1 = wY+dW;
  for (ulong j = 0L; j < In; j++)
  {H.Put(i,j,ConvolutionKernel(n1,n2));
   if (++hX == GetInHeight()) {hX = 0L; n1--; n2 = dH-hY;}
   else n2++;
  }
  if (++hY == GetOutHeight()) {hY = 0L; wY++;}
 }
return true;
}
//***********************************************************************************
//СТАТУС: I.23; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ImpulseResponse(rmatrix& H, double& normH) const
//НАЗНАЧЕНИЕ: Формирование матрицы импульсного отклика системы обработки двумерных
//дискретных сигналов (изображений) по заданным размерам входной и выходной выборки и
//ядра свертки (Convolution kernel). Рассчитанные коэффициенты матрицы заносятся в
//матрицу H, передаваемую по ссылке. Функция не изменяет внутренних установок объекта
//класса. Функция возвращает true, если матрицу импульсного отклика удалось построить
//и false в противоположном случае. Возможные причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Не удалось выделить память под размещение элементов матрицы H.
//Алгоритм работы функции аналогичен функции ImpulseResponse(H), кроме формирования
//самой функции импульсного отклика, функция рассчитывает квадрат евклидовой нормы
//матрицы H, что необходимо для построения ряда аналитических моделей.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& H - ссылка на матрицу в которой формируются коэффициенты матрицы
//   импульсного отклика системы;
//2. double& normH - ссылка на число, в котором ведется подсчет квадрата евклидовой
//   нормы матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак построения матрицы H
//***********************************************************************************
bool TImpulseResponse::ImpulseResponse(rmatrix& H, double& normH) const
{//----------------------------------------------------------------------------------
 //Проверка на возможность построения матрицы импульсного отклика
 //----------------------------------------------------------------------------------
 normH = 0.0;
 if (!IsReady()) {H.Set(0L,false); return false;}
 //Формирование матрицы импульсного отклика необходимой размерности
 ulong In = GetInSize();//Кол-во отсчетов входного сигнала (изображения)
 ulong Out = GetOutSize();//Кол-во отсчетов выходного сигнала (изображения)
 if (!H.Set(Out,In,false)) return false;
 //----------------------------------------------------------------------------------
 //Расчет двумерной дискретной свертки
 //----------------------------------------------------------------------------------
 ulong hY = 0L, hX, wY = 0L;
 long dW = GetInW0()-GetOutW0();
 long dH = GetOutH0()-GetInH0();
 long n1, n2;

 for (ulong i = 0L; i < Out; i++)
 {hX = 0L; n2 = dH-hY; n1 = wY+dW;
  for (ulong j = 0L; j < In; j++)
  {H.Put(i,j,ConvolutionKernel(n1,n2));
   normH += H.Get(i,j)*H.Get(i,j);
   if (++hX == GetInHeight()) {hX = 0L; n1--; n2 = dH-hY;}
   else n2++;
  }
  if (++hY == GetOutHeight()) {hY = 0L; wY++;}
 }
return true;
}
//***********************************************************************************
//СТАТУС: I.24; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TrImpulseResponse(rmatrix& trH) const
//НАЗНАЧЕНИЕ: Формирование транспонированной матрицы импульсного отклика системы
//обработки двумерных дискретных сигналов (изображений) по заданным размерам входной
//и выходной выборки и ядра свертки (Convolution kernel). Рассчитанные коэффициенты
//матрицы заносятся в матрицу trH, передаваемую по ссылке. Функция не изменяет внутрен-
//них установок объекта класса. Функция возвращает true, если транспонированную матрицу
//импульсного отклика удалось построить и false в противоположном случае. Возможные
//причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Не удалось выделить память под размещение элементов матрицы H.
//Алгоритм построения trH аналогичен функции ImpulseResponse(rmatrix& H) с учетом того,
//что trH.Rows == GetInSize(), trH.Cols == GetOutSize().
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: rmatrix& trH - ссылка на матрицу в которой формируются
//коэффициенты транспонированной матрицы импульсного отклика системы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак построения матрицы H
//***********************************************************************************
bool TImpulseResponse::TrImpulseResponse(rmatrix& trH) const
{//----------------------------------------------------------------------------------
 //Проверка на возможность построения матрицы импульсного отклика
 //----------------------------------------------------------------------------------
 if (!IsReady()) {trH.Set(0L,false); return false;}
 //Формирование матрицы импульсного отклика необходимой размерности
 ulong In = GetInSize();//Кол-во отсчетов входного сигнала (изображения)
 ulong Out = GetOutSize();//Кол-во отсчетов выходного сигнала (изображения)
 if (!trH.Set(In,Out,false)) return false;
 //----------------------------------------------------------------------------------
 //Расчет двумерной дискретной свертки
 //----------------------------------------------------------------------------------
 ulong hY = 0L, hX, wY = 0L;
 long dW = GetInW0()-GetOutW0();
 long dH = GetOutH0()-GetInH0();
 long n1, n2;

 for (ulong i = 0L; i < Out; i++)
 {hX = 0L; n2 = dH-hY; n1 = wY+dW;
  for (ulong j = 0L; j < In; j++)
  {trH.Put(j,i,ConvolutionKernel(n1,n2));
   if (++hX == GetInHeight()) {hX = 0L; n1--; n2 = dH-hY;}
   else n2++;
  }
  if (++hY == GetOutHeight()) {hY = 0L; wY++;}
 }
return true;
}
//***********************************************************************************
//СТАТУС: I.25; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetInverseOperator(rmatrix& invH) const
//НАЗНАЧЕНИЕ: Формирование инверсного оператора матрицы импульсного отклика системы
//обработки двумерных дискретных сигналов (изображений) в зависимости от размеров
//входной N, выходной M выборок и ядра свертки (Convolution kernel):
// a) inv(H) - complete system M == N  [inv(*) - операция обращения]
// b) inv(trH x H) - overdetermined system M > N
// c) inv(H x trH) - undetermined system M < N
//Матрица инверсного оператора заносится в матрицу invH, передаваемую по ссылке.
//Функция не изменяет внутренних установок объекта класса. Функция возвращает true,
//если инверсный оператор матрицы импульсного отклика удалось построить и false в
//противоположном случае. Возможные причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Не удалось выделить память под размещение элементов матрицы H;
//3. Матрицы (H), (trH x H), (H x trH) - вырожденные.
//Обращение матриц (H) || (trH x H) || (H x trH) осуществляется по алгоритму Краута
//(модифицированный алгоритм Гаусса), так как в общем случае матрицы могут не быть
//симметрическими и положительно определенными.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: rmatrix& invH - ссылка на матрицу в которой формируются
//коэффициенты инверсного оператора матрицы импульсного отклика системы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак построения матрицы invH
//***********************************************************************************
bool TImpulseResponse::GetInverseOperator(rmatrix& invH) const
{invH.Set(0L,false);
 //----------------------------------------------------------------------------------
 //Проверка на возможность построения инверсного оператора матрицы импульсного отклика
 //----------------------------------------------------------------------------------
 if (!IsReady()) return false;
 ulong N = GetInSize();//Количество входных отсчетов
 ulong M = GetOutSize();//Количество выходных отсчетов
 //----------------------------------------------------------------------------------
 //Расчет invH в зависимости от соотношения M и N
 //----------------------------------------------------------------------------------
 rmatrix H;
 ImpulseResponse(H);
 if (H.IsZeroSize()) return false;
 if (M == N) //M == N - complete system
 {//Обращение матрицы
  if (!H.INV_Krauth(invH)) return false;//Матрица H вырождена
 }
 else if (M > N) //M > N - overdetermined system
 {rmatrix trHH;
  //Реализация умножения вида trH x H
  if (!H.MultByTransposedMatrixOnLeft(trHH)) return false;
  //Обращение матрицы trHH
  if (!trHH.INV_Krauth(invH)) return false;//Матрица trHH вырождена
 }
 else //M < N - undetermined system
 {rmatrix HtrH;
  //Реализация умножения вида H x trH
  if (!H.MultByTransposedMatrixOnRight(HtrH)) return false;
  //Обращение матрицы HtrH
  if (!HtrH.INV_Krauth(invH)) return false;//Матрица HtrH вырождена
 }
 return true;//Обратный оператор импульсного отклика системы вычислен успешно
}
//***********************************************************************************
//СТАТУС: I.26; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetInverseOperator(rmatrix& invH, double& normH) const
//НАЗНАЧЕНИЕ: Формирование инверсного оператора матрицы импульсного отклика системы
//обработки двумерных дискретных сигналов (изображений) в зависимости от размеров
//входной N, выходной M выборок и ядра свертки (Convolution kernel):
// a) inv(H) - complete system M == N  [inv(*) - операция обращения]
// b) inv(trH x H) - overdetermined system M > N
// c) inv(H x trH) - undetermined system M < N
//Матрица инверсного оператора заносится в матрицу invH, передаваемую по ссылке.
//Функция не изменяет внутренних установок объекта класса. Функция возвращает true,
//если инверсный оператор матрицы импульсного отклика удалось построить и false в
//противоположном случае. Возможные причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Не удалось выделить память под размещение элементов матрицы H;
//3. Матрицы (H), (trH x H), (H x trH) - вырожденные.
//Обращение матриц (H) || (trH x H) || (H x trH) осуществляется по алгоритму Краута
//(модифицированный алгоритм Гаусса), так как в общем случае матрицы могут не быть
//симметрическими и положительно определенными.
//Функция производит подсчет квадрата евклидовой нормы матрицы импульсного отклика H.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& invH - ссылка на матрицу в которой формируются коэффициенты инверсного
//   оператора матрицы импульсного отклика системы;
//2. double& normH - ссылка на число, в котором ведется подсчет квадрата евклидовой
//   нормы матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак построения матрицы invH
//***********************************************************************************
bool TImpulseResponse::GetInverseOperator(rmatrix& invH, double& normH) const
{invH.Set(0L,false);
 normH = 0.0;
 //----------------------------------------------------------------------------------
 //Проверка на возможность построения инверсного оператора матрицы импульсного отклика
 //----------------------------------------------------------------------------------
 if (!IsReady()) return false;
 ulong N = GetInSize();//Количество входных отсчетов
 ulong M = GetOutSize();//Количество выходных отсчетов
 //----------------------------------------------------------------------------------
 //Расчет invH в зависимости от соотношения M и N
 //----------------------------------------------------------------------------------
 rmatrix H;
 ImpulseResponse(H,normH);
 if (H.IsZeroSize()) return false;
 if (M == N) //M == N - complete system
 {//Обращение матрицы
  if (!H.INV_Krauth(invH)) return false;//Матрица H вырождена
 }
 else if (M > N) //M > N - overdetermined system
 {rmatrix trHH;
  //Реализация умножения вида trH x H
  if (!H.MultByTransposedMatrixOnLeft(trHH)) return false;
  //Обращение матрицы trHH
  if (!trHH.INV_Krauth(invH)) return false;//Матрица trHH вырождена
 }
 else //M < N - undetermined system
 {rmatrix HtrH;
  //Реализация умножения вида H x trH
  if (!H.MultByTransposedMatrixOnRight(HtrH)) return false;
  //Обращение матрицы HtrH
  if (!HtrH.INV_Krauth(invH)) return false;//Матрица HtrH вырождена
 }
 return true;//Обратный оператор импульсного отклика системы вычислен успешно
}
//***********************************************************************************
//СТАТУС: I.27; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool GetInverseOperator(rmatrix& invH, double& normH, double& normA) const
//НАЗНАЧЕНИЕ: Формирование инверсного оператора матрицы импульсного отклика системы
//обработки двумерных дискретных сигналов (изображений) в зависимости от размеров
//входной N, выходной M выборок и ядра свертки (Convolution kernel):
// a) inv(H) - complete system M == N  [inv(*) - операция обращения]
// b) inv(trH x H) - overdetermined system M > N
// c) inv(H x trH) - undetermined system M < N
//Матрица инверсного оператора заносится в матрицу invH, передаваемую по ссылке.
//Функция не изменяет внутренних установок объекта класса. Функция возвращает true,
//если инверсный оператор матрицы импульсного отклика удалось построить и false в
//противоположном случае. Возможные причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Не удалось выделить память под размещение элементов матрицы H;
//3. Матрицы (H), (trH x H), (H x trH) - вырожденные.
//Обращение матриц (H) || (trH x H) || (H x trH) осуществляется по алгоритму Краута
//(модифицированный алгоритм Гаусса), так как в общем случае матрицы могут не быть
//симметрическими и положительно определенными.
//Функция производит подсчет квадрата евклидовой нормы матрицы импульсного отклика H
//и матрицы A (для ПЕРЕОПРЕДЕЛЕННОЙ A=(trHxH) и НЕДООПРЕДЕЛЕННОЙ A=(HxtrH) систем).
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& invH - ссылка на матрицу в которой формируются коэффициенты инверсного
//   оператора матрицы импульсного отклика системы;
//2. double& normH - ссылка на число, в котором ведется подсчет квадрата евклидовой
//   нормы матрицы H;
//3. double& normA - ссылка на число, в котором ведется подсчет квадрата евклидовой
//   нормы матрицы A.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак построения матрицы invH
//***********************************************************************************
bool TImpulseResponse::GetInverseOperator(rmatrix& invH, double& normH, double& normA) const
{invH.Set(0L,false);
 normH = 0.0;
 //----------------------------------------------------------------------------------
 //Проверка на возможность построения инверсного оператора матрицы импульсного отклика
 //----------------------------------------------------------------------------------
 if (!IsReady()) return false;
 ulong N = GetInSize();//Количество входных отсчетов
 ulong M = GetOutSize();//Количество выходных отсчетов
 //----------------------------------------------------------------------------------
 //Расчет invH в зависимости от соотношения M и N
 //----------------------------------------------------------------------------------
 rmatrix H;
 ImpulseResponse(H,normH);
 if (H.IsZeroSize()) return false;
 if (M == N) //M == N - complete system
 {//Обращение матрицы
  if (!H.INV_Krauth(invH)) return false;//Матрица H вырождена
  normA = normH;
 }
 else if (M > N) //M > N - overdetermined system
 {rmatrix trHH;
  //Реализация умножения вида trH x H
  if (!H.MultByTransposedMatrixOnLeft(trHH)) return false;
  //Обращение матрицы trHH
  if (!trHH.INV_Krauth(invH)) return false;//Матрица trHH вырождена
  //Расчет квадрата евклидовой нормы матрицы A = trH*H
  normA = 0.0;
  for (ulong i = 0L; i < trHH.Rows(); i++)
   for (ulong j = 0L; j < trHH.Cols(); j++)
    normA += trHH.Get(i,j)*trHH.Get(i,j);
 }
 else //M < N - undetermined system
 {rmatrix HtrH;
  //Реализация умножения вида H x trH
  if (!H.MultByTransposedMatrixOnRight(HtrH)) return false;
  //Обращение матрицы HtrH
  if (!HtrH.INV_Krauth(invH)) return false;//Матрица HtrH вырождена
  //Расчет квадрата евклидовой нормы матрицы A = H*trH
  normA = 0.0;
  for (ulong i = 0L; i < HtrH.Rows(); i++)
   for (ulong j = 0L; j < HtrH.Cols(); j++)
    normA += HtrH.Get(i,j)*HtrH.Get(i,j);
 }
 return true;//Обратный оператор импульсного отклика системы вычислен успешно
}
//***********************************************************************************
//СТАТУС: I.28; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetRecoveryOperator(rmatrix& W) const
//НАЗНАЧЕНИЕ: Формирование  оператора реконструкции искаженного изображения в зависи-
//мости от размеров входной N, выходной M выборок и ядра свертки (Convolution kernel):
// a) inv(H) - complete system M == N
// b) inv(trH x H) x trH - overdetermined system M > N
// c) trH x inv(H x trH) - undetermined system M < N
//Матрица оператора реставрации заносится в матрицу W, передаваемую по ссылке. Функция
//не изменяет внутренних установок объекта класса. Функция возвращает true, если опе-
//ратор реставрации W удалось построить и false в противоположном случае. Возможные
//причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Не удалось выделить память под размещение элементов матриц H, trH, W;
//3. Матрицы (H), (trH x H), (H x trH) - вырожденные.
//Обращение матриц (H) || (trH x H) || (H x trH) осуществляется по алгоритму Краута
//(модифицированный алгоритм Гаусса), так как в общем случае матрицы могут не быть
//симметрическими и положительно определенными.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: rmatrix& W - ссылка на матрицу в которой формируются коэффи-
//циенты оператора реставрации
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак построения матрицы W
//***********************************************************************************
bool TImpulseResponse::GetRecoveryOperator(rmatrix& W) const
{W.Set(0L,false);
 //----------------------------------------------------------------------------------
 //Проверка на возможность построения инверсного оператора матрицы импульсного отклика
 //----------------------------------------------------------------------------------
 if (!IsReady()) return false;
 ulong N = GetInSize();//Количество входных отсчетов
 ulong M = GetOutSize();//Количество выходных отсчетов
 //----------------------------------------------------------------------------------
 //Расчет оператора инверсии invH
 //----------------------------------------------------------------------------------
 rmatrix invH;
 if (!GetInverseOperator(invH)) return false;//Обратный оператор вырожден
 //----------------------------------------------------------------------------------
 //Расчет оператора реставрации в зависимости от соотношений M и N
 //----------------------------------------------------------------------------------
 if (M == N) W = invH;//M == N - complete system
 else if (M > N) //M > N - overdetermined system
 {rmatrix trH;
  TrImpulseResponse(trH);
  Multiply(W,invH,trH);//W = InvH * trH
  if (W.IsZeroSize()) return false;//Оператор реставрации не создан
 }
 else //M < N - undetermined system
 {rmatrix trH;
  TrImpulseResponse(trH);
  Multiply(W,trH,invH);//W = trH * invH
  if (W.IsZeroSize()) return false;//Оператор реставрации не создан
 }
 return true;
}
//***********************************************************************************
//СТАТУС: I.29; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool GetRecoveryOperator(rmatrix& W, rmatrix& InvA, double& normH, double& normA) const
//НАЗНАЧЕНИЕ: Формирование  оператора реконструкции искаженного изображения и
//обратного оператора в зависимости от размеров входной N, выходной M выборок и ядра
//свертки (Convolution kernel):
// a) inv(H) - complete system M == N
// b) inv(trH x H) x trH - overdetermined system M > N
// c) trH x inv(H x trH) - undetermined system M < N
//Матрица оператора реставрации заносится в матрицу W, передаваемую по ссылке. Матрица
//обратного оператора заносится в матрицу InvA, передаваемую по ссылке. Функция
//не изменяет внутренних установок объекта класса. Функция возвращает true, если опе-
//ратор реставрации W и обратный оператор InvA удалось построить и false в противопо-
//ложном случае. Возможные причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Не удалось выделить память под размещение элементов матриц H, trH, W, InvA;
//3. Матрицы (H), (trH x H), (H x trH) - вырожденные.
//Обращение матриц (H) || (trH x H) || (H x trH) осуществляется по алгоритму Краута
//(модифицированный алгоритм Гаусса), так как в общем случае матрицы могут не быть
//симметрическими и положительно определенными.
//Для случая полной системы (M == N) матрицы W и InvA совпадают.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& W - ссылка на матрицу в которой формируются коэффициенты оператора
//   реставрации;
//2. rmatrix& InvA - ссылка на матрицу в которой формируются коэффициенты оператора
//   обращения.
//3. double& normH - ссылка на число, в котором ведется подсчет квадрата евклидовой
//   нормы матрицы H;
//4. double& normA - ссылка на число, в котором ведется подсчет квадрата евклидовой
//   нормы матрицы A.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак построения матрицы W
//***********************************************************************************
bool TImpulseResponse::GetRecoveryOperator(rmatrix& W, rmatrix& InvA, double& normH,
     double& normA) const
{W.Set(0L,false); normH = normA = 0.0;
 if (&W == &InvA) {InvA.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Проверка на возможность построения инверсного оператора матрицы импульсного отклика
 //----------------------------------------------------------------------------------
 if (!IsReady()) return false;
 ulong N = GetInSize();//Количество входных отсчетов
 ulong M = GetOutSize();//Количество выходных отсчетов
 //----------------------------------------------------------------------------------
 //Расчет оператора инверсии InvA
 //----------------------------------------------------------------------------------
 if (!GetInverseOperator(InvA,normH,normA)) //Обратный оператор вырожден
 {W.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Расчет оператора реставрации в зависимости от соотношений M и N
 //----------------------------------------------------------------------------------
 if (M == N) W = InvA; //M == N - complete system
 else if (M > N) //M > N - overdetermined system
 {rmatrix trH;
  TrImpulseResponse(trH);
  Multiply(W,InvA,trH);//W = InvA * trH
  if (W.IsZeroSize()) return false;//Оператор реставрации не создан
 }
 else //M < N - undetermined system
 {rmatrix trH;
  TrImpulseResponse(trH);
  Multiply(W,trH,InvA);//W = trH * InvA
  if (W.IsZeroSize()) return false;//Оператор реставрации не создан
 }
 return true;
}
//***********************************************************************************
//СТАТУС: I.30; TImpulseResponse public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool FrequencyResponse(rmatrix& H,  ulong HCount = 0L, ulong VCount = 0L) const
//НАЗНАЧЕНИЕ: Формирование частотной характеристики оператора H системы обработки дву-
//мерных дискретных сигналов (изображений) по заданным размерам входной и выходной вы-
//борки и ядру свертки (Convolution kernel). Рассчитанные значения заносятся в матрицу
//H, передаваемую по ссылке. Функция не изменяет внутренних установок объекта
//класса. Функция возвращает true, если частотную характеристику удалось построить
//и false в противоположном случае. Возможные причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Не удалось выделить память под размещение элементов матрицы H.
//Для построения частотной характеристики H используется преобразование Фурье.
//Частотная характеристика H - периодическая функция с периодом 2*PI. Для пары значений
//горизонтальной w1 и вертикальной w2 пространственных частот H(w1,w2) вычисляется:
// H(w1,w2) = SUM[n1]SUM[n2] h(n1,n2)*exp(-j*w1*n1-j*w2*n2),
//h(n1,n2) - значение импульсного отклика системы в точке с координатами (n1,n2);
// 0 <= n1 < max(HeightX,HeightY); 0 <= n2 < max(WidthX,WidthY); -PI <= w1,w2 <= PI
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& H - ссылка на матрицу в которой формируется частотная характеристика
//   оператора импульсного отклика системы H;
//2. ulong HCount (0L) - кол-во отсчетов горизонтальной пространственной частоты;
//3. ulong VCount (0L) - кол-во отсчетов вертикальной пространственной частоты;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак построения матрицы H
//***********************************************************************************
bool TImpulseResponse::FrequencyResponse(rmatrix& H, ulong HCount, ulong VCount) const
{//----------------------------------------------------------------------------------
 //Проверка на возможность построения матрицы импульсного отклика
 //----------------------------------------------------------------------------------
 if (!IsReady()) {H.Set(0L,false); return false;}
 //Формирование матрицы необходимой размерности
 ulong In = GetInSize();//Кол-во отсчетов входного сигнала (изображения)
 ulong Out = GetOutSize();//Кол-во отсчетов выходного сигнала (изображения)
 //Определение количества отсчетов горизонтальной и вертикальной частот
 if (HCount == 0L)
  HCount = (GetInWidth() > GetOutWidth()) ? GetInWidth() : GetOutWidth();
 if (VCount == 0L)
  VCount = (GetInHeight() > GetOutHeight()) ? GetInHeight() : GetOutHeight();
 if (!H.Set(VCount,HCount,false)) return false;
 //----------------------------------------------------------------------------------
 //Расчет частотной характеристики
 //----------------------------------------------------------------------------------
 double dw1 = 6.2831853/(VCount-1);
 double dw2 = 6.2831853/(HCount-1);
 double W1 = -3.14159265, W2;

 for (ulong w1 = 0; w1 < VCount; w1++)
 {W2 = -3.14159265;
  for (ulong w2 = 0; w2 < HCount; w2++)
  {complex sum(0.0,0.0);

   ulong hY = 0L, hX, wY = 0L;
   long dW = GetInW0()-GetOutW0();
   long dH = GetOutH0()-GetInH0();
   long n1, n2;

   for (ulong i = 0L; i < Out; i++)
   {hX = 0L; n2 = dH-hY; n1 = wY+dW;
    for (ulong j = 0L; j < In; j++)
    {sum += polar(ConvolutionKernel(n1,n2),-W1*n1-W2*n2);
     if (++hX == GetInHeight()) {hX = 0L; n1--; n2 = dH-hY;}
     else n2++;
    }
    if (++hY == GetOutHeight()) {hY = 0L; wY++;}
   }
   H.Put(w1,w2,norm(sum));
   W2 += dw2;
  }
  W1 += dw1;
 }
 return true;
}

//***********************************************************************************
//II. Реализация защищенных членов-функций класса TImpulseResponse
//***********************************************************************************
//***********************************************************************************
//СТАТУС: II.1; TImpulseResponse protected member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Convolute(const rmatrix& X, rmatrix& Y) const
//НАЗНАЧЕНИЕ: Построение свертки по входному воздействию X. Результат свертки форми-
//руется в матрице Y. Предполагается, что размерности X и кол-во установленных входных
//отсчетов в классе согласованы заранее и размерность выходной выборки, установленной
//в классе отлична от нуля. Функция проверку вышеперечисленных ситуаций не производит.
//Размерность матрицы Y будет установлена функцией в соответствии с размерностью выборки
//по выходу, установленной заранее. Матрица входного сигнала X не изменяется функцией.
//Коэффициенты матрицы импульсного отклика системы формируются "на лету", что позволяет
//избежать формирования матрицы импульсного отклика H в явном виде (формирование матрицы
//H приводит к большим затратам памяти, так как ее размерность для X(M,N) & Y(K*L) будет
//равна: H(Q,P), где Q=K*L, P=M*N).
//Функция возвращает true, если свертку удалось построить и false в противоположном
//случае. Возможные причины неудачного завершения функции:
//1. Не удалось выделить память под размещение элементов выходного сигнала Y.
//Операция построения импульсного отклика системы обработки двумерных дискретных сиг-
//налов по заданным входному сигналу X, функции ядра свертки (Convolution kernel) и
//размерам (количеству отсчетов) по вертикали и горизонтали реализуется АЛГОРИТМОМ:
//1. По размерам входного двумерного сигнала X и задаваемым размерам выходного сигнала
//   hY & wY формируется размерность матрицы импульсного отклика H(Q,P): Q=K*L, P=M*N
//   Q - количество строк матрицы импульсного отклика H;
//   P - количество столбцов матрицы импульсного отклика H;
//   M = X.rows() - количество отсчетов входного сигнала X по вертикали;
//   N = X.cols() - количество отсчетов входного сигнала X по горизонтали;
//   K = Y.rows() = hY - количество отсчетов выходного сигнала Y по вертикали;
//   L = Y.cols() = wY - количество отсчетов выходного сигнала Y по горизонтали;
//2. Формируется матрица выходного сигнала Y(hY,wY)
//3. В двойном цикле по Q и P вычисляется два значения отсчетов i & j для H(q,p) эле-
//   мента матрицы импульсного отклика системы: i = I - J; j = k-m
//   0 <= q < Q, 0 <= p < P
//   I - номер строчного блока матрицы H (0 <= I < L)
//   J - номер столбцового блока матрицы H (0 <= J < N)
//   k - вертикальный отсчет внутри блока (0 <= k < K)
//   m - горизонтальный отсчет внутри блока (0 <= m < M)
//   Когда значения k или m достигают своих предельных значений K или M соответственно,
//   они обнуляются, а значения I или J соответственно увеличиваются на единицу.
//4. Вычисленные значения i & j для H(q,p) элемента матрицы H являются аргументами
//   функции ядра свертки (Convolution kernel). По аргументам i & j, в соответствии
//   с функцией ядра и значению X(m,J) вычислятся величина sum во внутреннем цикле:
//   sum += ConvolutionKernel(i,j)*X(m,J). При выходе из внутреннего цикла величина
//   sum присваивается Y(k,I). При входе во внутренний цикл sum обнуляется.
//   Таким образом, формируются все элементы выходного двумерного сигнала (изображения)
//   без формирования матрицы H в явном виде.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& X - константная ссылка на входной двумерный дискретный сигнал;
//2. rmatrix& Y - ссылка на матрицу, в которой формируется выходной двумерный
//   дискретный сигнал (изображение);
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции свертки
//***********************************************************************************
bool TImpulseResponse::Convolute(const rmatrix& X, rmatrix& Y) const
{//Формирование матрицы выходного двумерного сигнала
 if (Y.Set(GetOutHeight(),GetOutWidth(),false) == false) return false;
 //----------------------------------------------------------------------------------
 //Расчет двумерной дискретной свертки
 //----------------------------------------------------------------------------------
 ulong In = GetInSize();//Кол-во отсчетов входного сигнала (изображения)
 ulong Out = GetOutSize();//Кол-во отсчетов выходного сигнала (изображения)
 ulong hY = 0L, wY = 0L, hX, wX;
 long dW = GetInW0()-GetOutW0();
 long dH = GetOutH0()-GetInH0();
 long n1, n2;

 for (ulong i = 0L; i < Out; i++)
 {hX = 0L; wX = 0L; n2 = dH-hY; n1 = wY+dW;
  double sum = 0.0;
  for (ulong j = 0L; j < In; j++)
  {sum += ConvolutionKernel(n1,n2)*X.Get(hX,wX);
   if (++hX == GetInHeight()) {hX = 0L; wX++; n1--; n2 = dH-hY;}
   else n2++;
  }
  Y.Put(hY,wY,sum);
  if (++hY == GetOutHeight()) {hY = 0L; wY++;}
 }
return true;
}
//***********************************************************************************
//СТАТУС: II.2; TImpulseResponse protected member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Convolute(const rmatrix& X, rvector& Y) const
//НАЗНАЧЕНИЕ: Построение свертки по входному воздействию X. Результат свертки форми-
//руется в векторе Y. Предполагается, что размерности X и кол-во установленных входных
//отсчетов в классе согласованы заранее и размерность выходной выборки, установленной
//в классе отлична от нуля. Функция проверку вышеперечисленных ситуаций не производит.
//Размерность вектора Y будет установлена функцией в соответствии с размерностью выборки
//по выходу, установленной заранее. Матрица входного сигнала X не изменяется функцией.
//Коэффициенты матрицы импульсного отклика системы формируются "на лету", что позволяет
//избежать формирования матрицы импульсного отклика H в явном виде (формирование матрицы
//H приводит к большим затратам памяти, так как ее размерность для X(M,N) & Y(Q,1) будет
//равна: H(Q,P), где Q=K*L, P=M*N).
//Функция возвращает true, если свертку удалось построить и false в противоположном
//случае. Возможные причины неудачного завершения функции:
//1. Не удалось выделить память под размещение элементов выходного сигнала Y.
//Операция построения импульсного отклика системы обработки двумерных дискретных сиг-
//налов по заданным входному сигналу X, функции ядра свертки (Convolution kernel) и
//размерам (количеству отсчетов) по вертикали и горизонтали реализуется АЛГОРИТМОМ:
//1. По размерам входного двумерного сигнала X и задаваемым размерам выходного сигнала
//   hY & wY формируется размерность матрицы импульсного отклика H(Q,P): Q=K*L, P=M*N
//   Q - количество строк матрицы импульсного отклика H;
//   P - количество столбцов матрицы импульсного отклика H;
//   M = X.rows() - количество отсчетов входного сигнала X по вертикали;
//   N = X.cols() - количество отсчетов входного сигнала X по горизонтали;
//   K = Y.rows() = hY - количество отсчетов выходного сигнала Y по вертикали;
//   L = Y.cols() = wY - количество отсчетов выходного сигнала Y по горизонтали;
//2. Формируется вектор выходного сигнала Y(hY*wY,1) = Y(Q,1).
//3. В двойном цикле по Q и P вычисляется два значения отсчетов i & j для H(q,p) эле-
//   мента матрицы импульсного отклика системы: i = I - J; j = k-m
//   0 <= q < Q, 0 <= p < P
//   I - номер строчного блока матрицы H (0 <= I < L)
//   J - номер столбцового блока матрицы H (0 <= J < N)
//   k - вертикальный отсчет внутри блока (0 <= k < K)
//   m - горизонтальный отсчет внутри блока (0 <= m < M)
//   Когда значения k или m достигают своих предельных значений K или M соответственно,
//   они обнуляются, а значения I или J соответственно увеличиваются на единицу.
//4. Вычисленные значения i & j для H(q,p) элемента матрицы H являются аргументами
//   функции ядра свертки (Convolution kernel). По аргументам i & j, в соответствии
//   с функцией ядра и значению X(m,J) вычислятся величина sum во внутреннем цикле:
//   sum += ConvolutionKernel(i,j)*X(m,J). При выходе из внутреннего цикла величина
//   sum присваивается Y(q). При входе во внутренний цикл sum обнуляется.
//   Таким образом, формируются все элементы выходного двумерного сигнала (изображения)
//   без формирования матрицы H в явном виде.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& X - константная ссылка на входной двумерный дискретный сигнал;
//2. rvector& Y - ссылка на вектор, в котором формируется выходной двумерный
//   дискретный сигнал (изображение);
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции свертки
//***********************************************************************************
bool TImpulseResponse::Convolute(const rmatrix& X, rvector& Y) const
{//Формирование матрицы выходного двумерного сигнала
 if (!Y.Set(GetOutSize(),COL,false)) return false;
 //----------------------------------------------------------------------------------
 //Расчет двумерной дискретной свертки
 //----------------------------------------------------------------------------------
 ulong In = GetInSize();//Кол-во отсчетов входного сигнала (изображения)
 ulong Out = GetOutSize();//Кол-во отсчетов выходного сигнала (изображения)
 ulong hY = 0L, wY = 0L, hX, wX;
 long dW = GetInW0()-GetOutW0();
 long dH = GetOutH0()-GetInH0();
 long n1, n2;

 for (ulong i = 0L; i < Out; i++)
 {hX = 0L; wX = 0L; n2 = dH-hY; n1 = wY+dW;
  double sum = 0.0;
  for (ulong j = 0L; j < In; j++)
  {sum += ConvolutionKernel(n1,n2)*X.Get(hX,wX);
   if (++hX == GetInHeight()) {hX = 0L; wX++; n1--; n2 = dH-hY;}
   else n2++;
  }
  Y.Put(i,sum);
  if (++hY == GetOutHeight()) {hY = 0L; wY++;}
 }
return true;
}
//***********************************************************************************
//СТАТУС: II.3; TImpulseResponse protected member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Convolute(const rvector& X, rvector& Y) const
//НАЗНАЧЕНИЕ: Построение свертки по входному воздействию X. Результат свертки форми-
//руется в векторе Y. Предполагается, что размерность X и кол-во установленных входных
//отсчетов в классе согласованы заранее и размерность выходной выборки, установленной
//в классе отлична от нуля. Функция проверку вышеперечисленных ситуаций не производит.
//Размерность вектора Y будет установлена функцией в соответствии с размерностью выборки
//по выходу, установленной заранее. Вектор входного сигнала X не изменяется функцией.
//Коэффициенты матрицы импульсного отклика системы формируются "на лету", что позволяет
//избежать формирования матрицы импульсного отклика H в явном виде (формирование матрицы
//H приводит к большим затратам памяти, так как ее размерность для X(M,N) & Y(Q,1) будет
//равна: H(Q,P), где Q=K*L, P=M*N).
//Функция возвращает true, если свертку удалось построить и false в противоположном
//случае. Возможные причины неудачного завершения функции:
//1. Не удалось выделить память под размещение элементов выходного сигнала Y.
//Операция построения импульсного отклика системы обработки двумерных дискретных сиг-
//налов по заданным входному сигналу X, функции ядра свертки (Convolution kernel) и
//размерам (количеству отсчетов) по вертикали и горизонтали реализуется АЛГОРИТМОМ:
//1. По размерам входного двумерного сигнала X и задаваемым размерам выходного сигнала
//   hY & wY формируется размерность матрицы импульсного отклика H(Q,P): Q=K*L, P=M*N
//   Q - количество строк матрицы импульсного отклика H;
//   P - количество столбцов матрицы импульсного отклика H;
//   M - количество отсчетов входного сигнала X по вертикали;
//   N - количество отсчетов входного сигнала X по горизонтали;
//   K - количество отсчетов выходного сигнала Y по вертикали;
//   L - количество отсчетов выходного сигнала Y по горизонтали;
//2. Формируется вектор выходного сигнала Y(hY*wY,1) = Y(Q,1).
//3. В двойном цикле по Q и P вычисляется два значения отсчетов i & j для H(q,p) эле-
//   мента матрицы импульсного отклика системы: i = I - J; j = k-m
//   0 <= q < Q, 0 <= p < P
//   I - номер строчного блока матрицы H (0 <= I < L)
//   J - номер столбцового блока матрицы H (0 <= J < N)
//   k - вертикальный отсчет внутри блока (0 <= k < K)
//   m - горизонтальный отсчет внутри блока (0 <= m < M)
//   Когда значения k или m достигают своих предельных значений K или M соответственно,
//   они обнуляются, а значения I или J соответственно увеличиваются на единицу.
//4. Вычисленные значения i & j для H(q,p) элемента матрицы H являются аргументами
//   функции ядра свертки (Convolution kernel). По аргументам i & j, в соответствии
//   с функцией ядра и значению X(p) вычислятся величина sum во внутреннем цикле:
//   sum += ConvolutionKernel(i,j)*X(p). При выходе из внутреннего цикла величина
//   sum присваивается Y(q). При входе во внутренний цикл sum обнуляется.
//   Таким образом, формируются все элементы выходного двумерного сигнала (изображения)
//   без формирования матрицы H в явном виде.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& X - константная ссылка на вектор входного двумерного дискретного сигнала;
//2. rvector& Y - ссылка на вектор, в котором формируется выходной двумерный дискретный
//   сигнал (изображение);
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции свертки
//***********************************************************************************
bool TImpulseResponse::Convolute(const rvector& X, rvector& Y) const
{//Формирование матрицы выходного двумерного сигнала
 if (!Y.Set(GetOutSize(),COL,false)) return false;
 //Формирование вектора выходного двумерного сигнала размерности GetOutSize()
 if (Y.Set(GetOutSize(),false) == false) return false;
 //----------------------------------------------------------------------------------
 //Расчет двумерной дискретной свертки
 //----------------------------------------------------------------------------------
 ulong In = GetInSize();//Кол-во отсчетов входного сигнала (изображения)
 ulong Out = GetOutSize();//Кол-во отсчетов выходного сигнала (изображения)
 ulong hY = 0L, wY = 0L, hX;
 long dW = GetInW0()-GetOutW0();
 long dH = GetOutH0()-GetInH0();
 long n1, n2;

 for (ulong i = 0L; i < Out; i++)
 {hX = 0L; n2 = dH-hY; n1 = wY+dW;
  double sum = 0.0;
  for (ulong j = 0L; j < In; j++)
  {sum += ConvolutionKernel(n1,n2)*X.Get(j);
   if (++hX == GetInHeight()) {hX = 0L; n1--; n2 = dH-hY;}
   else n2++;
  }
  Y.Put(i,sum);
  if (++hY == GetOutHeight()) {hY = 0L; wY++;}
 }
 return true;
}
//***********************************************************************************
//СТАТУС: II.4; TImpulseResponse protected member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool InvRecovery(const rmatrix& Y, rmatrix& EstX) const
//НАЗНАЧЕНИЕ: Реставрация изображения Y методом инверсного синтеза. Результат рестав-
//рации формируется в матрице EstX. Предполагается, что размерности Y и кол-во установ-
//ленных выходных отсчетов в классе согласованы заранее и размерность входной выборки,
//установленной в классе отлична от нуля. Функция проверку вышеперечисленных ситуаций
//не производит. Размерность матрицы EstX будет установлена функцией в соответствии с
//размерностью выборки по входу, установленной заранее. Матрица выходного сигнала Y не
//изменяется функцией.
//Для успешного восстановления необходимы следующие условия:
//1) Оператор искажения H должен иметь такие же параметры (кол-во входных и выходных
//   отсчетов, ядро свертки с идентичными аргументами) какие использовались получения
//   изображения Y;
//2) Возможность методом инверсного синтеза построить оператор реставрации W (вычислить
//   оператор обращения функции импульсного отклика системы).
//В случае нарушения условия #1 успешное восстановление не гарантируется, а в случае
//нарушения условия #2 - реставрация невозможна.
//АЛГОРИТМ реставрации сводится к построению оператора реставрации W и в случае его
//построения к применению его к искаженному изображению: EstX = W x Y.
//Функция возвращает true, если удалось реставрировать Y и false в противоположном
//случае. Возможные причины неудачного завершения функции:
//1. Не удалось построить оператор реставрации W методом инверсного синтеза;
//2. Не удалось выделить память под размещение элементов EstX.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Y - константная ссылка на выходной двумерный дискретный сигнал;
//2. rmatrix& EstX - ссылка на матрицу, в которой формируется входной двумерный
//   дискретный сигнал (изображение) восстанавливаемый по выходному сигналу Y;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения реставрации входного
//сигнала по выходному методом инверсного синтеза
//***********************************************************************************
bool TImpulseResponse::InvRecovery(const rmatrix& Y, rmatrix& EstX) const
{//----------------------------------------------------------------------------------
 //Формирование оператора реставрации W
 //----------------------------------------------------------------------------------
 rmatrix W;
 //Построить оператор реставрации методом инверсного синтеза не удалось
 if (!GetRecoveryOperator(W)) {EstX.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Реставрация изображения Y: EstX = W x Y
 //----------------------------------------------------------------------------------
 //Формирование матрицы EstX размерностью согласованной с выходной размерностью H
 if (!EstX.Set(GetInHeight(),GetInWidth(),false)) return false;
 //Цикл реставрации изображения
 //M - высота входного изображения;  N - ширина входного изображения (EstX)
 //K - высота выходного изображения; L - ширина выходного изображения (Y)
 //P = M*N; Q = K*L
 //W(p,q)  0 <= p < P, 0 <= q < Q
 ulong Q = GetOutSize();
 ulong P = GetInSize();
 ulong M = GetInHeight();
 ulong K = GetOutHeight();
 ulong m = 0L, n = 0L;
 //Цикл расчета
 for (ulong p = 0L; p < P; p++)
 {ulong k = 0L, l = 0L;
  double sum = 0.0;
  for (ulong q = 0L; q < Q; q++)
  {sum += W.Get(p,q)*Y.Get(k,l);
   if (++k == K) {k = 0L; l++;}
  }
  EstX.Put(m,n,sum);
  if (++m == M) {m = 0L; n++;}
 }
 return true;
}
//***********************************************************************************
//СТАТУС: II.5; TImpulseResponse protected member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool InvRecovery(const rvector& Y, rvector& EstX) const
//НАЗНАЧЕНИЕ: Реставрация изображения Y методом инверсного синтеза. Результат рестав-
//рации формируется в векторе EstX. Предполагается, что размерность Y и кол-во установ-
//ленных выходных отсчетов в классе согласованы заранее и размерность входной выборки,
//установленной в классе отлична от нуля. Функция проверку вышеперечисленных ситуаций
//не производит. Размерность вектора EstX будет установлена функцией в соответствии с
//размерностью выборки по входу, установленной заранее. Вектор выходного сигнала Y не
//изменяется функцией.
//Для успешного восстановления необходимы следующие условия:
//1) Оператор искажения H должен иметь такие же параметры (кол-во входных и выходных
//   отсчетов, ядро свертки с идентичными аргументами) какие использовались получения
//   изображения Y;
//2) Возможность методом инверсного синтеза построить оператор реставрации W (вычислить
//   оператор обращения функции импульсного отклика системы).
//В случае нарушения условия #1 успешное восстановление не гарантируется, а в случае
//нарушения условия #2 - реставрация невозможна.
//АЛГОРИТМ реставрации сводится к построению оператора реставрации W и в случае его
//построения к применению его к искаженному изображению: EstX = W x Y.
//Функция возвращает true, если удалось реставрировать Y и false в противоположном
//случае. Возможные причины неудачного завершения функции:
//1. Не удалось построить оператор реставрации W методом инверсного синтеза;
//2. Не удалось выделить память под размещение элементов EstX.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& Y - константная ссылка на выходной двумерный дискретный сигнал;
//2. rvector& EstX - ссылка на вектор, в котором формируется входной двумерный
//   дискретный сигнал (изображение) восстанавливаемый по выходному сигналу Y;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения реставрации входного
//сигнала по выходному методом инверсного синтеза
//***********************************************************************************
bool TImpulseResponse::InvRecovery(const rvector& Y, rvector& EstX) const
{//----------------------------------------------------------------------------------
 //Формирование оператора реставрации W
 //----------------------------------------------------------------------------------
 rmatrix W;
 //Построить оператор реставрации методом инверсного синтеза не удалось
 if (!GetRecoveryOperator(W)) {EstX.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Реставрация вектора наблюдаемого изображения Y в вектор EstX = W x Y
 //----------------------------------------------------------------------------------
 return Multiply(EstX,W,Y);
}


//***********************************************************************************
//               РЕАЛИЗАЦИЯ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССА TImpulseResponse
//***********************************************************************************
//***********************************************************************************
//СТАТУС: #1; TImpulseResponse class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool StrictConvolution(const TImpulseResponse& H, const rmatrix& X, rmatrix& Y)
//НАЗНАЧЕНИЕ: Расчет импульсного отклика системы обработки двумерных дискретных сигна-
//лов (изображений) по заданному входному воздействию X. Выходной сигнал (изображение)
//формируется в матрице Y, передаваемой по ссылке. Размерность матрицы X должна совпа-
//дать с количеством отсчетов по вертикали и горизонтали, установленными в классе H.
//Количество выходных отсчетов, установленных в классе H не должно быть равно нулю.
//Коэффициенты матрицы импульсного отклика системы H формируются "на лету", что позво-
//ляет избежать формирования матрицы импульсного отклика H в явном виде (формирование
//матрицы H приводит к большим затратам памяти). Матрица входного сигнала X и свойства
//оператора импульсного отклика двумерной системы (оператора искажения изображения) H
//не изменяется функцией. АЛГОРИТМ построения свертки аналогичен функции класса
//TImpulseResponse - bool operator() (X, Y, hY, wY).
//Функция возвращает true, если свертку удалось построить и false в противоположном
//случае. Возможные причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Размерность матрицы входного сигнала X не согласована с входной размерностью H;
//3. Не удалось выделить память под размещение элементов выходного сигнала Y.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TImpulseResponse& H - ссылка на класс по формированию двумерной свертки;
//2. const rmatrix& X - константная ссылка на входной двумерный дискретный сигнал;
//3. rmatrix& Y - ссылка на матрицу, в которой формируется выходной двумерный
//   дискретный сигнал (изображение);
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции свертки
//***********************************************************************************
bool StrictConvolution(const TImpulseResponse& H, const rmatrix& X, rmatrix& Y)
{//----------------------------------------------------------------------------------
 //Проверка на возможность осуществления операции двумерной свертки
 //----------------------------------------------------------------------------------
 if ((!H.IsReady()) || (H.GetInHeight() != X.Rows()) || (H.GetInWidth() != X.Cols()))
 {Y.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Формирование выходного двумерного сигнала (расчет двумерной дискретной свертки)
 //----------------------------------------------------------------------------------
 if (H.GetTypeConvKernel() == CK_2D_UNIT) {Y = X; return true;}
 else return H.Convolute(X,Y);
}
//***********************************************************************************
//СТАТУС: #2; TImpulseResponse class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool StrictConvolution(const TImpulseResponse* H, const rmatrix& X, rmatrix& Y)
//НАЗНАЧЕНИЕ: Расчет импульсного отклика системы обработки двумерных дискретных сигна-
//лов (изображений) по заданному входному воздействию X. Выходной сигнал (изображение)
//формируется в матрице Y, передаваемой по ссылке. Размерность матрицы X должна совпа-
//дать с количеством отсчетов по вертикали и горизонтали, установленными в классе H.
//Количество выходных отсчетов, установленных в классе H не должно быть равно нулю.
//Коэффициенты матрицы импульсного отклика системы H формируются "на лету", что позво-
//ляет избежать формирования матрицы импульсного отклика H в явном виде (формирование
//матрицы H приводит к большим затратам памяти). Матрица входного сигнала X и свойства
//оператора импульсного отклика двумерной системы (оператора искажения изображения) H
//не изменяется функцией. АЛГОРИТМ построения свертки аналогичен функции класса
//TImpulseResponse - bool operator() (X, Y, hY, wY).
//Функция возвращает true, если свертку удалось построить и false в противоположном
//случае. Возможные причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Размерность матрицы входного сигнала X не согласована с входной размерностью H;
//3. Не удалось выделить память под размещение элементов выходного сигнала Y.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TImpulseResponse* H - указатель на класс по формированию двумерной свертки;
//2. const rmatrix& X - константная ссылка на входной двумерный дискретный сигнал;
//3. rmatrix& Y - ссылка на матрицу, в которой формируется выходной двумерный
//   дискретный сигнал (изображение);
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции свертки
//***********************************************************************************
bool StrictConvolution(const TImpulseResponse* H, const rmatrix& X, rmatrix& Y)
{//----------------------------------------------------------------------------------
 //Проверка на возможность осуществления операции двумерной свертки
 //----------------------------------------------------------------------------------
 if ((!H->IsReady()) || (H->GetInHeight() != X.Rows()) || (H->GetInWidth() != X.Cols()))
 {Y.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Формирование выходного двумерного сигнала (расчет двумерной дискретной свертки)
 //----------------------------------------------------------------------------------
 if (H->GetTypeConvKernel() == CK_2D_UNIT) {Y = X; return true;}
 else return H->Convolute(X,Y);
}
//***********************************************************************************
//СТАТУС: #3; TImpulseResponse class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool StrictConvolution(const TImpulseResponse* H, const rmatrix& X, rvector& Y)
//НАЗНАЧЕНИЕ: Расчет импульсного отклика системы обработки двумерных дискретных сигна-
//лов (изображений) по заданному входному воздействию X. Выходной сигнал (изображение)
//формируется в векторе Y, передаваемом по ссылке. Размерность матрицы X должна совпа-
//дать с количеством отсчетов по вертикали и горизонтали, установленными в классе H.
//Количество выходных отсчетов, установленных в классе H не должно быть равно нулю.
//Коэффициенты матрицы импульсного отклика системы H формируются "на лету", что позво-
//ляет избежать формирования матрицы импульсного отклика H в явном виде (формирование
//матрицы H приводит к большим затратам памяти). Матрица входного сигнала X и свойства
//оператора импульсного отклика двумерной системы (оператора искажения изображения) H
//не изменяется функцией. АЛГОРИТМ построения свертки аналогичен функции класса
//TImpulseResponse - bool operator() (X, Y, hY, wY).
//Функция возвращает true, если свертку удалось построить и false в противоположном
//случае. Возможные причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Размерность матрицы входного сигнала X не согласована с входной размерностью H;
//3. Не удалось выделить память под размещение элементов выходного сигнала Y.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TImpulseResponse* H - указатель на класс по формированию двумерной свертки;
//2. const rmatrix& X - константная ссылка на входной двумерный дискретный сигнал;
//3. rvector& Y - ссылка на вектор, в котором формируется выходной двумерный
//   дискретный сигнал (изображение);
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции свертки
//***********************************************************************************
bool StrictConvolution(const TImpulseResponse* H, const rmatrix& X, rvector& Y)
{//----------------------------------------------------------------------------------
 //Проверка на возможность осуществления операции двумерной свертки
 //----------------------------------------------------------------------------------
 if ((!H->IsReady()) || (H->GetInHeight() != X.Rows()) || (H->GetInWidth() != X.Cols()))
 {Y.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Формирование выходного двумерного сигнала (расчет двумерной дискретной свертки)
 //----------------------------------------------------------------------------------
 return H->Convolute(X,Y);
}
//***********************************************************************************
//СТАТУС: #4; TImpulseResponse class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool AdaptConvolution(TImpulseResponse& H, const rmatrix& X, rmatrix& Y)
//НАЗНАЧЕНИЕ: Расчет импульсного отклика системы обработки двумерных дискретных сигна-
//лов (изображений) по заданному входному воздействию X. Выходной сигнал (изображение)
//формируется в матрице Y, передаваемой по ссылке. Размерность матрицы X задает коли-
//чество входных отсчетов по вертикали и горизонтали в классе H. Если количество вы-
//ходных отсчетов, установленных в классе H равно нулю, то размерность выходной выборки
//становится равной размерности входной выборки и, таким образом, размерность выходного
//изображения Y будет совпадать с размерностью входного изображения X.
//Коэффициенты матрицы импульсного отклика системы H формируются "на лету", что позво-
//ляет избежать формирования матрицы импульсного отклика H в явном виде (формирование
//матрицы H приводит к большим затратам памяти). Матрица входного сигнала X не изме-
//няется функцией. Свойства оператора импульсного отклика двумерной системы (оператора
//искажения изображения) H могут изменяться функцией. АЛГОРИТМ построения свертки ана-
//логичен функции класса TImpulseResponse - bool operator() (X, Y, hY, wY).
//Функция возвращает true, если свертку удалось построить и false в противоположном
//случае. Возможные причины неудачного завершения функции:
//1. Матрица X нулевого размера;
//3. Не удалось выделить память под размещение элементов выходного сигнала Y.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TImpulseResponse& H - ссылка на класс по формированию двумерной свертки;
//2. const rmatrix& X - константная ссылка на входной двумерный дискретный сигнал;
//3. rmatrix& Y - ссылка на матрицу, в которой формируется выходной двумерный
//   дискретный сигнал (изображение);
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции свертки
//***********************************************************************************
bool AdaptConvolution(TImpulseResponse& H, const rmatrix& X, rmatrix& Y)
{//----------------------------------------------------------------------------------
 //Проверка на возможность осуществления операции двумерной свертки
 //----------------------------------------------------------------------------------
 if (X.IsZeroSize()) {Y.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Согласование установленных размеров входной выборки в H с размерами X
 //Установка корректной размерности выходной выборки при необходимости
 //----------------------------------------------------------------------------------
 H.SetInSize(X.Rows(), X.Cols());
 if (H.GetOutSize() == 0L) H.SetOutSize(X.Rows(), X.Cols());
 //----------------------------------------------------------------------------------
 //Формирование выходного двумерного сигнала (расчет двумерной дискретной свертки)
 //----------------------------------------------------------------------------------
 return H.Convolute(X,Y);
}
//***********************************************************************************
//СТАТУС: #5; TImpulseResponse class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool StrictInvRecovery(const TImpulseResponse& H, const rmatrix& Y, rmatrix& EstX)
//НАЗНАЧЕНИЕ: Реставрация искаженного изображения Y методом инверсного синтеза. Выход-
//ной сигнал (изображение) формируется в матрице EstX, передаваемой по ссылке. Размер-
//ность матрицы Y должна совпадать с количеством выходных отсчетов по вертикали и го-
//ризонтали, установленными в классе H. Количество входных отсчетов, установленных в
//классе H не должно быть равно нулю (матрица выходного изображения будет иметь размер-
//ность равную размерности выходной выборки H).
//Для успешного восстановления необходимы следующие условия:
//1) Оператор искажения H должен иметь такие же параметры (кол-во входных и выходных
//   отсчетов, ядро свертки с идентичными аргументами) какие использовались получения
//   изображения Y;
//2) Возможность методом инверсного синтеза построить оператор реставрации W (вычислить
//   оператор обращения функции импульсного отклика системы).
//В случае нарушения условия #1 успешное восстановление не гарантируется, а в случае
//нарушения условия #2 - реставрация невозможна.
//АЛГОРИТМ реставрации сводится к построению оператора реставрации W и в случае его
//построения к применению его к искаженному изображению: EstX = W x Y.
//Функция возвращает true, если удалось реставрировать Y и false в противоположном
//случае. Возможные причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Размерность матрицы входного сигнала Y не согласована с входной размерностью H;
//3. Не удалось построить оператор реставрации W методом инверсного синтеза;
//4. Не удалось выделить память под размещение элементов EstX.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TImpulseResponse& H - ссылка на класс по формированию двумерной свертки;
//2. const rmatrix& Y - константная ссылка на искаженный двумерный дискретный сигнал;
//3. rmatrix& EstX - ссылка на матрицу, в которой формируется реставрированный выход-
//   ной двумерный дискретный сигнал (изображение);
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции реставрации
//***********************************************************************************
bool StrictInvRecovery(const TImpulseResponse& H, const rmatrix& Y, rmatrix& EstX)
{//----------------------------------------------------------------------------------
 //Проверка на возможность осуществления операции реставрации
 //----------------------------------------------------------------------------------
 if ((!H.IsReady()) || (H.GetOutHeight() != Y.Rows()) || (H.GetOutWidth() != Y.Cols()))
 {EstX.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Реставрация входного изображения EstX по выходному изображению Y методом
 //инверсного синтеза оператора импульсного отклика двумерной дискретной системы
 //----------------------------------------------------------------------------------
 return H.InvRecovery(Y,EstX);
}
//***********************************************************************************
//СТАТУС: #6; TImpulseResponse class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool StrictInvRecovery(const TImpulseResponse* H, const rmatrix& Y, rmatrix& EstX)
//НАЗНАЧЕНИЕ: Реставрация искаженного изображения Y методом инверсного синтеза. Выход-
//ной сигнал (изображение) формируется в матрице EstX, передаваемой по ссылке. Размер-
//ность матрицы Y должна совпадать с количеством выходных отсчетов по вертикали и го-
//ризонтали, установленными в классе H. Количество входных отсчетов, установленных в
//классе H не должно быть равно нулю (матрица выходного изображения будет иметь размер-
//ность равную размерности выходной выборки H).
//Для успешного восстановления необходимы следующие условия:
//1) Оператор искажения H должен иметь такие же параметры (кол-во входных и выходных
//   отсчетов, ядро свертки с идентичными аргументами) какие использовались получения
//   изображения Y;
//2) Возможность методом инверсного синтеза построить оператор реставрации W (вычислить
//   оператор обращения функции импульсного отклика системы).
//В случае нарушения условия #1 успешное восстановление не гарантируется, а в случае
//нарушения условия #2 - реставрация невозможна.
//АЛГОРИТМ реставрации сводится к построению оператора реставрации W и в случае его
//построения к применению его к искаженному изображению: EstX = W x Y.
//Функция возвращает true, если удалось реставрировать Y и false в противоположном
//случае. Возможные причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Размерность матрицы входного сигнала Y не согласована с входной размерностью H;
//3. Не удалось построить оператор реставрации W методом инверсного синтеза;
//4. Не удалось выделить память под размещение элементов EstX.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TImpulseResponse* H - указатель на класс по формированию двумерной свертки;
//2. const rmatrix& Y - константная ссылка на искаженный двумерный дискретный сигнал;
//3. rmatrix& EstX - ссылка на матрицу, в которой формируется реставрированный выход-
//   ной двумерный дискретный сигнал (изображение);
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции реставрации
//***********************************************************************************
bool StrictInvRecovery(const TImpulseResponse* H, const rmatrix& Y, rmatrix& EstX)
{//----------------------------------------------------------------------------------
 //Проверка на возможность осуществления операции реставрации
 //----------------------------------------------------------------------------------
 if ((!H->IsReady()) || (H->GetOutHeight() != Y.Rows()) || (H->GetOutWidth() != Y.Cols()))
 {EstX.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Реставрация входного изображения EstX по выходному изображению Y методом
 //инверсного синтеза оператора импульсного отклика двумерной дискретной системы
 //----------------------------------------------------------------------------------
 return H->InvRecovery(Y,EstX);
}
//***********************************************************************************
//СТАТУС: #7; TImpulseResponse class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool StrictInvRecovery(const TImpulseResponse* H, const rvector& Y, rvector& EstX)
//НАЗНАЧЕНИЕ: Реставрация искаженного изображения Y методом инверсного синтеза. Выход-
//ной сигнал (изображение) формируется в векторе EstX, передаваемом по ссылке. Размер
//вектора Y должен совпадать с количеством выходных отсчетов, установленным в классе H.
//Количество входных отсчетов, установленных в классе H не должно быть равно нулю
//(вектор выходного изображения будет иметь размерность равную размерности выходной
//выборки H). Для успешного восстановления необходимы следующие условия:
//1) Оператор искажения H должен иметь такие же параметры (кол-во входных и выходных
//   отсчетов, ядро свертки с идентичными аргументами) какие использовались получения
//   изображения Y;
//2) Возможность методом инверсного синтеза построить оператор реставрации W (вычислить
//   оператор обращения функции импульсного отклика системы).
//В случае нарушения условия #1 успешное восстановление не гарантируется, а в случае
//нарушения условия #2 - реставрация невозможна.
//АЛГОРИТМ реставрации сводится к построению оператора реставрации W и в случае его
//построения к применению его к искаженному изображению: EstX = W x Y.
//Функция возвращает true, если удалось реставрировать Y и false в противоположном
//случае. Возможные причины неудачного завершения функции:
//1. Размерности входной либо выходной выборок равны нулю;
//2. Размер вектора входного сигнала Y не согласована с входной размерностью H;
//3. Не удалось построить оператор реставрации W методом инверсного синтеза;
//4. Не удалось выделить память под размещение элементов EstX.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TImpulseResponse* H - указатель на класс по формированию двумерной свертки;
//2. const rvector& Y - константная ссылка на искаженный двумерный дискретный сигнал;
//3. rvector& EstX - ссылка на вектор, в котором формируется реставрированный выходной
//   двумерный дискретный сигнал (изображение);
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции реставрации
//***********************************************************************************
bool StrictInvRecovery(const TImpulseResponse* H, const rvector& Y, rvector& EstX)
{//----------------------------------------------------------------------------------
 //Проверка на возможность осуществления операции реставрации
 //----------------------------------------------------------------------------------
 if ((!H->IsReady()) || (H->GetOutSize() != Y.Size()))
 {EstX.Set(0L,COL,false); return false;}
 //----------------------------------------------------------------------------------
 //Реставрация входного изображения EstX по выходному изображению Y методом
 //инверсного синтеза оператора импульсного отклика двумерной дискретной системы
 //----------------------------------------------------------------------------------
 return H->InvRecovery(Y,EstX);
}
//***********************************************************************************
//СТАТУС: #8; TImpulseResponse class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool AdaptInvRecovery(TImpulseResponse& H, const rmatrix& Y, rmatrix& EstX)
//НАЗНАЧЕНИЕ: Реставрация искаженного изображения Y методом инверсного синтеза. Выход-
//ной сигнал (изображение) формируется в матрице EstX, передаваемой по ссылке. Размер-
//ность матрицы Y задает размерность выходных отсчетов в H. Если количество входных
//отсчетов, установленных в классе H равно нулю, то размерность входной выборки EstX
//становится равной размерности выходной выборки Y (случай ПОЛНОЙ СИСТЕМЫ).
//Для успешного восстановления необходимы следующие условия:
//1) Оператор искажения H должен иметь такие же параметры (кол-во входных и выходных
//   отсчетов, ядро свертки с идентичными аргументами) какие использовались получения
//   изображения Y;
//2) Возможность методом инверсного синтеза построить оператор реставрации W (вычислить
//   оператор обращения функции импульсного отклика системы).
//В случае нарушения условия #1 успешное восстановление не гарантируется, а в случае
//нарушения условия #2 - реставрация невозможна.
//АЛГОРИТМ реставрации сводится к построению оператора реставрации W и в случае его
//построения к применению его к искаженному изображению: EstX = W x Y.
//Функция возвращает true, если удалось реставрировать Y и false в противоположном
//случае. Возможные причины неудачного завершения функции:
//1. Размерность выходной выборки равна нулю;
//2. Не удалось построить оператор реставрации W методом инверсного синтеза;
//3. Не удалось выделить память под размещение элементов EstX.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TImpulseResponse& H - ссылка на класс по формированию двумерной свертки;
//2. const rmatrix& Y - константная ссылка на искаженный двумерный дискретный сигнал;
//3. rmatrix& EstX - ссылка на матрицу, в которой формируется реставрированный выход-
//   ной двумерный дискретный сигнал (изображение);
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения операции реставрации
//***********************************************************************************
bool AdaptInvRecovery(TImpulseResponse& H, const rmatrix& Y, rmatrix& EstX)
{//----------------------------------------------------------------------------------
 //Проверка на возможность осуществления операции реставрации
 //----------------------------------------------------------------------------------
 if (Y.IsZeroSize()) {EstX.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Согласование установленных размеров выходной выборки в H с размерами Y
 //Установка корректной размерности входной выборки при необходимости
 //----------------------------------------------------------------------------------
 H.SetOutSize(Y.Rows(),Y.Cols());
 if (H.GetInSize() == 0L) H.SetInSize(Y.Rows(), Y.Cols());
 //----------------------------------------------------------------------------------
 //Реставрация входного изображения EstX по выходному изображению Y методом
 //инверсного синтеза оператора импульсного отклика двумерной дискретной системы
 //----------------------------------------------------------------------------------
 return H.InvRecovery(Y,EstX);
}

//***********************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TIR_UnitFunction
//***********************************************************************************
//===================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TIR_UnitFunction
//    PUBLIC MEMBER-FUNCTION OF TIR_UnitFunction CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1; TIR_UnitFunction public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetConvKernel(string& s, uint left_indent = 0) const
//НАЗНАЧЕНИЕ: Формирование наименования функции ядра свертки и ее параметров в s, пе-
//редаваемой в функцию по ссылке. Функция возвращает ссылку на строку s. Формат:
//<Convolution Kernel: Unit Function;\n>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой формируются характеристики ядра свертки;
//2. uint left_indent - отступ слева.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, с сформированными характеристиками ядра свертки.
//***********************************************************************************
string& TIR_UnitFunction::GetConvKernel(string& s, uint left_indent) const
{string space(left_indent,' ');
 s = space+"Convolution Kernel: Unit Function;\n";
 return s;
}
//***********************************************************************************
//СТАТУС: I.2; TIR_UnitFunction public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditConvKernel(uint left_indent = 0)
//НАЗНАЧЕНИЕ: Консольный ввод параметров функции ядра свертки. Для ЕДИНИЧНОЙ функции
//ядра свертки дополнительных параметров вводить не требуется.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint left_indent - начальное смещение строки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIR_UnitFunction::EditConvKernel(uint left_indent)
{int y = wherey(), x = wherex();
 string t;
 string space = string(left_indent,' ');//Начальный отступ
 string s(space+"Edit <Convolution Kernel Unit Function>:");
 cout << s << endl;
 cout << space << " There is no need to input any data!!!" << endl;
 //Отображение свойств ядра свертки
 cout << space << GetConvKernel(t); gotoxy(x,wherey());
 cout << space << "Press any key..."; getch();
 ClrScr(x,y);//Очистка экрана
}

//***********************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TIR_GaussFunction
//***********************************************************************************
//===================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TIR_GaussFunction
//    PUBLIC MEMBER-FUNCTION OF TIR_GaussFunction CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1; TIR_GaussFunction public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetConvKernel(string& s, uint left_indent = 0) const
//НАЗНАЧЕНИЕ: Формирование наименования функции ядра свертки и ее параметров в s, пе-
//редаваемой в функцию по ссылке. Функция возвращает ссылку на строку s. Формат:
//<Convolution Kernel: Gauss Function (t1,t2);\n>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой формируются характеристики ядра свертки;
//2. uint left_indent - отступ слева.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, с сформированными характеристиками ядра свертки.
//***********************************************************************************
string& TIR_GaussFunction::GetConvKernel(string& s, uint left_indent) const
{char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 string space(left_indent,' ');
 s = space+"Convolution Kernel: Gauss Function (";
 //Формирование параметров ГАУССОВОЙ функции ядра двумерной свертки в виде строки
 text << _t1 << "," << _t2 << ");" << endl << ends;
 s.append(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.2; TIR_GaussFunction public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& BriefConvKernel(string& s) const
//НАЗНАЧЕНИЕ: Формирование наименования функции ядра свертки и ее параметров в s, пе-
//редаваемой в функцию по ссылке, сжатом формате. Функция возвращает ссылку на строку
//s. Формат: <Gauss(t1,t2)>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строку, в которой формируются характеристики ядра свертки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, с сформированными характеристиками ядра свертки.
//***********************************************************************************
string& TIR_GaussFunction::BriefConvKernel(string& s) const
{char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 s.assign("Gauss");
 //Формирование параметров ГАУССОВОЙ функции ядра двумерной свертки в виде строки
 text << '(' << _t1 << "," << _t2 << ')' << ends;
 s.append(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.3; TIR_GaussFunction public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditConvKernel(uint left_indent = 0)
//НАЗНАЧЕНИЕ: Консольный ввод параметров функции ядра свертки. Для ГАУССОВОЙ функции
//ядра свертки необходимо ввести два параметров t1 & t2 (t1, t2 >= 0.0).
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint left_indent - начальное смещение строки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIR_GaussFunction::EditConvKernel(uint left_indent)
{bool flag = true;
 int y = wherey(), x = wherex();
 char c;
 double t1, t2;
 //Формирование заголовка
 string t;
 string space = string(left_indent,' ');//Начальный отступ
 string s(space+"Edit <Convolution Kernel Gauss Function>:");
 do //Цикл ввода размеров выходной двумерной выборки
 {cout << s << endl;
  cout << space << " Enter t1 (Y-direction): "; cin >> t1;
  cout << space << " Enter t2 (X-direction): "; cin >> t2;
  SetConvKernelArgs(t1,t2);//Установка параметров гауссовой функции
  ClrScr(x,y);//Очистка экрана
  //Отображение введенного значения и запрос на подтверждение ввода
  cout << space << GetConvKernel(t) << endl; gotoxy(x,wherey());
  cout << space << "Confirm data input, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  ClrScr(x,y);//Очистка экрана
 } while (flag);
}

//***********************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TIR_RoundFunction
//***********************************************************************************
//===================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TIR_RoundFunction
//    PUBLIC MEMBER-FUNCTION OF TIR_RoundFunction CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1; TIR_RoundFunction public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetConvKernel(string& s, uint left_indent = 0) const
//НАЗНАЧЕНИЕ: Формирование наименования функции ядра свертки и ее параметров в s, пе-
//редаваемой в функцию по ссылке. Функция возвращает ссылку на строку s. Формат:
//<Convolution Kernel: Round Function (_R);\n>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой формируются характеристики ядра свертки;
//2. uint left_indent - отступ слева.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, с сформированными характеристиками ядра свертки.
//***********************************************************************************
string& TIR_RoundFunction::GetConvKernel(string& s, uint left_indent) const
{char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 string space(left_indent,' ');
 s = space+"Convolution Kernel: Round Function (";
 //Формирование параметров функции ОКРУЖНОСТИ ядра двумерной свертки в виде строки
 text << "R: " <<_R << ",Bright: " << _Brightness << ");" << endl << ends;
 s.append(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.2; TIR_RoundFunction public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& BriefConvKernel(string& s) const
//НАЗНАЧЕНИЕ: Формирование наименования функции ядра свертки и ее параметров в s, пе-
//редаваемой в функцию по ссылке, сжатом формате. Функция возвращает ссылку на строку
//s. Формат: <Round(_R)>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строку, в которой формируются характеристики ядра свертки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, с сформированными характеристиками ядра свертки.
//***********************************************************************************
string& TIR_RoundFunction::BriefConvKernel(string& s) const
{char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 s.assign("Round");
 //Формирование параметров функции ОКРУЖНОСТИ ядра двумерной свертки в виде строки
 text << '(' << _R << ')' << ends;
 s.append(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.3; TIR_RoundFunction public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditConvKernel(uint left_indent = 0)
//НАЗНАЧЕНИЕ: Консольный ввод параметров функции ядра свертки. Для функции ОКРУЖНОСТИ
//ядра свертки необходимо ввести один параметр R - радиус окружности (R > 0.0).
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint left_indent - начальное смещение строки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIR_RoundFunction::EditConvKernel(uint left_indent)
{bool flag = true;
 int y = wherey(), x = wherex();
 char c;
 double radius;
 //Формирование заголовка
 string t;
 string space = string(left_indent,' ');//Начальный отступ
 string s(space+"Edit <Convolution Kernel Round Function>:");
 do //Цикл ввода размеров выходной двумерной выборки
 {cout << s << endl;
  cout << space << " Enter radius R (R > 0): "; cin >> radius;
  SetConvKernelArgs(radius);//Установка параметров функции окружности
  ClrScr(x,y);//Очистка экрана
  //Отображение введенного значения и запрос на подтверждение ввода
  cout << space << GetConvKernel(t) << endl; gotoxy(x,wherey());
  cout << space << "Confirm data input, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  ClrScr(x,y);//Очистка экрана
 } while (flag);
}

//***********************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TIR_EllipseFunction
//***********************************************************************************
//===================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TIR_EllipseFunction
//    PUBLIC MEMBER-FUNCTION OF TIR_ElipseFunction CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1; TIR_EllipseFunction public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetConvKernel(string& s, uint left_indent = 0) const
//НАЗНАЧЕНИЕ: Формирование наименования функции ядра свертки и ее параметров в s, пе-
//редаваемой в функцию по ссылке. Функция возвращает ссылку на строку s. Формат:
//<Convolution Kernel: Ellipse Function (_A, _B, _Brightness);\n>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой формируются характеристики ядра свертки;
//2. uint left_indent - отступ слева.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, с сформированными характеристиками ядра свертки.
//***********************************************************************************
string& TIR_EllipseFunction::GetConvKernel(string& s, uint left_indent) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 string space(left_indent,' ');
 s = space+"Convolution Kernel: Ellipse Function (";
 //Формирование параметров функции ОКРУЖНОСТИ ядра двумерной свертки в виде строки
 text << "A: " <<_A << ",B: " <<_B << ",Bright: " << _Brightness << ");\n" << ends;
 s.append(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.2; TIR_RoundFunction public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& BriefConvKernel(string& s) const
//НАЗНАЧЕНИЕ: Формирование наименования функции ядра свертки и ее параметров в s, пе-
//редаваемой в функцию по ссылке, сжатом формате. Функция возвращает ссылку на строку
//s. Формат: <Ellipse(_A,_B,_Brightness)>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строку, в которой формируются характеристики ядра свертки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, с сформированными характеристиками ядра свертки.
//***********************************************************************************
string& TIR_EllipseFunction::BriefConvKernel(string& s) const
{char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 s.assign("Ellipse");
 //Формирование параметров функции ЭЛЛИПСА ядра двумерной свертки в виде строки
 text << '(' << _A << ',' << _B << ',' << _Brightness << ')' << ends;
 s.append(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.3; TIR_EllipseFunction public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditConvKernel(uint left_indent = 0)
//НАЗНАЧЕНИЕ: Консольный ввод параметров функции ядра свертки. Для функции ЭЛЛИПСА
//ядра свертки необходимо ввести три параметра:
// A - большая ось (_A > 0.0, по ширине, ось OX);
// B - малая ось   (_B > 0.0, по высоте, ось OY);
// A - яркость внутри эллипса (_Brightness >= 0.0).
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint left_indent - начальное смещение строки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIR_EllipseFunction::EditConvKernel(uint left_indent)
{bool flag = true;
 int y = wherey(), x = wherex();
 char c;
 double a, b, brightness;
 //Формирование заголовка
 string t;
 string space = string(left_indent,' ');//Начальный отступ
 string s(space+"Edit <Convolution Kernel Ellipse Function>:");
 do //Цикл ввода размеров выходной двумерной выборки
 {cout << s << endl;
  cout << space << " Enter Longer Axes A (> 0): "; cin >> a;
  cout << space << " Enter Shorter Axes B (> 0): "; cin >> b;
  cout << space << " Enter Brightness (>= 0): "; cin >> brightness;
  SetConvKernelArgs(a,b,brightness);//Установка параметров функции эллипса
  ClrScr(x,y);//Очистка экрана
  //Отображение введенного значения и запрос на подтверждение ввода
  cout << space << GetConvKernel(t) << endl; gotoxy(x,wherey());
  cout << space << "Confirm data input, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  ClrScr(x,y);//Очистка экрана
 } while (flag);
}


//***********************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TDisturbance
//***********************************************************************************

//===================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TDisturbance
//    PUBLIC MEMBER-FUNCTION OF TDisturbance CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1; TDisturbance public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& RandProcH(string& s, uint left_indent = 0) const
//НАЗНАЧЕНИЕ: Формирование статистических свойств случайного процесса возмущения при
//оценке оператора импульсного отклика H (внутрисистемная ошибка H) в строке s.
//Функция возвращает ссылку на строку s. Формат вывода свойств в строку:
//<Intrasystem error H: Disp = value; Noise = [WHITE || NOT WHITE];\n>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой формируются свойства внутрисистемной
//   ошибки H;
//2. uint left_indent - отступ слева.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку, с сформированными статистичес-
//кими свойствами внутрисистемной ошибки H.
//***********************************************************************************
string& TDisturbance::RandProcH(string& s, uint left_indent) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 string space(left_indent,' ');
 s.assign(space+"Intrasystem error H: ");
 //----------------------------------------------------------------------------------
 //Дисперсия H и вид внутрисистемного шума (белый или небелый)
 text << "Disp = " << GetDispH() << ", Noise = " << ends;
 s.append(text.str()); text.seekp(0);
 if (GetNoiseH()) s.append("WHITE;\n");
 else s.append("NON-WHITE;\n");
 return s;
}
//***********************************************************************************
//СТАТУС: I.2; TDisturbance public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& BriefRandProcH(string& s) const
//НАЗНАЧЕНИЕ: Формирование статистических свойств случайного процесса возмущения при
//оценке оператора импульсного отклика H (внутрисистемная ошибка H) в строке s в
//кратком виде. Функция возвращает ссылку на строку s. Формат вывода в строку:
//<DispH[w]>, [w] - в случае белого шума
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строку, в которой формируются свойства
//внутрисистемной ошибки H;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку, с сформированными статистичес-
//кими свойствами внутрисистемной ошибки H.
//***********************************************************************************
string& TDisturbance::BriefRandProcH(string& s) const
{char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 //----------------------------------------------------------------------------------
 //Дисперсия H и вид внутрисистемного шума (белый или небелый)
 text << GetDispH() << ends; s.assign(text.str()); text.seekp(0);
 if (GetNoiseH()) s.append(1,'w');
 return s;
}
//***********************************************************************************
//СТАТУС: I.3; TDisturbance public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& RandProcInvH(string& s, uint left_indent = 0) const
//НАЗНАЧЕНИЕ: Формирование статистических свойств случайного процесса возмущения при
//обращении оператора импульсного отклика H (внутрисистемная ошибка invH) в строке s.
//Функция возвращает ссылку на строку s. Формат вывода свойств в строку:
//<Intrasystem error InvH: Disp = value; Noise = [WHITE || NOT WHITE];\n>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой формируются свойства внутрисистемной
//   ошибки InvH;
//2. uint left_indent - отступ слева.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку, с сформированными статистичес-
//кими свойствами внутрисистемной ошибки InvH.
//***********************************************************************************
string& TDisturbance::RandProcInvH(string& s, uint left_indent) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 string space(left_indent,' ');
 s.assign(space+"Intrasystem error InvH: ");
 //----------------------------------------------------------------------------------
 //Дисперсия H и вид внутрисистемного шума (белый или небелый)
 text << "Disp = " << GetDispInvH() << ", Noise = " << ends;
 s.append(text.str()); text.seekp(0);
 if (GetNoiseInvH()) s.append("WHITE;\n");
 else s.append("NON-WHITE;\n");
 return s;
}
//***********************************************************************************
//СТАТУС: I.4; TDisturbance public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& BriefRandProcInvH(string& s) const
//НАЗНАЧЕНИЕ: Формирование статистических свойств случайного процесса возмущения при
//обращении оператора импульсного отклика H (внутрисистемная ошибка InvH) в строке s
//в кратком виде. Функция возвращает ссылку на строку s. Формат вывода в строку:
//<DispInvH[w]>, [w] - в случае белого шума
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строку, в которой формируются свойства
//внутрисистемной ошибки InvH.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку, с сформированными статистичес-
//кими свойствами внутрисистемной ошибки InvH.
//***********************************************************************************
string& TDisturbance::BriefRandProcInvH(string& s) const
{char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 //----------------------------------------------------------------------------------
 //Дисперсия H и вид внутрисистемного шума (белый или небелый)
 text << GetDispInvH() << ends; s.assign(text.str()); text.seekp(0);
 if (GetNoiseInvH()) s.append(1,'w');
 return s;
}
//***********************************************************************************
//СТАТУС: I.5; TDisturbance public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& RandProcNoise(string& s, uint left_indent = 0) const
//НАЗНАЧЕНИЕ: Формирование статистических свойств внутреннего шума в строке s.
//Функция возвращает ссылку на строку s. Формат вывода свойств в строку:
//<Internal Noise: Disp = value, Noise = WHITE;\n>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой формируются свойства внутреннего шума;
//2. uint left_indent - отступ слева.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку, с сформированными статистичес-
//кими свойствами внутреннего шума.
//***********************************************************************************
string& TDisturbance::RandProcNoise(string& s, uint left_indent) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 string space(left_indent,' ');
 s.assign(space+"Internal Noise: ");
 //----------------------------------------------------------------------------------
 //Дисперсия H и вид внутреннего шума - белый
 text << "Disp = " << GetDispNoise() << ", Noise = WHITE;" << endl << ends;
 s.append(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.6; TDisturbance public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& BriefRandProcNoise(string& s) const
//НАЗНАЧЕНИЕ: Формирование статистических свойств внутреннего шума в строке s в крат-
//ком виде. Функция возвращает ссылку на строку s. Формат вывода в строку:
//<DispNoise[w]>, [w] - белый шум
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строку, в которой формируются свойства
//внутреннего шума.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку, с сформированными статистичес-
//кими свойствами внутреннего шума.
//***********************************************************************************
string& TDisturbance::BriefRandProcNoise(string& s) const
{char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 //----------------------------------------------------------------------------------
 //Дисперсия H и вид внутреннего шума - белый
 text << GetDispNoise() << 'w' << ends; s.assign(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.7; TDisturbance public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//string& Info(string& s, bool lInvH = true, string& head = string(),
//             uint left_indent = 0) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта TDisturbance в виде строки. Свойства объекта
//заносятся в строку s, передаваемую в функцию по ссылке, предыдущее содержимое строки
//уничтожается.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. bool lInvH [true] - опция включения статистических свойств внутрисистемной
//   ошибки invH в строку s.
//3. string& head - ссылка на строку с заголовком объекта;
//4. uint indent - отступ слева.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//***********************************************************************************
string& TDisturbance::Info(string& s, bool lInvH, string& head, uint left_indent) const
{string t;
 string space(left_indent,' ');
 s.resize(0);
 //Формирование заголовка объекта
 s.append(space);
 if (head.empty()) s.append("Recovery Operator Disturbance Stochastic Processes");
 else s.append(head);
 s.append(":\n");
 //----------------------------------------------------------------------------------
 //1. Статистические свойства внутрисистемной ошибки оценки оператора H
 s.append(RandProcH(t,left_indent+1));
 //----------------------------------------------------------------------------------
 //2. Статистические свойства внутрисистемной ошибки при обращении оператора H
 if (lInvH) s.append(RandProcInvH(t,left_indent+1));
 //----------------------------------------------------------------------------------
 //3. Статистические свойства внутреннего шума
 s.append(RandProcNoise(t,left_indent+1));
return s;
}
//***********************************************************************************
//СТАТУС: I.8; TDisturbance public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& BriefInfo(string& s, bool lInvH = true, bool lNoise = true) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта TDisturbance в кратком виде в строке s.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. bool lInvH [true] - опция включения статистических свойств внутрисистемной
//   ошибки invH в строку s;
//3. bool lNoise [true] - опция включения статистических свойств внутреннего шума
//   в строку s.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//***********************************************************************************
string& TDisturbance::BriefInfo(string& s, bool lInvH, bool lNoise) const
{string t;
 //----------------------------------------------------------------------------------
 //1. Статистические свойства внутрисистемной ошибки оценки оператора H
 s.assign(BriefRandProcH(t));
 //----------------------------------------------------------------------------------
 //2. Статистические свойства внутрисистемной ошибки при обращении оператора H
 if (lInvH) {s.append(1,'_'); s.append(BriefRandProcInvH(t));}
 //----------------------------------------------------------------------------------
 //3. Статистические свойства внутреннего шума
 if (lNoise) {s.append(1,'_'); s.append(BriefRandProcNoise(t));}
return s;
}
//***********************************************************************************
//СТАТУС: I.9; TDisturbance public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditRandProcH(uint left_indent = 0);
//НАЗНАЧЕНИЕ: Консольный ввод статистических свойств внутрисистемной ошибки оценки
//оператора H:
//1) DispH - дисперсия ошибки (DispH >= 0.0)
//2) NoiseH - вид шума (белый или небелый)
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint left_indent - начальное смещение строки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TDisturbance::EditRandProcH(uint left_indent)
{bool flag = true;
 int y = wherey(), x = wherex();
 char c;
 double Disp;
 bool Noise;
 //Формирование заголовка
 string t;
 string space = string(left_indent,' ');//Начальный отступ
 string s(space+"Edit <Infrasystem error H properties>:");
 do //Цикл ввода свойств внутрисистемной ошибки H
 {cout << s << endl;
  cout << space << " Enter Dispersion [>= 0]: "; cin >> Disp;
  cout << space << " Noise is WHITE, isn't it ? [y/n]: "; cin >> c;
  if ((c == 'y') || (c == 'Y')) Noise = true;
  else Noise = false;
  //Установка cтатистических свойств внутрисистемной ошибки оценки оператора H
  SetRandProcH(Disp,Noise);
  ClrScr(x,y);//Очистка экрана
  //Отображение введенных значений и запрос на подтверждение ввода
  cout << space << RandProcH(t,left_indent); gotoxy(x,wherey());
  cout << space << "Confirm data input, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  ClrScr(x,y);//Очистка экрана
 } while (flag);
}
//***********************************************************************************
//СТАТУС: I.10; TDisturbance public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditRandProcInvH(uint left_indent = 0);
//НАЗНАЧЕНИЕ: Консольный ввод статистических свойств внутрисистемной ошибки обращения
//оператора H:
//1) DispInvH - дисперсия ошибки (DispInvH >= 0.0)
//2) NoiseInvH - вид шума (белый или небелый)
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint left_indent - начальное смещение строки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TDisturbance::EditRandProcInvH(uint left_indent)
{bool flag = true;
 int y = wherey(), x = wherex();
 char c;
 double Disp;
 bool Noise;
 //Формирование заголовка
 string t;
 string space = string(left_indent,' ');//Начальный отступ
 string s(space+"Edit <Infrasystem error InvH properties>:");
 do //Цикл ввода свойств внутрисистемной ошибки H
 {cout << s << endl;
  cout << space << " Enter Dispersion [>= 0]: "; cin >> Disp;
  cout << space << " Noise is WHITE, isn't it ? [y/n]: "; cin >> c;
  if ((c == 'y') || (c == 'Y')) Noise = true;
  else Noise = false;
  //Установка cтатистических свойств внутрисистемной ошибки обращения оператора H
  SetRandProcInvH(Disp,Noise);
  ClrScr(x,y);//Очистка экрана
  //Отображение введенных значений и запрос на подтверждение ввода
  cout << space << RandProcInvH(t,left_indent); gotoxy(x,wherey());
  cout << space << "Confirm data input, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  ClrScr(x,y);//Очистка экрана
 } while (flag);
}
//***********************************************************************************
//СТАТУС: I.11; TDisturbance public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditRandProcNoise(uint left_indent = 0);
//НАЗНАЧЕНИЕ: Консольный ввод статистических свойств внутреннего шума:
// 1) DispNoise - дисперсия внутреннего шума (DispNoise >= 0.0)
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint left_indent - начальное смещение строки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TDisturbance::EditRandProcNoise(uint left_indent)
{bool flag = true;
 int y = wherey(), x = wherex();
 char c;
 double Disp;
 //Формирование заголовка
 string t;
 string space(left_indent,' ');//Начальный отступ
 string s(space+"Edit <Internal Noise properties>:");
 do //Цикл ввода свойств внутреннего шума
 {cout << s << endl;
  cout << space << " Enter Dispersion [>= 0]: "; cin >> Disp;
  //Установка cтатистических свойств внутреннего шума
  SetRandProcNoise(Disp);
  ClrScr(x,y);//Очистка экрана
  //Отображение введенных значений и запрос на подтверждение ввода
  cout << space << RandProcNoise(t,left_indent); gotoxy(x,wherey());
  cout << space << "Confirm data input, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  ClrScr(x,y);//Очистка экрана
 } while (flag);
}
//***********************************************************************************
//СТАТУС: I.12; TDisturbance public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit();
//НАЗНАЧЕНИЕ: Редактирование статистических свойств случайных процессов, возмущающих
//оператор реставрации при его построении методом инверсного синтеза оператора импульс-
//ного отклика системы. Функция позволяет редактировать:
//1) Статистические свойства внутрисистемной ошибки оценки оператора H;
//2) Статистические свойства внутрисистемной ошибки при обращении оператора H;
//3) Статистические свойств внутреннего шума.
//Функция позволяет изменять свойства класса TDisturbance.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TDisturbance::Edit()
{string line(78,'-');
 STR_UINT Option[5] = {
 {1, "Edit <Infrasystem error H>" },
 {2, "Edit <Infrasystem error InvH>"},
 {3, "Edit <Internal Noise>"},
 {4, "View <Stochastic Processes Properties>"},
 {5, "Exit" } };
 TB_STR_UINT Menu = {5, Option};
 const string menu_head(" Choice menu option [1-4]: ");
 const string head("Edition <Stochastic Processes Properties>");
 bool flag = true;
 string s;
 clrscr(); //Полная очистка экрана
 do
 {cout << line << endl << head << endl << line << endl;
  uint choice = ConsoleChoice(Menu, 1, menu_head.c_str(), 2);
  switch (choice)
  {case 1: //Edit Infrasystem error H
    EditRandProcH(2);
    break;
   case 2: //Edit Infrasystem error InvH
    EditRandProcInvH(2);
    break;
   case 3: //Edit Internal Noise
    EditRandProcNoise(2);
    break;
   case 4: //Stochastic Processes Properties
    clrscr();
    cout << line << endl;
    cout << "Stochastic Processes Properties:" << endl;
    cout << Info(s);
    cout << line << endl;
    cout << "Press any key to continue..."; getch();
    break;
   case 5: flag = false; break;//Завершение работы с функцией
  }
  clrscr(); //Полная очистка экрана
 } while (flag);
}

//***********************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TRandomProcess
//***********************************************************************************

//===================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TRandomProcess
//    PUBLIC MEMBER-FUNCTION OF TRandomProcess CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1; TRandomProcess public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& Disp(string& s, uint maxlen = 0, uint precision = 6) const
//НАЗНАЧЕНИЕ: Формирование символьного представления значений дисперсий в строке s с
//длиной maxlen. Если все значения не удалось разместить в строке с длиной maxlen, то
//выводится такое количество значений дисперсии, которые разместятся в строке длиной
//maxlen. Если maxlen = 0 (default), то выводятся все значения дисперсии из вектора
//DispSet. Функция возвращает ссылку на строку s. Формат вывода свойств в строку:
//<Disp [count] {D_1, D_2, D_3 ... [D_n]}>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой формируются значения дисперсии
//2. uint maxlen - максимально допустимая длина строки s
//3. uint precision - точность представления значений дисперсии
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// string& s - ссылка на строку, с сформированными значениями дисперсий
//***********************************************************************************
string& TRandomProcess::Disp(string& s, uint maxlen, uint precision) const
{char buffer[40];
 ostrstream text(buffer, sizeof(buffer));
 s.assign("Disp");
 //----------------------------------------------------------------------------------
 //Формируем кол-во значений дисперсии случайного процесса
 text << " [" << DispCount() << "] " << ends; s.append(text.str()); text.seekp(0);
 //Выводим в строку s значения дисперсии
 if ((maxlen != 0) && (maxlen <= s.length()+5)) s.append("{...}");
 else
 {string buf;
  DispSet.ToString(buf,maxlen-s.length()-2,precision);
  s.append(1,'{'); s.append(buf); s.append(1,'}');
 }
 return s;
}
//***********************************************************************************
//СТАТУС: I.2; TRandomProcess public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Noise(string& s, bool brief = true) const
//НАЗНАЧЕНИЕ: Формирование наименования типа случайного процесса (WHITE || COLOR) в
//строке s, передаваемой в функцию по ссылке. Если опция brief установлена (true, по
//умолчанию), то наименование формируется в виде одного символа ('w' || 'c'). Функция
//возвращает ссылку на строку s. Формат вывода типа случайного процесса в строку:
//<WHITE [w] || COLOR [c]>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которую заносится тип случайного процесса;
//2. bool brief (true) - опция формирования наименования типа случайного процесса в
//   сокращенном (true) или полном (false) формате.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//string& s - ссылка на строку, с сформированными наименования типа случайного процесса
//***********************************************************************************
string& TRandomProcess::Noise(string& s, bool brief) const
{if (IsWhiteNoise()) //БЕЛЫЙ ШУМ
 {if (brief) s.assign(1,'w');
  else s.assign("WHITE");
 }
 else //НЕБЕЛЫЙ ШУМ (ЦВЕТНОЙ)
 {if (brief) s.assign(1,'c');
  else s.assign("COLOR");
 }
 return s;
}
//***********************************************************************************
//СТАТУС: I.3; TRandomProcess public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Value(string& s, ulong i, uint prec = 6) const
//НАЗНАЧЕНИЕ: Формирует символьное представления для i-го значения дисперсии случайного
//процесса в строке s. Значения i должны располагаться в интервале [0...DispCount()-1].
//Если индекс i не принадлежит интервалу, то формируется нулевое значение дисперсии.
//Функция возвращает ссылку на строку s.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой формируется i-ое значение дисперсии
//2. uint i - значение индекса, по которому формируется символьное значение дисперсии
//3. uint prec - точность представления i-го значения дисперсии
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// string& s - ссылка на строку, с сформированным значением i-ой дисперсии
//***********************************************************************************
string& TRandomProcess::Value(string& s, ulong i, uint prec) const
{char buffer[20];
 ostrstream text(buffer, sizeof(buffer));
 //----------------------------------------------------------------------------------
 //Формируем i-ое значение дисперсии случайного процесса
 text << setprecision(prec) << GetDisp(i) << ends;
 s.assign(text.str()); text.seekp(0);
 return s;
}
//***********************************************************************************
//СТАТУС: I.4; TRandomProcess public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& ValueInfo(string& s, ulong i, bool brief = true, uint precision = 6) const
//НАЗНАЧЕНИЕ: Формирование строкового представления значения i-ой дисперсии и типа шума
//в строке s. Значения i должны располагаться в интервале [0...DispCount()-1].
//Если индекс i не принадлежит интервалу, то формируется нулевое значение дисперсии.
//Функция возвращает ссылку на строку s. Формат вывода в строку:
//<Di {WHITE | COLOR]> || <Di[w | c]>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой формируется i-ое значение дисперсии
//2. uint i - значение индекса, по которому формируется символьное значение дисперсии
//3. bool brief (true) - опция формирования наименования типа случайного процесса в
//   сокращенном (true) или полном (false) формате.
//4. uint prec - точность представления i-го значения дисперсии
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// string& s - ссылка на строку, с сформированным значением i-ой дисперсии
//***********************************************************************************
string& TRandomProcess::ValueInfo(string& s, ulong i, bool brief, uint precision) const
{string t;
 Value(s,i,precision);//Формируем символьное значение i-ой дисперсии
 Noise(t,brief);//Наименование типа случайного процесса
 if (!brief) s.append(1,' ');
 s.append(t);
 return s;
}
//***********************************************************************************
//СТАТУС: I.5; TRandomProcess public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& Info(string& s, uint maxlen = 0, uint precision = 6) const
//НАЗНАЧЕНИЕ: Вывод свойств класса в строку s, передаваемую по ссылке. Предыдущие со-
//держимое строки уничтожается. Функция возвращает ссылку на строку s. Минимальное
//значение maxlen == 25, если maxlen == 0 (default), то выводится вся информация об
//объекте класса. Ограничение вывода распространяется только на кол-во выводимых зна-
//чений дисперсии, хранимых в векторе DispSet, информация о кол-ве значений дисперсии
//и типа случайного процесса всегда будет присутствовать в строке s (maxlen >= 25 ||
//maxlen == 0). Формат вывода свойств класса в строку:
//<Disp [count] {D_1, D_2, D_3 ... [D_n]} {WHITE | COLOR}\n>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой формируются свойства класса
//2. uint maxlen - максимально допустимая длина строки s для вывода свойств класса
//3. uint precision (6) - точность представления значений дисперсии
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// string& s - ссылка на строку, с сформированными свойствами класса
//***********************************************************************************
string& TRandomProcess::Info(string& s, uint maxlen, uint precision) const
{string t;
 //Формирование строковых значений дисперсии и их количества
 if (maxlen == 0L) Disp(s,maxlen,precision);
 else
 {if (maxlen < 15) Disp(s,15,precision);
  else Disp(s,maxlen-7,precision);
 }
 //Формирование наименования типа случайного процесса (WHITE || COLOR)
 Noise(t,false);
 s.append(1,' '); s.append(t); s.append(1,'\n');
 return s;
}
//***********************************************************************************
//СТАТУС: I.6; TRandomProcess public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong SetDisp(const rvector& Disp)
//НАЗНАЧЕНИЕ: Переустановка значений дисперсии случайного процесса по данным из вектора
//Disp, передаваемого в функцию по ссылке. Фильтрация устанавливаемых значений из
//вектора Disp в вектор DispSet осуществляется по следующим признакам:
//1) УНИКАЛЬНОСТЬ - в векторе DispSet не должно быть повторяющихся значений;
//2) НЕОТРИЦАТЕЛЬНОСТЬ - значения дисперсии должны быть больше или равны нулю.
//DispSet будет хранить отсортированный в порядке возрастания список значений случай-
//ного процесса. Если вектор Disp окажется вектором нулевого размера или ни одно из
//его значений не будет удовлетворять условию (2), то в этом случае формируется вектор
//DispSet длины ОДИН и значением дисперсии равным НУЛЮ.
//Функция изменяет вектор DispSet и возвращает новое кол-во значений дисперсии.
//Свойства и значения вектора Disp функцией не изменяются.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const rvector& Disp - ссылка на вектор с новыми значениями дисперсии
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ulong count - установленное количество новых значений дисперсии
//***********************************************************************************
ulong TRandomProcess::SetDisp(const rvector& Disp)
{if (Disp.IsZeroSize()) DispSet.Set(1,ROW,0.0);//Disp - вектор нулевого размера
 else
 {Disp.Unique(DispSet);//Установка уникальных значений
  //Фильтрация отрицательных значений
  rvector LowerBound(1,COL,0.0);
  TGreaterOrEqual<double,rvector> Predicate(LowerBound);
  DispSet = DispSet.SubVector(Predicate);
  //Не задано ни одного значения
  if (DispSet.IsZeroSize()) DispSet.Set(1,ROW,0.0);
  else DispSet.BubbleSort();//Сортировка в порядке возрастания
 }
 return DispCount();
}
//***********************************************************************************
//СТАТУС: I.7; TRandomProcess public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditNoise(uint left_indent = 0)
//НАЗНАЧЕНИЕ: Консольный ввод вида случайного процесса (белый или небелый шум).
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint left_indent - начальное смещение строки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRandomProcess::EditNoise(uint left_indent)
{bool flag = true;
 int y = wherey(), x = wherex();
 char c;
 bool NoiseType;
 //Формирование заголовка
 string t;
 string space(left_indent,' ');//Начальный отступ
 string s(space+"Edit <Random process type>:");
 do //Цикл ввода типа случайного процесса
 {cout << s << endl;
  cout << space << " Noise is WHITE, isn't it ? [y/n]: "; cin >> c;
  if ((c == 'y') || (c == 'Y')) NoiseType = true;
  else NoiseType = false;
  SetNoise(NoiseType);//Установка введенного значения типа случайного процесса
  ClrScr(x,y);//Очистка экрана
  //Отображение введенного типа случайного процесса и запрос на подтверждение ввода
  cout << space << "Random process: " << Noise(t,false) << endl; //gotoxy(x,wherey());
  cout << space << "Confirm data input, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  ClrScr(x,y);//Очистка экрана
 } while (flag);
}
//***********************************************************************************
//СТАТУС: I.8; TRandomProcess public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void EditDisp(uint left_indent = 0)
//НАЗНАЧЕНИЕ: Консольный ввод значений дисперсии случайного процесса.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint left_indent - начальное смещение строки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRandomProcess::EditDisp(uint left_indent)
{bool flag = true;
 int y = wherey(), x = wherex();
 char c;
 rvector DispVals;
 //Формирование заголовка
 string t;
 string space(left_indent,' ');//Начальный отступ
 string s(space+"Edit <Random process dispersions>:");
 do //Цикл ввода значений дисперсии
 {t.resize(80);
  cout << s << endl << '>';
  //Ввод значений из стандартного потока ввода cin
  cin.ignore();
  getline(cin,t,'\n');

  //cin >> t;
  DispVals.GetDataFromString(t);
  SetDisp(DispVals);
  ClrScr(x,y);//Очистка экрана
  //Отображение введенного типа случайного процесса и запрос на подтверждение ввода
  cout << space << Disp(t, 79 - left_indent) << endl; //gotoxy(x,wherey());
  cout << space << "Confirm data input, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  ClrScr(x,y);//Очистка экрана
 } while (flag);
}
//***********************************************************************************
//СТАТУС: I.9; TRandomProcess public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// void Edit(string& head = string(), bool lDispEdit = true, bool lNoiseEdit = true)
//НАЗНАЧЕНИЕ: Редактирование статистических свойств случайного процесса. Функция
//позволяет:
//1) Переустанавливать значения дисперсии;
//2) Устанавливать тип случайного процесса (WHITE || COLOR);
//3) Просматривать свойства случайного процесса.
//Функция позволяет разрешать/запрещать редактирование отдельных свойств класса в
//зависимости от опций lDispEdit и lNoiseEdit.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& head - наименование случайного процесса
//2. bool lDispEdit (true) - опция доступа к редактированию значений дисперсии
//3. bool lNoiseEdit (true) - опция доступа к редактированию типа случайного процесса
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRandomProcess::Edit(string& head, bool lDispEdit, bool lNoiseEdit)
{string line(78,'-');
 STR_UINT Option[4] = {
 {1, "Edit <Dispersion values>" },
 {2, "Edit <Random process type>"},
 {3, "View <Stochastic Processes Properties>"},
 {4, "Exit" } };
 TB_STR_UINT Menu = {4, Option};
 const string menu_head(" Choice menu option [1-4]: ");
 bool flag = true;
 string s;
 //Формирование заголовка редактируемого случайного процесса
 if (head.length() == 0) head.assign("Edition <Stochastic Processes Properties>");
 clrscr(); //Полная очистка экрана
 do
 {cout << line << endl << head << endl << line << endl;
  uint choice = ConsoleChoice(Menu, 1, menu_head.c_str(), 2);
  switch (choice)
  {case 1: //Edit Dispersion Values
    if (lDispEdit) EditDisp(0);
    else {cout << "  Access denied !!! Press any key ..."; getch();}
    break;
   case 2: //Edit Random Process type
    if (lNoiseEdit) EditNoise(0);
    else {cout << "  Access denied !!! Press any key ..."; getch();}
    break;
   case 3: //Stochastic Processes Properties
    clrscr();
    cout << line << endl;
    cout << "Stochastic Processes Properties:" << endl;
    cout << Info(s,79);
    cout << line << endl;
    cout << "Press any key to continue..."; getch();
    break;
   case 4: flag = false; break;//Завершение работы с функцией
  }
  clrscr(); //Полная очистка экрана
 } while (flag);
}

//***********************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TRecoveryDisturbance
//***********************************************************************************

//===================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TRecoveryDisturbance
//    PUBLIC MEMBER-FUNCTION OF TRecoveryDisturbance CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1; TRecoveryDisturbance public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//string& Info(string& s, bool lErrH = true, bool lErrInvH = true, bool lNoise = true,
//             uint maxlen = 0, uint precision = 6) const;
//НАЗНАЧЕНИЕ: Формирование свойств объекта TRecoveryDisturbance в виде строки. Свойства
//объекта заносятся в строку s, передаваемую в функцию по ссылке, предыдущее содержимое
//строки уничтожается. Формат вывода свойств класса в строку:
//<Stochastic Processes of Recovery Operator Disturbance:\n>
//<ErrH: Disp [count] {D1, D2, D3 ... [Dn]} {WHITE | COLOR}\n>
//<ErrInvH: Disp [count] {D1, D2, D3 ... [Dn]} {WHITE | COLOR}\n>
//<Noise: Disp [count] {D1, D2, D3 ... [Dn]} WHITE\n>
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект;
//2. bool lErrH [true] - опция включения статистических свойств внутрисистемной ошибки
//   ErrH в строку s.
//3. bool lErrInvH [true] - опция включения статистических свойств внутрисистемной
//   ошибки ErrInvH в строку s.
//4. bool lNoise [true] - опция включения статистических свойств внутреннего шума Noise
//   в строку s.
//5. uint maxlen [0] - максимально допустимая длина строки s для вывода свойств каждого
//   случайного процесса, возмущающего оператор реставрации
//6. uint precision (6) - точность представления значений дисперсии
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строковое представление свойств объекта
//***********************************************************************************
string& TRecoveryDisturbance::Info(string& s, bool lErrH, bool lErrInvH, bool lNoise,
        uint maxlen, uint precision) const
{string t;
 //Формирование заголовка объекта
 s.assign("Stochastic Processes of Recovery Operator Disturbance:\n");
 //----------------------------------------------------------------------------------
 //1. Статистические свойства внутрисистемной ошибки оценки оператора H
 if (lErrH) {s.append(" ErrH: "); s.append(_ErrH.Info(t,maxlen,precision));}
 //----------------------------------------------------------------------------------
 //2. Статистические свойства внутрисистемной ошибки при обращении оператора H
 if (lErrInvH) {s.append(" ErrInvH: "); s.append(_ErrInvH.Info(t,maxlen,precision));}
 //----------------------------------------------------------------------------------
 //3. Статистические свойства внутреннего шума
 if (lNoise) {s.append(" Noise: "); s.append(_Noise.Info(t,maxlen,precision));}
 return s;
}
//***********************************************************************************
//СТАТУС: I.2; TRecoveryDisturbance public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// void Edit(bool lErrH = true, bool lErrInvH = true, bool lNoise = true);
//НАЗНАЧЕНИЕ: Редактирование статистических свойств случайных процессов, возмущающих
//оператор реставрации при его построении методом инверсного синтеза оператора
//импульсного отклика системы. Функция позволяет редактировать:
//1) Статистические свойства внутрисистемной ошибки оценки оператора H;
//2) Статистические свойства внутрисистемной ошибки при обращении оператора H;
//3) Статистические свойств внутреннего шума.
//Функция позволяет изменять свойства класса TRecoveryDisturbance.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. bool lErrH [true] - опция разрешения/запрещения редактирования свойств ErrH;
//2. bool lErrInvH [true] - опция разрешения/запрещения редактирования свойств ErrInvH;
//3. bool lNoise [true] - опция разрешения/запрещения редактирования свойств Noise;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRecoveryDisturbance::Edit(bool lErrH, bool lErrInvH, bool lNoise)
{string line(78,'-');
 STR_UINT Option[5] = {
 {1, "Edit <Infrasystem error H>" },
 {2, "Edit <Infrasystem error InvH>"},
 {3, "Edit <Internal Noise>"},
 {4, "View <Stochastic Processes Properties>"},
 {5, "Exit" } };
 TB_STR_UINT Menu = {5, Option};
 const string menu_head(" Choice menu option [1-4]: ");
 const string head("Edition <Stochastic Processes Properties>");
 bool flag = true;
 string s,t;
 clrscr(); //Полная очистка экрана
 do
 {cout << line << endl << head << endl << line << endl;
  uint choice = ConsoleChoice(Menu, 1, menu_head.c_str(), 2);
  switch (choice)
  {case 1: //Edit Infrasystem error H
    t.assign("Edit Infrasystem error H");
    if (lErrH) _ErrH.Edit(t);
    else {cout << "  Access denied !!! Press any key ..."; getch();}
    break;
   case 2: //Edit Infrasystem error InvH
    t.assign("Edit Infrasystem error InvH");
    if (lErrInvH) _ErrInvH.Edit(t);
    else {cout << "  Access denied !!! Press any key ..."; getch();}
    break;
   case 3: //Edit Internal Noise
    t.assign("Edit Internal Noise");
    if (lNoise) _Noise.Edit(t,true,false);
    else {cout << "  Access denied !!! Press any key ..."; getch();}
    break;
   case 4: //Stochastic Processes Properties
    clrscr();
    cout << line << endl;
    cout << Info(s,lErrH,lErrInvH,lNoise,78);
    cout << line << endl;
    cout << "Press any key to continue..."; getch();
    break;
   case 5: flag = false; break;//Завершение работы с функцией
  }
  clrscr(); //Полная очистка экрана
 } while (flag);
}

//----------------------------------------------------------------------------------------
//Редактирование свойств оператора двумерной свертки:
//1) Размерность входной выборки HeightX & WidthX (опционально по lEditIn)
//2) Размерность выходной выборки HeightY & WidthY
//3) Координаты начала отсчета входной выборки OriginHX & OriginWX
//4) Координаты начала отсчета выходной выборки OriginHY & OriginWY
//5) Выбор функции ядра свертки (Convolution Kernel) и редактирование ее параметров
//Функция при редактировании изменяет свойства оператора H
//----------------------------------------------------------------------------------------
void Edit_2DConvolutionOperator(TImpulseResponse** pH, bool lEditIn)
{string line(78,'-');
 STR_UINT Option[7] = {
 {1, "Edit <InSample Size>" },
 {2, "Edit <OutSample Size>"},
 {3, "Edit <InOrigin>"},
 {4, "Edit <OutOrigin>"},
 {5, "Edit <Convolution Kernel>"},
 {6, "Bilateral Convolution Operator Properties"},
 {7, "Exit" } };
 TB_STR_UINT Menu = {7, Option};
 const string menu_head(" Choice menu option [1-7]: ");
 const string head("Edition <Bilateral Convolution Operator>");
 bool flag = true;
 string s;
 clrscr(); //Полная очистка экрана
 do
 {cout << line << endl << head << endl << line << endl;
  uint choice = ConsoleChoice(Menu, 1, menu_head.c_str(), 2);
  switch (choice)
  {case 1: //Edit InSample Size
    if (lEditIn) (*pH)->EditInSampleSize(2);
    else
    {cout << "Access is denied !!!" << endl;
     cout << "Press any key..."; getch();
    }
    break;
   case 2: //Edit OutSample Size
    (*pH)->EditOutSampleSize(2);
    break;
   case 3: //Edit InOrigin
    (*pH)->EditInOrigin(2);
    break;
   case 4: //Edit OutOrigin
    (*pH)->EditOutOrigin(2);
    break;
   case 5: //Edit Convolution Kernel
    Edit_2DConvolutionKernel(pH);
    break;
   case 6: //Bilateral Convolution Operator Properties
    clrscr();
    cout << line << endl;
    cout << "Bilateral Convolution Operator Properties:" << endl;
    cout << (*pH)->BriefInfo(s);
    cout << line << endl;
    cout << "Press any key to continue..."; getch();
    break;
   case 7: flag = false; break;//Завершение работы с функцией
  }
  clrscr(); //Полная очистка экрана
 } while (flag);
}
//----------------------------------------------------------------------------------------
//Выбор функции ядра двумерной свертки, просмотр и редактирование ее параметров через
//стандартный поток ввода/вывода cin/cout (консольный ввод/вывод данных).
//----------------------------------------------------------------------------------------
void Edit_2DConvolutionKernel(TImpulseResponse** pH)
{STR_UINT Option[7] = {
  {CK_2D_UNIT,    "Select < Unit Function >"    }, //1
  {CK_2D_GAUSS,   "Select < Gauss Function >"   }, //2
  {CK_2D_ROUND,   "Select < Round Function >"   }, //3
  {CK_2D_ELLIPSE, "Select < Ellipse Function >" }, //4
  {5,             "Edit < Params >"             },
  {6,             "View < Params >"             },
  {7,             "Exit"                        } };
 TB_STR_UINT Menu = {7, Option};
 string head(" Choice menu option [1-7]: ");
 //Рабочие переменные
 int y_start = wherey();
 string line(78,'-');
 const string msg("Press any key...");
 const string s("2D-Convolution Kernel Functions : < Editing/Choosing >");
 string t;
 bool flag = true;
 gotoxy(1,y_start); clreol();
 do
 {cout << line << endl << s << endl << line << endl;
  uint choice = ConsoleChoice(Menu, 7, head.c_str(), 2);
  switch (choice)
  {//Выбор функции ядра двумерной свертки
   case CK_2D_UNIT:
   case CK_2D_GAUSS:
   case CK_2D_ROUND:
   case CK_2D_ELLIPSE:
    //Создание оператора двумерной свертки с новым ядром. Параметры функции ядра
    //свертки устанавливаются по умолчанию.
    //Предыдущие размеры входной и выходной выборок сохраняются.
    if (Modify_2DConvKernel(pH, choice))
     cout << "New KERNEL has been installed successfully !!!" << endl;
    else
     cout << "New KERNEL has not been installed." << endl;
    cout << msg << endl; getch();
    break;
   case 5: //Редактирование параметров функции ядра двумерной свертки
    (*pH)->EditConvKernel();
    break;
   case 6: //Информация о типе и параметрах ядра свертки в виде строки
    cout << (*pH)->GetConvKernel(t);
    cout << msg << endl; getch();
    break;
   case 7: flag = false; break;//Выход из режима редактирования
  }
  ClrScr(1,y_start);//Очистка экрана
 } while (flag);
}
//----------------------------------------------------------------------------------------
//Изменение типа функции ядра двумерного оператора свертки. Параметры нового ядра свертки
//устанавливаются по умолчанию. Предыдущие размеры входной и выходной выборок двумерного
//оператора свертки сохраняются без изменения. При совпадении функций устанавливаемого ядра
//с установленным выдаются сообщение и оператор свертки не изменяется
//----------------------------------------------------------------------------------------
bool Modify_2DConvKernel(TImpulseResponse** pH, const uint TypeConvKernel)
{bool lSuccess = false;
 const string msg("Press any key...");
 //Проверка на совпадение устанавливаемой функции ядра двумерной свертки c установленным
 //ядром свертки
 if (TypeConvKernel == (*pH)->GetTypeConvKernel())
 {cout << "New 2D-Convolution Kernel is exactly the same as Present Kernel." << endl;
  cout << "Modification is unsuitable." << endl;
  cout << msg << endl; getch();
  return lSuccess;
 }
 //Сохранение предыдущих размеров входной и выходной выборок оператора свертки
 ulong hX, wX, hY, wY;
 (*pH)->GetInOutSizes(hX, wX, hY, wY);

 switch (TypeConvKernel)
 {case CK_2D_UNIT: //Выбор ЕДИНИЧНОЙ функции
   delete (*pH);//Уничтожение оператора свертки с прежним ядром
   //Конструирование оператора свертки с новым ядром
   (*pH) = new TIR_UnitFunction(hX, wX, hY, wY);
   lSuccess = true;
   break;
  case CK_2D_GAUSS: //Выбор ГАУССОВОЙ функции
   delete (*pH);//Уничтожение оператора свертки с прежним ядром
   //Конструирование оператора свертки с новым ядром
   (*pH) = new TIR_GaussFunction(hX, wX, hY, wY);
   lSuccess = true;
   break;
  case CK_2D_ROUND: //Выбор КРУГОВОЙ функции
   delete (*pH);//Уничтожение оператора свертки с прежним ядром
   //Конструирование оператора свертки с новым ядром
   (*pH) = new TIR_RoundFunction(hX, wX, hY, wY);
   lSuccess = true;
   break;
  case CK_2D_ELLIPSE: //Выбор функции ЭЛЛИПСА
   delete (*pH);//Уничтожение оператора свертки с прежним ядром
   //Конструирование оператора свертки с новым ядром
   (*pH) = new TIR_EllipseFunction(hX, wX, hY, wY);
   lSuccess = true;
   break;
   //cout << "This KERNEL has not been implemented yet!!!" << endl;
   //cout << msg << endl; getch();
   //break;
  default: //Неизвестный тип функции ядра двумерной свертки
   cout << "Unknown KERNEL. Modification is impossible." << endl;
   cout << msg << endl; getch();
 }
 if (lSuccess)
 {string s;
  cout << (*pH)->BriefInfo(s) << msg << endl; getch();
 }
 return lSuccess;
}

