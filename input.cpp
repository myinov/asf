//input.cpp
//Реализация класса TInputSignal - ВХОДНОЙ СИГНАЛ
//Initial date: November,8,1998. Final date:
//Copyright (c) JohnSoft 1998. All rights reserved. Borland C++ 5.01

#include "input.h"
//------------------------------------------------------------------------------
//Объявление констант, используемых функциями класса TInputSignal
//------------------------------------------------------------------------------
const complex C_ZERO = complex(0,0);//Комплексный нуль
const complex C_ONE = complex(1,0); //Комплексная единица
const double PI_TWO = 6.283185307178;
const double DegRad = 0.01745329251994;
const double RadDeg = 57.2957795131;

//==============================================================================
// I. ОПИСАНИЕ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TInputSignal
//    PUBLIC MEMBER-FUNCTION OF TInputSignal CLASS
//==============================================================================
//******************************************************************************
//СТАТУС: I.1; public member-function of class TInputSignal
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Update(double time, bool casual = ON)
//НАЗНАЧЕНИЕ:
//Функция предназначена для обновления данных (времени моделирования, случайных
//величин в списках параметров функций базовых классов ExtSignal и TLinearArray)
//и расчета мгновенных комплексных напряжений (вертикальной и горизонтальной
//составляющих) на выходе приемных каналов АР.
//ЗАМЕЧАНИЕ. Если функция формирует мгновенные значения напряжений на выходе
//приемных каналов АР без учета случайных составляющих фазы и амплитуды каждой
//компоненты внешнего сигнала, что является необходимым для АНАЛИТИЧЕСКОГО ПОСТ-
//РОЕНИЯ КОРРЕЛЯЦИОННОЙ МАТРИЦЫ ВХОДНОГО СИГНАЛА, то в этом случае уровень вход-
//ного шума приемных каналов принимается равным ЕДИНИЦЕ - Unoise = 1.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double time - значение модельного времени
//2. bool casual - флаг формирования мгновенных значений комплексных напряжений
//   с учетом или без СЛУЧАЙНЫХ СОСТАВЛЯЮЩИХ ФАЗЫ и АМПЛИТУДЫ СИГНАЛА.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TInputSignal::Update(double time, bool casual)
{uint JamCount = ExtSignal::ActiveJammers();//Кол-во источников помех
 //1. Устанавливаем модельное время и новые значения СВ в списках параметров
 //   функций объекта класса ExtSignal
 ExtSignal::SetTime(time);
 if (casual == ON) ExtSignal::SetRandNumber();
 //2. Устанавливаем новые значения СВ в списках параметров функций объекта клас-
 //   са TLinearArray
 if (casual == ON) TLinearArray::SetRandNumber();
 //-----------------------------------------------------------------------------
 //3. Записываем текущие свойства всех компонент аддитивного внешнего сигнала
 //   в векторы свойств
 //-----------------------------------------------------------------------------
 //Начальная инициализация
 Ampl = 0; Phase = 0; Azimuth = 0; Elevate = 0;
 PolarAngle = 0; PhaseVCP = 0; PhaseHCP = 0;
 //Свойства ПОЛЕЗНОГО СИГНАЛА
 if (ExtSignal::Usage(0) == ON)
 {Ampl[0] = (casual) ? AmplSignalComp(0, NONPOLAR) : DetAmpl(0, NONPOLAR);
  Phase[0] = (casual) ? PhaseSignalComp(0, NONPOLAR) : DetPhase(0, NONPOLAR);

  Azimuth[0] = AzimuthAngle(0);
  Elevate[0] = ElevateAngle(0);
  PolarAngle[0] = ExtSignal::PolarAngle(0);
  PhaseVCP[0] = VCPPhase(0);
  PhaseHCP[0] = HCPPhase(0);
 }
 //Свойства АДДИТИВНОЙ ПОМЕХИ
 if (JamCount != 0) //Проверка на наличие активных помех
 {uint k = 1;
  for (uint i = 1; i < Ampl.Size(); i++)
  {//Поиск активной компоненты внешнего сигнала (Usage == ON)
   while (ExtSignal::Usage(k) != ON) ++k;
   Ampl[i] = (casual) ? AmplSignalComp(k, NONPOLAR) : DetAmpl(k, NONPOLAR);
   Phase[i] = (casual) ? PhaseSignalComp(k, NONPOLAR) : DetPhase(k, NONPOLAR);

   Azimuth[i] = AzimuthAngle(k);
   Elevate[i] = ElevateAngle(k);
   PolarAngle[i] = ExtSignal::PolarAngle(k);
   PhaseVCP[i] = VCPPhase(k);
   PhaseHCP[i] = HCPPhase(k);
   k++;
  }//Конец цикла получения свойств компонент аддитивной активной помехи
 }
 //Расчет для СТАТИСТИЧЕСКОЙ и АНАЛИТИЧЕСКОЙ МОДЕЛИ АДДИТИВНОГО ВНЕШНЕГО СИГНАЛА
 //4. Рассчитываем мгновенные комплексные напряжения полезного сигнала, суммар-
 //   ной помехи и внутреннего шума с вертикальной поляризацией на выходах
 //   приемных каналов линейной АР
 double Amplitude, SumPhase; //Рабочие переменные
 complex U;
 //Предварительное обнуление комплексных векторов и матриц с предыдущими значе-
 //ниями напряжений полезного сигнала, источников активных помех и внутреннего
 //шума на входе адаптивной LAA
 VPSignal = C_ZERO; VPJammer = C_ZERO; VPNoise = C_ZERO;
 HPSignal = C_ZERO; HPJammer = C_ZERO; HPNoise = C_ZERO;

 for (ulong i = 0; i < VPSignal.Size(); i++)
 {//Проверка на использование i-го элемента АР в расчетах
  if (TLinearArray::data[i].GetUsage() == ON)
  {//Вычисление новых значений комплексных напряжений в i-ом приемном канале
   //***************************************************************************
   //1. Вычисление комплексного напряжения ПОЛЕЗНОГО СИГНАЛА с вертикальной
   //   поляризацией
   //***************************************************************************
   //Полезный сигнал присутствует во внешнем сигнале
   if (ExtSignal::Usage(0) == ON)
   {SetAngle(i,Azimuth.Get(0),Elevate.Get(0),RAD);
    //Расчет амплитуды: Ampl=Aj(t)*Sj(t)*ARFi*Fi(AzAnglej,ElAnglej)*sin(PolAnglej)
    Amplitude = Ampl.Get(0)*sin(PolarAngle.Get(0));
    Amplitude *= TLinearArray::data[i].GetN() *
                 TLinearArray::data[i].CalcAntPatterns(Disposition);
    //Расчет фазы: Phase=Phasej(t)+Sj(t)+VCP_Phasej(t)+PhaseShift(i,j,t)
    SumPhase = Phase.Get(0) + PhaseVCP.Get(0);
    if (Disposition == EQUATOR) //АР расположена горизонтально
     SumPhase += TLinearArray::data[i].GetL() * sin(Azimuth.Get(0)) * PI_TWO;
    else //АР расположена вертикально
     SumPhase += TLinearArray::data[i].GetL() * sin(Elevate.Get(0)) * PI_TWO;
    //Вычисление Us для i-го приемного канала АР
    U = polar(Amplitude,SumPhase);
    VPSignal.Put(i,U);
   }
   //***************************************************************************
   //2. Вычисление комплексного напряжения АДДИТИВНОЙ ПОМЕХИ с вертикальной
   //   поляризацией
   //***************************************************************************
   if (JamCount != 0) //Проверка на наличие активных помех
   {//Цикл расчета суммарной помехи на выходе i-го приемного канала АР
    for (uint j = 1; j < Ampl.Size(); j++)
    {SetAngle(i,Azimuth.Get(j),Elevate.Get(j),RAD);
     //Расчет амплитуды: Ampl=Aj(t)*Sj(t)*ARFi*Fi(AzAnglej,ElAnglej)*sin(PolAnglej)
     Amplitude = Ampl.Get(j)*sin(PolarAngle.Get(j));
     Amplitude *= TLinearArray::data[i].GetN() *
                  TLinearArray::data[i].CalcAntPatterns(Disposition);
     //Расчет фазы: Phase=Phasej(t)+Sj(t)+VCP_Phasej(t)+PhaseShift(i,j,t)
     SumPhase = Phase.Get(j) + PhaseVCP.Get(j);
     if (Disposition == EQUATOR) //АР расположена горизонтально
      SumPhase += TLinearArray::data[i].GetL() * sin(Azimuth.Get(j)) * PI_TWO;
     else //АР расположена вертикально
      SumPhase += TLinearArray::data[i].GetL() * sin(Elevate.Get(j)) * PI_TWO;
     //Вычисление Ujam для i-го приемного канала АР
     U = polar(Amplitude,SumPhase);
     VPJammer.Put(i,j-1,U);
    }//Конец цикла вычисления суммарной помехи на выходе i-го приемного канала АР
   }
   //***************************************************************************
   //3. Вычисление комплексного напряжения ВНУТРЕННЕГО ШУМА с вертикальной
   //   поляризацией i-го приемного канала АР
   //***************************************************************************
   if (casual == ON)
   {Amplitude = TLinearArray::data[i].GetAmplNoise();
    SumPhase = TLinearArray::data[i].GetPhaseNoise();
    U = polar(Amplitude,SumPhase);
    VPNoise.Put(i,U);
   }
   else VPNoise.Put(i,C_ONE);
  }
 }//Конец цикла вычисления комплексных напряжений в момент времени t

 //5. Рассчитываем мгновенные комплексные напряжения полезного сигнала, суммар-
 //   ной помехи и внутреннего шума с горизонтальной поляризацией на выходах
 //   приемных каналов линейной АР
 if (casual == ON) TLinearArray::SetRandNumber();
 for (ulong i = 0; i < HPSignal.Size(); i++)
 {//Проверка на использование i-го элемента АР в расчетах
  if (TLinearArray::data[i].GetUsage() == ON)
  {//Вычисление новых значений комплексных напряжений в i-ом приемном канале
   //***************************************************************************
   //1. Вычисление комплексного напряжения ПОЛЕЗНОГО СИГНАЛА с горизонтальной
   //   поляризацией
   //***************************************************************************
   //Полезный сигнал присутствует во внешнем сигнале
   if (ExtSignal::Usage(0) == ON)
   {SetAngle(i,Azimuth.Get(0),Elevate.Get(0),RAD);
    //Расчет амплитуды: Ampl=Aj(t)*Sj(t)*ARFi*Fi(AzAnglej,ElAnglej)*cos(PolAnglej)
    Amplitude = Ampl.Get(0)*cos(PolarAngle.Get(0));
    Amplitude *= TLinearArray::data[i].GetN() *
                 TLinearArray::data[i].CalcAntPatterns(Disposition);
    //Расчет фазы: Phase=Phasej(t)+Sj(t)+HCP_Phasej(t)+PhaseShift(i,j,t)
    SumPhase = Phase.Get(0) + PhaseHCP.Get(0);
    if (Disposition == EQUATOR) //АР расположена горизонтально
     SumPhase += TLinearArray::data[i].GetL() * sin(Azimuth.Get(0)) * PI_TWO;
    else //АР расположена вертикально
     SumPhase += TLinearArray::data[i].GetL() * sin(Elevate.Get(0)) * PI_TWO;
    //Вычисление Us для i-го приемного канала АР
    U = polar(Amplitude,SumPhase);
    HPSignal.Put(i,U);
   }
   //***************************************************************************
   //2. Вычисление комплексного напряжения АДДИТИВНОЙ ПОМЕХИ с горизонтальной
   //   поляризацией
   //***************************************************************************
   if (JamCount != 0) //Проверка на наличие активных помех
   {//Цикл расчета суммарной помехи на выходе i-го приемного канала АР
    for (uint j = 1; j < Ampl.Size(); j++)
    {SetAngle(i,Azimuth.Get(j),Elevate.Get(j),RAD);
     //Расчет амплитуды: Ampl=Aj(t)*Sj(t)*ARFi*Fi(AzAnglej,ElAnglej)*cos(PolAnglej)
     Amplitude = Ampl.Get(j)*cos(PolarAngle.Get(j));
     Amplitude *= TLinearArray::data[i].GetN() *
                  TLinearArray::data[i].CalcAntPatterns(Disposition);
     //Расчет фазы: Phase=Phasej(t)+Sj(t)+HCP_Phasej(t)+PhaseShift(i,j,t)
     SumPhase = Phase.Get(j) + PhaseHCP.Get(j);
     if (Disposition == EQUATOR) //АР расположена горизонтально
      SumPhase += TLinearArray::data[i].GetL() * sin(Azimuth.Get(j)) * PI_TWO;
     else //АР расположена вертикально
      SumPhase += TLinearArray::data[i].GetL() * sin(Elevate.Get(j)) * PI_TWO;
     //Вычисление Ujam для i-го приемного канала АР
     U = polar(Amplitude,SumPhase);
     HPJammer.Put(i,j-1,U);
    }//Конец цикла вычисления суммарной помехи на выходе i-го приемного канала АР
   }
   //***************************************************************************
   //3. Вычисление комплексного напряжения ВНУТРЕННЕГО ШУМА с горизонтальной
   //   поляризацией i-го приемного канала АР
   //***************************************************************************
   if (casual == ON)
   {Amplitude = TLinearArray::data[i].GetAmplNoise();
    SumPhase = TLinearArray::data[i].GetPhaseNoise();
    U = polar(Amplitude,SumPhase);
    HPNoise.Put(i,U);
   }
   else HPNoise.Put(i,C_ONE);
  }
 }//Конец цикла вычисления комплексных напряжений в момент времени t
}
//*****************************************************************************
//СТАТУС: I.2; public member-function of class TInputSignal
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector GetPower(bool PolarType) const;
//НАЗНАЧЕНИЕ: Формирование вектора мощностей компонент  внешнего сигнала, посту-
//пающих на вход линейной АР, для АНАЛИТИЧЕСКОЙ МОДЕЛИ представления аддитивного
//внешнего сигнала.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint PolarType - поляризационная составляющая сигнала
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rvector P - вектор мощностей компонент внешнего сигнала на входе линейной АР
//*****************************************************************************
rvector TInputSignal::GetPower(bool PolarType) const
{//Конструирование вектора-столбца с размерностью равной количеству компонент
 //внешнего сигнала
 rvector P(Ampl.Size(),COL,false);
 double U;
 double PolAngle;
 //Формирование вектора мощностей компонент внешнего сигнала на входе АР
 //для АНАЛИТИЧЕСКОЙ МОДЕЛИ представления аддитивного сигнала
 for (ulong i = 0; i < P.Size(); i++)
 {U = Ampl[i];
  PolAngle = PolarAngle.Get(i);
  if (PolarType == VP_SIGNAL) U = U * sin(PolAngle);
  else U = U * cos(PolAngle);
  P.Put(i, U*U);
 }
return P;
}
//*****************************************************************************
//СТАТУС: I.3; public member-function of class TInputSignal
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector GetAngle(bool DispLAA, bool Deg = RAD) const;
//НАЗНАЧЕНИЕ: Формирование вектора одной из двух угловых координат (азимутально-
//го угла или угла места) источников  аддитивного  внешнего сигнала, поступающих
//на вход LAA.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. bool DispLAA - пространственное расположение линейной АР.
//   Если DispLAA == EQUATOR - формируется вектор АЗИМУТАЛЬНЫХ УГЛОВ источников
//   внешнего сигнала;
//   Если DispLAA == MERIDIAN - формируется вектор УГЛОВ МЕСТА источников внеш-
//   него сигнала;
//2. bool Deg - мера угловой координаты
//   Deg == RAD [по умолчанию] - в радианах
//   Deg == DEG - в градусах
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rvector Angle - вектор одной из двух угловых координат источников внешнего
// сигнала
//*****************************************************************************
rvector TInputSignal::GetAngle(bool DispLAA, bool Deg) const
{//Конструирование вектора-столбца с размерностью равной количеству компонент
 //внешнего сигнала
 rvector Angle(Ampl.Size(),COL,false);
 //Формирование вектора угловой координаты (азимутального угла или угла места)
 //источников внешнего сигнала на входе АР для АНАЛИТИЧЕСКОЙ МОДЕЛИ представле-
 //ния аддитивного входного сигнала
 for (ulong i = 0; i < Angle.Size(); i++)
 {if (DispLAA == EQUATOR) Angle.Put(i,Azimuth.Get(i));
  else if (DispLAA == MERIDIAN) Angle.Put(i,Elevate.Get(i));
  if (Deg == DEG) Angle.Put(i,Angle.Get(i)*RadDeg);
 }
 return Angle;
}
//*****************************************************************************
//СТАТУС: I.4; public member-function of class TInputSignal
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector TestSignal(const ivector& Channels,
//                      double Angle, bool Deg = DEG, bool Check = ON) const;
//НАЗНАЧЕНИЕ: Формирование комплексного вектора напряжений на элементах LAA, ин-
//дексы которых передаются вектором Channels, при действии одного источника сиг-
//нала ЕДИНИЧНОЙ МОЩНОСТИ с направления Angle относительно раскрыва LAA. Функция
//используется для построения диаграммы направленности адаптивных решеток.
//   Функция осуществляет проверку индексов элементов, передаваемых через вектор
//Channels. При обнаружении некорректного индекса элемента LAA, такой индекс ис-
//ключается  из  расчетов. Кроме  того, исключаются повторяющиеся индексы. Таким
//образом, формируется подвектор Index вектора Channels, который содержит только
//корректные и неповторяющиеся индексы LAA. Корректные индексы элементов LAA
//должны удовлетворять следующим условиям: 0 <= Index < LAAElem().
//   Функция рассчитывает комплексный вектор напряжений на элементах LAA, индек-
//сы которых хранятся в векторе Index, размерность которого может не совпадать с
//размерностью вектора Channels.
//   Функция возвращает вектор нулевого размера в следующих случаях:
//1. Вектор Channels - вектор нулевого размера;
//2. Вектор Index - вектор нулевого размера. Это означает отсутствие корректных
//   индексов элементов LAA в векторе Channels.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& Channels - ссылка на вектор с индексами элементов LAA, для
//   которых будет производиться расчет комплексных напряжений при действии
//   источника сигнала ЕДИНИЧНОЙ МОЩНОСТИ;
//2. double Angle - угловая координата источника сигнала ЕДИНИЧНОЙ МОЩНОСТИ
//   относительно раскрыва LAA;
//3. bool Deg - мера угловой координаты
//   Deg == RAD [по умолчанию] - в радианах
//   Deg == DEG - в градусах
//4. bool Check (ON) - опция проверки корректности передаваемых аргументов
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// cvector U - вектор напряжений на элементах LAA при действии сигнала ЕДИНИЧНОЙ
// МОЩНОСТИ с направления Angle относительно раскрыва LAA.
//*****************************************************************************
cvector TInputSignal::TestSignal(const ivector& Channels, double Angle, bool Deg,
        bool Check) const
{cvector U;
 ivector Index = Channels;
 //Блок проверки корректности индексов каналов LAA
 if (Check == ON)
 {//Проверка вектора индексов элементов LAA на вектор нулевого размера
  if (Channels.IsZeroSize()) return U;
  //Формирование вектора корректных индексов элементов для данной LAA
  ivector interval(2,0L);
  interval[0] = 0; interval[1] = LAAElem()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  if (Index.IsZeroSize()) return U;
 }
  //Создание вектора напряжений на элементах LAA при действии источника сигнала
  //ЕДИНИЧНОЙ МОЩНОСТИ действующего с направления Angle относительно раскрыва LAA
  U.Set(Index.Size(),COL,false);
 //Расчет комплексных напряжений на элементах LAA
 Angle = (Deg == DEG) ? Angle*DegRad : Angle;
 //Устанавливаем угловое положение источника сигнала ЕДИНИЧНОЙ МОЩНОСТИ в
 //зависимости от расположения LAA относительно поверхности Земли
 bool EarthPlane = TLinearArray::GetDisp();
 if (EarthPlane == EQUATOR) TLinearArray::SetAngle(Angle,0,RAD);
 else TLinearArray::SetAngle(0,Angle,RAD);
 double Ampl;
 double Phase;
 ulong index;
 for (ulong i = 0; i < Index.Size(); i++)
 {index = Index.Get(i);
  Ampl = GetN(index) * CalcAntPatterns(index,EarthPlane);
  Phase = GetL(index)*sin(Angle)*PI_TWO;
  U.Put(i,polar(Ampl,Phase));
 }
return U;
}
//*****************************************************************************
//СТАТУС: I.5; public member-function of class TInputSignal
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix TestSignal(const ivector& Channels, const rvector& Angle,
//                    bool Deg = DEG, bool Check = ON) const;
//НАЗНАЧЕНИЕ: Формирование  комплексной матрицы напряжений на элементах LAA, ин-
//дексы которых передаются вектором Channels, при действии одного источника сиг-
//нала ЕДИНИЧНОЙ МОЩНОСТИ с направлений, передаваемых в векторе Angle относитель-
//но раскрыва LAA. Функция используется для расчета коэффициентов схемы исключе-
//ния  приема  сигналов  дополнительными  каналами пространственного адаптивного
//фильтра с нескольких направлений.
//   Функция формирует результирующую комплексную матрицу U размерностью N x M,
//где M - количество  угловых  положений  источника сигнала (размерность вектора
//Angle); N - количество каналов LAA (размерность вектора Chаnnels). Матрица U
//имеет следующий вид:
//        1   2   3   ... M - угловая координата источника сигнала
//     1 |U11 U12 U13 ... U1N|
//     2 |U21 U22 U23 ... U2N|
//     3 |U31 U32 U33 ... U3N|
// U = . |... ... ... ... ...|
//     . |... ... ... ... ...|
//     . |... ... ... ... ...|
//     N |UM1 UM2 UM3 ... UMN|
//   Функция осуществляет проверку индексов элементов, передаваемых через вектор
//Channels. При обнаружении некорректного индекса элемента LAA, такой индекс ис-
//ключается  из  расчетов. Кроме  того, исключаются повторяющиеся индексы. Таким
//образом, формируется подвектор Index вектора Channels, который содержит только
//корректные и неповторяющиеся индексы LAA. Корректные индексы элементов LAA
//должны удовлетворять следующим условиям: 0 <= Index < LAAElem().
//   Функция рассчитывает комплексную матрицу напряжений на элементах LAA, индек-
//сы которых хранятся в векторе Index, размерность которого может не совпадать с
//размерностью вектора Channels.
//   Функция возвращает матрицу нулевого размера в следующих случаях:
//1. Вектор Channels - вектор нулевого размера;
//2. Вектор Index - вектор нулевого размера. Это означает отсутствие корректных
//   индексов элементов LAA в векторе Channels.
//3. Вектор Angle - вектор нулевого размера. Отсутствуют координаты источника
//   сигнала относительно раскрыва LAA.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& Channels - ссылка на вектор с индексами элементов LAA, для
//   которых будет производиться расчет комплексных напряжений при действии
//   источника сигнала ЕДИНИЧНОЙ МОЩНОСТИ;
//2. const ivector& Angle - ссылка на вектор с угловой координатой источника
//   сигнала ЕДИНИЧНОЙ МОЩНОСТИ относительно раскрыва LAA;
//3. bool Deg - мера угловой координаты
//   Deg == RAD [по умолчанию] - в радианах
//   Deg == DEG - в градусах
//4. bool Check (ON) - опция проверки корректности передаваемых аргументов
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// cmatrix U - матрица напряжений на элементах LAA при действии сигнала ЕДИНИЧНОЙ
// МОЩНОСТИ с направлений задаваемых вектором Angle относительно раскрыва LAA.
//*****************************************************************************
cmatrix TInputSignal::TestSignal(const ivector& Channels, const rvector& Angle,
                      bool Deg, bool Check) const
{cmatrix U;
 ivector Index = Channels;
 //Блок проверки корректности индексов каналов LAA
 if (Check == ON)
 {//Проверка вектора Angle на вектор нулевого размера
  if (Angle.IsZeroSize()) return U;
  //Проверка вектора индексов элементов LAA на вектор нулевого размера
  if (Channels.IsZeroSize()) return U;
  //Формирование вектора корректных индексов элементов для данной LAA
  ivector interval(2,0L);
  interval[0] = 0; interval[1] = LAAElem()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  if (Index.IsZeroSize()) return U;
 }
 //Создание матрицы напряжений на элементах LAA при действии источника сигнала
 //ЕДИНИЧНОЙ МОЩНОСТИ действующего с направлений задаваемых вектором Angle отно-
 //сительно раскрыва LAA
 U.Set(Index.Size(),Angle.Size(),false);
 //Расчет комплексных напряжений на элементах LAA
 double Ampl, Phase, AngCoord;
 ulong index;
 //Устанавливаем угловое положение источника сигнала ЕДИНИЧНОЙ МОЩНОСТИ в
 //зависимости от расположения LAA относительно поверхности Земли
 bool EarthPlane = TLinearArray::GetDisp();
 for (ulong j = 0L; j < U.Cols(); j++)
 {AngCoord = Angle[j];
  if (Deg == DEG) AngCoord *= DegRad;//Перевод градусов в радианы
  if (EarthPlane == EQUATOR) TLinearArray::SetAngle(AngCoord,0,RAD);
  else TLinearArray::SetAngle(0,AngCoord,RAD);
  for (ulong i = 0L; i < U.Rows(); i++)
  {index = Index.Get(i);
   Ampl = GetN(index) * CalcAntPatterns(index,EarthPlane);
   Phase = GetL(index)*sin(AngCoord)*PI_TWO;
   U.Put(i,j,polar(Ampl,Phase));
  }
 }
return U;
}
//******************************************************************************
//СТАТУС: I.6; public member-function of class TInputSignal
//НАИМЕНОВАНИЕ ФУНКЦИИ: double CalcPSignal(bool Type)
//НАЗНАЧЕНИЕ: Суммарной мгновенной мощности полезного сигнала на выходе АР.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: bool Type - поляризационная составляющая сигнала
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// double P - суммарная мгновенная мощность полезного сигнала на выходе АР
//******************************************************************************
double TInputSignal::CalcPSignal(bool Type)
{double P;
 complex U = C_ZERO;
 //Подсчет мощности по всем приемным каналам АР
 for (ulong i = 0; i < VPSignal.Size(); i++)
 {if (Type == VP_SIGNAL) U += VPSignal.Get(i);
  else U += HPSignal.Get(i);
 }
P = norm(U);
return P;
}
//******************************************************************************
//СТАТУС: I.7; public member-function of class TInputSignal
//НАИМЕНОВАНИЕ ФУНКЦИИ: double CalcPJammer(bool Type)
//НАЗНАЧЕНИЕ: Суммарная мгновенной мощности аддитивной помехи на выходе АР.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: bool Type - поляризационная составляющая помехи
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// double P - суммарная мгновенная мощность аддитивной помехи на выходе АР
//******************************************************************************
double TInputSignal::CalcPJammer(bool Type)
{double P;
 complex U = C_ZERO;
 //Подсчет мощности по всем приемным каналам АР
 for (ulong i = 0L; i < VPJammer.Rows(); i++)
  for (ulong j = 0L; j < VPJammer.Cols(); j++)
  {if (Type == VP_SIGNAL) U += VPJammer.Get(i,j);
   else U += HPJammer.Get(i,j);
  }
 P = norm(U);
 return P;
}
//******************************************************************************
//СТАТУС: I.8; public member-function of class TInputSignal
//НАИМЕНОВАНИЕ ФУНКЦИИ: double CalcPNoise(bool Type)
//НАЗНАЧЕНИЕ: Суммарная мгновенной мощности внутреннего шума на выходе АР.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: bool Type - поляризационная составляющая шума
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// double P - суммарная мгновенная мощность внутреннего шума на выходе АР
//******************************************************************************
double TInputSignal::CalcPNoise(bool Type)
{double P;
 complex U = C_ZERO;
 //Подсчет мощности по всем приемным каналам АР
 for (ulong i = 0; i < VPNoise.Size(); i++)
 {if (Type == VP_SIGNAL) U += VPNoise.Get(i);
  else U += HPNoise.Get(i);
 }
P = norm(U);
return P;
}
//******************************************************************************
//СТАТУС: I.9; public member-function of class TInputSignal
//НАИМЕНОВАНИЕ ФУНКЦИИ: double CalcPSignal(ulong Channel, bool PolarType)
//НАЗНАЧЕНИЕ: Вычисление мгновенной мощности полезного сигнала на выходе прием-
//ного канала АР с номером Channel.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong Channel - номер канала антенной решетки;
//2. bool PolarType - поляризационная составляющая полезного сигнала.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double P - мгновенная мощность полезного сигнала на
//выходе приемного канала АР
//******************************************************************************
double TInputSignal::CalcPSignal(ulong Channel, bool PolarType)
{double P = 0.0;
 if (Channel >= LAAElem()) return P;
 //Подсчет мощности сигнала в приемном канале АР с номером Channel
 if (PolarType == VP_SIGNAL) P = norm(VPSignal.Get(Channel));
 else P = norm(HPSignal.Get(Channel));
return P;
}
//******************************************************************************
//СТАТУС: I.10; public member-function of class TInputSignal
//НАИМЕНОВАНИЕ ФУНКЦИИ: double CalcPJammer(ulong Channel, bool PolarType)
//НАЗНАЧЕНИЕ: Вычисление мгновенной мощности аддитивной помехи на выходе прием-
//ного канала АР с номером Channel.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong Channel - номер канала антенной решетки;
//2. bool PolarType - поляризационная составляющая аддитивной помехи.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double P - мгновенная мощность аддитивной помехи на
//выходе приемного канала АР
//******************************************************************************
double TInputSignal::CalcPJammer(ulong Channel, bool PolarType)
{if (Channel >= LAAElem()) return 0.0;
 complex U = C_ZERO;
 //Подсчет мощности помехи в приемном канале АР с номером Channel
 for (ulong j = 0L; j < VPJammer.Cols(); j++)
 {if (PolarType == VP_SIGNAL) U += VPJammer.Get(Channel,j);
  else U += HPJammer.Get(Channel,j);
 }
return norm(U);
}
//******************************************************************************
//СТАТУС: I.11; public member-function of class TInputSignal
//НАИМЕНОВАНИЕ ФУНКЦИИ: double CalcPNoise(ulong Channel, bool PolarType)
//НАЗНАЧЕНИЕ: Вычисление мгновенной мощности внутреннего шума на выходе
//приемного канала АР с номером Channel.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong Channel - номер канала антенной решетки;
//2. bool PolarType - поляризационная составляющая внутреннего шума.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double P - мгновенная мощность внутреннего шума на
//выходе приемного канала АР
//******************************************************************************
double TInputSignal::CalcPNoise(ulong Channel, bool PolarType)
{double P = 0.0;
 if (Channel >= LAAElem()) return P;
 //Подсчет мощности шума в приемном канале АР с номером Channel
 if (PolarType == VP_SIGNAL) P = norm(VPNoise.Get(Channel));
 else P = norm(HPNoise.Get(Channel));
return P;
}
//******************************************************************************
//СТАТУС: I.12; public; TInputSignal class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double SJNRatio(bool PolarType)
//НАЗНАЧЕНИЕ:
//Функция вычисляет отношение сигнал/помеха+шум (в децибелах) по суммарным мгно-
//венным значениям мощностям полезного сигнала, аддитивной помехе и шума на вы-
//ходе АР.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: bool PolarType - поляризационная составлющая сигнала
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double SJR - отношение сигнал/помеха+шум в Дб (Db)
//*****************************************************************************
double TInputSignal::SJNRatio(bool PolarType)
{ double SJR;
  double Pjam = CalcPJammer(PolarType);
  double Pnoise = CalcPNoise(PolarType);
  double Ps = CalcPSignal(PolarType);
  //Суммарная мощность помехи+шум равна нулю
  if ((Pjam+Pnoise) == 0.0) return 100.0;
  //Суммарная мощность сигнала равна нулю
  if (Ps == 0.0) return -100.0;
  //Расчет отношения сигнал/помеха+шум (ОСПШ)
  SJR = 10*log10(Ps/(Pjam+Pnoise));
 return SJR;
}
//******************************************************************************
//СТАТУС: I.13; public; TInputSignal class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double SJNRatio(ulong Channel, bool PolarType)
//НАЗНАЧЕНИЕ: Вычисление отношения сигнал/помеха+шум (в децибелах) по мгновенным
//значениям мощностей полезного сигнала, аддитивной помехи и шума на выходе
//приемного канала АР с номером Channel.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong Channel - номер канала антенной решетки;
//2. bool PolarType - поляризационная составляющая сигнала.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double SJR - отношение сигнал/помеха+шум в Дб (Db)
//******************************************************************************
double TInputSignal::SJNRatio(ulong Channel, bool PolarType)
{ double SJR;
  double Pjam = CalcPJammer(Channel, PolarType);
  double Pnoise = CalcPNoise(Channel, PolarType);
  double Ps = CalcPSignal(Channel, PolarType);
  //Суммарная мощность помехи+шум равна нулю
  if ((Pjam+Pnoise) == 0.0) return 100.0;
  //Суммарная мощность сигнала равна нулю
  if (Ps == 0.0) return -100.0;
  //Расчет отношения сигнал/помеха+шум (ОСПШ)
  SJR = 10*log10(Ps/(Pjam+Pnoise));
 return SJR;
}
//******************************************************************************
//СТАТУС: I.14; public; TInputSignal class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector& StatSignal(cvector& V, bool PolarType) const
//НАЗНАЧЕНИЕ: Формирование вектора напряжений полезного сигнала на выходе всех
//каналов LAA
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& V - вектор полезного сигнала на выходе LAA;
//2. bool PolarType - поляризационная составляющая полезного сигнала.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector& V - вектор полезного сигнала на выходе LAA
//******************************************************************************
cvector& TInputSignal::StatSignal(cvector& V, bool PolarType) const
{V.Set(LAAElem(),COL,false);
 if (PolarType == VP_SIGNAL)
  for (ulong i = 0L; i < V.Size(); i++) V.Put(i,VPSignal.Get(i));
 else
  for (ulong i = 0L; i < V.Size(); i++) V.Put(i,HPSignal.Get(i));
return V;
};
//******************************************************************************
//СТАТУС: I.15; public; TInputSignal class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector& StatJammer(cvector& V, bool PolarType) const
//НАЗНАЧЕНИЕ: Формирование вектора напряжений аддитивной помехи на выходе всех
//каналов LAA
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& V - вектор аддитивной помехи на выходе LAA;
//2. bool PolarType - поляризационная составляющая аддитивной помехи.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector& V - вектор аддитивной помехи на выходе LAA
//******************************************************************************
cvector& TInputSignal::StatJammer(cvector& V, bool PolarType) const
{V.Set(LAAElem(),COL,C_ZERO);
 if (PolarType == VP_SIGNAL)
  for (ulong i = 0L; i < V.Size(); i++)
   for (ulong j = 0L; j < VPJammer.Cols(); j++)
    V.Put(i,V.Get(i)+VPJammer.Get(i,j));
 else
  for (ulong i = 0L; i < V.Size(); i++)
   for (ulong j = 0L; j < HPJammer.Cols(); j++)
    V.Put(i,V.Get(i)+HPJammer.Get(i,j));
 return V;
};
//******************************************************************************
//СТАТУС: I.16; public; TInputSignal class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector& StatNoise(cvector& V, bool PolarType) const
//НАЗНАЧЕНИЕ: Формирование вектора напряжений внутреннего шума на выходе всех
//каналов LAA
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& V - вектор  на выходе внутреннего шума LAA;
//2. bool PolarType - поляризационная составляющая внутреннего шума.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector& V - вектор внутреннего шума на выходе LAA
//******************************************************************************
cvector& TInputSignal::StatNoise(cvector& V, bool PolarType) const
{V.Set(LAAElem(),COL,false);
 if (PolarType == VP_SIGNAL)
  for (ulong i = 0L; i < V.Size(); i++) V.Put(i,VPNoise.Get(i));
 else
  for (ulong i = 0L; i < V.Size(); i++) V.Put(i,HPNoise.Get(i));
 return V;
};
//******************************************************************************
//СТАТУС: I.15; public; TInputSignal class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector& Jammer(cvector& V, bool PolarType) const
//НАЗНАЧЕНИЕ: Формирование вектора напряжений аддитивной помехи на выходе всех
//каналов LAA
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& V - вектор аддитивной помехи на выходе LAA;
//2. bool PolarType - поляризационная составляющая аддитивной помехи.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector& V - вектор аддитивной помехи на выходе LAA
//******************************************************************************
cvector& TInputSignal::Jammer(cvector& V, bool PolarType) const
{V.Resize(VPJammer.Rows()); V = complex(0,0);
 if (PolarType == VP_SIGNAL)
 {for (ulong i = 0L; i < VPJammer.Rows(); i++)
   for (ulong j = 0L; j < VPJammer.Cols(); j++)
    V.Put(i,V.Get(i)+VPJammer.Get(i,j));
 }
 else
 {for (ulong i = 0L; i < HPJammer.Rows(); i++)
   for (ulong j = 0L; j < HPJammer.Cols(); j++)
    V.Put(i,V.Get(i)+HPJammer.Get(i,j));
 }
return V;
};
//******************************************************************************
//СТАТУС: I.16; public; TInputSignal class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool GetRnn(cmatrix& R, bool PolarType) const
//НАЗНАЧЕНИЕ: Формирование корреляционной матрицы внутреннего шума. Все внедиаго-
//нальные элементы матрицы Rnn равны нулю, диагональные элементы равны мощности
//внутреннего шума в соответствующем канале.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой формируется корреляционная матрица
//   внутреннего шума;
//2. bool PolarType - поляризационная составляющая внутреннего шума.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат формирования Rnn
//******************************************************************************
bool TInputSignal::GetRnn(cmatrix& R, bool PolarType) const
{//Формирование Rnn для вертикальной поляризационной составляющей
 if (PolarType == VP_SIGNAL)
 {if (VPNoise.IsZeroSize()) return false;
  if (R.Set(VPNoise.Size(),C_ZERO) == false) return false;
  for (ulong i = 0L; i < R.Rows(); i++) R.Put(i,i,norm(VPNoise.Get(i)));
 }
 //Формирование Rnn для горизонтальной поляризационной составляющей
 else
 {if (HPNoise.IsZeroSize()) return false;
  if (R.Set(HPNoise.Size(),C_ZERO) == false) return false;
  for (ulong i = 0L; i < R.Rows(); i++) R.Put(i,i,norm(HPNoise.Get(i)));
 }
return true;
};


//******************************************************************************
// I. ОПИСАНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРОВ КЛАССА TInputSignal
//******************************************************************************
//******************************************************************************
//СТАТУС: I.1; public; constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TInputSignal(const char* extsignal,const char* linarray)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TInputSignal.
//Функция предназначена для создания класса TInputSignal. Данный класс наследует
//свойства двух классов ExtSignal и TLinearArray конструкторы которых должны быть
//вызваны до вызова конструктора класса TInputSignal. Конструкторы базовых клас-
//сов ExtSignal и TLinearArray для создания собственных объектов используют ин-
//формацию, которая хранится в текстовых файлах специального вида, поэтому конст-
//руктор класса TInputSignal должен передать имена этих файлов вышеупомянутым
//конструкторам. В случае неудачной попытки создания экземпляра класса
//TInputSignal его данные инициализируются нулевыми значениями.
//-----------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const char* extsignal - имя входного файла с данными по аддитивному внешне-
//   му сигналу;
//2. const char* linarray - имя входного файла с данными по линейной АР.
//-----------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//*****************************************************************************
TInputSignal::TInputSignal(const char* extsignal, const char* linarray) :
              ExtSignal(extsignal), TLinearArray(linarray)
{bool lSuccess = true;
 //Начальная инициализация характеристик входного сигнала
 if (TLinearArray::Count != 0L) Init();
 else lSuccess = false;
 if (lSuccess) //Объект TInputSignal создан успешно
 {
  #if defined(CONSOLE)
   cout << endl << "The INPUT SIGNAL is designed." << endl;
  #endif
 }
 else //Ошибка считывания данных
 {
  #if defined(CONSOLE)
   cout << endl << "The INPUT SIGNAL design is impossible." << endl;
   cout << "The program will be terminated." << endl;
   cout << "Press any key ..."; getch();
  #endif
  Reset();
  }
}
//******************************************************************************
//СТАТУС: I.2; public; TInputSignal class destructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: ~TInputSignal()
//НАЗНАЧЕНИЕ: Деструктор класса TInputSignal.
//Функция предназначена для разрушения класса. При работе функции освобождается
//память выделяемая под хранение характеристик составляющих внешнего сигнала и
//комплексных напряжений на выходе приемных каналов АР.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TInputSignal::~TInputSignal()
{ Reset();//Удаление всех характеристик входного сигнала
}

//==============================================================================
//III. ОПИСАНИЕ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TInputSignal
//     PROTECTED MEMBER-FUNCTION OF TInputSignal CLASS
//==============================================================================
//******************************************************************************
//СТАТУС: III.1, protected TInputSignal class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Init()
//НАЗНАЧЕНИЕ: Начальная инициализация характеристик входного сигнала при
//создании объекта класса.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TInputSignal::Init()
{//Начальная инициализация характеристик объекта класса
 //Конструирование векторов со свойствами компонент внешнего сигнала
 ulong count = 1;//Количество активных компонент внешнего сигнала (Usage == ON)
 //Определение количества активных помех во внешнем сигнале
 count += ExtSignal::ActiveJammers();
 if (count == 1) count++;
 Ampl.Set(count,COL,0.0);
 Phase.Set(count,COL,0.0);
 Azimuth.Set(count,COL,0.0);
 Elevate.Set(count,COL,0.0);
 PolarAngle.Set(count,COL,0.0);
 PhaseVCP.Set(count,COL,0.0);
 PhaseHCP.Set(count,COL,0.0);
 //Конструирование комплексных векторов мгновенных значений напряжений полезного
 //сигнала и внутреннего шума и комплексной матрицы мгновенных значений напряже-
 //ний каждого источника активных помех для всех приемных каналов LAA
 VPSignal.Set(LAAElem(),COL,C_ZERO);
 HPSignal.Set(LAAElem(),COL,C_ZERO);
 VPNoise.Set(LAAElem(),COL,C_ZERO);
 HPNoise.Set(LAAElem(),COL,C_ZERO);

 ulong Jams = (ActiveJammers() == 0) ? 1 : ActiveJammers();
 VPJammer.Set(LAAElem(),Jams,C_ZERO);
 HPJammer.Set(LAAElem(),Jams,C_ZERO);
}
//******************************************************************************
//СТАТУС: III.2, protected TInputSignal class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Reset()
//НАЗНАЧЕНИЕ: Сброс всех характеристик входного сигнала. Функция используется при
//удалении объекта TInputSignal, а также в случае обновления всех характеристик
//входного воздействия.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TInputSignal::Reset()
{//Удаление векторов с параметрами аддитивного сигнала
 Ampl.Set(0L,COL,false);
 Phase.Set(0L,COL,false);
 Azimuth.Set(0L,COL,false);
 Elevate.Set(0L,COL,false);
 PolarAngle.Set(0L,COL,false);
 PhaseVCP.Set(0L,COL,false);
 PhaseHCP.Set(0L,COL,false);

 VPSignal.Set(0L,COL,false);
 HPSignal.Set(0L,COL,false);
 VPNoise.Set(0L,COL,false);
 HPNoise.Set(0L,COL,false);

 VPJammer.Set(0L,0L,false);
 HPJammer.Set(0L,0L,false);
}

