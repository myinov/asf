//----------------------------------------------------------------------------------------
//SF_CommonFunc.h     C++ Builder 6.0 JohnSoft Initial date: 23/03/2007
//Объявление общеупотребительных интерфейсных функций, используемых при моделировании
//адаптивных систем (АС) пространственной обработки сигналов на фоне внешних шумовых полей
//с учетом внутрисистемных возмущений параметрического вектора АС.
//----------------------------------------------------------------------------------------
#ifndef SF_CommonFuncH
#define SF_CommonFuncH
//----------------------------------------------------------------------------------------
//Объявление заголовочных файлов
#include "const.h"
#include "matrix.h"
#include "arrays.h"
#include "Regularity.h"
#include "RandGen.h"
#include "CoDec.h"

//****************************************************************************************
//Предварительное объявление имен классов и структур
//****************************************************************************************
//Объявление структуры данных результатов работы функции вычисления показателя качества
//адаптации пространственного фильтра статистическим методом. Весовой вектор фильтра форми-
//руется путем обращения регуляризированной оценочной ковариационной матрицы входного про-
//цесса EstRsjn.
struct TResultStatCalcQadaptDM {
 double Q;    //Мат. ожидание показателя качества адаптации
 double MSD_Q;//СКВО показателя качества адаптации
 ulong InvErr;//Счетчик числа неудачных обращений EstRsjn
 string Msg; //Строка сообщений хода выполнения расчета
};//Конец объявления структуры TResultStatCalcQadaptDM

//****************************************************************************************
// Предварительное объявление функций
//****************************************************************************************
//Функция расчета показателя качества адаптации пространственного фильтра статистическим
//методом. Весовой вектор фильтра формируется путем обращения регуляризированной оценочной
//ковариационной матрицы входного процесса EstRsjn. Мат. ожидание показателя эффективности
//вычисляется по формуле: Q=10*Log10(Ps/OutPsjn) путем проведения Test экспериментов и
//усреднением полученных результатов. Показатель эффективности Q адаптивного пространствен-
//ного фильтра зависит от следующих факторов:
//1) Приемной системы (числа вспомогательных каналов фильтра - приемных каналов антенной
//   решетки и их внутреннего шума) => LAA;
//2) Помеховой ситуации - суммарной мощности помехи и числа источников помех => Jams;
//3) Алгоритма обращения регуляризированной ковариационной матрицы EstRsjn => pInvOp;
//4) Значения параметра регуляризации => alpha;
//5) Объема выборки, по которой формируется оценочная матрица EstRsjn => n;
//6) Мощности полезного сигнала и его углового положения => Signal_2D;
//7) Использованием схемы линейного ограничения весового вектора адаптивного фильтра, кото-
//   рая позволяет исключить подавление сигнала с заданного направления. Для этого задается
//   направление, совпадающее с направлением прихода полезного сигнала => ElimDirs.
//В данной функции принята модель детерминированного полезный сигнала и статистических
//(случайных) процессов аддитивной помехи и внутреннего шума. В связи с этим вычисляется
//не точное значение показателя эффективности Q, а его математическое ожидание, что требует
//проведения Test экспериментов. Наряду с мат. ожиданием Q вычисляется и его СКВО.
//Функция проводит проверку на допустимость вычисления показателя адаптации. Для этого
//должны выполняться следующие условия:
//1) Число приемных каналов фильтра Naux >= 1, что требует наличия минимум двух каналов LAA -
//   основного и одного вспомогательного каналов для адаптивного пространственного фильтра;
//2) Мощность полезного сигнала Ps > 0;
//3) Наличии алгоритма обращения оценочной матрицы входного процесса EstRsjn => pInvOp!=NULL;
//4) Объем выборки отличен от нуля n > 0.
//Данные условия не гарантируют обращение EstRsjn. Так, например, при обращении нерегуляри-
//зированной матрицы EstRsjn (классический метод обращения) в случае n < Naux данная матрица
//будет вырожденной. В этом случае, за значение мощности на выходе адаптивного фильтра
//OutPsjn принимают просто мощность на выходе основного канала, что соответствует нулевому
//весовому вектору дополнительных каналов фильтра Waux (ненастроенному фильтру). В остальных
//случаях, при обращении оценочной ковариационной матрицы входного процесса EstRsjn мощность
//на выходе адаптивного фильтра вычисляется по следующей схеме:
//1) Формируем оценочную ковариационную матрицу EstRsjn путем проведения n усреднений
//   ковариационных матриц Rsjn(i), 1 < i <= n. Каждая Rsjn(i) формируется из статистичес-
//   кого входного вектора U(i) = Us+Ujam(i)+Un(i), Ujam(i), Un(i) - статистические входные
//   процессы аддитивного помехи и внутреннего шума размерностью N (по числу каналов LAA),
//   Us - детерминированный процесс размерностью N. Rsjn(i) = U(i)*Tr[U(i)], где
//   Tr[*] - оператор комплексно-сопряженного транспонирования вектора(или матрицы).
//2) По матрице EstRsjn рассчитываем матрицу вспомогательных каналов A и вектор взаимных
//   ковариаций дополнительных и основного каналов фильтра b. Размерности A и b равны числу
//   дополнительных каналов фильтра Naux = N - 1;
//3) Обращаем предварительно регуляризированную матрицу A с учетом одного из выбранных
//   алгоритмов обращения матрицы (схема Лаврентьева, Тихонова, Тихонова n-го порядка или
//   Скачкова) либо без предварительной регуляризации (классический метод). Получаем матрицу
//   InvAa обратную к A. Результат обращения будет зависеть как от выбранного метода обра-
//   щения, так и от значения параметра регуляризации alpha, используемого для данной
//   оценочной матрицы.
//4) Определяем весовой вектор для дополнительных каналов фильтра Waux:
//   - Без схемы линейного ограничения весового вектора: Waux = -InvAa*b;
//   - С учетом схемы весового ограничения: Waux = -InvAa*B*b.
//   Схема линейного ограничения (метод Лагранжа) позволяет исключить подавление полезного
//   сигнала адаптивным пространственным фильтром. Матрица B - оператор линейного ограни-
//   чения: B = I-C*Inv[Tr[C]*InvAa*C]*Tr[C]*InvAa. Размерности всех матриц равна Naux.
//    Inv[*] - оператор обращения матрицы;
//    I - единичная матрица;
//    C - матрица (Naux x K) фазовых набегов между дополнительными и основным каналами
//    фильтра для заданных направлений исключения (K - число направлений исключения).
//5) Формируем расширенный весовой вектор (с учетом веса для основного канала равный 1):
//   ExtW = {Waux 1}.
//6) Рассчитываем мощность на выходе: OutPsjn = Tr[ExtW]*EstRsjn*ExtW.
//Затем по значениям Ps и OutPsjn вычисляется показатель эффективности адаптивной системы.
//Для формирования оценочного значения Q (мат. ожидания Q) выполняется Test экспериментов.
//Функция возвращает true в случае успешного вычисления Q (даже в случае вырожденности A)
//и false - в противном случае. Входные параметры функции:
//1. TResultStatCalcQadaptDM& Result - данные с результатами работы функции;
//2. TUnEqLAA_ODA& LAA - линейная эквидистантная однородная решетка с всенаправленными
//   антенными элементами (приемник входного сигнала);
//3. TGrayScaleImgSrc_2D& Signal_2D - источник двумерного сигнала (изображения);
//4. TDoubleSet& ElimDirs - направления исключения (используются для линейного ограничения
//   методом Лагранжа весового вектора Waux с целью исключения подавления сигнала с заданных
//   направлений;
//5. TJammers_2D& Jams - аддитивная помеха;
//6. TCovMatrixInversion* pInvOp - оператор обращения ковариационной матрицы входного про-
//   цесса с возможностью ее предварительной регуляризации по заданным алгоритмам с целью
//   компенсации влияния внутрисистемных ошибок на качество реставрации изображения, при-
//   нимаемого на фоне аддитивной помехи.
//7. double alpha - параметр регуляризации;
//8. ulong n - значение объема выборки;
//9. ulong Test - число статистических опытов для получения точечных оценок показателя
//   качества адаптации (мат. ожидания и СКВО).
//----------------------------------------------------------------------------------------
bool StatCalcQadaptDM(TResultStatCalcQadaptDM& Result, const TUnEqLAA_ODA& LAA,
     const TGrayScaleImgSrc_2D& Signal_2D, const TDoubleSet& ElimDirs,
     const TJammers_2D& Jams, TCovMatrixInversion* pInvOp, double alpha, ulong n,
     ulong Test);

//Редактирование параметров кодера-декодера 2D-Signal (установка значений порогов напряже-
//ний и мощностей, выбор функции кодирования-декодирования)
bool Edit_CoDec(TFuncGen_DSClipper** pCoDec);

//Выбор оператора возмущения ковариационной матрицы входного процесса (выбор закона распре-
//деления внутрисистемных ошибок)
bool Edit_DispOperator(TCovMatrixPerturbOperator** pDistOp);

//Выбор метода обращения ковариационной матрицы входного процесса (с ее предварительной
//регуляризацией по алгоритмам Лаврентьева, Тихонова, модифицированный Тихонова, Скачкова
//или без регуляризации (классический метод))
bool Edit_InvOperator(TCovMatrixInversion** pInvOp);

//Выбор детерминированного (ковариационная матрица Rsjn) или случайного (статистический
//вектор Usjn) входного процесса адаптивного фильтра
void Edit_InputProcess(enProcess& ProcessType, string& sProcessName);

//Редактирование параметров источников излучения (помех) с одной угловой координатой и
//изменяемой суммарной мощностью излучения.
void Edit_JamParams(TDoubleSet& Angle, TDoubleSet& Psum);

//Анализ входного процесса (сигнал + аддитивная помеха + внутренний шум):
//1. Собственные значения и собственные векторы матриц Ajn, Asjn, Rjn, Rsjn;
//2. Определители матриц Ajn, Asjn, Rjn, Rsjn (произведение всех собственных значений);
//3. Числа обусловленности матриц Ajn, Asjn, Rjn, Rsjn: Wmax/Wmin (Wmax, Wmin - максималь-
//   ное и минимальное собственное значение матрицы;
//4. След матриц Ajn, Asjn, Rjn, Rsjn (сумма диагональных элементов или сумма собственных
//   значений матрицы);
//5. Потенциальный коэффициент подавления: Ksup = det|R|/det|A|
bool CovMatrixAnalysis(const TUnEqLAA_ODA& LAA, const TJammers_2D& Jams, string& sInfo);

//Расчет матрицы линейных ограничений весового вектора W адаптивной системы по методу
//Лагранжа: B = I - C*Inv(trC*InvA*C)*trC*InvA, где:
//1) InvA - обратная матрица к ковариационной матрице входного процесса дополнит-х каналов
//   адаптивной системы (эрмитовая матрица) размерности N;
//2) C - комплексная матрица размерности (N*K), N - кол-во дополнительных каналов АС, K -
//   число ограничений (направлений исключения - направления режекции приема источников
//   излучения дополнительными каналами АС). Каждый столбец матрицы C задает значения фазо-
//   вых набегов между i-ым дополнительным и основным каналами АС (пространственного фильтра)
//   при действии источника излучения единичной мощности с k-го направления исключения.
//   Для LAA коэффициенты матрицы C вычисляются по формуле: C[i,k]=EXP(j*2PI*d[i]*sin(Qk)),
//   d[i] - относительное расстояние (в длинах волн) между i-м вспомогательным и основным
//   каналами; Qk - угловое положение k-го источника излучения (в радианах), исключаемого
//   при приеме дополнительными каналами АС (направление исключения);
//3) I - диагональная единичная матрица размерности N.
//Матрица B используется, как правило, для приема полезного сигнала без его подавления АС,
//когда положение источника излучения полезного сигнала известно.
bool LagrangeMethod(cmatrix& B, const cmatrix& InvA, const cmatrix& C);

//Запрос на ввод одного неотрицательного значения в вектор V с изменением его размерности
//до 1 в случае подтверждения запроса и вводом только одного значения (консольная функция)
bool InputSingleNonNegateValue(rvector& V, const char* name = NULL);

//Консольный ввод числа опытов для проведения статистического моделирования. Введенная
//пользователем величина сохраняется в переменной Test, передаваемой по ссылке.
ulong InputTests(ulong& Test);

//Консольный ввод неотрицательного вещественного значения с сохранением результата в rval
double InputNonNegateValue(double& rval, const char* name = NULL);

//Консольный ввод булевого значения с сохранением результата в bval [0-false, 1-true]
bool InputBooleanValue(bool& bval, const char* VarName = NULL, const char* TrueMsg = NULL,
                       const char* FalseMsg = NULL);

//Консольный ввод неотрицательного целого значения с сохранением результата в ival
ulong InputNonNegateValue(ulong& ival, const char* name = NULL);


#endif //Завершение объявления заголовочного файла - SF_CommonFunc.h
