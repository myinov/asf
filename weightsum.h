//weightsum.h - Объявление классов весовых сумматоров (WEIGHT SUMMATOR)
//Copyright (c) JohnSoft 2000. All rights reserved.
//Initial date: March,27,2000; Final date:
#if !defined(__WEIGHTSUM_H)
#define __WEIGHTSUM_H

#include "const.h"
//#pragma hdrstop

#include "matrix.h"
#include "arrays.h"
#include "PreProcessor.h"

//****************************************************************************************
//Предварительное объявление имен классов
//****************************************************************************************
//Абстрактный базовый класс весового сумматора типа (N x 1)
class TMultiInSingleOutWeightSummator;
class TMultiStageSteepestDescentAlgMISOWeightSum;
class TMultiStageSDA_ENCC_MISOWSum;
class TMultiStageSDA_DMPE_MISOWSum;
class TMultiStageSDA_DIPE_MISOWSum;
class TSingleStageSteepestDescentAlgMISOWeightSum;
class TSingleStage_SDA_LCC_MISOWSum;//LCC - Linear Constraint Circuit

//Абстрактный базовый класс весового сумматора типа (N x N)
class TMultiInMultiOutWeightSummator;
class TMultiStageSDA_MIMOWSum;
class TMultiStageSDA_ENCC_MIMOWSum;
class TMultiStageSDA_DMPE_MIMOWSum;
class TMultiStageSDA_DIPE_MIMOWSum;

class TDMultiStageSDA_MIMOWSum;
class TDMultiStageSDA_DMPE_MIMOWSum;
class TDMultiStageSDA_DIPE_MIMOWSum;
class TDMultiStageSDA_EITPE_MIMOWSum;

class TSingleStageSDA_MIMOWeightSum;//It hasn't implemented yet

//****************************************************************************************
//Переопределение имен классов
//****************************************************************************************
typedef TMultiInSingleOutWeightSummator TMISOWeightSum;
typedef TMultiStageSteepestDescentAlgMISOWeightSum TMultiStageSDAlgMISOWSum;
typedef TMultiStageSDA_ENCC_MISOWSum
        TMultiStageSDAlgENCCStabCircuitMISOWSum;
typedef TMultiStageSDA_DMPE_MISOWSum
        TMultiStageSDAlgDirectMomentaryPowerEstimationStabCircuitMISOWSum;
typedef TMultiStageSDA_DIPE_MISOWSum
        TMultiStageSDAlgDirectIteratePowerEstimationStabCircuitMISOWSum;
typedef TSingleStageSteepestDescentAlgMISOWeightSum TSingleStageSDAlgMISOWSum;

typedef TMultiInMultiOutWeightSummator TMIMOWeightSum;
//****************************************************************************************
//Константы
//****************************************************************************************
//const bool ON  = true;
//const bool OFF = false;
//Идентификаторы типов весовых сумматоров
const uint NONAME_WSum = 0;
//----------------------------------------------------------------------------------------
//Идентификаторы весовых сумматоров типа N x 1
const uint MS_SDM_MISO_WSum = 1; //TAMultiStageSDAlgMISOWSum
const uint MS_SDM_ENCC_MISO_WSum = 2;
const uint MS_SDM_DMPE_MISO_WSum = 3;
const uint MS_SDM_DIPE_MISO_WSum = 4;
const uint SS_SDM_MISO_WSum = 5; //TASingleStageSDAlgMISOWSum
const uint SS_SDA_LCC_MISO_WSum = 6;
//----------------------------------------------------------------------------------------
//Идентификаторы весовых сумматоров типа N x N
const uint MS_SDM_MIMO_WSum = 1;
const uint MS_SDM_ENCC_MIMO_WSum = 2;
const uint MS_SDM_DMPE_MIMO_WSum = 3;
const uint MS_SDM_DIPE_MIMO_WSum = 4;
const uint MS_DSDM_MIMO_WSum = 5;
const uint MS_DSDM_DMPE_MIMO_WSum = 6;
const uint MS_DSDM_DIPE_MIMO_WSum = 7;
const uint MS_DSDM_EITPE_MIMO_WSum = 8;

//****************************************************************************************
//      ОБЪЯВЛЕНИЕ КЛАССОВ ВЕСОВЫХ СУММАТОРОВ С N ВХОДАМИ И N ВЫХОДАМИ
//****************************************************************************************
//****************************************************************************************
// Объявление абстрактного класса TMultiInMultiOutWeightSummator
// Данный класс является исходным для создания классов ВЕСОВЫХ СУММАТОРОВ с N ВХОДАМИ и
//N ВЫХОДАМИ. На его основе проектируются классы, реализующие  статистические и аналитичес-
//кие модели весовых сумматоров с конфигурацией (N x N), где N - количество входов и выходов
//сумматора. Классификация весовых сумматоров с N входами и N выходами осуществляется по
//следующим признакам:
// 1. По схеме построения сумматора: ОДНОСТУПЕНЧАТЫЕ (SingleStage) и МНОГОСТУПЕНЧАТЫЕ
//    (MultiStage);
// 2. По алгоритму настройки весовых коэффициентов в процессе адаптации.
//    Допускаются различные алгоритмы настройки, например ГРАДИЕНТНЫЕ АЛГОРИТМЫ (Метод наи-
//    скорейшего спуска - Method of Steepest Descent; алгоритм Ньютона - Newton's algorithm,
//    ...) и т.д.;
// 3. По схемам (алгоритмам) стабилизации динамических параметров сумматоров (Stabilization
//    Circuit [Algorithm]). Данные схемы могут использоваться в весовых сумматорах с наст-
//    раиваемыми весовыми коэффициентами во время работы (адаптивный весовой сумматор).
// Каждый производный класс TMultiInMultiOutWeightSummator может отличаться от остальных
// производных классов всеми или одним из трех признаков.
// Следует отметить, что алгоритмы (схемы) стабилизации используются в классах, описывающих
// АДАПТИВНЫЕ весовые сумматоры (весовые коэффициенты таких сумматоров изменяются в процессе
// его работы при изменении внешних воздействий по заданному алгоритму). Допускается создание
// классов весовых сумматоров конфигурации N x N с заранее настроенными (фиксированными)
// весовыми коэффициентами. В этом случае, алгоритмы настройки весовых коэффициентов и ста-
// билизации динамических параметров сумматоров не используются и могут быть выведены только
// два класса НЕАДАПТИВНЫХ ВЕСОВЫХ СУММАТОРА - ОДНОСТУПЕНЧАТЫЙ и МНОГОСТУПЕНЧАТЫЙ с N вхо-
// дами и N выходами. В классах производных от данного базового класса в случае необходимости
// не все входы можно считать равнозначными.
//****************************************************************************************
class TMultiInMultiOutWeightSummator {
//----------------------------------------------------------------------------------------
// Объявление защищенных членов-данных класса TMultiInMultiOutWeightSummator
//----------------------------------------------------------------------------------------
protected:
 ulong N;//Размерность весового сумматора (N входов и N выходов)
//----------------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TMultiInMultiOutWeightSummator
//----------------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TMIMOWeightSum() {Reset();};
 //Конструктор с аргументами
 TMIMOWeightSum(ulong Size, const rvector& Param = rvector()) {Set(Size,Param);};
 //Объявление конструктора копирования
 TMIMOWeightSum(const TMIMOWeightSum &WSum) {*this = WSum;};
 //Объявление деструктора класса
 virtual ~TMultiInMultiOutWeightSummator() {Reset();};
//------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TMultiInMultiOutWeightSummator
//------------------------------------------------------------------------------
public:
 //Определение работоспособности сумматора
 bool IsReady() const {return (N > 1L) ? true : false;};
 ulong Inputs() const {return N;};//Количество входов весового сумматора
 ulong Outputs() const {return N;};//Количество выходов весового сумматора
 virtual ulong Stages() const = 0;
 virtual uint Type() const = 0;//Тип весового сумматора
 virtual rvector& Param(rvector& Arg) const = 0;//Параметры весового сумматора
 //-----------------------------------------------------------------------------
 //Установка параметров весового сумматора
 //-----------------------------------------------------------------------------
 //Дополнительные параметры передаются в векторе Param в зависимости от конкретного типа
 //весового сумматора
 virtual void Set(ulong Size, const rvector& Param) = 0;
 //Установка размерности весового сумматора
 virtual void SetInput(ulong Size) = 0;

 //Перегрузка оператора присваивания (=) для класса TMIMOWeightSum
 TMIMOWeightSum& operator =(const TMIMOWeightSum& WSum)
 {if (this != &WSum) {SetInput(WSum.Inputs());}
  return *this;
 };
 //Начальная установка параметров весового сумматора для моделирования
 virtual bool SimulateInit() = 0;
 //--------------------------------------------------------------------------------------
 //Передаточная функция весового сумматора (TRANSFER FUNCTION)
 //--------------------------------------------------------------------------------------
 virtual bool operator ()(cmatrix& R) const = 0;
 virtual bool operator ()(cvector& V) const = 0;

 bool operator ()(const cmatrix& InR, cmatrix& OutR) const
  {OutR = InR; return (*this)(OutR);};
 bool operator ()(const cvector& InV, cvector& OutV) const
  {OutV = InV; return (*this)(OutV);};

 virtual rvector& operator ()(rvector& P, cmatrix& R) const = 0;
 virtual rvector& operator ()(rvector& P, cvector& V) const = 0;

 virtual bool TF_WSum(cmatrix& R) const {return (*this)(R);};
 virtual bool TF_WSum(cvector& V) const {return (*this)(V);};

 virtual bool TF_WSum(const cmatrix& InR, cmatrix& OutR) const
  {return (*this)(InR, OutR);};
 virtual bool TF_WSum(const cvector& InV, cvector& OutV) const
  {return (*this)(InV, OutV);};
 virtual rvector& TF_WSum(rvector& P, cmatrix& R) const {return (*this)(P,R);};
 virtual rvector& TF_WSum(rvector& P, cvector& V) const {return (*this)(P,V);};
 virtual bool TestFunc(cvector& V, rvector& P) const = 0;

 virtual rmatrix& Powers(rmatrix& P, cmatrix& R) const = 0;
 virtual rmatrix& Powers(rmatrix& P, cvector& V) const = 0;
 //---------------------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //---------------------------------------------------------------------------------------
 virtual bool Tuning(cmatrix& R) = 0;
 virtual bool Tuning(cvector& V) = 0;
 //-----------------------------------------------------------------------------
 //Настройка коэффициентов нормирования сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 virtual bool TuneNorm(const cmatrix& R) = 0;
 virtual bool TuneNorm(const cvector& V) = 0;
 //-----------------------------------------------------------------------------
 //Получение коэффициентов весового сумматора
 //-----------------------------------------------------------------------------
 virtual cmatrix& GetW(cmatrix& Weight) const = 0;
 virtual cvector& GetW(cvector& Weight, ulong Stage = 0L) const = 0;

 //-----------------------------------------------------------------------------
 //Расчет оптимальных весовых коэффициентов сумматора для заданного воздействия
 //-----------------------------------------------------------------------------
 virtual cmatrix& GetOptW(cmatrix& OptW, const cmatrix& R) const = 0;

 //-----------------------------------------------------------------------------
 //Установка коэффициентов весового сумматора
 //-----------------------------------------------------------------------------
 virtual bool SetW(const cmatrix& Weight) = 0;

 //-----------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса
 //-----------------------------------------------------------------------------
 virtual string& Type(string& s) const = 0;//Тип весового сумматора
 //Сокращенное наименование класса
 virtual string& Clip(string& s) const {return s = "MIMOWeightSummator";};
 //Формирование конфигурации весового сумматора в виде символьной строки вида:
 //<CONFIGURATION: Dimension = <value> x <value>, Stages = <value>;\n>
 virtual string& GetConfig(string& s) const
 {char buffer[80]; ostrstream text (buffer, sizeof(buffer));
  s = "Configuration: ";
  text << "Dimension = " << Inputs() << " x " << Outputs() << ", Stages = "
       << Stages() << endl << ends;
  s.append(text.str()); text.seekp(0);
  return s;
 };
 //Формирование адаптивного алгоритма сумматора в виде символьной строки вида:
 //<Algorithm: "name_string", [algoritnm params];\n>
 virtual string& GetAdaptAlg(string& s) const = 0;
 //Формирование алгоритма стабилизации сумматора в виде символьной строки вида:
 //<Stabilizing Circuit: "name_string", [stabcircuit params];\n>
 virtual string& GetStabCircuit(string& s) const = 0;
 //Формирование свойств весового сумматора в виде символьной строки
 virtual string& Properties(string& s, string& head, uint indent = 0)
  const = 0;

 //Консольный ввод размерности весового сумматора с проверкой введенного параметра и
 //подтверждением введенного значения
 virtual void InputEdit(string& head, uint indent = 0);
 //Консольный ввод параметров весового сумматора
 virtual void Edit(bool ExtParam = true) = 0;

 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator <<(ostream& out, const TMIMOWeightSum& WSum)
 {string s, head; return out << WSum.Properties(s,head);};
//------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TMultiInMultiOutWeightSummator
//------------------------------------------------------------------------------
protected:
 //Начальная установка параметров весового сумматора
 void Reset() {N = 0L;};
};//Завершение объявления класса TMIMOWeightSum
//--------- Завершение объявления класса TMultiInMultiOutWeightSummator --------

//****************************************************************************************
//          Объявление класса TMultiStageSDA_MIMOWSum
// Класс является производным от базового класса TMIMOWSum. Он представляет АНАЛИТИЧЕСКУЮ
// и СТАТИСТИЧЕСКУЮ  модели МНОГОСТУПЕНЧАТОГО весового сумматора с N-ВХОДАМИ и N-ВЫХОДАМИ
// с АДАПТИВНЫМ алгоритмом настройки  весовых коэффициентов по МЕТОДУ НАИСКОРЕЙШЕГО СПУСКА
// (градиентный алгоритм), БЕЗ схемы стабилизации динамических параметров адаптивного сум-
// матора. Данный весовой сумматор характеризуется следующими свойствами:
// 1. Конфигурация: N-входов - N-выходов;
// 2. Cхема построения сумматора: МНОГОСТУПЕНЧАТАЯ (MultiStage);
// 3. Алгоритм настройки: МЕТОД НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм);
// 4. Алгоритм стабилизации динамических параметров: ОТСУТСТВУЕТ.
// Класс имеет два ВНУТРЕННИХ ПАРАМЕТРА:
// 1) Tsbp - шаг адаптации, который зависит от уровня внешнего сигнала на входе сумматора;
// 2) Gsbp - коэффициент усиления в цепи обратной связи.
// Количество ступеней сумматора определяется по формуле: StageCount = 2*(N-1).
// Индексы выходов сумматора соответствуют индексам входов. Весовые коэффициенты
// сумматора хранятся в квадратной  матрице W размерности N. Диагональные элемен-
// ты матрицы  всегда  равны  единице. В нижних столбцовых элементарных матрицах
// компактно  хранящихся в матрице W содержатся весовые коэффициенты каждой сту-
// пени  первого  сумматора. В  правых  строковых элементарных матрицах хранятся
// комплексно-сопряженные значения весовых коэффициентов каждой ступени  второго
// сумматора. Каждая  ступень  двух сумматоров представляет из себя совокупность
// элементарных весовых сумматоров на два входа и один выход. Между двумя парал-
// лельно-последовательными  сумматорами расположен НОРМИРОВАТЕЛЬ. Нормирователь
// осуществляет операцию деления  каждого выхода  первого  сумматора на значение
// выходной мощности, соответствующего выхода. Данная операция является эквива-
// лентной  умножению обратной  диагональной матрицы InvD, полученной из матрицы
// R', на матрицу R'. Матрица R' = W*R, получается в ходе преобразования входной
// корреляционной матрицы R, первым  сумматором. Под матрицей W следует понимать
// совокупность  нижних  столбцовых  элементарных  матриц Lkc, которые описывают
// структуру и работу многоступенчатого сумматора.
// Минимальное количество входов I и II сумматора равно 2.
// ПЕРВЫЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов  последовательно уменьшается на единицу для каждой последующей ступени.
// Крайний левый выход предыдущей ступени сумматора подключается к каждому  эле-
// ментарному  сумматору следующей ступени сумматора, к второму входу элементар-
// ного сумматора подключается соответствующий вход многоступенчатого сумматора.
// Данный сумматор является АДАПТИВНЫМ, в нем происходит настройка весовых коэф-
// фициентов  по градиентному  алгоритиу в зависимости от входного воздействия и
// параметров  алгоритма  настройки. Вычисленные  комплексно-сопряженные весовые
// коэффициенты  передаются второму сумматору. Весовые коэффициенты первого сум-
// матора  хранятся  в матрице  W и  соответствуют нижней треугольной подматрице
// матрицы W по расположению.
// ВТОРОЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов последовательно увеличивается на единицу для каждой последующей ступени.
// На первой ступени сумматора размещается один модуль, на последней - N-1. Каж-
// дый элементарный  сумматор  (модуль) имеет  два входа и один выход. Один вход
// соответствует  выходам  первого  сумматора, другой вход для всех модулей i-ой
// ступени второго сумматора определяется по формуле - (i+1). Для первой ступени
// (с  одним  модулем) таким  входом будет 2 выход первого сумматора, для второй
// ступени - выход 3, для N-1 (последняя ступень) - выход N. Весовые коэффициен-
// ты в комплексно-сопряженном виде передаются ВТОРОМУ сумматору с ПЕРВОГО, хра-
// нятся в матрице W и соответствуют верхней треугольной подматрице матрицы W.
//
// Исходному состоянию сумматора соответствует ЕДИНИЧНАЯ матрица весовых коэффи-
// циентов W. В этом случае входной сигнал проходит через сумматор без изменений.
// Для аналитической модели многоступенчатого сумматора в качестве входного воз-
// действия  рассматривается  корреляционная матрица входного сигнала или вектор
// входного  сигнала. Настройка весовых коэффициентов (адаптация) сумматора осу-
// ществляется только по корреляционной матрице входного сигнала. Структура мат-
// рицы весовых коэффициентов и корреляционной матрицы входного  воздействия для
// многоступенчатого  весового сумматора на 5 входов (InCount = 5) выглядит сле-
// дующим образом:
// U = [U0 U1 U2 U3 U4] - вектор входного сигнала
//     | R00 R01 R02 R03 R04 |
//     | R10 R11 R12 R13 R14 |
// R = | R20 R21 R22 R23 R24 |, Rij = Ui*conj(Uj), Rji = conj(Rij).
//     | R30 R31 R32 R33 R34 |
//     | R40 R41 R42 R43 R44 |
// R - корреляционная матрица входного сигнала (воздействия)
//     |  1  W01 W02 W03 W04 |
//     | W10  1  W12 W13 W14 |
// W = | W20 W21  1  W23 W24 |, Wji = conj(Wij)
//     | W30 W31 W32  1  W34 |
//     | W40 W41 W42 W43  1  |
//В соответствии с МЕТОДОМ НАИСКОРЕЙШЕГО СПУСКА каждый весовой коэффициент вычи-
//сляется по формуле:
// Wij(n+1) = Wij(n) - (1/Tsbp)*[Wij(n)*(1+Gsbp*Rjj) + Gsbp*Rij], i > j
//******************************************************************************
class TMultiStageSDA_MIMOWSum : public TMIMOWeightSum {
//------------------------------------------------------------------------------
//Объявление защищенных членов-данных класса TMultiStageSDA_MIMOWSum
//------------------------------------------------------------------------------
protected:
 double Tsbp;//Шаг адаптации алгоритма настройки весовых коэффициентов
 double Gsbp;//Коэффициент усиления в цепи обратной связи
 cmatrix W;//Весовые коэффициенты многоступенчатого сумматора
//------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TMultiStageSDA_MIMOWSum
//------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TMultiStageSDA_MIMOWSum() : TMIMOWeightSum() {Reset();};
 //Конструктор с аргументами
 TMultiStageSDA_MIMOWSum(ulong Size, const rvector& Param = rvector())
 {Reset(); Set(Size,Param);};
 TMultiStageSDA_MIMOWSum(ulong Size, double T, double G)
 {Reset(); Set(Size,T,G);};
 //Объявление конструктора копирования
 TMultiStageSDA_MIMOWSum(const TMultiStageSDA_MIMOWSum &WSum) {*this = WSum;};
 //Объявление деструктора класса
 virtual ~TMultiStageSDA_MIMOWSum() {Reset();};
//------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TMultiStageSDA_MIMOWSum
//------------------------------------------------------------------------------
public:
 virtual uint Type() const {return MS_SDM_MIMO_WSum;};//Тип весового сумматора
 //Параметры весового сумматора
 virtual rvector& Param(rvector& Arg) const
 {if (IsReady()) {Arg.Set(2,ROW,false); Arg.Put(0,Tsbp); Arg.Put(1,Gsbp);}
  else Arg.Set(0,ROW,false);
  return Arg;
 };
 ulong Stages() const {return 2*(N-1);};//Количество ступеней сумматора
 double GetTsbp() const {return Tsbp;}; //Значение шага адаптации
 double GetGsbp() const {return Gsbp;}; //Коэффициент усиления
 //*****************************************************************************
 //Установка параметров весового сумматора
 //*****************************************************************************
 //Дополнительные параметры передаются в векторе Param.
 //Param[0] - значение шага адаптации T (T != 0)
 //Param[1] - значение коэффициента усиления G (произвольное значение)
 virtual void Set(ulong Size, const rvector& Param)
 {SetInput(Size);//Установка размерности сумматора по входу
  double T = (Param.Size() > 0L) ? Param.Get(0) : 1.0e6;
  SetTsbp(T);//Установка шага адаптации
  double G = (Param.Size() > 1L) ? Param.Get(1) : 1.0;
  SetGsbp(G);//Установка коэффициента усиления
 };
 void Set(ulong Size, double T, double G)
 {SetInput(Size); SetTsbp(T); SetGsbp(G);};
 //Установка шага адаптации (постоянная времени автокомпенсатора)
 void SetTsbp(double T) {Tsbp = (T > 0) ? T : 1.0e6;};
 //Установка коэффициента усиления (крутизна регулировочной характеристики)
 void SetGsbp(double G) {Gsbp = G;};
 //Установка числа входов (размерности по входу) весового сумматора
 virtual void SetInput(ulong Size);
 //Перегрузка оператора присваивания (=) для класса
 TMultiStageSDA_MIMOWSum& operator =(const TMultiStageSDA_MIMOWSum& WSum)
 {if (this != &WSum) {Set(WSum.Inputs(),WSum.GetTsbp(),WSum.GetGsbp());}
  return *this;
 };
 //Начальная установка параметров весового сумматора для моделирования
 virtual bool SimulateInit();
 //-----------------------------------------------------------------------------
 //Передаточная функция весового сумматора (TRANSFER FUNCTION)
 //-----------------------------------------------------------------------------
 bool operator ()(cmatrix& R) const;
 bool operator ()(cvector& V) const;
 rvector& operator ()(rvector& P, cmatrix& R) const;
 rvector& operator ()(rvector& P, cvector& V) const;
 bool TestFunc(cvector& V, rvector& P) const;
 //Мощности на входах/выходах I и II сумматоров
 rmatrix& Powers(rmatrix& P, cmatrix& R) const;
 rmatrix& Powers(rmatrix& P, cvector& V) const;

 //-----------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 virtual bool Tuning(cmatrix& R);
 virtual bool Tuning(cvector& V);

 //-----------------------------------------------------------------------------
 //Расчет оптимальных весовых коэффициентов сумматора для заданного воздействия
 //-----------------------------------------------------------------------------
 virtual cmatrix& GetOptW(cmatrix& OptW, const cmatrix& R) const;

 //-----------------------------------------------------------------------------
 //Настройка коэффициентов нормирования сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 virtual bool TuneNorm(const cmatrix& R);
 virtual bool TuneNorm(const cvector& V);

 //-----------------------------------------------------------------------------
 //Получение коэффициентов весового сумматора
 //-----------------------------------------------------------------------------
 cmatrix& GetW(cmatrix& Weight) const {Weight = W; return Weight;};
 cvector& GetW(cvector& Weight, ulong Stage = 0L) const;
 //-----------------------------------------------------------------------------
 //Установка коэффициентов весового сумматора
 //-----------------------------------------------------------------------------
 bool SetW(const cmatrix& Weight);
 //-----------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса
 //-----------------------------------------------------------------------------
 virtual string& Type(string& s) const //Тип весового сумматора
 {s = "MultiInMultiOut MultiStage Adaptive WeightSummator"; return s;};
  //Сокращенное наименование класса
 virtual string& Clip(string& s) const
 {return s = "MultiStageSDA_MIMOWeightSum";};
 //Формирование адаптивного алгоритма сумматора в виде символьной строки вида:
 //<Algorithm: <Steepest Descent Method>, Tadapt = <value>;\n>
 virtual string& GetAdaptAlg(string& s) const
 {char buffer[80]; ostrstream text (buffer, sizeof(buffer));
  s = "Algorithm: <Steepest Descent Method>, ";
  text << "Tsbp = " << GetTsbp() << ends;
  s.append(text.str()); text.seekp(0);
  text << ", Gsbp = " << GetGsbp() << endl << ends;
  s.append(text.str()); text.seekp(0);
  return s;
 };
 //Формирование алгоритма стабилизации сумматора в виде символьной строки вида:
 //<Stabilizing Circuit: "name_string", [stabcircuit params];\n>
 virtual string& GetStabCircuit(string& s) const
 {s = "Stabilizing Circuit: < Off >\n"; return s;};

 //Формирование свойств весового сумматора в виде символьной строки
 virtual string& Properties(string& s, string& head, uint indent = 0) const;

 //Консольный ввод шага адаптации с проверкой введенного параметра и подтвержде-
 //нием введенного значения
 void TsbpEdit(string& head, uint indent = 0);
 //Консольный ввод коэффициента усиления G и подтверждение введенного значения
 void GsbpEdit(string& head, uint indent = 0);
 //Консольное редактирование параметров весового сумматора
 virtual void Edit(bool ExtParam = true);
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator << (ostream& out, const TMultiStageSDA_MIMOWSum& WSum)
        {string s, head; return out << WSum.Properties(s,head);};
//------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TMultiStageSDA_MIMOWSum
//------------------------------------------------------------------------------
protected:
 //Начальная установка параметров весового сумматора
 void Reset() {N = 0L; Tsbp = 0.0; Gsbp = 0.0; W = cmatrix();};
 //Передаточная функция весового сумматора
 void TransferFunction(cmatrix& R) const;
 void TransferFunction(cvector& V) const;
 void CalcAllPowers(rmatrix& P, cmatrix& R) const;
 void CalcAllPowers(rmatrix& P, cvector& V) const;

};//Завершение объявления класса TMultiStageSDA_MIMOWSum
//--------- Завершение объявления класса TMultiStageSDA_MIMOWeightSum ---------

//******************************************************************************
//               Объявление класса TMultiStageSDA_DMPE_MIMOWSum
// Класс является производным от класса TMultiStageSDA_MIMOWSum. Он реализует
// АНАЛИТИЧЕСКУЮ и СТАТИСТИЧЕСКУЮ  модели МНОГОСТУПЕНЧАТОГО весового сумматора с
// N-ВХОДАМИ и N-ВЫХОДАМИ с АДАПТИВНЫМ алгоритмом настройки весовых коэффициентов
// по МЕТОДУ  НАИСКОРЕЙШЕГО  СПУСКА (градиентный алгоритм) и схемой стабилизации
// динамических параметров адаптивного сумматора. Данный весовой сумматор харак-
// теризуется следующими свойствами:
// 1. Конфигурация: N-входов - N-выходов;
// 2. Cхема построения сумматора: МНОГОСТУПЕНЧАТАЯ (MultiStage);
// 3. Алгоритм настройки: МЕТОД НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм);
// 4. Алгоритм стабилизации динамических параметров: ПРЯМАЯ МГНОВЕННАЯ ОЦЕНКА
//    МОЩНОСТИ (Direct Momentary Power Estimation)
// Класс имеет четыре ВНУТРЕННИХ ПАРАМЕТРА:
// 1) Tsbp - шаг адаптации, который зависит от уровня внешнего сигнала на входе
//    сумматора;
// 2) Gsbp - коэффициент усиления в цепи обратной связи;
// 3) Gsc - крутизна регулировочной характеристики элемента нормирования.
// 4) Tnorm - постоянная времени НОРМИРОВАТЕЛЯ
// Количество ступеней сумматора определяется по формуле: Stages = 2*(N-1).
// Индексы выходов сумматора соответствуют индексам входов. Весовые коэффициенты
// сумматора хранятся в квадратной  матрице W размерности N. Диагональные элемен-
// ты матрицы  всегда  равны  единице. В нижних столбцовых элементарных матрицах
// компактно  хранящихся в матрице W содержатся весовые коэффициенты каждой сту-
// пени  первого  сумматора. В  правых  строковых элементарных матрицах хранятся
// комплексно-сопряженные значения весовых коэффициентов каждой ступени  второго
// сумматора. Каждая  ступень  двух сумматоров представляет из себя совокупность
// элементарных весовых сумматоров на два входа и один выход. Между двумя парал-
// лельно-последовательными  сумматорами расположен НОРМИРОВАТЕЛЬ. Нормирователь
// осуществляет операцию деления  каждого выхода  первого  сумматора на значение
// выходной мощности, соответствующего выхода. Данная операция является эквива-
// лентной  умножению обратной  диагональной матрицы InvD, полученной из матрицы
// R', на матрицу R'. Матрица R' = W*R, получается в ходе преобразования входной
// корреляционной матрицы R, первым  сумматором. Под матрицей W следует понимать
// совокупность  нижних  столбцовых  элементарных  матриц Lkc, которые описывают
// структуру и работу многоступенчатого сумматора.
// Минимальное количество входов I и II сумматора равно 2.
// ПЕРВЫЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов  последовательно уменьшается на единицу для каждой последующей ступени.
// Крайний левый выход предыдущей ступени сумматора подключается к каждому  эле-
// ментарному  сумматору следующей ступени сумматора, к второму входу элементар-
// ного сумматора подключается соответствующий вход многоступенчатого сумматора.
// Данный сумматор является АДАПТИВНЫМ, в нем происходит настройка весовых коэф-
// фициентов  по градиентному  алгоритиу в зависимости от входного воздействия и
// параметров  алгоритма  настройки. Вычисленные  комплексно-сопряженные весовые
// коэффициенты  передаются второму сумматору. Весовые коэффициенты первого сум-
// матора  хранятся  в матрице  W и  соответствуют нижней треугольной подматрице
// матрицы W по расположению.
// ВТОРОЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов последовательно увеличивается на единицу для каждой последующей ступени.
// На первой ступени сумматора размещается один модуль, на последней - N-1. Каж-
// дый элементарный  сумматор  (модуль) имеет  два входа и один выход. Один вход
// соответствует  выходам  первого  сумматора, другой вход для всех модулей i-ой
// ступени второго сумматора определяется по формуле - (i+1). Для первой ступени
// (с  одним  модулем) таким  входом будет 2 выход первого сумматора, для второй
// ступени - выход 3, для N-1 (последняя ступень) - выход N. Весовые коэффициен-
// ты в комплексно-сопряженном виде передаются ВТОРОМУ сумматору с ПЕРВОГО, хра-
// нятся в матрице W и соответствуют верхней треугольной подматрице матрицы W.
// Исходному состоянию сумматора соответствует ЕДИНИЧНАЯ матрица весовых коэффи-
// циентов W. В этом случае входной сигнал проходит через сумматор без изменений.
// Для аналитической модели многоступенчатого сумматора в качестве входного воз-
// действия  рассматривается  корреляционная матрица входного сигнала или вектор
// входного  сигнала. Настройка весовых коэффициентов (адаптация) сумматора осу-
// ществляется только по корреляционной матрице входного сигнала. Структура мат-
// рицы весовых коэффициентов и корреляционной матрицы входного  воздействия для
// многоступенчатого  весового сумматора на 5 входов (InCount = 5) выглядит сле-
// дующим образом:
// U = [U0 U1 U2 U3 U4] - вектор входного сигнала
//     | R00 R01 R02 R03 R04 |
//     | R10 R11 R12 R13 R14 |
// R = | R20 R21 R22 R23 R24 |, Rij = Ui*conj(Uj), Rji = conj(Rij).
//     | R30 R31 R32 R33 R34 |
//     | R40 R41 R42 R43 R44 |
// R - корреляционная матрица входного сигнала (воздействия)
//     |  1  W01 W02 W03 W04 |
//     | W10  1  W12 W13 W14 |
// W = | W20 W21  1  W23 W24 |, Wji = conj(Wij)
//     | W30 W31 W32  1  W34 |
//     | W40 W41 W42 W43  1  |
//Каждая  ступень I-го многоступенчатого весового сумматора имеет элемент норми-
//рования с прямой мгновенной оценкой мощности. Модель функционирования элемента
//нормирования для i-ой ступени описывается формулой:
//1) для АНАЛИТИЧЕСКОЙ модели: Ki[n] = 1/[1+Gsc*Rii];
//2) для СТАТИСТИЧЕСКОЙ модели: Ki[n] = 1/[1+Gsc*norm(Ui)];
// Rii = norm(Ui)- оценка мощности входного процесса для i-ой ступени.
//В соответствии с МЕТОДОМ НАИСКОРЕЙШЕГО СПУСКА и с учетом схемы стабилизации с
//прямой мгновенной оценкой мощности каждый весовой коэффициент вычисляется по
// формуле:
//1) для АНАЛИТИЧЕСКОЙ модели:
//   Wij(n+1) = Wij(n) - (1/Tsbp)*[Wij(n)*(1+Ki*Gsbp*Rjj) + Ki*Gsbp*Rij], i > j
//2) для СТАТИСТИЧЕСКОЙ модели:
//   Wij(n+1) = Wij(n) - (1/Tsbp)*[Wij(n) + Ki*Gsbp*conj(SumUij)*Ui], i > j
//SumUij - выходное напряжение с элементарного весового сумматора, расположенного
//на i-ой ступени для j-го входа;
//Ui - задающее напряжение для i-ой ступени весового сумматора.
//Модель функционирования элементов НОРМИРОВАТЕЛЯ для i-го канала фильтра:
// Ki[n+1] = 1/Pi[n+1],
//1) для ЧИСЛЕННОЙ модели: Pi[n+1] = Pi[n] - (1/Tnorm)*[Pi[n]-real(Rii)];
//2) для СТАТИСТИЧЕСКОЙ модели: Pi[n+1] = Pi[n] - (1/Tnorm)*[Pi[n]-norm(Ui)];
// Pi - оценка мощности входного процесса.
//Начальное значение всех Pi=0, соответственно начальное значение всех Ki=1.
//Коэффициенты Ki нормирователя хранятся на главной диагонали матрицы W.
//****************************************************************************************
class TMultiStageSDA_DMPE_MIMOWSum : public TMultiStageSDA_MIMOWSum {
//------------------------------------------------------------------------------
//Объявление защищенных членов-данных класса TMultiStageSDA_DMPE_MIMOWSum
//------------------------------------------------------------------------------
protected:
 double Gsc;//Крутизна регулировочной характеристики элемента нормирования
 //Постоянная времени интегрирующего фильтра в цепи управления НОРМИРОВАТЕЛЯ
 double Tnorm;
 rvector Power;//Оценки мощности входного процесса для каждой ступени сумматора

//------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TMultiStageSDA_DMPE_MIMOWSum
//------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TMultiStageSDA_DMPE_MIMOWSum() : TMultiStageSDA_MIMOWSum() {};
 //Конструктор с аргументами
 TMultiStageSDA_DMPE_MIMOWSum(ulong Size, const rvector& Arg = rvector())
 {Reset(); Set(Size,Arg);};
 TMultiStageSDA_DMPE_MIMOWSum(ulong Size, double SBP_T, double SBP_G,
  double SC_G, double NORM_T) {Reset(); Set(Size,SBP_T,SBP_G,SC_G,NORM_T);};
 //Объявление конструктора копирования
 TMultiStageSDA_DMPE_MIMOWSum(const TMultiStageSDA_DMPE_MIMOWSum &WSum)
 {*this = WSum;};
 //Объявление деструктора класса
 ~TMultiStageSDA_DMPE_MIMOWSum() {Reset();};
//------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TMultiStageSDA_DMPE_MIMOWSum
//------------------------------------------------------------------------------
public:
 uint Type() const {return MS_SDM_DMPE_MIMO_WSum;};//Тип весового сумматора
 //Параметры весового сумматора
 rvector& Param(rvector& Arg) const
 {if (IsReady())
  {Arg.Set(4,ROW,false); Arg.Put(0,Tsbp); Arg.Put(1,Gsbp);
   Arg.Put(2,Gsc); Arg.Put(3,Tnorm);
  }
  else Arg.Set(0,ROW,false);
  return Arg;
 }
 double GetGsc() const {return Gsc;};//Коэффициент усиления элемента нормирования
 double GetTnorm() const {return Tnorm;};//Постоянная времени НОРМИРОВАТЕЛЯ
 //*****************************************************************************
 //Установка параметров весового сумматора TMultiStageSDA_DMPE_MIMOWSum
 //*****************************************************************************
 //Дополнительные параметры передаются в векторе Arg.
 //Arg[0] - Постоянная времени модуля весового сумматора Tsbp (Tsbp > 0)
 //Arg[1] - Коэффициент усиления модуля весового сумматора Gsbp (произвольное)
 //Arg[2] - Коэффициент усиления элемента нормирования Gsc (Gsc произвольное)
 //Arg[3] - Постоянная времени НОРМИРОВАТЕЛЯ (Tnorm > 0)
 void Set(ulong Size, const rvector& Arg)
 {SetInput(Size);//Установка размерности сумматора по входу
  //Установка постоянной времени модуля весового сумматора
  double value = (Arg.Size() > 0L) ? Arg.Get(0) : 100.0; SetTsbp(value);
  //Установка коэффициента усиления модуля весового сумматора
  value = (Arg.Size() > 1L) ? Arg.Get(1) : 10.0; SetGsbp(value);
  //Установка коэффициента усиления элемента нормирования
  value = (Arg.Size() > 2L) ? Arg.Get(2) : 1.0; SetGsc(value);
  //Установка постоянной времени НОРМИРОВАТЕЛЯ
  value = (Arg.Size() > 3L) ? Arg.Get(3) : 10.0; SetTnorm(value);
 };
 void Set(ulong Size, double SBP_T, double SBP_G, double SC_G, double NORM_T)
 {SetInput(Size); SetTsbp(SBP_T); SetGsbp(SBP_G); SetGsc(SC_G); SetTnorm(NORM_T);};

 //Установка числа входов (размерности по входу) весового сумматора
 void SetInput(ulong Size)
 {TMultiStageSDA_MIMOWSum::SetInput(Size); Power.Set(Inputs(),ROW,0.0);};

 //Установка коэффициента усиления элемента нормирования
 void SetGsc(double SC_G) {Gsc = SC_G;};
 //Установка постоянной времени НОРМИРОВАТЕЛЯ
 void SetTnorm(double NORM_T) {Tnorm = (NORM_T > 0) ? NORM_T : 10.0;};

 //Перегрузка оператора присваивания (=) для класса
 TMultiStageSDA_DMPE_MIMOWSum& operator =
 (const TMultiStageSDA_DMPE_MIMOWSum& WSum)
 {if (this != &WSum)
  {Set(WSum.Inputs(),WSum.GetTsbp(),WSum.GetGsbp(),WSum.GetGsc(),WSum.GetTnorm());}
  return *this;
 };
 //Начальная установка параметров весового сумматора для моделирования
 bool SimulateInit();
 //-----------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool Tuning(cmatrix& R);
 bool Tuning(cvector& V);
 //-----------------------------------------------------------------------------
 //Настройка коэффициентов нормирования сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool TuneNorm(const cmatrix& R);
 bool TuneNorm(const cvector& V);
 //-----------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса TMultiStageSDA_DMPE_MIMOWSum
 //-----------------------------------------------------------------------------
 string& Type(string& s) const //Тип весового сумматора
 {s = "MultiStageSDA_DirectMomentaryPowerEstimation_MIMOWeightSummator"; return s;};
  //Сокращенное наименование класса
 string& Clip(string& s) const {return s = "MultiStageSDA_DMPE_MIMOWSum";};
 //Формирование алгоритма стабилизации сумматора в виде символьной строки вида:
 //<Stabilizing Circuit: "name_string", [stabcircuit params];\n>
 string& GetStabCircuit(string& s) const
 {char buffer[80]; ostrstream text (buffer, sizeof(buffer));
  s = "Stabilizing Circuit: <Direct Momentary Power Estimation> [";
  text << "Gsc=" << GetGsc() << ", Tnorm=" << GetTnorm()<< "];" << endl << ends;
  s.append(text.str()); text.seekp(0);
  return s;
 };
 //Консольный ввод Gsc с проверкой введенного параметра и подтверждением ввода
 void GscEdit(string& head, uint indent = 0);
 //Консольный ввод Tnorm с проверкой введенного параметра и подтверждением ввода
 void TnormEdit(string& head, uint indent = 0);
 //Консольное редактирование параметров весового сумматора
 void Edit(bool ExtParam = true);
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator << (ostream& out, const TMultiStageSDA_DMPE_MIMOWSum& WSum)
 {string s,head; return out << WSum.Properties(s,head);};
//------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TMultiStageSDA_DMPE_MIMOWSum
//------------------------------------------------------------------------------
protected:
 //Начальная установка параметров весового сумматора
 void Init() {Gsc = 1.0; Tnorm = 10.0; Power = rvector();};
 //Сброс всех параметров весового сумматора
 void Reset()
 {N = 0L; Tsbp = 0.0; Gsbp = 0.0; Gsc = 0.0; Tnorm = 0.0;
  W = cmatrix(); Power = rvector();};

};//Завершение объявления класса TMultiStageSDA_DMPE_MIMOWSum
//--------- Завершение объявления класса TMultiStageSDA_DMPE_MIMOWSum ---------

//******************************************************************************
//            Объявление класса TMultiStageSDA_DIPE_MIMOWSum
// Класс является производным от класса TMultiStageSDA_MIMOWSum. Он представляет
// АНАЛИТИЧЕСКУЮ и СТАТИСТИЧЕСКУЮ  модели МНОГОСТУПЕНЧАТОГО весового сумматора с
// N-ВХОДАМИ и N-ВЫХОДАМИ с АДАПТИВНЫМ алгоритмом настройки весовых коэффициентов
// по  МЕТОДУ НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм), с схемой стабилизации
// динамических параметров адаптивного сумматора. Данный весовой сумматор харак-
// теризуется следующими свойствами:
// 1. Конфигурация: N-входов - N-выходов;
// 2. Cхема построения сумматора: МНОГОСТУПЕНЧАТАЯ (MultiStage);
// 3. Алгоритм настройки: МЕТОД НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм);
// 4. Алгоритм стабилизации динамических параметров: ПРЯМАЯ ИТЕРАЦИОННАЯ ОЦЕНКА
//    МОЩНОСТИ (Direct Iterative Power Estimation).
// Класс имеет три ВНУТРЕННИХ ПАРАМЕТРА:
// 1) Tsbp - постоянная времени интегрирующего фильтра элементарного модуля;
// 2) Gsbp - коэффициент усиления в цепи обратной связи элементарного модуля;
// 3) Tsc - постоянная времени в цепи управления элемента нормирования;
// Количество ступеней сумматора определяется по формуле: Stages = 2*(N-1).
// Индексы выходов сумматора соответствуют индексам входов. Весовые коэффициенты
// сумматора хранятся в квадратной  матрице W размерности N. Диагональные элемен-
// ты матрицы  всегда  равны  единице. В нижних столбцовых элементарных матрицах
// компактно  хранящихся в матрице W содержатся весовые коэффициенты каждой сту-
// пени  первого  сумматора. В  правых  строковых элементарных матрицах хранятся
// комплексно-сопряженные значения весовых коэффициентов каждой ступени  второго
// сумматора. Каждая  ступень  двух сумматоров представляет из себя совокупность
// элементарных весовых сумматоров на два входа и один выход. Между двумя парал-
// лельно-последовательными  сумматорами расположен НОРМИРОВАТЕЛЬ. Нормирователь
// осуществляет операцию деления  каждого выхода  первого  сумматора на значение
// выходной мощности, соответствующего выхода. Данная операция является эквива-
// лентной  умножению обратной  диагональной матрицы InvD, полученной из матрицы
// R', на матрицу R'. Матрица R' = W*R, получается в ходе преобразования входной
// корреляционной матрицы R, первым  сумматором. Под матрицей W следует понимать
// совокупность  нижних  столбцовых  элементарных  матриц Lkc, которые описывают
// структуру и работу многоступенчатого сумматора.
// Минимальное количество входов I и II сумматора равно 2.
// ПЕРВЫЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов  последовательно уменьшается на единицу для каждой последующей ступени.
// Крайний левый выход предыдущей ступени сумматора подключается к каждому  эле-
// ментарному  сумматору следующей ступени сумматора, к второму входу элементар-
// ного сумматора подключается соответствующий вход многоступенчатого сумматора.
// Данный сумматор является АДАПТИВНЫМ, в нем происходит настройка весовых коэф-
// фициентов  по градиентному  алгоритиу в зависимости от входного воздействия и
// параметров  алгоритма  настройки. Вычисленные  комплексно-сопряженные весовые
// коэффициенты  передаются второму сумматору. Весовые коэффициенты первого сум-
// матора  хранятся  в матрице  W и  соответствуют нижней треугольной подматрице
// матрицы W по расположению.
// ВТОРОЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов последовательно увеличивается на единицу для каждой последующей ступени.
// На первой ступени сумматора размещается один модуль, на последней - N-1. Каж-
// дый элементарный  сумматор  (модуль) имеет  два входа и один выход. Один вход
// соответствует  выходам  первого  сумматора, другой вход для всех модулей i-ой
// ступени второго сумматора определяется по формуле - (i+1). Для первой ступени
// (с  одним  модулем) таким  входом будет 2 выход первого сумматора, для второй
// ступени - выход 3, для N-1 (последняя ступень) - выход N. Весовые коэффициен-
// ты в комплексно-сопряженном виде передаются ВТОРОМУ сумматору с ПЕРВОГО, хра-
// нятся в матрице W и соответствуют верхней треугольной подматрице матрицы W.
// Исходному состоянию сумматора соответствует ЕДИНИЧНАЯ матрица весовых коэффи-
// циентов W. В этом случае входной сигнал проходит через сумматор без изменений.
// Для аналитической модели многоступенчатого сумматора в качестве входного воз-
// действия  рассматривается  корреляционная матрица входного сигнала или вектор
// входного  сигнала. Настройка весовых коэффициентов (адаптация) сумматора осу-
// ществляется только по корреляционной матрице входного сигнала. Структура мат-
// рицы весовых коэффициентов и корреляционной матрицы входного  воздействия для
// многоступенчатого  весового сумматора на 5 входов (InCount = 5) выглядит сле-
// дующим образом:
// U = [U0 U1 U2 U3 U4] - вектор входного сигнала
//     | R00 R01 R02 R03 R04 |
//     | R10 R11 R12 R13 R14 |
// R = | R20 R21 R22 R23 R24 |, Rij = Ui*conj(Uj), Rji = conj(Rij).
//     | R30 R31 R32 R33 R34 |
//     | R40 R41 R42 R43 R44 |
// R - корреляционная матрица входного сигнала (воздействия)
//     |  1  W01 W02 W03 W04 |
//     | W10  1  W12 W13 W14 |
// W = | W20 W21  1  W23 W24 |, Wji = conj(Wij)
//     | W30 W31 W32  1  W34 |
//     | W40 W41 W42 W43  1  |
//Каждая  ступень I-го многоступенчатого весового сумматора имеет элемент норми-
//рования с прямой итерационной оценкой мощности. Модель функционирования элемен-
//та нормирования для i-ой ступени описывается формулой:
// Ki[n+1] = 1/Pi[n+1],
//1) для АНАЛИТИЧЕСКОЙ модели: Pi[n+1] = Pi[n] - (1/Tsc)*[Pi[n]-real(Rii)];
//2) для СТАТИСТИЧЕСКОЙ модели: Pi[n+1] = Pi[n] - (1/Tsc)*[Pi[n]-norm(Ui)];
// Pi - оценка мощности входного процесса.
// Начальное значение всех Pi=0, соответственно начальное значение всех Ki=1.
//В  соответствии с МЕТОДОМ НАИСКОРЕЙШЕГО СПУСКА и с учетом схемы стабилизации с
//прямой итерационной оценкой мощности для каждой ступени каждый весовой коэффи-
//циент вычисляется по формуле:
//1) для АНАЛИТИЧЕСКОЙ модели:
// Wij(n+1) = Wij(n) - (1/Tsbp)*[Wij(n)*(1+Ki*Gsbp*Rjj) + Ki*Gsbp*Rij], i > j
//2) для СТАТИСТИЧЕСКОЙ модели:
// Wij(n+1) = Wij(n) - (1/Tsbp)*[Wij(n) + Ki*Gsbp*conj(SumUij)*Ui], i > j
//******************************************************************************
class TMultiStageSDA_DIPE_MIMOWSum : public TMultiStageSDA_MIMOWSum {
//------------------------------------------------------------------------------
//Объявление защищенных членов-данных класса TMultiStageSDA_DIPE_MIMOWSum
//------------------------------------------------------------------------------
protected:
 //Постоянная времени интегрирующего фильтра в цепи управления элемента
 //нормирования
 double Tsc;
 rvector Power;//Оценки мощности входного процесса для каждой ступени сумматора
//------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TMultiStageSDA_DIPE_MIMOWSum
//------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TMultiStageSDA_DIPE_MIMOWSum() : TMultiStageSDA_MIMOWSum() {Init();};
 //Конструктор с аргументами
 TMultiStageSDA_DIPE_MIMOWSum(ulong Size, const rvector& Arg = rvector())
 {Reset(); Set(Size,Arg);};
 TMultiStageSDA_DIPE_MIMOWSum(ulong Size, double SBP_T, double SBP_G, double SC_T)
 {Reset(); Set(Size,SBP_T,SBP_G,SC_T);};
 //Объявление конструктора копирования
 TMultiStageSDA_DIPE_MIMOWSum(const TMultiStageSDA_DIPE_MIMOWSum &WSum)
 {*this = WSum;};
 //Объявление деструктора класса
 ~TMultiStageSDA_DIPE_MIMOWSum() {Reset();};
//------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TMultiStageSDA_DIPE_MIMOWSum
//------------------------------------------------------------------------------
public:
 uint Type() const {return MS_SDM_DIPE_MIMO_WSum;};//Тип весового сумматора
 //Параметры весового сумматора
 rvector& Param(rvector& Arg) const
 {if (IsReady())
  {Arg.Set(3,ROW,false); Arg.Put(0,Tsbp); Arg.Put(1,Gsbp); Arg.Put(2,Tsc);}
  else Arg.Set(0,ROW,false);
  return Arg;
 }
 double GetTsc() const {return Tsc;};//Постоянная времени элемента нормирования

 //*****************************************************************************
 //Установка параметров весового сумматора TMultiStageSDA_DIPE_MIMOWSum
 //*****************************************************************************
 //Дополнительные параметры передаются в векторе Arg.
 //Arg[0] - Постоянная времени модуля весового сумматора Tsbp (Tsbp > 0)
 //Arg[1] - Коэффициент усиления модуля весового сумматора Gsbp (произвольное)
 //Arg[2] - Постоянная времени элемента нормирования Tsc (Tsc > 0)
 void Set(ulong Size, const rvector& Arg)
 {SetInput(Size);//Установка размерности сумматора по входу
  //Установка постоянной времени модуля весового сумматора
  double value = (Arg.Size() > 0L) ? Arg.Get(0) : 100.0; SetTsbp(value);
  //Установка коэффициента усиления модуля весового сумматора
  value = (Arg.Size() > 1L) ? Arg.Get(1) : 10.0; SetGsbp(value);
  //Установка постоянной времени элемента нормирования
  value = (Arg.Size() > 2L) ? Arg.Get(2) : 10.0; SetTsc(value);
 };
 void Set(ulong Size, double SBP_T, double SBP_G, double SC_T)
 {SetInput(Size); SetTsbp(SBP_T); SetGsbp(SBP_G); SetTsc(SC_T);};

 //Установка постоянной времени элемента нормирования
 void SetTsc(double SC_T) {Tsc = (SC_T > 0) ? SC_T : 10.0;};

 //Установка числа входов (размерности по входу) весового сумматора
 void SetInput(ulong Size)
 {TMultiStageSDA_MIMOWSum::SetInput(Size); Power.Set(Inputs(),ROW,0.0);};

 //Перегрузка оператора присваивания (=) для класса
 TMultiStageSDA_DIPE_MIMOWSum& operator = (const TMultiStageSDA_DIPE_MIMOWSum& WSum)
 {if (this != &WSum)
  {Set(WSum.Inputs(),WSum.GetTsbp(),WSum.GetGsbp(),WSum.GetTsc());}
  return *this;
 };
 //Начальная установка параметров весового сумматора для моделирования
 bool SimulateInit();
 //-----------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool Tuning(cmatrix& R);
 bool Tuning(cvector& V);
 //-----------------------------------------------------------------------------
 //Настройка коэффициентов нормирования сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool TuneNorm(const cmatrix& R);
 bool TuneNorm(const cvector& V);
 //-----------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса
 //-----------------------------------------------------------------------------
 string& Type(string& s) const //Тип весового сумматора
 {s = "MultiStageSDA_DIPEStabCircuit_MIMOWeightSummator"; return s;};
  //Сокращенное наименование класса
 string& Clip(string& s) const
 {return s = "MultiStageSDA_DIPE_MIMOWeightSum";};
 //Формирование алгоритма стабилизации сумматора в виде символьной строки вида:
 //<Stabilizing Circuit: "name_string", [stabcircuit params];\n>
 string& GetStabCircuit(string& s) const
 {char buffer[80]; ostrstream text (buffer, sizeof(buffer));
  s = "StabCircuit: < Direct Iterative Power Estimation >, ";
  text << "Tsc = " << GetTsc() << ";" << endl << ends;
  s.append(text.str()); text.seekp(0);
  return s;
 };
 //Консольный ввод Tsc с проверкой введенного параметра и подтверждением
 //введенного значения
 void TscEdit(string& head, uint indent = 0);
 //Консольное редактирование параметров весового сумматора
 void Edit(bool ExtParam = true);
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator << (ostream& out, const TMultiStageSDA_DIPE_MIMOWSum& WSum)
        {string s,head; return out << WSum.Properties(s,head);};
//------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TMultiStageSDA_DIPE_MIMOWSum
//------------------------------------------------------------------------------
protected:
 //Начальная установка параметров весового сумматора
 void Init() {Tsc = 0.0; Power = rvector();};
 //Сброс всех параметров весового сумматора
 void Reset()
 {N = 0L; Tsbp = 0.0; Gsbp = 0.0; Tsc = 0.0; W = cmatrix(); Power = rvector();};
};
//---------- Завершение объявления класса TMultiStageSDA_DIPE_MIMOWSum ---------

//******************************************************************************
//            Объявление класса TMultiStageSDA_ENCC_MIMOWSum
// Класс является производным от класса TMultiStageSDA_MIMOWSum. Он представляет
// АНАЛИТИЧЕСКУЮ и СТАТИСТИЧЕСКУЮ  модели МНОГОСТУПЕНЧАТОГО весового сумматора с
// N-ВХОДАМИ  и  ОДНИМ ВЫХОДОМ с АДАПТИВНЫМ алгоритмом настройки весовых коэффи-
// циентов по МЕТОДУ НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм), с схемой  ста-
// билизации  динамических параметров адаптивного сумматора. Данный весовой сум-
// матор характеризуется следующими свойствами:
// 1. Конфигурация: N-входов - ОДИН выход;
// 2. Cхема построения сумматора: МНОГОСТУПЕНЧАТАЯ (MultiStage);
// 3. Алгоритм настройки: МЕТОД НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм);
// 4. Алгоритм стабилизации динамических параметров: ЭКСПОНЕНЦИАЛЬНОЕ НОРМИРОВА-
//    НИЕ в СОПРЯЖЕННОЙ ЦЕПИ (Exponential Normalization In Conjugated Circuit).
// Класс имеет четыре ВНУТРЕННИХ ПАРАМЕТРА:
// 1) Tsbp - постоянная времени интегрирующего фильтра элементарного модуля;
// 2) Gsbp - коэффициент усиления в цепи обратной связи элементарного модуля;
// 3) Tsc - постоянная времени интегрирующего фильтра в цепи управления элемента
//          нормирования;
// 4) Gsc - крутизна регулировочной характеристики экспоненциального элемента
//          нормирования.
// Количество ступеней сумматора определяется по формуле: Stages = 2*(N-1).
// Индексы выходов сумматора соответствуют индексам входов. Весовые коэффициенты
// сумматора хранятся в квадратной  матрице W размерности N. Диагональные элемен-
// ты матрицы  всегда  равны  единице. В нижних столбцовых элементарных матрицах
// компактно  хранящихся в матрице W содержатся весовые коэффициенты каждой сту-
// пени  первого  сумматора. В  правых  строковых элементарных матрицах хранятся
// комплексно-сопряженные значения весовых коэффициентов каждой ступени  второго
// сумматора. Каждая  ступень  двух сумматоров представляет из себя совокупность
// элементарных весовых сумматоров на два входа и один выход. Между двумя парал-
// лельно-последовательными  сумматорами расположен НОРМИРОВАТЕЛЬ. Нормирователь
// осуществляет операцию деления  каждого выхода  первого  сумматора на значение
// выходной мощности, соответствующего выхода. Данная операция является эквива-
// лентной  умножению обратной  диагональной матрицы InvD, полученной из матрицы
// R', на матрицу R'. Матрица R' = W*R, получается в ходе преобразования входной
// корреляционной матрицы R, первым  сумматором. Под матрицей W следует понимать
// совокупность  нижних  столбцовых  элементарных  матриц Lkc, которые описывают
// структуру и работу многоступенчатого сумматора.
// Минимальное количество входов I и II сумматора равно 2.
// ПЕРВЫЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов  последовательно уменьшается на единицу для каждой последующей ступени.
// Крайний левый выход предыдущей ступени сумматора подключается к каждому  эле-
// ментарному  сумматору следующей ступени сумматора, к второму входу элементар-
// ного сумматора подключается соответствующий вход многоступенчатого сумматора.
// Данный сумматор является АДАПТИВНЫМ, в нем происходит настройка весовых коэф-
// фициентов  по градиентному  алгоритиу в зависимости от входного воздействия и
// параметров  алгоритма  настройки. Вычисленные  комплексно-сопряженные весовые
// коэффициенты  передаются второму сумматору. Весовые коэффициенты первого сум-
// матора  хранятся  в матрице  W и  соответствуют нижней треугольной подматрице
// матрицы W по расположению.
// ВТОРОЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов последовательно увеличивается на единицу для каждой последующей ступени.
// На первой ступени сумматора размещается один модуль, на последней - N-1. Каж-
// дый элементарный  сумматор  (модуль) имеет  два входа и один выход. Один вход
// соответствует  выходам  первого  сумматора, другой вход для всех модулей i-ой
// ступени второго сумматора определяется по формуле - (i+1). Для первой ступени
// (с  одним  модулем) таким  входом будет 2 выход первого сумматора, для второй
// ступени - выход 3, для N-1 (последняя ступень) - выход N. Весовые коэффициен-
// ты в комплексно-сопряженном виде передаются ВТОРОМУ сумматору с ПЕРВОГО, хра-
// нятся в матрице W и соответствуют верхней треугольной подматрице матрицы W.
// Исходному состоянию сумматора соответствует ЕДИНИЧНАЯ матрица весовых коэффи-
// циентов W. В этом случае входной сигнал проходит через сумматор без изменений.
// Для аналитической модели многоступенчатого сумматора в качестве входного воз-
// действия  рассматривается  корреляционная матрица входного сигнала или вектор
// входного  сигнала. Настройка весовых коэффициентов (адаптация) сумматора осу-
// ществляется только по корреляционной матрице входного сигнала. Структура мат-
// рицы весовых коэффициентов и корреляционной матрицы входного  воздействия для
// многоступенчатого  весового сумматора на 5 входов (InCount = 5) выглядит сле-
// дующим образом:
// U = [U0 U1 U2 U3 U4] - вектор входного сигнала
//     | R00 R01 R02 R03 R04 |
//     | R10 R11 R12 R13 R14 |
// R = | R20 R21 R22 R23 R24 |, Rij = Ui*conj(Uj), Rji = conj(Rij).
//     | R30 R31 R32 R33 R34 |
//     | R40 R41 R42 R43 R44 |
// R - корреляционная матрица входного сигнала (воздействия)
//     |  1  W01 W02 W03 W04 |
//     | W10  1  W12 W13 W14 |
// W = | W20 W21  1  W23 W24 |, Wji = conj(Wij)
//     | W30 W31 W32  1  W34 |
//     | W40 W41 W42 W43  1  |
//Каждая ступень I-го многоступенчатого весового сумматора имеет  элемент норми-
//рования  с  экспоненциальной  регулировочной характеристикой и логарифмическим
//усилителем в цепи управления. Модель функционирования элемента нормирования для
//i-ой ступени описывается формулой:
// Ki[n+1] = 10^[-Gsc*log10(Pi)],
// Pi[n+1] = Pi[n] - (1/Tsc)*[Pi[n]-real(Rii)], real(Rii) <=> norm(Ui)
// Pi - оценка мощности входного процесса.
// Начальное значение всех Pi=1, соответственно начальное значение всех Ki=1.
//В  соответствии с МЕТОДОМ НАИСКОРЕЙШЕГО СПУСКА и с учетом схемы стабилизации с
//экспоненциальным  нормированием  в сопряженной цепи каждый весовой коэффициент
//вычисляется по формуле:
// Wij(n+1) = Wij(n) - (1/Tsbp)*[Wij(n)*(1+Ki*Gsbp*Rjj) + Ki*Gsbp*Rij], i > j
//******************************************************************************
class TMultiStageSDA_ENCC_MIMOWSum : public TMultiStageSDA_MIMOWSum {
//------------------------------------------------------------------------------
//Объявление защищенных членов-данных класса TMultiStageSDA_ENCC_MIMOWSum
//------------------------------------------------------------------------------
protected:
 //Постоянная времени интегрирующего фильтра в цепи управления элемента
 //нормирования
 double Tsc;
 //Крутизна регулировочной характеристики экспоненциального элемента нормирования
 double Gsc;
 rvector Power;//Оценки мощности входного процесса для каждой ступени сумматора
 rvector K;//Коэффициенты нормирования для каждой ступени сумматора
//------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TMultiStageSDA_ENCC_MIMOWSum
//------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TMultiStageSDA_ENCC_MIMOWSum() : TMultiStageSDA_MIMOWSum() {Init();};
 //Конструктор с аргументами
 TMultiStageSDA_ENCC_MIMOWSum(ulong Size, const rvector& Arg = rvector())
 {Reset(); Set(Size,Arg);};
 TMultiStageSDA_ENCC_MIMOWSum(ulong Size, double SBP_T, double SBP_G,
  double SC_T, double SC_G) {Reset(); Set(Size,SBP_T,SBP_G,SC_T,SC_G);};
 //Объявление конструктора копирования
 TMultiStageSDA_ENCC_MIMOWSum(const TMultiStageSDA_ENCC_MIMOWSum &WSum)
 {*this = WSum;};
 //Объявление деструктора класса
 ~TMultiStageSDA_ENCC_MIMOWSum() {Reset();};
//------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TMultiStageSDA_ENCC_MIMOWSum
//------------------------------------------------------------------------------
public:
 uint Type() const {return MS_SDM_ENCC_MIMO_WSum;};//Тип весового сумматора
 //Параметры весового сумматора
 rvector& Param(rvector& Arg) const
 {if (IsReady())
  {Arg.Set(4,ROW,false);
   Arg.Put(0,Tsbp); Arg.Put(1,Gsbp); Arg.Put(2,Tsc); Arg.Put(3,Gsc);
  }
  else Arg.Set(0,ROW,false);
  return Arg;
 }
 double GetTsc() const {return Tsc;};//Постоянная времени элемента нормирования
 double GetGsc() const {return Gsc;};//Коэффициент усиления элемента нормирования

 //*****************************************************************************
 //Установка параметров весового сумматора TMultiStageSDA_ENCC_MIMOWSum
 //*****************************************************************************
 //Дополнительные параметры передаются в векторе Arg.
 //Arg[0] - Постоянная времени модуля весового сумматора Tsbp (Tsbp > 0)
 //Arg[1] - Коэффициент усиления модуля весового сумматора Gsbp (произвольное)
 //Arg[2] - Постоянная времени элемента нормирования Tsc (Tsc > 0)
 //Arg[3] - Коэффициент усиления элемента нормирования Gsc (произвольное)
 void Set(ulong Size, const rvector& Arg)
 {SetInput(Size);//Установка размерности сумматора по входу
  //Установка постоянной времени модуля весового сумматора
  double value = (Arg.Size() > 0L) ? Arg.Get(0) : 1000.0; SetTsbp(value);
  //Установка коэффициента усиления модуля весового сумматора
  value = (Arg.Size() > 1L) ? Arg.Get(1) : 50.0; SetGsbp(value);
  //Установка постоянной времени элемента нормирования
  value = (Arg.Size() > 2L) ? Arg.Get(2) : 10.0; SetTsc(value);
  //Установка коэффициента усиления элемента нормирования
  value = (Arg.Size() > 3L) ? Arg.Get(3) : 1.0; SetGsc(value);
 };
 void Set(ulong Size, double SBP_T, double SBP_G, double SC_T, double SC_G)
 {SetInput(Size); SetTsbp(SBP_T); SetGsbp(SBP_G); SetTsc(SC_T); SetGsc(SC_G);};

 //Установка постоянной времени элемента нормирования
 void SetTsc(double SC_T) {Tsc = (SC_T > 0) ? SC_T : 10.0;};
 //Установка коэффициента усиления модуля весового сумматора
 void SetGsc(double SC_G) {Gsc = SC_G;};

 //Установка числа входов (размерности по входу) весового сумматора
 void SetInput(ulong Size)
 {TMultiStageSDA_MIMOWSum::SetInput(Size);
  Power.Resize(Inputs()); Power = 1.0; K.Resize(Inputs()); K = 0.0;
 };

 //Перегрузка оператора присваивания (=) для класса
 TMultiStageSDA_ENCC_MIMOWSum& operator = (const TMultiStageSDA_ENCC_MIMOWSum& WSum)
 {if (this != &WSum)
  {Set(WSum.Inputs(),WSum.GetTsbp(),WSum.GetGsbp(),WSum.GetTsc(),WSum.GetGsc());}
  return *this;
 };
 //Начальная установка параметров весового сумматора для моделирования
 bool SimulateInit();
 //-----------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool Tuning(cmatrix& R);
 bool Tuning(cvector& V);
 //-----------------------------------------------------------------------------
 //Настройка коэффициентов нормирования сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool TuneNorm(const cmatrix& R);
 bool TuneNorm(const cvector& V);
 //-----------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса
 //-----------------------------------------------------------------------------
 string& Type(string& s) const //Тип весового сумматора
 {s = "MultiStageSDA_ENCCStabCircuit_MIMOWeightSummator"; return s;};
  //Сокращенное наименование класса
 string& Clip(string& s) const
 {return s = "MultiStageSDA_ENCC_MIMOWeightSum";};
 //Формирование алгоритма стабилизации сумматора в виде символьной строки вида:
 //<Stabilizing Circuit: "name_string", [stabcircuit params];\n>
 string& GetStabCircuit(string& s) const
 {char buffer[80]; ostrstream text (buffer, sizeof(buffer));
  s = "StabCircuit: < ExpNormInConjCircuit >, ";
  text << "Tsc = " << GetTsc() << ends;
  s.append(text.str()); text.seekp(0);
  text << ", Gsc = " << GetGsc() << endl << ends;
  s.append(text.str()); text.seekp(0);
  return s;
 };
 //Консольный ввод Tsc с проверкой введенного параметра и подтверждением
 //введенного значения
 void TscEdit(string& head, uint indent = 0);
 //Консольный ввод Gsc и подтверждение введенного значения
 void GscEdit(string& head, uint indent = 0);
 //Консольное редактирование параметров весового сумматора
 void Edit(bool ExtParam = true);
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator << (ostream& out, const TMultiStageSDA_ENCC_MIMOWSum& WSum)
        {string s,head; return out << WSum.Properties(s,head);};
//------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TMultiStageSDA_ENCC_MIMOWSum
//------------------------------------------------------------------------------
protected:
 //Начальная установка параметров весового сумматора
 void Init() {Tsc = 0.0; Gsc = 0.0; Power = rvector(); K = rvector();};
 //Сброс всех параметров весового сумматора
 void Reset()
 {N = 0L; Tsbp = 0.0; Gsbp = 0.0; Tsc = 0.0; Gsc = 0.0;
  W = cmatrix(); Power = rvector(); K = rvector();
 };
};
//---------- Завершение объявления класса TMultiStageSDA_ENCC_MIMOWSum ---------
//******************************************************************************
//          Объявление класса TDMultiStageSDA_MIMOWSum
//Класс, производный от  базового класса TMIMOWSum, представляет АНАЛИТИЧЕСКУЮ и
//СТАТИСТИЧЕСКУЮ модели МНОГОСТУПЕНЧАТОГО весового сумматора с N-ВХОДАМИ и N-ВЫ-
//ХОДАМИ с АДАПТИВНЫМ цифровым алгоритмом настройки весовых коэффициентов по МЕ-
//ТОДУ НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм), БЕЗ схемы стабилизации дина-
//мических параметров адаптивного сумматора. Свойства весового сумматора:
// 1. Конфигурация: N-входов - N-выходов;
// 2. Cхема построения сумматора: МНОГОСТУПЕНЧАТАЯ (MultiStage);
// 3. Алгоритм настройки: МЕТОД НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм);
// 4. Алгоритм стабилизации динамических параметров: ОТСУТСТВУЕТ.
// Класс имеет один ВНУТРЕННИЙ ПАРАМЕТР:
// 1) Tsbp - шаг адаптации, который зависит от уровня внешнего сигнала на входе
//    сумматора;
// Количество ступеней сумматора определяется по формуле: StageCount = 2*(N-1).
// Индексы выходов сумматора соответствуют индексам входов. Весовые коэффициенты
// сумматора хранятся в квадратной  матрице W размерности N. Диагональные элемен-
// ты матрицы  всегда  равны  единице. В нижних столбцовых элементарных матрицах
// компактно  хранящихся в матрице W содержатся весовые коэффициенты каждой сту-
// пени  первого  сумматора. В  правых  строковых элементарных матрицах хранятся
// комплексно-сопряженные значения весовых коэффициентов каждой ступени  второго
// сумматора. Каждая  ступень  двух сумматоров представляет из себя совокупность
// элементарных весовых сумматоров на два входа и один выход. Между двумя парал-
// лельно-последовательными  сумматорами расположен НОРМИРОВАТЕЛЬ. Нормирователь
// осуществляет операцию деления  каждого выхода  первого  сумматора на значение
// выходной мощности, соответствующего выхода. Данная операция является эквива-
// лентной  умножению обратной  диагональной матрицы InvD, полученной из матрицы
// R', на матрицу R'. Матрица R' = W*R, получается в ходе преобразования входной
// корреляционной матрицы R, первым  сумматором. Под матрицей W следует понимать
// совокупность  нижних  столбцовых  элементарных  матриц Lkc, которые описывают
// структуру и работу многоступенчатого сумматора.
// Минимальное количество входов I и II сумматора равно 2.
// ПЕРВЫЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов  последовательно уменьшается на единицу для каждой последующей ступени.
// Крайний левый выход предыдущей ступени сумматора подключается к каждому  эле-
// ментарному  сумматору следующей ступени сумматора, к второму входу элементар-
// ного сумматора подключается соответствующий вход многоступенчатого сумматора.
// Данный сумматор является АДАПТИВНЫМ, в нем происходит настройка весовых коэф-
// фициентов  по градиентному  алгоритиу в зависимости от входного воздействия и
// параметров  алгоритма  настройки. Вычисленные  комплексно-сопряженные весовые
// коэффициенты  передаются второму сумматору. Весовые коэффициенты первого сум-
// матора  хранятся  в матрице  W и  соответствуют нижней треугольной подматрице
// матрицы W по расположению.
// ВТОРОЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов последовательно увеличивается на единицу для каждой последующей ступени.
// На первой ступени сумматора размещается один модуль, на последней - N-1. Каж-
// дый элементарный  сумматор  (модуль) имеет  два входа и один выход. Один вход
// соответствует  выходам  первого  сумматора, другой вход для всех модулей i-ой
// ступени второго сумматора определяется по формуле - (i+1). Для первой ступени
// (с  одним  модулем) таким  входом будет 2 выход первого сумматора, для второй
// ступени - выход 3, для N-1 (последняя ступень) - выход N. Весовые коэффициен-
// ты в комплексно-сопряженном виде передаются ВТОРОМУ сумматору с ПЕРВОГО, хра-
// нятся в матрице W и соответствуют верхней треугольной подматрице матрицы W.
// Исходному состоянию сумматора соответствует ЕДИНИЧНАЯ матрица весовых коэффи-
// циентов W. В этом случае входной сигнал проходит через сумматор без изменений.
// Для аналитической модели многоступенчатого сумматора в качестве входного воз-
// действия  рассматривается  корреляционная матрица входного сигнала или вектор
// входного  сигнала. Настройка весовых коэффициентов (адаптация) сумматора осу-
// ществляется только по корреляционной матрице входного сигнала. Структура мат-
// рицы весовых коэффициентов и корреляционной матрицы входного  воздействия для
// многоступенчатого  весового сумматора на 5 входов (InCount = 5) выглядит сле-
// дующим образом:
// U = [U0 U1 U2 U3 U4] - вектор входного сигнала
//     | R00 R01 R02 R03 R04 |
//     | R10 R11 R12 R13 R14 |
// R = | R20 R21 R22 R23 R24 |, Rij = Ui*conj(Uj), Rji = conj(Rij).
//     | R30 R31 R32 R33 R34 |
//     | R40 R41 R42 R43 R44 |
// R - корреляционная матрица входного сигнала (воздействия)
//     |  1  W01 W02 W03 W04 |
//     | W10  1  W12 W13 W14 |
// W = | W20 W21  1  W23 W24 |, Wji = conj(Wij)
//     | W30 W31 W32  1  W34 |
//     | W40 W41 W42 W43  1  |
//В соответствии с МЕТОДОМ НАИСКОРЕЙШЕГО СПУСКА каждый весовой коэффициент вычи-
//сляется по формуле (цифровой алгоритм настройки):
//1. ЧИСЛЕННАЯ МОДЕЛЬ: Wij(n+1) = Wij(n) - (1/Tsbp)*[Wij(n)*Rjj + Rij], i > j
//2. ИМИТАЦИОННАЯ МОДЕЛЬ: Wij(n+1) = Wij(n) - (1/Tsbp)*conj(Usum)*Uij, i > j
//   Usum = Ujj*Wij(n) + Uij.
//******************************************************************************
class TDMultiStageSDA_MIMOWSum : public TMIMOWeightSum {
//------------------------------------------------------------------------------
//Объявление защищенных членов-данных класса TDMultiStageSDA_MIMOWSum
//------------------------------------------------------------------------------
protected:
 double Tsbp;//Шаг адаптации алгоритма настройки весовых коэффициентов
 cmatrix W;//Весовые коэффициенты многоступенчатого сумматора
//------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TDMultiStageSDA_MIMOWSum
//------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TDMultiStageSDA_MIMOWSum() : TMIMOWeightSum() {Reset();};
 //Конструктор с аргументами
 TDMultiStageSDA_MIMOWSum(ulong Size, const rvector& Param = rvector())
 {Reset(); Set(Size,Param);};
 TDMultiStageSDA_MIMOWSum(ulong Size, double SBP_T) {Reset(); Set(Size,SBP_T);};
 //Объявление конструктора копирования
 TDMultiStageSDA_MIMOWSum(const TDMultiStageSDA_MIMOWSum &WSum) {*this = WSum;};
 //Объявление деструктора класса
 virtual ~TDMultiStageSDA_MIMOWSum() {Reset();};
//------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TDMultiStageSDA_MIMOWSum
//------------------------------------------------------------------------------
public:
 virtual uint Type() const {return MS_DSDM_MIMO_WSum;};//Тип весового сумматора
 //Параметры весового сумматора
 virtual rvector& Param(rvector& Arg) const
 {if (IsReady()) {Arg.Set(1,ROW,false); Arg.Put(0,Tsbp);}
  else Arg.Set(0,ROW,false);
  return Arg;
 };
 ulong Stages() const {return 2*(N-1);};//Количество ступеней сумматора
 double GetTsbp() const {return Tsbp;}; //Значение шага адаптации
 //*****************************************************************************
 //Установка параметров весового сумматора
 //*****************************************************************************
 //Дополнительные параметры передаются в векторе Param.
 //Param[0] - значение шага адаптации Tsbp (Tsbp != 0)
 virtual void Set(ulong Size, const rvector& Param)
 {SetInput(Size);//Установка размерности сумматора по входу
  double SBP_T = (Param.Size() > 0L) ? Param.Get(0) : 1.0e6;
  SetTsbp(SBP_T);//Установка шага адаптации
 };
 void Set(ulong Size, double SBP_T) {SetInput(Size); SetTsbp(SBP_T);};
 //Установка шага адаптации (постоянная времени автокомпенсатора)
 virtual void SetTsbp(double SBP_T) {Tsbp = (SBP_T > 0) ? SBP_T : 1.0e6;};
 //Установка числа входов (размерности по входу) весового сумматора
 virtual void SetInput(ulong Size);
 //Перегрузка оператора присваивания (=) для класса
 TDMultiStageSDA_MIMOWSum& operator =(const TDMultiStageSDA_MIMOWSum& WSum)
 {if (this != &WSum) {Set(WSum.Inputs(),WSum.GetTsbp());}
  return *this;
 };
 //Начальная установка параметров весового сумматора для моделирования
 virtual bool SimulateInit();
 //-----------------------------------------------------------------------------
 //Передаточная функция весового сумматора (TRANSFER FUNCTION)
 //-----------------------------------------------------------------------------
 bool operator ()(cmatrix& R) const;
 bool operator ()(cvector& V) const;
 rvector& operator ()(rvector& P, cmatrix& R) const;
 rvector& operator ()(rvector& P, cvector& V) const;
 bool TestFunc(cvector& V, rvector& P) const;
 //Мощности на входах/выходах I и II сумматоров
 rmatrix& Powers(rmatrix& P, cmatrix& R) const;
 rmatrix& Powers(rmatrix& P, cvector& V) const;

 //-----------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 virtual bool Tuning(cmatrix& R);
 virtual bool Tuning(cvector& V);

 //-----------------------------------------------------------------------------
 //Расчет оптимальных весовых коэффициентов сумматора для заданного воздействия
 //-----------------------------------------------------------------------------
 virtual cmatrix& GetOptW(cmatrix& OptW, const cmatrix& R) const;

 //-----------------------------------------------------------------------------
 //Настройка коэффициентов нормирования сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 virtual bool TuneNorm(const cmatrix& R);
 virtual bool TuneNorm(const cvector& V);

 //-----------------------------------------------------------------------------
 //Получение коэффициентов весового сумматора
 //-----------------------------------------------------------------------------
 cmatrix& GetW(cmatrix& Weight) const {Weight = W; return Weight;};
 cvector& GetW(cvector& Weight, ulong Stage = 0L) const;
 //-----------------------------------------------------------------------------
 //Установка коэффициентов весового сумматора
 //-----------------------------------------------------------------------------
 bool SetW(const cmatrix& Weight);
 //-----------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса
 //-----------------------------------------------------------------------------
 virtual string& Type(string& s) const //Тип весового сумматора
 {s = "MultiInMultiOut MultiStage DigitSDA Adaptive WeightSummator"; return s;};
  //Сокращенное наименование класса
 virtual string& Clip(string& s) const
 {return s = "MultiStageDigitSDA_MIMOWeightSum";};
 //Формирование адаптивного алгоритма сумматора в виде символьной строки вида:
 //<Algorithm: <Steepest Descent Method>, Tadapt = <value>;\n>
 virtual string& GetAdaptAlg(string& s) const
 {char buffer[80]; ostrstream text (buffer, sizeof(buffer));
  s = "Algorithm: <Digital Steepest Descent Method>, ";
  text << "Tsbp = " << GetTsbp() << endl << ends;
  s.append(text.str()); text.seekp(0);
  return s;
 };
 //Формирование алгоритма стабилизации сумматора в виде символьной строки вида:
 //<Stabilizing Circuit: "name_string", [stabcircuit params];\n>
 virtual string& GetStabCircuit(string& s) const
 {s = "Stabilizing Circuit: < Off >\n"; return s;};
 //Формирование свойств весового сумматора в виде символьной строки
 virtual string& Properties(string& s, string& head, uint indent = 0) const;
 //Консольный ввод шага адаптации с проверкой и подтверждением ввода
 void TsbpEdit(string& head, uint indent = 0);
 //Консольное редактирование параметров весового сумматора
 virtual void Edit(bool ExtParam = true);
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator << (ostream& out, const TDMultiStageSDA_MIMOWSum& WSum)
        {string s,head; return out << WSum.Properties(s,head);};
//------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TDMultiStageSDA_MIMOWSum
//------------------------------------------------------------------------------
protected:
 //Начальная установка параметров весового сумматора
 void Reset() {N = 0L; Tsbp = 0.0; W = cmatrix();};
 //Передаточная функция весового сумматора
 void TransferFunction(cmatrix& R) const;
 void TransferFunction(cvector& V) const;
 void CalcAllPowers(rmatrix& P, cmatrix& R) const;
 void CalcAllPowers(rmatrix& P, cvector& V) const;

};//Завершение объявления класса TDMultiStageSDA_MIMOWSum
//--------- Завершение объявления класса TDMultiStageSDA_MIMOWeightSum ---------

//******************************************************************************
//               Объявление класса TDMultiStageSDA_DMPE_MIMOWSum
//Класс, производный от класса TDMultiStageSDA_MIMOWSum, реализует АНАЛИТИЧЕСКУЮ
//и  СТАТИСТИЧЕСКУЮ  модели  МНОГОСТУПЕНЧАТОГО  весового сумматора с N-ВХОДАМИ и
//N-ВЫХОДАМИ с АДАПТИВНЫМ цифровым алгоритмом настройки весовых коэффициентов по
//МЕТОДУ НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм) и схемой стабилизации дина-
//мических параметров адаптивного сумматора. Свойства весового сумматора:
// 1. Конфигурация: N-входов - N-выходов;
// 2. Cхема построения сумматора: МНОГОСТУПЕНЧАТАЯ (MultiStage);
// 3. Алгоритм настройки: цифровой МЕТОД НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм);
// 4. Алгоритм стабилизации динамических параметров: ПРЯМАЯ МГНОВЕННАЯ ОЦЕНКА
//    МОЩНОСТИ (Direct Momentary Power Estimation)
// Класс имеет один ВНУТРЕННИЙ ПАРАМЕТР:
// 1) Tsbp - шаг адаптации, который зависит от уровня внешнего сигнала на входе
//    сумматора.
// Количество ступеней сумматора определяется по формуле: Stages = 2*(N-1).
// Индексы выходов сумматора соответствуют индексам входов. Весовые коэффициенты
// сумматора хранятся в квадратной  матрице W размерности N. Диагональные элемен-
// ты матрицы  всегда  равны  единице. В нижних столбцовых элементарных матрицах
// компактно  хранящихся в матрице W содержатся весовые коэффициенты каждой сту-
// пени  первого  сумматора. В  правых  строковых элементарных матрицах хранятся
// комплексно-сопряженные значения весовых коэффициентов каждой ступени  второго
// сумматора. Каждая  ступень  двух сумматоров представляет из себя совокупность
// элементарных весовых сумматоров на два входа и один выход. Между двумя парал-
// лельно-последовательными  сумматорами расположен НОРМИРОВАТЕЛЬ. Нормирователь
// осуществляет операцию деления  каждого выхода  первого  сумматора на значение
// выходной мощности, соответствующего выхода. Данная операция является эквива-
// лентной  умножению обратной  диагональной матрицы InvD, полученной из матрицы
// R', на матрицу R'. Матрица R' = W*R, получается в ходе преобразования входной
// корреляционной матрицы R, первым  сумматором. Под матрицей W следует понимать
// совокупность  нижних  столбцовых  элементарных  матриц Lkc, которые описывают
// структуру и работу многоступенчатого сумматора.
// Минимальное количество входов I и II сумматора равно 2.
// ПЕРВЫЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов  последовательно уменьшается на единицу для каждой последующей ступени.
// Крайний левый выход предыдущей ступени сумматора подключается к каждому  эле-
// ментарному  сумматору следующей ступени сумматора, к второму входу элементар-
// ного сумматора подключается соответствующий вход многоступенчатого сумматора.
// Данный сумматор является АДАПТИВНЫМ, в нем происходит настройка весовых коэф-
// фициентов  по градиентному  алгоритиу в зависимости от входного воздействия и
// параметров  алгоритма  настройки. Вычисленные  комплексно-сопряженные весовые
// коэффициенты  передаются второму сумматору. Весовые коэффициенты первого сум-
// матора  хранятся  в матрице  W и  соответствуют нижней треугольной подматрице
// матрицы W по расположению.
// ВТОРОЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов последовательно увеличивается на единицу для каждой последующей ступени.
// На первой ступени сумматора размещается один модуль, на последней - N-1. Каж-
// дый элементарный  сумматор  (модуль) имеет  два входа и один выход. Один вход
// соответствует  выходам  первого  сумматора, другой вход для всех модулей i-ой
// ступени второго сумматора определяется по формуле - (i+1). Для первой ступени
// (с  одним  модулем) таким  входом будет 2 выход первого сумматора, для второй
// ступени - выход 3, для N-1 (последняя ступень) - выход N. Весовые коэффициен-
// ты в комплексно-сопряженном виде передаются ВТОРОМУ сумматору с ПЕРВОГО, хра-
// нятся в матрице W и соответствуют верхней треугольной подматрице матрицы W.
// Исходному состоянию сумматора соответствует ЕДИНИЧНАЯ матрица весовых коэффи-
// циентов W. В этом случае входной сигнал проходит через сумматор без изменений.
// Для аналитической модели многоступенчатого сумматора в качестве входного воз-
// действия  рассматривается  корреляционная матрица входного сигнала или вектор
// входного  сигнала. Настройка весовых коэффициентов (адаптация) сумматора осу-
// ществляется только по корреляционной матрице входного сигнала. Структура мат-
// рицы весовых коэффициентов и корреляционной матрицы входного  воздействия для
// многоступенчатого  весового сумматора на 5 входов (InCount = 5) выглядит сле-
// дующим образом:
// U = [U0 U1 U2 U3 U4] - вектор входного сигнала
//     | R00 R01 R02 R03 R04 |
//     | R10 R11 R12 R13 R14 |
// R = | R20 R21 R22 R23 R24 |, Rij = Ui*conj(Uj), Rji = conj(Rij).
//     | R30 R31 R32 R33 R34 |
//     | R40 R41 R42 R43 R44 |
// R - корреляционная матрица входного сигнала (воздействия)
//     |  1  W01 W02 W03 W04 |
//     | W10  1  W12 W13 W14 |
// W = | W20 W21  1  W23 W24 |, Wji = conj(Wij)
//     | W30 W31 W32  1  W34 |
//     | W40 W41 W42 W43  1  |
//Каждая  ступень I-го многоступенчатого весового сумматора имеет элемент норми-
//рования с прямой мгновенной оценкой мощности. Модель функционирования элемента
//нормирования для i-ой ступени описывается формулой:
//1) для АНАЛИТИЧЕСКОЙ модели: Ki[n] = 1/Rii;
//2) для СТАТИСТИЧЕСКОЙ модели: Ki[n] = 1/norm(Ui);
// Rii = norm(Ui)- оценка мощности входного процесса для i-ой ступени.
//В соответствии с цифровой реализацией МЕТОДА НАИСКОРЕЙШЕГО СПУСКА и с учетом
//схемы стабилизации с прямой мгновенной оценкой мощности каждый весовой коэффи-
//циент вычисляется по формуле:
//1) для ЧИСЛЕННОЙ модели:
//   Wij(n+1) = Wij(n) - (1/Tsbp)*Ki*[Wij(n)*Rjj + Rij], i > j
//2) для СТАТИСТИЧЕСКОЙ модели:
//   Wij(n+1) = Wij(n) - (1/Tsbp)*Ki*conj(SumUij)*Ui, i > j
//SumUij - выходное напряжение с элементарного весового сумматора, расположенного
//на i-ой ступени для j-го входа;
//Ui - задающее напряжение для i-ой ступени весового сумматора.
//******************************************************************************
class TDMultiStageSDA_DMPE_MIMOWSum : public TDMultiStageSDA_MIMOWSum {
//------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TMultiStageSDA_DMPE_MIMOWSum
//------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TDMultiStageSDA_DMPE_MIMOWSum() : TDMultiStageSDA_MIMOWSum() {};
 //Конструктор с аргументами
 TDMultiStageSDA_DMPE_MIMOWSum(ulong Size, const rvector& Arg = rvector())
 {Reset(); Set(Size,Arg);};
 TDMultiStageSDA_DMPE_MIMOWSum(ulong Size, double SBP_T)
 {Reset(); Set(Size,SBP_T);};
 //Объявление конструктора копирования
 TDMultiStageSDA_DMPE_MIMOWSum(const TDMultiStageSDA_DMPE_MIMOWSum &WSum)
 {*this = WSum;};
 //Объявление деструктора класса
 ~TDMultiStageSDA_DMPE_MIMOWSum() {Reset();};
//------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TDMultiStageSDA_DMPE_MIMOWSum
//------------------------------------------------------------------------------
public:
 //*****************************************************************************
 //Установка параметров весового сумматора
 //*****************************************************************************
 //Дополнительные параметры передаются в векторе Param.
 //Param[0] - значение шага адаптации Tsbp (Tsbp != 0)
 void Set(ulong Size, const rvector& Param)
 {SetInput(Size);//Установка размерности сумматора по входу
  double SBP_T = (Param.Size() > 0L) ? Param.Get(0) : 100.0;
  SetTsbp(SBP_T);//Установка шага адаптации
 };
 void Set(ulong Size, double SBP_T) {SetInput(Size); SetTsbp(SBP_T);};
 //Установка шага адаптации (постоянная времени автокомпенсатора)
 void SetTsbp(double SBP_T) {Tsbp = (SBP_T > 0) ? SBP_T : 100.0;};
 uint Type() const {return MS_DSDM_DMPE_MIMO_WSum;};//Тип весового сумматора
 //Перегрузка оператора присваивания (=) для класса
 TDMultiStageSDA_DMPE_MIMOWSum& operator =
 (const TDMultiStageSDA_DMPE_MIMOWSum& WSum)
 {if (this != &WSum) {Set(WSum.Inputs(),WSum.GetTsbp());}
  return *this;
 };
 //-----------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool Tuning(cmatrix& R);
 bool Tuning(cvector& V);
 //-----------------------------------------------------------------------------
 //Настройка коэффициентов нормирования сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool TuneNorm(const cmatrix& R);
 bool TuneNorm(const cvector& V);
 //-----------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса TDMultiStageSDA_DMPE_MIMOWSum
 //-----------------------------------------------------------------------------
 string& Type(string& s) const //Тип весового сумматора
 {s = "MultiStageDigitalSDA_DirectMomentaryPowerEstimation_MIMOWeightSum"; return s;};
  //Сокращенное наименование класса
 string& Clip(string& s) const {return s = "MultiStageDigSDA_DMPE_MIMOWSum";};
 //Формирование алгоритма стабилизации сумматора в виде символьной строки вида:
 //<Stabilizing Circuit: "name_string", [stabcircuit params];\n>
 string& GetStabCircuit(string& s) const
 {s = "Stabilizing Circuit: < Direct Momentary Power Estimation >\n";
  return s;
 };
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator << (ostream& out, const TDMultiStageSDA_DMPE_MIMOWSum& WSum)
 {string s,head; return out << WSum.Properties(s,head);};

//------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TDMultiStageSDA_MIMOWSum
//------------------------------------------------------------------------------
protected:
 //Начальная установка параметров весового сумматора
 void Reset() {N = 0L; Tsbp = 0.0; W = cmatrix();};
};//Завершение объявления класса TDMultiStageSDA_DMPE_MIMOWSum
//--------- Завершение объявления класса TDMultiStageSDA_DMPE_MIMOWSum ---------

//******************************************************************************
//            Объявление класса TDMultiStageSDA_DIPE_MIMOWSum
//Класс, производный от класса TDMultiStageSDA_MIMOWSum, представляет АНАЛИТИЧЕС-
//КУЮ  и СТАТИСТИЧЕСКУЮ  модели МНОГОСТУПЕНЧАТОГО весового сумматора с N-ВХОДАМИ
//и N-ВЫХОДАМИ с АДАПТИВНЫМ цифровым алгоритмом настройки весовых коэффициентов
//по МЕТОДУ НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм) и схемой стабилизации ди-
//намических параметров адаптивного сумматора. Свойства весового сумматора:
// 1. Конфигурация: N-входов - N-выходов;
// 2. Cхема построения сумматора: МНОГОСТУПЕНЧАТАЯ (MultiStage);
// 3. Алгоритм настройки: ЦИФРОВОЙ МЕТОД НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм);
// 4. Алгоритм стабилизации динамических параметров: ПРЯМАЯ ИТЕРАЦИОННАЯ ОЦЕНКА
//    МОЩНОСТИ (Direct Iterative Power Estimation).
// Класс имеет два ВНУТРЕННИХ ПАРАМЕТРА:
// 1) Tsbp - постоянная времени интегрирующего фильтра элементарного модуля;
// 2) Tsc - постоянная времени в цепи управления элемента нормирования;
// Количество ступеней сумматора определяется по формуле: Stages = 2*(N-1).
// Индексы выходов сумматора соответствуют индексам входов. Весовые коэффициенты
// сумматора хранятся в квадратной  матрице W размерности N. Диагональные элемен-
// ты матрицы  всегда  равны  единице. В нижних столбцовых элементарных матрицах
// компактно  хранящихся в матрице W содержатся весовые коэффициенты каждой сту-
// пени  первого  сумматора. В  правых  строковых элементарных матрицах хранятся
// комплексно-сопряженные значения весовых коэффициентов каждой ступени  второго
// сумматора. Каждая  ступень  двух сумматоров представляет из себя совокупность
// элементарных весовых сумматоров на два входа и один выход. Между двумя парал-
// лельно-последовательными  сумматорами расположен НОРМИРОВАТЕЛЬ. Нормирователь
// осуществляет операцию деления  каждого выхода  первого  сумматора на значение
// выходной мощности, соответствующего выхода. Данная операция является эквива-
// лентной  умножению обратной  диагональной матрицы InvD, полученной из матрицы
// R', на матрицу R'. Матрица R' = W*R, получается в ходе преобразования входной
// корреляционной матрицы R, первым  сумматором. Под матрицей W следует понимать
// совокупность  нижних  столбцовых  элементарных  матриц Lkc, которые описывают
// структуру и работу многоступенчатого сумматора.
// Минимальное количество входов I и II сумматора равно 2.
// ПЕРВЫЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов  последовательно уменьшается на единицу для каждой последующей ступени.
// Крайний левый выход предыдущей ступени сумматора подключается к каждому  эле-
// ментарному  сумматору следующей ступени сумматора, к второму входу элементар-
// ного сумматора подключается соответствующий вход многоступенчатого сумматора.
// Данный сумматор является АДАПТИВНЫМ, в нем происходит настройка весовых коэф-
// фициентов  по градиентному  алгоритиу в зависимости от входного воздействия и
// параметров  алгоритма  настройки. Вычисленные  комплексно-сопряженные весовые
// коэффициенты  передаются второму сумматору. Весовые коэффициенты первого сум-
// матора  хранятся  в матрице  W и  соответствуют нижней треугольной подматрице
// матрицы W по расположению.
// ВТОРОЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов последовательно увеличивается на единицу для каждой последующей ступени.
// На первой ступени сумматора размещается один модуль, на последней - N-1. Каж-
// дый элементарный  сумматор  (модуль) имеет  два входа и один выход. Один вход
// соответствует  выходам  первого  сумматора, другой вход для всех модулей i-ой
// ступени второго сумматора определяется по формуле - (i+1). Для первой ступени
// (с  одним  модулем) таким  входом будет 2 выход первого сумматора, для второй
// ступени - выход 3, для N-1 (последняя ступень) - выход N. Весовые коэффициен-
// ты в комплексно-сопряженном виде передаются ВТОРОМУ сумматору с ПЕРВОГО, хра-
// нятся в матрице W и соответствуют верхней треугольной подматрице матрицы W.
// Исходному состоянию сумматора соответствует ЕДИНИЧНАЯ матрица весовых коэффи-
// циентов W. В этом случае входной сигнал проходит через сумматор без изменений.
// Для аналитической модели многоступенчатого сумматора в качестве входного воз-
// действия  рассматривается  корреляционная матрица входного сигнала или вектор
// входного  сигнала. Настройка весовых коэффициентов (адаптация) сумматора осу-
// ществляется только по корреляционной матрице входного сигнала. Структура мат-
// рицы весовых коэффициентов и корреляционной матрицы входного  воздействия для
// многоступенчатого  весового сумматора на 5 входов (InCount = 5) выглядит сле-
// дующим образом:
// U = [U0 U1 U2 U3 U4] - вектор входного сигнала
//     | R00 R01 R02 R03 R04 |
//     | R10 R11 R12 R13 R14 |
// R = | R20 R21 R22 R23 R24 |, Rij = Ui*conj(Uj), Rji = conj(Rij).
//     | R30 R31 R32 R33 R34 |
//     | R40 R41 R42 R43 R44 |
// R - корреляционная матрица входного сигнала (воздействия)
//     |  1  W01 W02 W03 W04 |
//     | W10  1  W12 W13 W14 |
// W = | W20 W21  1  W23 W24 |, Wji = conj(Wij)
//     | W30 W31 W32  1  W34 |
//     | W40 W41 W42 W43  1  |
//Каждая  ступень I-го многоступенчатого весового сумматора имеет элемент норми-
//рования с прямой итерационной оценкой мощности. Модель функционирования элемен-
//та нормирования для i-ой ступени описывается формулой:
// Ki[n+1] = 1/Pi[n+1],
//1) для АНАЛИТИЧЕСКОЙ модели: Pi[n+1] = Pi[n] - (1/Tsc)*[Pi[n]-real(Rii)];
//2) для СТАТИСТИЧЕСКОЙ модели: Pi[n+1] = Pi[n] - (1/Tsc)*[Pi[n]-norm(Ui)];
// Pi - оценка мощности входного процесса.
// Начальное значение всех Pi=0, соответственно начальное значение всех Ki=1.
//В  соответствии с МЕТОДОМ НАИСКОРЕЙШЕГО СПУСКА и с учетом схемы стабилизации с
//прямой итерационной оценкой мощности для каждой ступени каждый весовой коэффи-
//циент вычисляется по формуле:
//1) для АНАЛИТИЧЕСКОЙ модели:
// Wij(n+1) = Wij(n) - (1/Tsbp)*Ki*[Wij(n)**Rjj + Rij], i > j
//2) для СТАТИСТИЧЕСКОЙ модели:
// Wij(n+1) = Wij(n) - (1/Tsbp)*Ki*conj(SumUij)*Ui, i > j
//******************************************************************************
class TDMultiStageSDA_DIPE_MIMOWSum : public TDMultiStageSDA_MIMOWSum {
//------------------------------------------------------------------------------
//Объявление защищенных членов-данных класса TDMultiStageSDA_DIPE_MIMOWSum
//------------------------------------------------------------------------------
protected:
 //Постоянная времени интегрирующего фильтра в цепи управления элемента
 //нормирования
 double Tsc;
 rvector Power;//Оценки мощности входного процесса для каждой ступени сумматора
//------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TDMultiStageSDA_DIPE_MIMOWSum
//------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TDMultiStageSDA_DIPE_MIMOWSum() : TDMultiStageSDA_MIMOWSum() {Init();};
 //Конструктор с аргументами
 TDMultiStageSDA_DIPE_MIMOWSum(ulong Size, const rvector& Arg = rvector())
 {Reset(); Set(Size,Arg);};
 TDMultiStageSDA_DIPE_MIMOWSum(ulong Size, double SBP_T, double SC_T)
 {Reset(); Set(Size,SBP_T,SC_T);};
 //Объявление конструктора копирования
 TDMultiStageSDA_DIPE_MIMOWSum(const TDMultiStageSDA_DIPE_MIMOWSum &WSum)
 {*this = WSum;};
 //Объявление деструктора класса
 ~TDMultiStageSDA_DIPE_MIMOWSum() {Reset();};
//------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TDMultiStageSDA_DIPE_MIMOWSum
//------------------------------------------------------------------------------
public:
 uint Type() const {return MS_DSDM_DIPE_MIMO_WSum;};//Тип весового сумматора
 //Параметры весового сумматора
 rvector& Param(rvector& Arg) const
 {if (IsReady()) {Arg.Set(2,ROW,false); Arg.Put(0,Tsbp); Arg.Put(1,Tsc);}
  else Arg.Set(0,ROW,false);
  return Arg;
 }
 double GetTsc() const {return Tsc;};//Постоянная времени элемента нормирования

 //*****************************************************************************
 //Установка параметров весового сумматора TDMultiStageSDA_DIPE_MIMOWSum
 //*****************************************************************************
 //Дополнительные параметры передаются в векторе Arg.
 //Arg[0] - Постоянная времени модуля весового сумматора Tsbp (Tsbp > 0)
 //Arg[1] - Постоянная времени элемента нормирования Tsc (Tsc > 0)
 void Set(ulong Size, const rvector& Arg)
 {SetInput(Size);//Установка размерности сумматора по входу
  //Установка постоянной времени модуля весового сумматора
  double value = (Arg.Size() > 0L) ? Arg.Get(0) : 100.0; SetTsbp(value);
  //Установка постоянной времени элемента нормирования
  value = (Arg.Size() > 1L) ? Arg.Get(1) : 10.0; SetTsc(value);
 };
 void Set(ulong Size, double SBP_T, double SC_T)
 {SetInput(Size); SetTsbp(SBP_T); SetTsc(SC_T);};

 //Установка постоянной времени элемента нормирования
 void SetTsc(double SC_T) {Tsc = (SC_T > 0) ? SC_T : 10.0;};

 //Установка числа входов (размерности по входу) весового сумматора
 void SetInput(ulong Size)
 {TDMultiStageSDA_MIMOWSum::SetInput(Size); Power.Set(Inputs(),ROW,0.0);};

 //Перегрузка оператора присваивания (=) для класса
 TDMultiStageSDA_DIPE_MIMOWSum& operator = (const TDMultiStageSDA_DIPE_MIMOWSum& WSum)
 {if (this != &WSum) {Set(WSum.Inputs(),WSum.GetTsbp(),WSum.GetTsc());}
  return *this;
 };
 //Начальная установка параметров весового сумматора для моделирования
 bool SimulateInit();
 //-----------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool Tuning(cmatrix& R);
 bool Tuning(cvector& V);
 //-----------------------------------------------------------------------------
 //Настройка коэффициентов нормирования сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool TuneNorm(const cmatrix& R);
 bool TuneNorm(const cvector& V);
 //-----------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса
 //-----------------------------------------------------------------------------
 string& Type(string& s) const //Тип весового сумматора
 {s = "MultiStageDigitSDA_DIPEStabCircuit_MIMOWeightSummator"; return s;};
  //Сокращенное наименование класса
 string& Clip(string& s) const
 {return s = "MultiStageDigSDA_DIPE_MIMOWeightSum";};
 //Формирование алгоритма стабилизации сумматора в виде символьной строки вида:
 //<Stabilizing Circuit: "name_string", [stabcircuit params];\n>
 string& GetStabCircuit(string& s) const
 {char buffer[80]; ostrstream text (buffer, sizeof(buffer));
  s = "StabCircuit: < Direct Iterative Power Estimation >, ";
  text << "Tsc = " << GetTsc() << ";" << endl << ends;
  s.append(text.str()); text.seekp(0);
  return s;
 };
 //Консольный ввод Tsc с проверкой введенного параметра и подтверждением
 //введенного значения
 void TscEdit(string& head, uint indent = 0);
 //Консольное редактирование параметров весового сумматора
 void Edit(bool ExtParam = true);
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator << (ostream& out, const TDMultiStageSDA_DIPE_MIMOWSum& WSum)
  {string s,head; return out << WSum.Properties(s,head);};
//------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TDMultiStageSDA_DIPE_MIMOWSum
//------------------------------------------------------------------------------
protected:
 //Начальная установка параметров весового сумматора
 void Init() {Tsc = 0.0; Power = rvector();};
 //Сброс всех параметров весового сумматора
 void Reset() {N = 0L; Tsbp = 0.0; Tsc = 0.0; W = cmatrix(); Power = rvector();};
};
//---------- Завершение объявления класса TDMultiStageSDA_DIPE_MIMOWSum ---------

//******************************************************************************
//            Объявление класса TDMultiStageSDA_EITPE_MIMOWSum
//Класс, производный от класса TDMultiStageSDA_MIMOWSum, представляет АНАЛИТИЧЕС-
//КУЮ  и СТАТИСТИЧЕСКУЮ  модели МНОГОСТУПЕНЧАТОГО весового сумматора с N-ВХОДАМИ
//и N-ВЫХОДАМИ с АДАПТИВНЫМ цифровым алгоритмом настройки весовых коэффициентов
//по МЕТОДУ НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм) и схемой стабилизации ди-
//намических параметров адаптивного сумматора. Свойства весового сумматора:
// 1. Конфигурация: N-входов - N-выходов;
// 2. Cхема построения сумматора: МНОГОСТУПЕНЧАТАЯ (MultiStage);
// 3. Алгоритм настройки: ЦИФРОВОЙ МЕТОД НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм);
// 4. Алгоритм стабилизации динамических параметров: ОЦЕНКА МОЩНОСТИ С БЕСКОНЕЧНЫМ
//    ВРЕМЕНЕМ ИНТЕГРИРОВАНИЯ (Endless Integration Time Power Estimation).
// Класс имеет три ВНУТРЕННИХ ПАРАМЕТРА:
// 1) Tsbp - постоянная времени интегрирующего фильтра элементарного модуля;
// 2) N - текущий шаг интегрирования (N > 0);
// 3) Ksc - постоянный коэффициент в схеме стабилизации (Ksc > 0).
// Количество ступеней сумматора определяется по формуле: Stages = 2*(N-1).
// Индексы выходов сумматора соответствуют индексам входов. Весовые коэффициенты
// сумматора хранятся в квадратной  матрице W размерности N. Диагональные элемен-
// ты матрицы  всегда  равны  единице. В нижних столбцовых элементарных матрицах
// компактно  хранящихся в матрице W содержатся весовые коэффициенты каждой сту-
// пени  первого  сумматора. В  правых  строковых элементарных матрицах хранятся
// комплексно-сопряженные значения весовых коэффициентов каждой ступени  второго
// сумматора. Каждая  ступень  двух сумматоров представляет из себя совокупность
// элементарных весовых сумматоров на два входа и один выход. Между двумя парал-
// лельно-последовательными  сумматорами расположен НОРМИРОВАТЕЛЬ. Нормирователь
// осуществляет операцию деления  каждого выхода  первого  сумматора на значение
// выходной мощности, соответствующего выхода. Данная операция является эквива-
// лентной  умножению обратной  диагональной матрицы InvD, полученной из матрицы
// R', на матрицу R'. Матрица R' = W*R, получается в ходе преобразования входной
// корреляционной матрицы R, первым  сумматором. Под матрицей W следует понимать
// совокупность  нижних  столбцовых  элементарных  матриц Lkc, которые описывают
// структуру и работу многоступенчатого сумматора.
// Минимальное количество входов I и II сумматора равно 2.
// ПЕРВЫЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов  последовательно уменьшается на единицу для каждой последующей ступени.
// Крайний левый выход предыдущей ступени сумматора подключается к каждому  эле-
// ментарному  сумматору следующей ступени сумматора, к второму входу элементар-
// ного сумматора подключается соответствующий вход многоступенчатого сумматора.
// Данный сумматор является АДАПТИВНЫМ, в нем происходит настройка весовых коэф-
// фициентов  по градиентному  алгоритиу в зависимости от входного воздействия и
// параметров  алгоритма  настройки. Вычисленные  комплексно-сопряженные весовые
// коэффициенты  передаются второму сумматору. Весовые коэффициенты первого сум-
// матора  хранятся  в матрице  W и  соответствуют нижней треугольной подматрице
// матрицы W по расположению.
// ВТОРОЙ ПАРАЛЛЕЛЬНО-ПОСЛЕДОВАТЕЛЬНЫЙ СУММАТОР. Количество  элементарных сумма-
// торов последовательно увеличивается на единицу для каждой последующей ступени.
// На первой ступени сумматора размещается один модуль, на последней - N-1. Каж-
// дый элементарный  сумматор  (модуль) имеет  два входа и один выход. Один вход
// соответствует  выходам  первого  сумматора, другой вход для всех модулей i-ой
// ступени второго сумматора определяется по формуле - (i+1). Для первой ступени
// (с  одним  модулем) таким  входом будет 2 выход первого сумматора, для второй
// ступени - выход 3, для N-1 (последняя ступень) - выход N. Весовые коэффициен-
// ты в комплексно-сопряженном виде передаются ВТОРОМУ сумматору с ПЕРВОГО, хра-
// нятся в матрице W и соответствуют верхней треугольной подматрице матрицы W.
// Исходному состоянию сумматора соответствует ЕДИНИЧНАЯ матрица весовых коэффи-
// циентов W. В этом случае входной сигнал проходит через сумматор без изменений.
// Для аналитической модели многоступенчатого сумматора в качестве входного воз-
// действия  рассматривается  корреляционная матрица входного сигнала или вектор
// входного  сигнала. Настройка весовых коэффициентов (адаптация) сумматора осу-
// ществляется только по корреляционной матрице входного сигнала. Структура мат-
// рицы весовых коэффициентов и корреляционной матрицы входного  воздействия для
// многоступенчатого  весового сумматора на 5 входов (InCount = 5) выглядит сле-
// дующим образом:
// U = [U0 U1 U2 U3 U4] - вектор входного сигнала
//     | R00 R01 R02 R03 R04 |
//     | R10 R11 R12 R13 R14 |
// R = | R20 R21 R22 R23 R24 |, Rij = Ui*conj(Uj), Rji = conj(Rij).
//     | R30 R31 R32 R33 R34 |
//     | R40 R41 R42 R43 R44 |
// R - корреляционная матрица входного сигнала (воздействия)
//     |  1  W01 W02 W03 W04 |
//     | W10  1  W12 W13 W14 |
// W = | W20 W21  1  W23 W24 |, Wji = conj(Wij)
//     | W30 W31 W32  1  W34 |
//     | W40 W41 W42 W43  1  |
//Каждая  ступень I-го многоступенчатого весового сумматора имеет элемент норми-
//рования с прямой итерационной оценкой мощности. Модель функционирования элемен-
//та нормирования для i-ой ступени описывается формулой:
// Ki[n+1] = 1/Pi[n+1],
//1) для АНАЛИТИЧЕСКОЙ модели: Pi[n+1] = Pi[n] - (Ksc/Ni)*[Pi[n]-real(Rii)];
//2) для СТАТИСТИЧЕСКОЙ модели: Pi[n+1] = Pi[n] - (Ksc/Ni)*[Pi[n]-norm(Ui)];
//Величина Ni увеличивается каждый раз на единицу. Начальное значение Ni = 1.
//Pi - оценка мощности входного процесса. Начальное значение всех Pi=0.
//В  соответствии с МЕТОДОМ НАИСКОРЕЙШЕГО СПУСКА и с учетом схемы стабилизации с
//прямой итерационной оценкой мощности для каждой ступени каждый весовой коэффи-
//циент вычисляется по формуле:
//1) для АНАЛИТИЧЕСКОЙ модели:
// Wij(n+1) = Wij(n) - (1/Tsbp)*Ki*[Wij(n)**Rjj + Rij], i > j
//2) для СТАТИСТИЧЕСКОЙ модели:
// Wij(n+1) = Wij(n) - (1/Tsbp)*Ki*conj(SumUij)*Ui, i > j
//******************************************************************************
class TDMultiStageSDA_EITPE_MIMOWSum : public TDMultiStageSDA_MIMOWSum {
//------------------------------------------------------------------------------
//Объявление защищенных членов-данных класса TDMultiStageSDA_EITPE_MIMOWSum
//------------------------------------------------------------------------------
protected:
 ulong Nsc;//Величина делителя в цепи управления элемента нормирования
 double Ksc;//Постоянная величина в цепи управления элемента нормирования
 rvector Power;//Оценки мощности входного процесса для каждой ступени сумматора
//------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TDMultiStageSDA_EITPE_MIMOWSum
//------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TDMultiStageSDA_EITPE_MIMOWSum() : TDMultiStageSDA_MIMOWSum() {Init();};
 //Конструктор с аргументами
 TDMultiStageSDA_EITPE_MIMOWSum(ulong Size, const rvector& Arg = rvector())
 {Reset(); Set(Size,Arg);};
 TDMultiStageSDA_EITPE_MIMOWSum(ulong Size, double SBP_T, double SC_K)
 {Reset(); Set(Size,SBP_T,SC_K);};
 //Объявление конструктора копирования
 TDMultiStageSDA_EITPE_MIMOWSum(const TDMultiStageSDA_EITPE_MIMOWSum &WSum)
 {*this = WSum;};
 //Объявление деструктора класса
 ~TDMultiStageSDA_EITPE_MIMOWSum() {Reset();};
//------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TDMultiStageSDA_EITPE_MIMOWSum
//------------------------------------------------------------------------------
public:
 uint Type() const {return MS_DSDM_EITPE_MIMO_WSum;};//Тип весового сумматора
 //Параметры весового сумматора
 rvector& Param(rvector& Arg) const
 {if (IsReady()) {Arg.Set(2,ROW,false); Arg.Put(0,Tsbp); Arg.Put(1,Ksc);}
  else Arg.Set(0,ROW,false);
  return Arg;
 }
 double GetKsc() const {return Ksc;};
 //*****************************************************************************
 //Установка параметров весового сумматора TDMultiStageSDA_EITPE_MIMOWSum
 //*****************************************************************************
 //Дополнительные параметры передаются в векторе Arg.
 //Arg[0] - Постоянная времени модуля весового сумматора Tsbp (Tsbp > 0)
 //Arg[1] - Постоянная величина в схеме стабилизации Ksc (Ksc > 0)
 void Set(ulong Size, const rvector& Arg)
 {SetInput(Size);//Установка размерности сумматора по входу
  //Установка постоянной времени модуля весового сумматора
  double value = (Arg.Size() > 0L) ? Arg.Get(0) : 100.0; SetTsbp(value);
  //Установка постоянной величины в схеме стабилизации весового сумматора
  value = (Arg.Size() > 1L) ? Arg.Get(1) : 1.0; SetKsc(value);
 };
 //Установка постоянной величины в схеме стабилизации
 void SetKsc(double value) {Ksc = (value > 0) ? value : 1.0;};
 //Установка внутренних параметров весового сумматора
 void Set(ulong Size, double SBP_T, double SC_K)
 {SetInput(Size); SetTsbp(SBP_T); SetKsc(SC_K);};

 //Установка числа входов (размерности по входу) весового сумматора
 void SetInput(ulong Size)
 {TDMultiStageSDA_MIMOWSum::SetInput(Size); Power.Set(Inputs(),ROW,0.0);};

 //Перегрузка оператора присваивания (=) для класса
 TDMultiStageSDA_EITPE_MIMOWSum& operator = (const TDMultiStageSDA_EITPE_MIMOWSum& WSum)
 {if (this != &WSum) {Set(WSum.Inputs(),WSum.GetTsbp(),WSum.GetKsc());}
  return *this;
 };
 //Начальная установка параметров весового сумматора для моделирования
 bool SimulateInit();
 //-----------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool Tuning(cmatrix& R);
 bool Tuning(cvector& V);
 //-----------------------------------------------------------------------------
 //Настройка коэффициентов нормирования сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool TuneNorm(const cmatrix& R);
 bool TuneNorm(const cvector& V);
 //-----------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса
 //-----------------------------------------------------------------------------
 string& Type(string& s) const //Тип весового сумматора
 {s = "MultiStageDigitSDA_EITPEStabCircuit_MIMOWeightSummator"; return s;};
  //Сокращенное наименование класса
 string& Clip(string& s) const
 {return s = "MultiStageDigSDA_EITPE_MIMOWeightSum";};
 //Формирование алгоритма стабилизации сумматора в виде символьной строки вида:
 //<Stabilizing Circuit: "name_string", [stabcircuit params];\n>
 string& GetStabCircuit(string& s) const
 {char buffer[80]; ostrstream text (buffer, sizeof(buffer));
  s = "StabCircuit: <Endless Integration Time Power Estimation> [";
  text << "Ksc=" << GetKsc() << "];" << endl << ends;
  s.append(text.str()); text.seekp(0);
  return s;
 };
 //Консольный ввод Ksc с проверкой введенного параметра и подтверждением ввода
 void KscEdit(string& head, uint indent = 0);
 //Консольное редактирование параметров весового сумматора
 void Edit(bool ExtParam = true);
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator << (ostream& out, const TDMultiStageSDA_EITPE_MIMOWSum& WSum)
  {string s,head; return out << WSum.Properties(s,head);};
//------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TDMultiStageSDA_EITPE_MIMOWSum
//------------------------------------------------------------------------------
protected:
 //Начальная установка параметров весового сумматора
 void Init() {Nsc = 0L; Ksc = 1.0; Power = rvector();};
 //Сброс всех параметров весового сумматора
 void Reset()
 {N = 0L; Tsbp = 0.0; Nsc = 0L; Ksc = 0; W = cmatrix(); Power = rvector();};
};
//---------- Завершение объявления класса TDMultiStageSDA_EITPE_MIMOWSum ---------

//****************************************************************************************
//      ОБЪЯВЛЕНИЕ КЛАССОВ ВЕСОВЫХ СУММАТОРОВ С N ВХОДАМИ И 1 ВЫХОДОМ
//****************************************************************************************
//****************************************************************************************
// Объявление абстрактного класса TMultiInSingleOutWeightSummator
// Данный класс является исходным для создания классов ВЕСОВЫХ СУММАТОРОВ со МНОЖЕСТВОМ
// ВХОДОВ и ОДНИМ ВЫХОДОМ. На основе данного класса проектируются классы для представления
// статистических и аналитических моделей весовых сумматоров с конфигурацией (N x 1), где
// N - количество входов сумматора. Классификация весовых сумматоров с многими входами и
// одним выходом осуществляется по следующим признакам:
// 1. По схеме построения сумматора: ОДНОСТУПЕНЧАТЫЕ (SingleStage) и МНОГОСТУПЕНЧАТЫЕ
//   (MultiStage);
// 2. По алгоритму настройки весовых коэффициентов в процессе адаптации.
//    Допускаются различные алгоритмы настройки, например ГРАДИЕНТНЫЕ АЛГОРИТМЫ
//    (Метод наискорейшего спуска - Method of Steepest Descent; алгоритм Ньютона
//     Newton's algorithm,...) и т.д.;
// 3. По схемам (алгоритмам) стабилизации динамических параметров сумматоров
//    (Stabilization Circuit [Algorithm]). Данные схемы могут использоваться в весовых
//     сумматорах с настраиваемыми весовыми коэффициентами во время работы (адаптивный
//     весовой сумматор).
// Новый класс производный от класса TMultiInSingleOutWeightSummator может отличаться от
// остальных производных классов всеми или одним из трех признаков. Следует отметить, что
// алгоритмы (схемы) стабилизации используются в классах, описывающих АДАПТИВНЫЕ весовые
// сумматоры (весовые коэффициенты таких сумматоров изменяются в процессе его работы при
// изменении внешних воздействий по заданному алгоритму). Допускается создание классов ве-
// совых сумматоров конфигурации N x 1 с заранее настроенными (фиксированными) весовыми
// коэффициентами. В этом случае, алгоритмы настройки весовых коэффициентов и стабилизации
// динамических параметров сумматоров не используются и могут быть выведены только два
// класса НЕАДАПТИВНЫХ ВЕСОВЫХ СУММАТОРА - ОДНОСТУПЕНЧАТЫЙ и МНОГОСТУПЕНЧАТЫЙ с N входами
// и одним выходом. В классах производных от данного базового класса в случае необходимости
// не все входы можно считать равнозначными. Вход сумматора с последним выходом является
// ОСОБЫМ по сравнению с другими. В адаптивных сумматорах с ОДНОЙ СТУПЕНЬЮ весовой коэффи-
// циент данного входа принимается равным единице и не изменяется при адаптации, а в адап-
// тивных сумматорах МНОГОСТУПЕНЧАТОЙ структуры данный вход является ВЫХОДОМ для такого
// сумматора.
//****************************************************************************************
class TMultiInSingleOutWeightSummator {
//---------------------------------------------------------------------------------------
// Объявление защищенных членов-данных класса TMultiInSingleOutWeightSummator
//---------------------------------------------------------------------------------------
protected:
 ulong InCount;//Количество входов весового сумматора
//---------------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TMultiInSingleOutWeightSummator
//---------------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TMISOWeightSum() {Reset();};
 //Конструктор с аргументами
 TMISOWeightSum(ulong Size, const rvector& Param = rvector()) {Set(Size,Param);};
 //Объявление конструктора копирования
 TMISOWeightSum(const TMISOWeightSum &WSum) {*this = WSum;};
 //Объявление деструктора класса
 virtual ~TMultiInSingleOutWeightSummator() {Reset();};
//---------------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TMultiInSingleOutWeightSummator
//---------------------------------------------------------------------------------------
public:
 //Определение работоспособности сумматора
 bool IsReady() const {return (InCount > 1L) ? true : false;};
 ulong Inputs() const {return InCount;};//Количество входов весового сумматора
 ulong Outputs() const {return 1;};//Количество выходов весового сумматора
 virtual ulong Stages() const = 0;
 //--------------------------------------------------------------------------------------
 //Установка параметров весового сумматора
 //--------------------------------------------------------------------------------------
 //Дополнительные параметры передаются в векторе Param в зависимости от конкретного типа
 //весового сумматора
 virtual void Set(ulong Size, const rvector& Param) = 0;
 //Установка числа входов (размерности по входу) весового сумматора
 virtual void SetInput(ulong Size) = 0;

 //Перегрузка оператора присваивания (=) для класса TMISOWeightSum
 TMISOWeightSum& operator =(const TMISOWeightSum& WSum)
 {if (this != &WSum) {SetInput(WSum.Inputs());}
  return *this;
 };
 //Начальная установка параметров весового сумматора для моделирования
 virtual bool SimulateInit() = 0;
 //-----------------------------------------------------------------------------
 //Передаточная функция весового сумматора (TRANSFER FUNCTION)
 //-----------------------------------------------------------------------------
 virtual double operator ()(cmatrix& R) const = 0;
 virtual double operator ()(cvector& V) const = 0;
 virtual rvector& operator ()(rvector& P, cmatrix& R) const = 0;
 virtual rvector& operator ()(rvector& P, cvector& V) const = 0;

 virtual double TF_WSum(cmatrix& R) const {return (*this)(R);};
 virtual double TF_WSum(cvector& V) const {return (*this)(V);};
 virtual rvector& TF_WSum(rvector& P, cmatrix& R) const {return (*this)(P,R);};
 virtual rvector& TF_WSum(rvector& P, cvector& V) const {return (*this)(P,V);};

 virtual double TestFunc(cvector& V) const = 0;
 //-----------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 virtual bool Tuning(cmatrix& R) = 0;
 virtual bool Tuning(cvector& V) = 0;
 //-----------------------------------------------------------------------------
 //Получение коэффициентов весового сумматора
 //-----------------------------------------------------------------------------
 virtual cmatrix& GetW(cmatrix& Weight) const = 0;
 virtual cvector& GetW(cvector& Weight, ulong Stage = 0L) const = 0;

 //-----------------------------------------------------------------------------
 //Установка коэффициентов весового сумматора
 //-----------------------------------------------------------------------------
 virtual bool SetW(const cmatrix& Weight) = 0;

 //-----------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса
 //-----------------------------------------------------------------------------
 virtual string& Type(string& s) const = 0;//Тип весового сумматора
 //Сокращенное наименование класса
 virtual string& Clip(string& s) const {return s = "MISOWeightSummator";};
 //Формирование конфигурации весового сумматора в виде символьной строки вида:
 //<CONFIGURATION: Dimension = <value> x 1, Stages = <value>;\n>
 virtual string& GetConfig(string& s) const
 {char buffer[80]; ostrstream text (buffer, sizeof(buffer));
  s = "Configuration: ";
  text << "Dimension = " << Inputs() << " x 1, Stages = " << Stages() << endl
       << ends; s.append(text.str()); text.seekp(0);
  return s;
 };
 //Формирование адаптивного алгоритма сумматора в виде символьной строки вида:
 //<Algorithm: "name_string", [algoritnm params];\n>
 virtual string& GetAdaptAlg(string& s) const = 0;
 //Формирование алгоритма стабилизации сумматора в виде символьной строки вида:
 //<Stabilizing Circuit: "name_string", [stabcircuit params];\n>
 virtual string& GetStabCircuit(string& s) const
 {return s.assign("Stabilizing Circuit: < Off >");};
 //Формирование свойств весового сумматора в виде символьной строки
 virtual string& Properties(string& s, string& head, uint indent = 0) const = 0;

 //Консольный ввод числа входов весового сумматора с проверкой введенного параметра и
 //подтверждением введенного значения
 virtual void InputEdit(string& head, uint indent = 0);
 //Консольный ввод параметров весового сумматора
 virtual void Edit(bool ExtParam = true) = 0;

 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator <<(ostream& out, const TMISOWeightSum& WSum)
 {string s,head; return out << WSum.Properties(s,head);};
//---------------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TMultiInSingleOutWeightSummator
//---------------------------------------------------------------------------------------
protected:
 //Начальная установка параметров весового сумматора
 void Reset() {InCount = 0L;};
};//Завершение объявления класса TMISOWeightSum
//------------- Завершение объявления класса TMultiInSingleOutWeightSummator -------------

//****************************************************************************************
//          Объявление класса TMultiStageSteepestDescentAlgMISOWeightSum
// Класс является производным от базового класса TMISOWeightSum. Он представляет
// АНАЛИТИЧЕСКУЮ и СТАТИСТИЧЕСКУЮ  модели МНОГОСТУПЕНЧАТОГО весового сумматора с
// N-ВХОДАМИ  и  ОДНИМ ВЫХОДОМ с АДАПТИВНЫМ алгоритмом настройки весовых коэффи-
// циентов по МЕТОДУ НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм), БЕЗ схемы ста-
// билизации  динамических параметров адаптивного сумматора. Данный весовой сум-
// матор характеризуется следующими свойствами:
// 1. Конфигурация: N-входов - ОДИН выход;
// 2. Cхема построения сумматора: МНОГОСТУПЕНЧАТАЯ (MultiStage);
// 3. Алгоритм настройки: МЕТОД НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм);
// 4. Алгоритм стабилизации динамических параметров: ОТСУТСТВУЕТ.
// Класс имеет два ВНУТРЕННИХ ПАРАМЕТРА:
// 1) Tsbp - шаг адаптации, который зависит от уровня внешнего сигнала на входе
//    сумматора;
// 2) Gsbp - коэффициент усиления в цепи обратной связи.
// Количество ступеней сумматора определяется по формуле: StageCount = InCount-1.
// Выходу  сумматора  соответствует вход сумматора с последним индексом. Весовые
// коэффициенты сумматора хранятся в квадратной  матрице W размерности InCount.
// Диагональные  элементы матрицы всегда равны единице. В нижних столбцовых эле-
// ментарных матрицах компактно хранящихся в  матрице W содержатся весовые коэф-
// фициенты  каждой  ступени сумматора. В правых строковых элементарных матрицах
// хранятся комплексно-сопряженные значения весовых коэффициентов каждой ступени
// сумматора. Каждая ступень сумматора представляет из себя совокупность элемен-
// тарных  весовых сумматоров на два входа и один выход. Количество элементарных
// сумматоров последовательно уменьшается на единицу для каждой последующей сту-
// пени сумматора. Крайний левый выход предыдущей ступени сумматора подключается
// к каждому элементарному сумматору следующей ступени сумматора, к второму вхо-
// ду элементарного сумматора подключается соответствующий вход многоступенчатого
// сумматора. Минимальное количество входов многоступенчатого сумматора равно 2.
// Исходному состоянию сумматора соответствует ЕДИНИЧНАЯ матрица весовых коэффи-
// циентов W. В этом случае входной сигнал проходит через сумматор без изменений.
// Для аналитической модели многоступенчатого сумматора в качестве входного воз-
// действия  рассматривается  корреляционная матрица входного сигнала или вектор
// входного  сигнала. Настройка весовых коэффициентов (адаптация) сумматора осу-
// ществляется только по корреляционной матрице входного сигнала. Структура мат-
// рицы весовых коэффициентов и корреляционной матрицы входного  воздействия для
// многоступенчатого  весового сумматора на 5 входов (InCount = 5) выглядит сле-
// дующим образом:
// U = [U0 U1 U2 U3 U4] - вектор входного сигнала
//     | R00 R01 R02 R03 R04 |
//     | R10 R11 R12 R13 R14 |
// R = | R20 R21 R22 R23 R24 |, Rij = Ui*conj(Uj), Rji = conj(Rij).
//     | R30 R31 R32 R33 R34 |
//     | R40 R41 R42 R43 R44 |
// R - корреляционная матрица входного сигнала (воздействия)
//     |  1  W01 W02 W03 W04 |
//     | W10  1  W12 W13 W14 |
// W = | W20 W21  1  W23 W24 |, Wji = conj(Wij)
//     | W30 W31 W32  1  W34 |
//     | W40 W41 W42 W43  1  |
//В соответствии с МЕТОДОМ НАИСКОРЕЙШЕГО СПУСКА каждый весовой коэффициент вычисляется по
//формуле:
// Wij(n+1) = Wij(n) - (1/Tsbp)*[Wij(n)*(1+Gsbp*Rjj) + Gsbp*Rij], i > j
//****************************************************************************************
class TMultiStageSteepestDescentAlgMISOWeightSum : public TMISOWeightSum {
//------------------------------------------------------------------------------
//Объявление защищенных членов-данных класса TMultiStageSDAlgMISOWSum
//------------------------------------------------------------------------------
protected:
 double Tsbp;//Шаг адаптации алгоритма настройки весовых коэффициентов
 double Gsbp;//Коэффициент усиления в цепи обратной связи
 cmatrix W;//Весовые коэффициенты многоступенчатого сумматора
//------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TMultiStageSDAlgMISOWSum
//------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TMultiStageSDAlgMISOWSum() : TMISOWeightSum() {Reset();};
 //Конструктор с аргументами
 TMultiStageSDAlgMISOWSum(ulong Size, const rvector& Param = rvector())
 {Reset(); Set(Size,Param);};
 TMultiStageSDAlgMISOWSum(ulong Size, double T, double G)
 {Reset(); Set(Size,T,G);};
 //Объявление конструктора копирования
 TMultiStageSDAlgMISOWSum(const TMultiStageSDAlgMISOWSum &WSum) {*this = WSum;};
 //Объявление деструктора класса
 virtual ~TMultiStageSteepestDescentAlgMISOWeightSum() {Reset();};
//------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TMultiStageSDAlgMISOWSum
//------------------------------------------------------------------------------
public:
 ulong Stages() const {return InCount-1;};//Количество ступеней сумматора
 double GetTsbp() const {return Tsbp;}; //Значение шага адаптации
 double GetGsbp() const {return Gsbp;}; //Коэффициент усиления
 //*****************************************************************************
 //Установка параметров весового сумматора
 //*****************************************************************************
 //Дополнительные параметры передаются в векторе Param.
 //Param[0] - значение шага адаптации T (T != 0)
 //Param[1] - значение коэффициента усиления G (произвольное значение)
 virtual void Set(ulong Size, const rvector& Param)
 {SetInput(Size);//Установка размерности сумматора по входу
  double T = (Param.Size() > 0L) ? Param.Get(0) : 1.0e6;
  SetTsbp(T);//Установка шага адаптации
  double G = (Param.Size() > 1L) ? Param.Get(1) : 1.0;
  SetGsbp(G);//Установка коэффициента усиления
 };
 void Set(ulong Size, double T, double G)
 {SetInput(Size); SetTsbp(T); SetGsbp(G);};
 //Установка шага адаптации (постоянная времени автокомпенсатора)
 void SetTsbp(double T) {Tsbp = (T > 0) ? T : 1.0e6;};
 //Установка коэффициента усиления (крутизна регулировочной характеристики)
 void SetGsbp(double G) {Gsbp = G;};
 //Установка числа входов (размерности по входу) весового сумматора
 virtual void SetInput(ulong Size);
 //Перегрузка оператора присваивания (=) для класса
 TMultiStageSDAlgMISOWSum& operator =(const TMultiStageSDAlgMISOWSum& WSum)
 {if (this != &WSum) {Set(WSum.Inputs(),WSum.GetTsbp(),WSum.GetGsbp());}
  return *this;
 };
 //Начальная установка параметров весового сумматора для моделирования
 virtual bool SimulateInit();
 //-----------------------------------------------------------------------------
 //Передаточная функция весового сумматора (TRANSFER FUNCTION)
 //-----------------------------------------------------------------------------
 double operator ()(cmatrix& R) const;
 double operator ()(cvector& V) const;
 rvector& operator ()(rvector& P, cmatrix& R) const;
 rvector& operator ()(rvector& P, cvector& V) const;
 double TestFunc(cvector& V) const;
 //-----------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 virtual bool Tuning(cmatrix& R);
 virtual bool Tuning(cvector& V);
 //-----------------------------------------------------------------------------
 //Получение коэффициентов весового сумматора
 //-----------------------------------------------------------------------------
 cmatrix& GetW(cmatrix& Weight) const {Weight = W; return Weight;};
 cvector& GetW(cvector& Weight, ulong Stage = 0L) const;
 //-----------------------------------------------------------------------------
 //Установка коэффициентов весового сумматора
 //-----------------------------------------------------------------------------
 bool SetW(const cmatrix& Weight);
 //-----------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса
 //-----------------------------------------------------------------------------
 virtual string& Type(string& s) const //Тип весового сумматора
 {s = "MultiInSingleOut MultiStage Adaptive WeightSummator"; return s;};
  //Сокращенное наименование класса
 virtual string& Clip(string& s) const
 {return s = "MultiStageSDAlgMISOWeightSum";};
 //Формирование адаптивного алгоритма сумматора в виде символьной строки вида:
 //<Algorithm: <Steepest Descent Method>, Tadapt = <value>;\n>
 virtual string& GetAdaptAlg(string& s) const
 {char buffer[80]; ostrstream text (buffer, sizeof(buffer));
  s = "Algorithm: <Steepest Descent Method>, ";
  text << "Tsbp = " << GetTsbp() << ends;
  s.append(text.str()); text.seekp(0);
  text << ", Gsbp = " << GetGsbp() << endl << ends;
  s.append(text.str()); text.seekp(0);
  return s;
 };

 //Формирование свойств весового сумматора в виде символьной строки
 virtual string& Properties(string& s, string& head, uint indent = 0) const;

 //Консольный ввод шага адаптации с проверкой введенного параметра и подтверждением
 //введенного значения
 void TsbpEdit(string& head, uint indent = 0);
 //Консольный ввод коэффициента усиления G и подтверждение введенного значения
 void GsbpEdit(string& head, uint indent = 0);
 //Консольное редактирование параметров весового сумматора
 virtual void Edit(bool ExtParam = true);
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator << (ostream& out, const TMultiStageSDAlgMISOWSum& WSum)
 {string s,head; return out << WSum.Properties(s,head);};
//------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TMultiStageSDAlgMISOWSum
//------------------------------------------------------------------------------
protected:
 //Начальная установка параметров весового сумматора
 void Reset() {InCount = 0L; Tsbp = 0.0; Gsbp = 0.0; W = cmatrix();};

};//Завершение объявления класса TMultiStageSDAlgMISOWSum
//-- Завершение объявления класса TMultiStageSteepestDescentAlgMISOWeightSum --

//******************************************************************************
//               Объявление класса TMultiStageSDA_DMPE_MISOWSum
// Класс является производным от класса TMultiStageSDAlgMISOWSum. Он реализует
// АНАЛИТИЧЕСКУЮ и СТАТИСТИЧЕСКУЮ  модели МНОГОСТУПЕНЧАТОГО весового сумматора с
// N-ВХОДАМИ  и  ОДНИМ ВЫХОДОМ с АДАПТИВНЫМ алгоритмом настройки весовых коэффи-
// циентов по МЕТОДУ НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм) и схемой стаби-
// лизации динамических параметров адаптивного сумматора. Данный весовой сум-
// матор характеризуется следующими свойствами:
// 1. Конфигурация: N-входов - ОДИН выход;
// 2. Cхема построения сумматора: МНОГОСТУПЕНЧАТАЯ (MultiStage);
// 3. Алгоритм настройки: МЕТОД НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм);
// 4. Алгоритм стабилизации динамических параметров: ПРЯМАЯ МГНОВЕННАЯ ОЦЕНКА
//    МОЩНОСТИ (Direct Momentary Power Estimation)
// Класс имеет два ВНУТРЕННИХ ПАРАМЕТРА:
// 1) Tsbp - шаг адаптации, который зависит от уровня внешнего сигнала на входе
//    сумматора;
// 2) Gsbp - коэффициент усиления в цепи обратной связи.
// Количество ступеней сумматора определяется по формуле: StageCount = InCount-1.
// Выходу  сумматора  соответствует вход сумматора с последним индексом. Весовые
// коэффициенты сумматора хранятся в квадратной  матрице W размерности InCount.
// Диагональные  элементы матрицы всегда равны единице. В нижних столбцовых эле-
// ментарных матрицах компактно хранящихся в  матрице W содержатся весовые коэф-
// фициенты  каждой  ступени сумматора. В правых строковых элементарных матрицах
// хранятся комплексно-сопряженные значения весовых коэффициентов каждой ступени
// сумматора. Каждая ступень сумматора представляет из себя совокупность элемен-
// тарных  весовых сумматоров на два входа и один выход. Количество элементарных
// сумматоров последовательно уменьшается на единицу для каждой последующей сту-
// пени сумматора. Крайний левый выход предыдущей ступени сумматора подключается
// к каждому элементарному сумматору следующей ступени сумматора, к второму вхо-
// ду элементарного сумматора подключается соответствующий вход многоступенчатого
// сумматора. Минимальное количество входов многоступенчатого сумматора равно 2.
// Исходному состоянию сумматора соответствует ЕДИНИЧНАЯ матрица весовых коэффи-
// циентов W. В этом случае входной сигнал проходит через сумматор без изменений.
// Для аналитической модели многоступенчатого сумматора в качестве входного воз-
// действия  рассматривается  корреляционная матрица входного сигнала или вектор
// входного  сигнала. Настройка весовых коэффициентов (адаптация) сумматора осу-
// ществляется только по корреляционной матрице входного сигнала. Структура мат-
// рицы весовых коэффициентов и корреляционной матрицы входного  воздействия для
// многоступенчатого  весового сумматора на 5 входов (InCount = 5) выглядит сле-
// дующим образом:
// U = [U0 U1 U2 U3 U4] - вектор входного сигнала
//     | R00 R01 R02 R03 R04 |
//     | R10 R11 R12 R13 R14 |
// R = | R20 R21 R22 R23 R24 |, Rij = Ui*conj(Uj), Rji = conj(Rij).
//     | R30 R31 R32 R33 R34 |
//     | R40 R41 R42 R43 R44 |
// R - корреляционная матрица входного сигнала (воздействия)
//     |  1  W01 W02 W03 W04 |
//     | W10  1  W12 W13 W14 |
// W = | W20 W21  1  W23 W24 |, Wji = conj(Wij)
//     | W30 W31 W32  1  W34 |
//     | W40 W41 W42 W43  1  |
//Каждая ступень многоступенчатого весового сумматора имеет элемент нормирования
//с прямой мгновенной оценкой мощности. Модель функционирования элемента  норми-
//ро для i-ой ступени описывается формулой:
//1) для АНАЛИТИЧЕСКОЙ модели: Ki[n] = 1/[1+Gsbp*Rii];
//2) для СТАТИСТИЧЕСКОЙ модели: Ki[n] = 1/[norm(Ui)];
// Rii = norm(Ui)- оценка мощности входного процесса для i-ой ступени.
//В соответствии с МЕТОДОМ НАИСКОРЕЙШЕГО СПУСКА и с учетом схемы стабилизации с
//прямой мгновенной оценкой мощности каждый весовой коэффициент вычисляется по
// формуле:
//1) для АНАЛИТИЧЕСКОЙ модели:
//   Wij(n+1) = Wij(n) - (1/Tsbp)*[Wij(n)*(1+Ki*Gsbp*Rjj) + Ki*Gsbp*Rij], i > j
//2) для СТАТИСТИЧЕСКОЙ модели:
//   Wij(n+1) = Wij(n) - (1/Tsbp)*[Wij(n) + Ki*Gsbp*conj(SumUij)*Ui], i > j
//SumUij - выходное напряжение с элементарного весового сумматора, расположенного
//на i-ой ступени для j-го входа;
//Ui - задающее напряжение для i-ой ступени весового сумматора.
//******************************************************************************
class TMultiStageSDA_DMPE_MISOWSum : public TMultiStageSDAlgMISOWSum {
//------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TMultiStageSDA_DMPE_MISOWSum
//------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TMultiStageSDA_DMPE_MISOWSum() : TMultiStageSDAlgMISOWSum() {};
 //Конструктор с аргументами
 TMultiStageSDA_DMPE_MISOWSum(ulong Size, const rvector& Param = rvector()) :
 TMultiStageSDAlgMISOWSum(Size, Param) {};
 TMultiStageSDA_DMPE_MISOWSum(ulong Size, double Step, double Gain) :
 TMultiStageSDAlgMISOWSum(Size, Step, Gain) {};
 //Объявление конструктора копирования
 TMultiStageSDA_DMPE_MISOWSum(const TMultiStageSDA_DMPE_MISOWSum &WSum)
 {*this = WSum;};
 //Объявление деструктора класса
 ~TMultiStageSDA_DMPE_MISOWSum() {Reset();};
//------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TMultiStageSDA_DMPE_MISOWSum
//------------------------------------------------------------------------------
public:
 //Перегрузка оператора присваивания (=) для класса
 TMultiStageSDA_DMPE_MISOWSum& operator =
 (const TMultiStageSDA_DMPE_MISOWSum& WSum)
 {if (this != &WSum) {Set(WSum.Inputs(),WSum.GetTsbp(),WSum.GetGsbp());}
  return *this;
 };
 //-----------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool Tuning(cmatrix& R);
 bool Tuning(cvector& V);
 //-----------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса TMultiStageSDA_DMPE_MISOWSum
 //-----------------------------------------------------------------------------
 string& Type(string& s) const //Тип весового сумматора
 {s = "MultiStageSDA_DirectMomentaryPowerEstimation_MISOWeightSummator"; return s;};
  //Сокращенное наименование класса
 string& Clip(string& s) const {return s = "MultiStageSDA_DMPE_MISOWSum";};
 //Формирование алгоритма стабилизации сумматора в виде символьной строки вида:
 //<Stabilizing Circuit: "name_string", [stabcircuit params];\n>
 string& GetStabCircuit(string& s) const
 {s = "Stabilizing Circuit: < Direct Momentary Power Estimation >\n"; return s;};
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator << (ostream& out, const TMultiStageSDA_DMPE_MISOWSum& WSum)
  {string s,head; return out << WSum.Properties(s,head);};
};//Завершение объявления класса TMultiStageSDA_DMPE_MISOWSum
//--------- Завершение объявления класса TMultiStageSDA_DMPE_MISOWSum ---------

//******************************************************************************
//            Объявление класса TMultiStageSDA_DIPE_MISOWSum
// Класс является производным от класса TMultiStageSDAlgMISOWSum. Он представляет
// АНАЛИТИЧЕСКУЮ и СТАТИСТИЧЕСКУЮ  модели МНОГОСТУПЕНЧАТОГО весового сумматора с
// N-ВХОДАМИ  и  ОДНИМ ВЫХОДОМ с АДАПТИВНЫМ алгоритмом настройки весовых коэффи-
// циентов по МЕТОДУ НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм), с схемой  ста-
// билизации  динамических параметров адаптивного сумматора. Данный весовой сум-
// матор характеризуется следующими свойствами:
// 1. Конфигурация: N-входов - ОДИН выход;
// 2. Cхема построения сумматора: МНОГОСТУПЕНЧАТАЯ (MultiStage);
// 3. Алгоритм настройки: МЕТОД НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм);
// 4. Алгоритм стабилизации динамических параметров: ПРЯМАЯ ИТЕРАЦИОННАЯ ОЦЕНКА
//    МОЩНОСТИ (Direct Iterative Power Estimation).
// Класс имеет четыре ВНУТРЕННИХ ПАРАМЕТРА:
// 1) Tsbp - постоянная времени интегрирующего фильтра элементарного модуля;
// 2) Gsbp - коэффициент усиления в цепи обратной связи элементарного модуля;
// 3) Tsc - постоянная времени в цепи управления элемента нормирования;
// Количество ступеней сумматора определяется по формуле: StageCount = InCount-1.
// Выходу  сумматора  соответствует вход сумматора с последним индексом. Весовые
// коэффициенты сумматора хранятся в квадратной  матрице W размерности InCount.
// Диагональные  элементы матрицы всегда равны единице. В нижних столбцовых эле-
// ментарных матрицах компактно хранящихся в  матрице W содержатся весовые коэф-
// фициенты  каждой  ступени сумматора. В правых строковых элементарных матрицах
// хранятся комплексно-сопряженные значения весовых коэффициентов каждой ступени
// сумматора. Каждая ступень сумматора представляет из себя совокупность элемен-
// тарных  весовых сумматоров на два входа и один выход. Количество элементарных
// сумматоров последовательно уменьшается на единицу для каждой последующей сту-
// пени сумматора. Крайний левый выход предыдущей ступени сумматора подключается
// к каждому элементарному сумматору следующей ступени сумматора, к второму вхо-
// ду элементарного сумматора подключается соответствующий вход многоступенчатого
// сумматора. Минимальное количество входов многоступенчатого сумматора равно 2.
// Исходному состоянию сумматора соответствует ЕДИНИЧНАЯ матрица весовых коэффи-
// циентов W. В этом случае входной сигнал проходит через сумматор без изменений.
// Для аналитической модели многоступенчатого сумматора в качестве входного воз-
// действия  рассматривается  корреляционная матрица входного сигнала или вектор
// входного  сигнала. Настройка весовых коэффициентов (адаптация) сумматора осу-
// ществляется только по корреляционной матрице входного сигнала. Структура мат-
// рицы весовых коэффициентов и корреляционной матрицы входного  воздействия для
// многоступенчатого  весового сумматора на 5 входов (InCount = 5) выглядит сле-
// дующим образом:
// U = [U0 U1 U2 U3 U4] - вектор входного сигнала
//     | R00 R01 R02 R03 R04 |
//     | R10 R11 R12 R13 R14 |
// R = | R20 R21 R22 R23 R24 |, Rij = Ui*conj(Uj), Rji = conj(Rij).
//     | R30 R31 R32 R33 R34 |
//     | R40 R41 R42 R43 R44 |
// R - корреляционная матрица входного сигнала (воздействия)
//     |  1  W01 W02 W03 W04 |
//     | W10  1  W12 W13 W14 |
// W = | W20 W21  1  W23 W24 |, Wji = conj(Wij)
//     | W30 W31 W32  1  W34 |
//     | W40 W41 W42 W43  1  |
//Каждая ступень многоступенчатого весового сумматора имеет элемент нормирования
//с  прямой итерационной оценкой мощности. Модель функционирования элемента нор-
//мирования для i-ой ступени описывается формулой:
// Ki[n+1] = 1/Pi[n+1],
//1) для АНАЛИТИЧЕСКОЙ модели: Pi[n+1] = Pi[n] - (1/Tsc)*[Pi[n]-real(Rii)];
//2) для СТАТИСТИЧЕСКОЙ модели: Pi[n+1] = Pi[n] - (1/Tsc)*[Pi[n]-norm(Ui)];
// Pi - оценка мощности входного процесса.
// Начальное значение всех Pi=0, соответственно начальное значение всех Ki=1.
//В  соответствии с МЕТОДОМ НАИСКОРЕЙШЕГО СПУСКА и с учетом схемы стабилизации с
//прямой итерационной оценкой мощности для каждой ступени каждый весовой коэффи-
//циент вычисляется по формуле:
//1) для АНАЛИТИЧЕСКОЙ модели:
// Wij(n+1) = Wij(n) - (1/Tsbp)*[Wij(n)*(1+Ki*Gsbp*Rjj) + Ki*Gsbp*Rij], i > j
//2) для СТАТИСТИЧЕСКОЙ модели:
// Wij(n+1) = Wij(n) - (1/Tsbp)*[Wij(n) + Ki*Gsbp*conj(SumUij)*Ui], i > j
//******************************************************************************
class TMultiStageSDA_DIPE_MISOWSum : public TMultiStageSDAlgMISOWSum {
//------------------------------------------------------------------------------
//Объявление защищенных членов-данных класса TMultiStageSDA_DIPE_MISOWSum
//------------------------------------------------------------------------------
protected:
 //Постоянная времени интегрирующего фильтра в цепи управления элемента
 //нормирования
 double Tsc;
 rvector Power;//Оценки мощности входного процесса для каждой ступени сумматора
//------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TMultiStageSDA_DIPE_MISOWSum
//------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TMultiStageSDA_DIPE_MISOWSum() : TMultiStageSDAlgMISOWSum() {Init();};
 //Конструктор с аргументами
 TMultiStageSDA_DIPE_MISOWSum(ulong Size, const rvector& Arg = rvector())
 {Reset(); Set(Size,Arg);};
 TMultiStageSDA_DIPE_MISOWSum(ulong Size, double SBP_T, double SBP_G, double SC_T)
 {Reset(); Set(Size,SBP_T,SBP_G,SC_T);};
 //Объявление конструктора копирования
 TMultiStageSDA_DIPE_MISOWSum(const TMultiStageSDA_DIPE_MISOWSum &WSum)
 {*this = WSum;};
 //Объявление деструктора класса
 ~TMultiStageSDA_DIPE_MISOWSum() {Reset();};
//------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TMultiStageSDA_DIPE_MISOWSum
//------------------------------------------------------------------------------
public:
 double GetTsc() const {return Tsc;};//Постоянная времени элемента нормирования

 //*****************************************************************************
 //Установка параметров весового сумматора TMultiStageSDA_DIPE_MISOWSum
 //*****************************************************************************
 //Дополнительные параметры передаются в векторе Arg.
 //Arg[0] - Постоянная времени модуля весового сумматора Tsbp (Tsbp > 0)
 //Arg[1] - Коэффициент усиления модуля весового сумматора Gsbp (произвольное)
 //Arg[2] - Постоянная времени элемента нормирования Tsc (Tsc > 0)
 void Set(ulong Size, const rvector& Arg)
 {SetInput(Size);//Установка размерности сумматора по входу
  //Установка постоянной времени модуля весового сумматора
  double value = (Arg.Size() > 0L) ? Arg.Get(0) : 100.0; SetTsbp(value);
  //Установка коэффициента усиления модуля весового сумматора
  value = (Arg.Size() > 1L) ? Arg.Get(1) : 1.0; SetGsbp(value);
  //Установка постоянной времени элемента нормирования
  value = (Arg.Size() > 2L) ? Arg.Get(2) : 10.0; SetTsc(value);
 };
 void Set(ulong Size, double SBP_T, double SBP_G, double SC_T)
 {SetInput(Size); SetTsbp(SBP_T); SetGsbp(SBP_G); SetTsc(SC_T);};

 //Установка постоянной времени элемента нормирования
 void SetTsc(double SC_T) {Tsc = (SC_T > 0) ? SC_T : 10.0;};

 //Установка числа входов (размерности по входу) весового сумматора
 void SetInput(ulong Size)
 {TMultiStageSDAlgMISOWSum::SetInput(Size);
  Power.Resize(InCount); Power = 0.0;
 };

 //Перегрузка оператора присваивания (=) для класса
 TMultiStageSDA_DIPE_MISOWSum& operator = (const TMultiStageSDA_DIPE_MISOWSum& WSum)
 {if (this != &WSum)
  {Set(WSum.Inputs(),WSum.GetTsbp(),WSum.GetGsbp(),WSum.GetTsc());}
  return *this;
 };
 //Начальная установка параметров весового сумматора для моделирования
 bool SimulateInit();
 //-----------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool Tuning(cmatrix& R);
 bool Tuning(cvector& V);
 //-----------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса
 //-----------------------------------------------------------------------------
 string& Type(string& s) const //Тип весового сумматора
 {s = "MultiStageSDA_DIPEStabCircuit_MISOWeightSummator"; return s;};
  //Сокращенное наименование класса
 string& Clip(string& s) const
 {return s = "MultiStageSDA_DIPE_MISOWeightSum";};
 //Формирование алгоритма стабилизации сумматора в виде символьной строки вида:
 //<Stabilizing Circuit: "name_string", [stabcircuit params];\n>
 string& GetStabCircuit(string& s) const
 {char buffer[80]; ostrstream text (buffer, sizeof(buffer));
  s = "StabCircuit: < Direct Iterative Power Estimation >, ";
  text << "Tsc = " << GetTsc() << ";" << endl << ends;
  s.append(text.str()); text.seekp(0);
  return s;
 };
 //Консольный ввод Tsc с проверкой введенного параметра и подтверждением
 //введенного значения
 void TscEdit(string& head, uint indent = 0);
 //Консольное редактирование параметров весового сумматора
 void Edit(bool ExtParam = true);
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator << (ostream& out, const TMultiStageSDA_DIPE_MISOWSum& WSum)
        {string s,head; return out << WSum.Properties(s,head);};
//------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TMultiStageSDA_DIPE_MISOWSum
//------------------------------------------------------------------------------
protected:
 //Начальная установка параметров весового сумматора
 void Init() {Tsc = 0.0; Power = rvector();};
 //Сброс всех параметров весового сумматора
 void Reset()
 {InCount = 0L; Tsbp = 0.0; Gsbp = 0.0; Tsc = 0.0; W = cmatrix(); Power = rvector();};
};
//---------- Завершение объявления класса TMultiStageSDA_DIPE_MISOWSum ---------

//******************************************************************************
//            Объявление класса TMultiStageSDAlgENCCStabCircuitMISOWSum
// Класс является производным от класса TMultiStageSDAlgMISOWSum. Он представляет
// АНАЛИТИЧЕСКУЮ и СТАТИСТИЧЕСКУЮ  модели МНОГОСТУПЕНЧАТОГО весового сумматора с
// N-ВХОДАМИ  и  ОДНИМ ВЫХОДОМ с АДАПТИВНЫМ алгоритмом настройки весовых коэффи-
// циентов по МЕТОДУ НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм), с схемой  ста-
// билизации  динамических параметров адаптивного сумматора. Данный весовой сум-
// матор характеризуется следующими свойствами:
// 1. Конфигурация: N-входов - ОДИН выход;
// 2. Cхема построения сумматора: МНОГОСТУПЕНЧАТАЯ (MultiStage);
// 3. Алгоритм настройки: МЕТОД НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм);
// 4. Алгоритм стабилизации динамических параметров: ЭКСПОНЕНЦИАЛЬНОЕ НОРМИРОВА-
//    НИЕ в СОПРЯЖЕННОЙ ЦЕПИ (Exponential Normalization In Conjugated Circuit).
// Класс имеет четыре ВНУТРЕННИХ ПАРАМЕТРА:
// 1) Tsbp - постоянная времени интегрирующего фильтра элементарного модуля;
// 2) Gsbp - коэффициент усиления в цепи обратной связи элементарного модуля;
// 3) Tsc - постоянная времени интегрирующего фильтра в цепи управления элемента
//          нормирования;
// 4) Gsc - крутизна регулировочной характеристики экспоненциального элемента
//          нормирования.
// Количество ступеней сумматора определяется по формуле: StageCount = InCount-1.
// Выходу  сумматора  соответствует вход сумматора с последним индексом. Весовые
// коэффициенты сумматора хранятся в квадратной  матрице W размерности InCount.
// Диагональные  элементы матрицы всегда равны единице. В нижних столбцовых эле-
// ментарных матрицах компактно хранящихся в  матрице W содержатся весовые коэф-
// фициенты  каждой  ступени сумматора. В правых строковых элементарных матрицах
// хранятся комплексно-сопряженные значения весовых коэффициентов каждой ступени
// сумматора. Каждая ступень сумматора представляет из себя совокупность элемен-
// тарных  весовых сумматоров на два входа и один выход. Количество элементарных
// сумматоров последовательно уменьшается на единицу для каждой последующей сту-
// пени сумматора. Крайний левый выход предыдущей ступени сумматора подключается
// к каждому элементарному сумматору следующей ступени сумматора, к второму вхо-
// ду элементарного сумматора подключается соответствующий вход многоступенчатого
// сумматора. Минимальное количество входов многоступенчатого сумматора равно 2.
// Исходному состоянию сумматора соответствует ЕДИНИЧНАЯ матрица весовых коэффи-
// циентов W. В этом случае входной сигнал проходит через сумматор без изменений.
// Для аналитической модели многоступенчатого сумматора в качестве входного воз-
// действия  рассматривается  корреляционная матрица входного сигнала или вектор
// входного  сигнала. Настройка весовых коэффициентов (адаптация) сумматора осу-
// ществляется только по корреляционной матрице входного сигнала. Структура мат-
// рицы весовых коэффициентов и корреляционной матрицы входного  воздействия для
// многоступенчатого  весового сумматора на 5 входов (InCount = 5) выглядит сле-
// дующим образом:
// U = [U0 U1 U2 U3 U4] - вектор входного сигнала
//     | R00 R01 R02 R03 R04 |
//     | R10 R11 R12 R13 R14 |
// R = | R20 R21 R22 R23 R24 |, Rij = Ui*conj(Uj), Rji = conj(Rij).
//     | R30 R31 R32 R33 R34 |
//     | R40 R41 R42 R43 R44 |
// R - корреляционная матрица входного сигнала (воздействия)
//     |  1  W01 W02 W03 W04 |
//     | W10  1  W12 W13 W14 |
// W = | W20 W21  1  W23 W24 |, Wji = conj(Wij)
//     | W30 W31 W32  1  W34 |
//     | W40 W41 W42 W43  1  |
//Каждая ступень многоступенчатого весового сумматора имеет элемент нормирования
//с экспоненциальной регулировочной характеристикой и логарифмическим усилителем
//в цепи управления. Модель функционирования элемента нормирования для i-ой сту-
//пени описывается формулой:
// Ki[n+1] = 10^[-Gsc*log10(Pi)],
// Pi[n+1] = Pi[n] - (1/Tsc)*[Pi[n]-real(Rii)], real(Rii) <=> norm(Ui)
// Pi - оценка мощности входного процесса.
// Начальное значение всех Pi=1, соответственно начальное значение всех Ki=1.
//В  соответствии с МЕТОДОМ НАИСКОРЕЙШЕГО СПУСКА и с учетом схемы стабилизации с
//экспоненциальным  нормированием  в сопряженной цепи каждый весовой коэффициент
//вычисляется по формуле:
// Wij(n+1) = Wij(n) - (1/Tsbp)*[Wij(n)*(1+Ki*Gsbp*Rjj) + Ki*Gsbp*Rij], i > j
//******************************************************************************
class TMultiStageSDA_ENCC_MISOWSum : public TMultiStageSDAlgMISOWSum {
//------------------------------------------------------------------------------
//Объявление защищенных членов-данных класса TMultiStageSDA_ENCC_MISOWSum
//------------------------------------------------------------------------------
protected:
 //Постоянная времени интегрирующего фильтра в цепи управления элемента
 //нормирования
 double Tsc;
 //Крутизна регулировочной характеристики экспоненциального элемента нормирования
 double Gsc;
 rvector Power;//Оценки мощности входного процесса для каждой ступени сумматора
 rvector K;//Коэффициенты нормирования для каждой ступени сумматора
//------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TMultiStageSDA_ENCC_MISOWSum
//------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TMultiStageSDA_ENCC_MISOWSum() : TMultiStageSDAlgMISOWSum() {Init();};
 //Конструктор с аргументами
 TMultiStageSDA_ENCC_MISOWSum(ulong Size, const rvector& Arg = rvector())
 {Reset(); Set(Size,Arg);};
 TMultiStageSDA_ENCC_MISOWSum(ulong Size, double SBP_T, double SBP_G,
  double SC_T, double SC_G) {Reset(); Set(Size,SBP_T,SBP_G,SC_T,SC_G);};
 //Объявление конструктора копирования
 TMultiStageSDA_ENCC_MISOWSum(const TMultiStageSDA_ENCC_MISOWSum &WSum)
 {*this = WSum;};
 //Объявление деструктора класса
 ~TMultiStageSDA_ENCC_MISOWSum() {Reset();};
//------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TMultiStageSDA_ENCC_MISOWSum
//------------------------------------------------------------------------------
public:
 double GetTsc() const {return Tsc;};//Постоянная времени элемента нормирования
 double GetGsc() const {return Gsc;};//Коэффициент усиления элемента нормирования

 //*****************************************************************************
 //Установка параметров весового сумматора TMultiStageSDA_ENCC_MISOWSum
 //*****************************************************************************
 //Дополнительные параметры передаются в векторе Arg.
 //Arg[0] - Постоянная времени модуля весового сумматора Tsbp (Tsbp > 0)
 //Arg[1] - Коэффициент усиления модуля весового сумматора Gsbp (произвольное)
 //Arg[2] - Постоянная времени элемента нормирования Tsc (Tsc > 0)
 //Arg[3] - Коэффициент усиления элемента нормирования Gsc (произвольное)
 void Set(ulong Size, const rvector& Arg)
 {SetInput(Size);//Установка размерности сумматора по входу
  //Установка постоянной времени модуля весового сумматора
  double value = (Arg.Size() > 0L) ? Arg.Get(0) : 1000.0; SetTsbp(value);
  //Установка коэффициента усиления модуля весового сумматора
  value = (Arg.Size() > 1L) ? Arg.Get(1) : 50.0; SetGsbp(value);
  //Установка постоянной времени элемента нормирования
  value = (Arg.Size() > 2L) ? Arg.Get(2) : 10.0; SetTsc(value);
  //Установка коэффициента усиления элемента нормирования
  value = (Arg.Size() > 3L) ? Arg.Get(3) : 1.0; SetGsc(value);
 };
 void Set(ulong Size, double SBP_T, double SBP_G, double SC_T, double SC_G)
 {SetInput(Size); SetTsbp(SBP_T); SetGsbp(SBP_G); SetTsc(SC_T); SetGsc(SC_G);};

 //Установка постоянной времени элемента нормирования
 void SetTsc(double SC_T) {Tsc = (SC_T > 0) ? SC_T : 10.0;};
 //Установка коэффициента усиления модуля весового сумматора
 void SetGsc(double SC_G) {Gsc = SC_G;};

 //Установка числа входов (размерности по входу) весового сумматора
 void SetInput(ulong Size)
 {TMultiStageSDAlgMISOWSum::SetInput(Size);
  Power.Resize(InCount); Power = 1.0; K.Resize(InCount); K = 0.0;
 };

 //Перегрузка оператора присваивания (=) для класса
 TMultiStageSDA_ENCC_MISOWSum& operator = (const TMultiStageSDA_ENCC_MISOWSum& WSum)
 {if (this != &WSum)
  {Set(WSum.Inputs(),WSum.GetTsbp(),WSum.GetGsbp(),WSum.GetTsc(),WSum.GetGsc());}
  return *this;
 };
 //Начальная установка параметров весового сумматора для моделирования
 bool SimulateInit();
 //-----------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool Tuning(cmatrix& R);
 bool Tuning(cvector& V);
 //-----------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса
 //-----------------------------------------------------------------------------
 string& Type(string& s) const //Тип весового сумматора
 {s = "MultiStageSDA_ENCCStabCircuit_MISOWeightSummator"; return s;};
  //Сокращенное наименование класса
 string& Clip(string& s) const
 {return s = "MultiStageSDA_ENCC_MISOWeightSum";};
 //Формирование алгоритма стабилизации сумматора в виде символьной строки вида:
 //<Stabilizing Circuit: "name_string", [stabcircuit params];\n>
 string& GetStabCircuit(string& s) const
 {char buffer[80]; ostrstream text (buffer, sizeof(buffer));
  s = "StabCircuit: < ExpNormInConjCircuit >, ";
  text << "Tsc = " << GetTsc() << ends;
  s.append(text.str()); text.seekp(0);
  text << ", Gsc = " << GetGsc() << endl << ends;
  s.append(text.str()); text.seekp(0);
  return s;
 };
 //Консольный ввод Tsc с проверкой введенного параметра и подтверждением
 //введенного значения
 void TscEdit(string& head, uint indent = 0);
 //Консольный ввод Gsc и подтверждение введенного значения
 void GscEdit(string& head, uint indent = 0);
 //Консольное редактирование параметров весового сумматора
 void Edit(bool ExtParam = true);
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator << (ostream& out, const TMultiStageSDA_ENCC_MISOWSum& WSum)
        {string s,head; return out << WSum.Properties(s,head);};
//------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TMultiStageSDA_ENCC_MISOWSum
//------------------------------------------------------------------------------
protected:
 //Начальная установка параметров весового сумматора
 void Init() {Tsc = 0.0; Gsc = 0.0; Power = rvector(); K = rvector();};
 //Сброс всех параметров весового сумматора
 void Reset()
 {InCount = 0L; Tsbp = 0.0; Gsbp = 0.0; Tsc = 0.0; Gsc = 0.0;
  W = cmatrix(); Power = rvector(); K = rvector();
 };
};
//---------- Завершение объявления класса TMultiStageSDA_ENCC_MISOWSum ---------

//****************************************************************************************
//         Объявление класса TSingleStageSteepestDescentAlgMISOWeightSum
// Класс является производным от базового класса TMISOWeightSum. Он представляет
// АНАЛИТИЧЕСКУЮ и СТАТИСТИЧЕСКУЮ  модели ОДНОСТУПЕНЧАТОГО весового сумматора с
// N-ВХОДАМИ  и  ОДНИМ ВЫХОДОМ с АДАПТИВНЫМ алгоритмом настройки весовых коэффи-
// циентов по МЕТОДУ НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм), БЕЗ схемы ста-
// билизации  динамических параметров адаптивного сумматора. Данный весовой сум-
// матор характеризуется следующими свойствами:
// 1. Конфигурация: N-входов - ОДИН выход;
// 2. Cхема построения сумматора: ОДНОСТУПЕНЧАТАЯ (SingleStage);
// 3. Алгоритм настройки: МЕТОД НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм);
// 4. Алгоритм стабилизации динамических параметров: ОТСУТСТВУЕТ.
// Класс имеет два ВНУТРЕННИХ ПАРАМЕТРА:
// 1) T - шаг адаптации, который зависит от уровня внешнего сигнала на входе
//    сумматора;
// 2) G - коэффициент усиления в цепи обратной связи.
// Адаптивный  сумматор  имеет одну ступень. Каждый вход сумматора умножается на
// соответствующий  каждому  входу  весовой коэффициент, полученные произведения
// суммируются  и выходу сумматора соответствует суммарное значение его взвешен-
// ных  входов. Вес сумматора соответствующий входу сумматора с последним индек-
// сом всегда равен ЕДИНИЦЕ и в процессе адаптации не изменяется. К данному входу
// подключается  ОСНОВНОЙ  канал  адаптивной LAA. Весовые коэффициенты хранятся в
// векторе-столбце W, размерность которого определяется числом  входов сумматора.
// Кроме  того, имеется  вектор-строка  весовых коэффициентов TrW с размерностью
// равной весовому вектору W. Значения элементов TrW комплексно-сопряжены к зна-
// чениям элементов вектора W. Вектор TrW необходим для быстрого  вычисления пе-
// редаточной  функции  сумматора, когда в качестве входного воздействия исполь-
// зуется корреляционная матрица входного сигнала или вектор входного сигнала.
// Минимальное  количество  входов  одноступенчатого весового сумматора равно 2.
// Исходным (начальным)  состоянием  весового состояния соответствует вектор W c
// НУЛЕВЫМИ  значениями  элементов, кроме последнего элемента равного ЕДИНИЦЕ. В
// этом случае  входной сигнал, поступающий на последний вход сумматора проходит
// без изменений. Для аналитической модели одноступенчатого весового сумматора в
// качестве входного воздействия рассматривается корреляционная матрица входного
// сигнала или вектор входного сигнала.
// Настройка весовых коэффициентов (адаптация) сумматора может осуществляться по
// корреляционной матрице или вектору входного сигнала. Структура вектора весовых
// коэффициентов и корреляционной матрицы входного воздействия для одноступенча-
// того весового сумматора на 5 входов (InCount = 5) выглядит следующим образом.
// U = [U0 U1 U2 U3 U4] - вектор входного сигнала
//     | R00 R01 R02 R03 R04 |     | R00 R01 R02 R03 |     | R04 |
//     | R10 R11 R12 R13 R14 |     | R10 R11 R12 R13 |     | R14 |     |A  P  |
// R = | R20 R21 R22 R23 R24 | A = | R20 R21 R22 R23 | P = | R24 | R = |      |
//     | R30 R31 R32 R33 R34 |     | R30 R31 R32 R33 |     | R34 |     |~P R44|
//     | R40 R41 R42 R43 R44 |
// Rij = Ui*conj(Uj), Rji = conj(Rij);
// ~P - вектор-строка комплексно-сопряженный с вектором-столбцом P;
// R - корреляционная матрица входного сигнала (воздействия)
// W = | W0  W1 W2 W3 1 | = | Waux 1 |; Waux = | W0 W1 W2 W3 |
// Исходя из особой структуры данного весового сумматора, в котором последнему
// входу соответствует вес всегда равный 1, данный вход называется ОСНОВНЫМ, а
// остальные входы - ВСПОМОГАТЕЛЬНЫМИ. Матрица R для такого сумматора называется
// РАСШИРЕННОЙ корреляционной матрицей; матрица A - корреляционной матрицей меж-
// ду вспомогательными каналами (входами) сумматора; вектор P - вектор взаимных
// корреляций между основным и вспомогательными входами сумматора.
// Весовой вектор одноступенчатого адаптивного сумматора в соответствии  с МЕТО-
// ДОМ НАИСКОРЕЙШЕГО СПУСКА вычисляется по формуле:
// Waux(n+1) = Waux(n) - 1/T * (A*Waux(n) + P),
// Waux(n) - весовой вектор-столбец соответствующий вспомогательным входам на
// n-ом шаге адаптации. Выходное значение вычисляется по формуле:
// Uout = SUM[Ui*Wi] или Uout = TrW * R * W.
//******************************************************************************
class TSingleStageSteepestDescentAlgMISOWeightSum : public TMISOWeightSum {
//------------------------------------------------------------------------------
//Объявление защищенных членов-данных класса TSingleStageSDAlgMISOWSum
//------------------------------------------------------------------------------
protected:
 double T;//Шаг адаптации алгоритма настройки весовых коэффициентов
 double G;//Коэффициент усиления цепи обратной связи
 cvector W;//Весовые коэффициенты одноступенчатого сумматора c ОСНОВНЫМ ВХОДОМ
 cvector TrW;//Комплексно-сопряженная вектор-строка к вектору-столбцу W
//------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TSingleStageSDAlgMISOWSum
//------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TSingleStageSDAlgMISOWSum() : TMISOWeightSum() {Reset();};
 //Конструктор с аргументами
 TSingleStageSDAlgMISOWSum(ulong Size, const rvector& Param = rvector())
 {Reset(); Set(Size,Param);};
 TSingleStageSDAlgMISOWSum(ulong Size, double Step, double Gain)
 {Reset(); Set(Size,Step,Gain);};
 //Объявление конструктора копирования
 void TSingleStageSDAlgMISOWtSum(const TSingleStageSDAlgMISOWSum &WSum)
 {*this = WSum;};
 //Объявление деструктора класса
 ~TSingleStageSteepestDescentAlgMISOWeightSum() {Reset();};
//------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TSingleStageSDAlgMISOWSum
//------------------------------------------------------------------------------
public:
 ulong Stages() const {return 1L;};//Количество ступеней сумматора
 double Tadapt() const {return T;}; //Значение шага адаптации
 double Gain() const {return G;}; //Коэффициент усиления
 //*****************************************************************************
 //Установка параметров весового сумматора
 //*****************************************************************************
 //Дополнительные параметры передаются в векторе Param.
 //Param[0] - значение шага адаптации T (T != 0)
 //Param[1] - коэффициент усиления G (произвольное значение)
 void Set(ulong Size, const rvector& Param)
 {SetInput(Size);//Установка размерности сумматора по входу
  double Step = (Param.Size() > 0L) ? Param.Get(0) : 1.0;
  SetStep(Step);//Установка шага адаптации
  double Gain = (Param.Size() > 1L) ? Param.Get(1) : 1.0;
  SetGain(Gain);//Установка коэффициента усиления
 };
 void Set(ulong Size, double Step, double Gain)
 {SetInput(Size); SetStep(Step); SetGain(Gain);};
 //Установка шага адаптации
 void SetStep(double Step) {T = (Step > 0) ? Step : 1.0;};
 //Установка коэффициента усиления
 void SetGain(double Gain) {G = Gain;};
 //Установка числа входов (размерности по входу) весового сумматора
 void SetInput(ulong Size)
 {InCount = Size;W.Set(Size,COL,complex(0,0)); TrW.Set(Size,ROW,complex(0,0));
  //Начальная установка коэффициентов весового сумматора
  W.Put(W.Size()-1,1.0); TrW.Put(W.Size()-1,1.0);
 };
 //Перегрузка оператора присваивания (=) для класса
 TSingleStageSDAlgMISOWSum& operator =(const TSingleStageSDAlgMISOWSum& WSum)
 {if (this != &WSum) {Set(WSum.Inputs(),WSum.Tadapt(),WSum.Gain());}
  return *this;
 };
 //Начальная установка параметров весового сумматора для моделирования
 bool SimulateInit();
 //-----------------------------------------------------------------------------
 //Передаточная функция весового сумматора (TRANSFER FUNCTION)
 //-----------------------------------------------------------------------------
 double operator ()(cmatrix& R) const;
 double operator ()(cvector& V) const;
 rvector& operator ()(rvector& P, cmatrix& R) const;
 rvector& operator ()(rvector& P, cvector& V) const;
 double TestFunc(cvector& V) const;
 //-----------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //-----------------------------------------------------------------------------
 bool Tuning(cmatrix& R);
 bool Tuning(cvector& V);
 //-----------------------------------------------------------------------------
 //Получение коэффициентов весового сумматора
 //-----------------------------------------------------------------------------
 cmatrix& GetW(cmatrix& Weight) const;
 cvector& GetW(cvector& Weight, ulong Stage = 0L) const
 {Weight = W; return Weight;};
 //-----------------------------------------------------------------------------
 //Установка коэффициентов весового сумматора
 //-----------------------------------------------------------------------------
 bool SetW(const cmatrix& Weight);
 //-----------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса
 //-----------------------------------------------------------------------------
 string& Type(string& s) const //Тип весового сумматора
 {s = "MultiInSingleOut SingleStage Adaptive WeightSummator"; return s;};
  //Сокращенное наименование класса
 string& Clip(string& s) const
 {return s = "SingleStageSDAlgMISOWeightSum";};
 //Формирование адаптивного алгоритма сумматора в виде символьной строки вида:
 //<Algorithm: <Steepest Descent Method>, Tadapt = <value>;\n>
 string& GetAdaptAlg(string& s) const
 {char buffer[80]; ostrstream text (buffer, sizeof(buffer));
  s = "Algorithm: <Steepest Descent Method>, ";
  text << "Tadapt = " << Tadapt() << ends;
  s.append(text.str()); text.seekp(0);
  text << ", Gain = " << Gain() << endl << ends;
  s.append(text.str()); text.seekp(0);
  return s;
 };
 //Формирование свойств весового сумматора в виде символьной строки
 string& Properties(string& s, string& head, uint indent = 0) const;

 //Консольный ввод шага адаптации с проверкой введенного параметра и подтверждением
 //введенного значения
 void TadaptEdit(string& head, uint indent = 0);
 //Консольный ввод коэффициента усиления G и подтверждение введенного значения
 void GainEdit(string& head, uint indent = 0);
 //Консольное редактирование параметров весового сумматора
 void Edit(bool ExtParam = true);
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator << (ostream& out, const TSingleStageSDAlgMISOWSum& WSum)
        {string s,head; return out << WSum.Properties(s,head);};
//------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TSingleStageSDAlgMISOWSum
//------------------------------------------------------------------------------
protected:
 //Начальная установка параметров весового сумматора
 void Reset() {InCount = 0L; T = 0.0; G = 0.0; W = cvector(); TrW = cvector();};

};//Завершение объявления класса TSingleStageSDAlgMISOWSum
//------- Завершение объявления класса TSingleStageSteepestDescentAlgMISOWeightSum -------

//****************************************************************************************
//         Объявление класса TSingleStage_SDA_LCC_MISOWSum
// Класс является производным от базового класса TMISOWeightSum. Он представляет АНАЛИТИ-
// ЧЕСКУЮ и СТАТИСТИЧЕСКУЮ  модели ОДНОСТУПЕНЧАТОГО весового сумматора с N-ВХОДАМИ и ОДНИМ
// ВЫХОДОМ, АДАПТИВНЫМ алгоритмом настройки весовых коэффициентов по МЕТОДУ НАИСКОРЕЙШЕГО
// СПУСКА (градиентный алгоритм) со схемой ЛИНЕЙНОГО ОГРАНИЧЕНИЯ ВЕСОВОГО ВЕКТОРА (LCC),
// БЕЗ схемы стабилизации динамических параметров адаптивного сумматора. Весовой сумматор
// характеризуется следующими свойствами:
// 1. Конфигурация: N-входов - ОДИН выход;
// 2. Cхема построения сумматора: ОДНОСТУПЕНЧАТАЯ (SingleStage);
// 3. Алгоритм настройки: МЕТОД НАИСКОРЕЙШЕГО СПУСКА (градиентный алгоритм);
// 4. Схема линейного ограничения весового вектора (LCC - Linear Constraint Circuit);
// 5. Алгоритм стабилизации динамических параметров: ОТСУТСТВУЕТ.
// Класс имеет четыре ВНУТРЕННИХ ПАРАМЕТРА:
// 1) TdF - шаг адаптации, который зависит от уровня внешнего сигнала на входе сумматора;
// 2) G - коэффициент усиления в цепи обратной связи;
// 3) ElimDirects - направления исключения (угловые координаты), при размещении в которых
//    источников излучений адаптивный алгоритм не будет подавлять данные источники (форми-
//    ровать нули диаграммы направленности в данных направлениях);
// 4) P(N-1xN-1) - квадратная комплексная матрица коэффициентов схемы линейного ограничения
//    весового вектора, которая обеспечивает передачу через весовой сумматор сигналов без
//    их подавления с направлений, заданных в ElimDirects. Размерность P определяется чис-
//    лом вспомогательных каналов сумматора.
//
// Данный весовой сумматор аналогичен TSingleStageSDAlgMISOWSum, за исключением LCC. Если
// направления исключения в объекте класса не заданы, то работа двух классов будет совер-
// шенна идентична. Применение LCC позволяет использовать пространственную селекцию в самом
// весовом сумматоре, что даст эффект подавления аддитивной помехи при свободном прохожде-
// нии сигнала, если его угловое положение будет включено в ElimDirects.
// Матрица P вычисляется следующим образом:
// P = I - C*Inv(trC*C)*trC, где
// I - единичная диагональная матрица размерности (N-1);
// Inv(trC*C) - обратная матрица матричного произведения trC*C;
// trC - транспонированная комплексно-сопряженная матрица к матрице C;
// C(N-1xM) - прямоугольная комплексная матрица. Число столбцов M соответствует количеству
// направлений исключения, число строк (N-1) - количеству вспомогательных каналов сумматора.
// Все столбцы матрицы C должны соответствовать различным угловым координатам. Матрица C
// для двух направлений исключения и трех вспомогательных каналов С(3,2) записывается так:
//          | c11 c12 |
// С(3,2) = | c21 c22 |, где c(i,j) - фазовый набег в i-ом канале относительно ОСНОВНОГО
//          | c31 c32 |  канала для j-го направления исключения.
// Коэффициенты с(i,j) зависят от пространственного размещения элементов антенной решетки,
// каналы которой подключаются к весовому сумматору и выбранных направлений исключения.
// Данные коэффициенты принимают комплексные значения и при подключении сумматора к
// эквидистантной LAA вычислются следующим образом:
// с(i,k) = EXP[j*(2*PI*d*(i-Origin)*sin(ElimDirects[k])], где
// j - мнимая единица [sqrt(-1)];
// d - относительное в длинах волн расстояние между соседними элементами LAA;
// Origin - порядковый номер отсчетного элемента LAA;
// ElimDirects[k] - значение угловой координаты для k-го направления исключения.
// Для неэквидистантной LAA величина: d*(i-Origin) заменяется, в общем случае, функцией
// одной переменной вида d(i), которая в зависимости от номера канала i должна вычислять
// относительное расстояние в длинах волн между i-м и ОСНОВНЫМ каналом LAA.
//
// Адаптивный сумматор имеет одну ступень. Каждый вход сумматора умножается на собственный
// весовой коэффициент, полученные произведения суммируются и на выходе сумматора получаем
// суммарное значение его взвешенных входов. Вес ПОСЛЕДНЕГО входа сумматора всегда равен
// ЕДИНИЦЕ и в процессе адаптации не изменяется. К входу с последним индексом подключается
// ОСНОВНОЙ канал адаптивной LAA. Весовые коэффициенты хранятся в векторе-столбце W с раз-
// мерностью равной числу входов сумматора. Комплексно-сопряженные веса хранятся в векторе
// TrW одинаковой расмерности с W. Вектор TrW необходим для быстрого вычисления передаточ-
// ной функции сумматора при использовании ковариационной матрицы в качестве входного воз-
// действия. Минимальное количество входов одноступенчатого весового сумматора равно 2.
// Начальному состоянию сумматора соответствует вектор W c НУЛЕВЫМИ значениями элементов,
// кроме последнего равного ЕДИНИЦЕ. В этом случае входной сигнал, поступающий на вход сум-
// матора проходит без изменений. При аналитическом (численном) моделировании входное воз-
// действие задается ковариационной матрицей входного сигнала, а при статистическом: входной
// сигнал задается в векторной форме. Настройка весов (адаптация) сумматора осуществляется
// по ковариационной матрице или вектору входного сигнала. Структура весового вектора и
// ковариационной матрицы входного воздействия для одноступенчатого весового сумматора на
// 5 входов (InCount = 5) выглядит следующим образом:
// U = [U0 U1 U2 U3 U4] - вектор входного сигнала
//     | R00 R01 R02 R03 R04 |     | R00 R01 R02 R03 |     | R04 |
//     | R10 R11 R12 R13 R14 |     | R10 R11 R12 R13 |     | R14 |     |A  B  |
// R = | R20 R21 R22 R23 R24 | A = | R20 R21 R22 R23 | B = | R24 | R = |      |
//     | R30 R31 R32 R33 R34 |     | R30 R31 R32 R33 |     | R34 |     |~B R44|
//     | R40 R41 R42 R43 R44 |
// Rij = Ui*conj(Uj), Rji = conj(Rij);
// ~B  - вектор-строка комплексно-сопряженный с вектором-столбцом B;
// R   - ковариационная матрица входного сигнала (воздействия);
// R44 - элемент матрицы R, равный входной мощности ОСНОВНОГО канала сумматора.
// W = | W0  W1 W2 W3 1 | = | Waux 1 |; Waux = | W0 W1 W2 W3 |
// Исходя из структуры весового сумматора, в котором последнему входу соответствует вес
// всегда равный 1, данный вход называется ОСНОВНЫМ, а остальные входы - ВСПОМОГАТЕЛЬНЫМИ.
// Матрица R для такого сумматора называется РАСШИРЕННОЙ ковариационной матрицей;
// матрица A - ковариационной матрицей между вспомогательными каналами (входами) сумматора;
// вектор B - вектор взаимных ковариаций между основным и вспомогательными входами сумматора.
// Весовой вектор одноступенчатого адаптивного сумматора по МЕТОДОМ НАИСКОРЕЙШЕГО СПУСКА с
// учетом схемы алгоритма ЛИНЕЙНОГО ОГРАНИЧЕНИЯ его весов вычисляется по формуле:
// Waux(n+1) = P*[Waux(n) - 1/T * (A*Waux(n) + B)], где
// Waux(n) - весовой вектор-столбец вспомогательных входов на n-ом шаге адаптации;
// P - матрица коэффициентов схемы (алгоритма) линейного ограничения весового вектора.
// Выходное значение вычисляется по формуле: Uout = SUM[Ui*Wi] или Uout = TrW * R * W.
//****************************************************************************************
class TSingleStage_SDA_LCC_MISOWSum : public TMISOWeightSum {
//----------------------------------------------------------------------------------------
//Объявление защищенных членов-данных класса TSingleStage_SDA_LCC_MISOWSum
//----------------------------------------------------------------------------------------
protected:
 double TdF;//Шаг адаптации алгоритма настройки весовых коэффициентов
 double G;//Коэффициент усиления цепи обратной связи
 std::set<double> ElimDirects;//Направления исключения (в градусах)
 cmatrix P;//Коэффициенты схемы линейного ограничения весового вектора

 cvector W;//Весовые коэффициенты одноступенчатого сумматора c ОСНОВНЫМ ВХОДОМ
 cvector TrW;//Комплексно-сопряженная вектор-строка к вектору-столбцу W
//----------------------------------------------------------------------------------------
//ОБЪЯВЛЕНИЕ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TSingleStage_SDA_LCC_MISOWSum
//----------------------------------------------------------------------------------------
public:
 //Конструктор по умолчанию
 TSingleStage_SDA_LCC_MISOWSum() : TMISOWeightSum() {Reset();};

 //Конструкторы с аргументами
 TSingleStage_SDA_LCC_MISOWSum(ulong Size, const rvector& Param = rvector())
 {Reset(); Set(Size,Param);};

 TSingleStage_SDA_LCC_MISOWSum(ulong Size, double Step, double Gain)
 {Reset(); SetInput(Size); SetSDA(Step,Gain);};

 TSingleStage_SDA_LCC_MISOWSum(ulong Size, const rvector& Params, const TUnEqLAA_ODA& LAA)
 {Reset(); Set(Size,Params); CalcFactorsLCC(LAA);};

 //Объявление конструктора копирования
 TSingleStage_SDA_LCC_MISOWSum(const TSingleStage_SDA_LCC_MISOWSum &WSum) {*this = WSum;};

 //Объявление деструктора класса
 ~TSingleStage_SDA_LCC_MISOWSum() {Reset();};
//----------------------------------------------------------------------------------------
//Объявление общедоступных членов-функций класса TSingleStage_SDA_LCC_MISOWSum
//----------------------------------------------------------------------------------------
public:
 ulong Stages() const {return 1L;};//Количество ступеней сумматора
 double Step() const {return TdF;}; //Значение шага адаптации
 double Gain() const {return G;}; //Коэффициент усиления
 //Проверка на использование LCC
 bool IsLCC() const {return (P.IsZeroSize()) ? false : true;};
 //Количество установленных направлений исключения
 ulong GetElimDirects() const {return ElimDirects.size();};
 //Копирование значений направлений исключения в вектор V
 bool GetElimDirects(rvector& V) const;
 //Копирование значений всех параметров весового сумматора в вектор V
 //V[0] <-- TdF; V[1] <-- G; V[2]..V[N-1] <-- ElimDirects
 ulong GetParams(rvector& V) const;
 //Получение коэффициентов схемы линейного ограничения весового вектора W сумматора
 bool GetFactorsLCC(cmatrix& C) const;
 //---------------------------------------------------------------------------------------
 //Получение коэффициентов весового сумматора
 //---------------------------------------------------------------------------------------
 cmatrix& GetW(cmatrix& Weight) const;
 cvector& GetW(cvector& Weight, ulong Stage = 0L) const {Weight = W; return Weight;};

 //***************************************************************************************
 //Установка параметров весового сумматора
 //***************************************************************************************
 //Установка числа входов (размерности по входу) весового сумматора
 void SetInput(ulong Size);
 //Установка шага адаптации
 double SetStep(double Step) {return TdF = (Step > 0) ? Step : 1.0;};
 //Установка коэффициента усиления
 double SetGain(double Gain) {return G = Gain;};
 //Установка параметров алгоритма адаптации: TdF и G
 void SetSDA(double Step, double Gain) {SetStep(Step); SetGain(Gain);};
 //Установка направлений исключения для настройки LCC
 ulong SetElimDirects(const rvector& Params, ulong start_index = 0, bool lClearOld = false);
 //Установка параметров алгоритма адаптации и схемы линейного ограничения из вектора Params
 //Param[0] - значение шага адаптации TdF (TdF != 0)
 //Param[1] - коэффициент усиления G (произвольное значение)
 //Param[2] ... Param[N-1] - направления исключения
 void SetParams(const rvector& Params);
 //Установка размерности сумматора по входу и его параметров из вектора Params
 void Set(ulong Size, const rvector& Params)
 {SetInput(Size);//Установка размерности сумматора по входу
  SetParams(Params);//Установка параметров адаптивного алгоритма и LCC
 };
 //Установка коэффициентов схемы линейного ограничения
 bool SetFactorsLCC(const cmatrix& C);
 //Расчет коэффициентов LCC при условии подключения сумматора к эквидистантной LAA
 //класса TUnEqLAA_ODA
 bool CalcFactorsLCC(const TUnEqLAA_ODA& LAA);
 //Расчет коэффициентов LCC при условии подключения сумматора к предпроцессору класса
 //TPreProcessor_MISO_SF
 bool CalcFactorsLCC(const TPreProcessor_MISO_SF& Preprocessor);

 //---------------------------------------------------------------------------------------
 //Установка коэффициентов весового сумматора
 //---------------------------------------------------------------------------------------
 bool SetW(const cmatrix& Weight);
 //Перегрузка оператора присваивания (=) для класса
 TSingleStage_SDA_LCC_MISOWSum& operator =(const TSingleStage_SDA_LCC_MISOWSum& WSum);
 //Начальная установка параметров весового сумматора для моделирования
 bool SimulateInit();
 //---------------------------------------------------------------------------------------
 //Передаточная функция весового сумматора (TRANSFER FUNCTION)
 //---------------------------------------------------------------------------------------
 double TestFunc(cvector& V) const;
 double operator ()(cmatrix& R) const;
 double operator ()(cvector& V) const;
 rvector& operator ()(rvector& P, cmatrix& R) const;
 rvector& operator ()(rvector& P, cvector& V) const;
 //---------------------------------------------------------------------------------------
 //Настройка весовых коэффициентов сумматора (для адаптивного WeightSummator)
 //---------------------------------------------------------------------------------------
 bool Tuning(cmatrix& R);
 bool Tuning(cvector& V);
 //---------------------------------------------------------------------------------------
 //Консольный ввод-вывод свойств класса
 //---------------------------------------------------------------------------------------
 string& Type(string& s) const //Тип весового сумматора
 {s = "MultiInSingleOut SingleStage Adaptive SDA_LCC WeightSummator"; return s;};
  //Сокращенное наименование класса
 string& Clip(string& s) const {return s = "SS_SDA_LCC_MISO_WSum";};
 //Формирование адаптивного алгоритма сумматора в виде символьной строки вида:
 //<Algorithm: <Steepest Descent Method>, TdF = <value>, Gain = <value>\n>
 string& GetAdaptAlg(string& s) const
 {char buffer[80]; ostrstream text (buffer, sizeof(buffer));
  s = "Algorithm: <Steepest Descent Method: ";
  text << "TdF = " << Step() << ", Gain = " << Gain() << ">\n" << ends;
  s.append(text.str()); text.seekp(0);
  return s;
 };
 //Формирование характеристик схемы линейного ограничения в символьном виде:
 //<Linear Constraint of Weights: <On> || <Off>, Limitations = <value>\n>
 //< Angles [deg]: <angle_1>, <angle_2> .. <angle_n>;\n>
 string& GetLCC(string& s, uint indent_first = 0, uint indent_other = 0) const;
 //Формирование свойств весового сумматора в символьном виде
 string& Properties(string& s, string& head, uint indent = 0) const;

 //Консольный ввод шага адаптации с проверкой введенного параметра и подтверждением
 //введенного значения
 void Edit_Step(string& head, uint indent = 0);
 //Консольный ввод коэффициента усиления G и подтверждение введенного значения
 void Edit_Gain(string& head, uint indent = 0);
 //Консольный ввод направлений исключения с подтверждением ввода
 bool Edit_LCC();

 //Консольное редактирование параметров весового сумматора
 void Edit(bool ExtParam = true);
 //Перегрузка операции потокового вывода (<<) свойств класса
 friend ostream& operator << (ostream& out, const TSingleStage_SDA_LCC_MISOWSum& WSum)
 {string s,head; return out << WSum.Properties(s,head);};
//------------------------------------------------------------------------------
//Объявление защищенных членов-функций класса TSingleStageSDAlgMISOWSum
//------------------------------------------------------------------------------
protected:
 //Начальная установка параметров весового сумматора
 void Reset();

};//Завершение объявления класса TSingleStage_SDA_LCC_MISOWSum
//-------------- Завершение объявления класса TSingleStage_SDA_LCC_MISOWSum --------------

//-------------------------- The end of file "weightsum.h" -------------------------------
#endif //ЗАВЕРШЕНИЕ ОБЪЯВЛЕНИЯ ЗАГОЛОВОЧНОГО ФАЙЛА "WEIGHTSUM.H"

