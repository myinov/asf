//arrays.cpp
//Initial date: May,10,2005. Final date:
//Copyright (c) JohnSoft 2005. All rights reserved. C++ Builder 6
#pragma hdrstop

#include "arrays.h"
#include "SF_CommonFunc.h"
#include <Jpeg.hpp>

//----------------------------------------------------------------------------------------
#pragma package(smart_init)

const double EPS = 1.0e-10;

//----------------------------------------------------------------------------------------
//Функция сравнения двух источников излучения по их угловой координате
//(для сортировки источников излучения по возрастанию угловой координаты)
//----------------------------------------------------------------------------------------
struct TEmiSrc2D_CompByAngle
{
 bool operator() (const TEmissionSource_2D& I1, const TEmissionSource_2D& I2) const
 {bool lComp;
  if (I1.GetAngle(RAD) < I2.GetAngle(RAD)) lComp = true;
  else if (I1.GetAngle(RAD) == I2.GetAngle(RAD))
   lComp = (I1.GetPower() < I2.GetPower()) ? true : false;
  else lComp = false;
  return lComp;
 }
};
//----------------------------------------------------------------------------------------
//Функция сравнения двух источников излучения по их мощности (для сортировки источников
//излучения по возрастанию их мощности)
//----------------------------------------------------------------------------------------
struct TEmiSrc2D_CompByPower
{
 bool operator() (const TEmissionSource_2D& I1, const TEmissionSource_2D& I2) const
 {bool lComp;
  if (I1.GetPower() < I2.GetPower()) lComp = true;
  else if (I1.GetPower() == I2.GetPower())
   lComp = (I1.GetAngle(RAD) < I2.GetAngle(RAD)) ? true : false;
  else lComp = false;
  return lComp;
 }
};

//****************************************************************************************
//                        РЕАЛИЗАЦИЯ КЛАССА TUnEqLAA_ODA
//Класс описывает математическую модель однородной эквидистантной линейной АР с всенаправ-
//ленными элементами (Uniform Equispaced Linear Antenna Array with Omnidirectional antenna),
//которая характеризуется тремя параметрами:
// 1) N - количество антенных элементов (N > 0, by default N = 1);
// 2) d - относительное расстояние в длинах волн между соседними элементами LAA (d > 0,
//    by default d = 0.5);
// 3) Zero - номер антенного элемента, относительно которого осуществляется отсчет
//    (0 <= Origin < N, by default N = 0).
//****************************************************************************************

//========================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TUnEqLAA_ODA
//    PUBLIC MEMBER-FUNCTION OF TUnEqLAA_ODA CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TUnEqLAA_ODA class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// void Set(ulong DimLAA, double RelDist, double Pnoise = 1.0, ulong Origin = 0L)
//НАЗНАЧЕНИЕ: Установка всех свойств модели LAA.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong DimLAA - размерность LAA;
//2. double RelDist - относительное расстояния между соседними антеннами (в длинах волн);
//3. ulong Origin (0L) - номер отсчетного элемента LAA;
//4. double Pnoise (1.0) - уровень внутреннего шума в каждом канале LAA.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TUnEqLAA_ODA::Set(ulong DimLAA, double RelDist, double Pnoise, ulong Origin)
{//Установка новых параметров
 SetDimLAA(DimLAA);//Установка размерности LAA
 SetRelDist(RelDist);//Установка относительного расстояния между соседними антеннами
 SetOrigin(Origin);//Установка отсчетного элемента LAA
 SetPn(Pnoise);//Установка уровня внутреннего шума в каналах LAA
}
//****************************************************************************************
//СТАТУС: I.2; public; TUnEqLAA_ODA class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong SetDimLAA(ulong N)
//НАЗНАЧЕНИЕ: Установка размерности LAA (_N > 0).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong N - количество антенн LAA;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong _N - новая размерность LAA
//****************************************************************************************
ulong TUnEqLAA_ODA::SetDimLAA(ulong N)
{_N = (N > 0) ? N : 1;//Установка новой размерности LAA
 //Проверка номера отсчетного элемента LAA после изменения размерности
 SetOrigin(GetOrigin());
 return _N;
}
//****************************************************************************************
//СТАТУС: I.3; public; TUnEqLAA_ODA class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double SetRelDist(double d)
//НАЗНАЧЕНИЕ: Установка относительного (в длинах волн) расстояния между соседними элемента-
//ми LAA (_d > 0).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: double d - расстояние между соседними антеннами решетки;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double _d - новое расстояние между соседними антеннами решетки
//****************************************************************************************
double TUnEqLAA_ODA::SetRelDist(double d)
{
 return _d = (d != 0) ? fabs(d) : 0.5;
}
//****************************************************************************************
//СТАТУС: I.4; public; TUnEqLAA_ODA class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong SetOrigin(ulong Origin)
//НАЗНАЧЕНИЕ: Установка номера отсчетного элемента LAA (0 <= _Zer0 < _N).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong Origin - порядковый номер отсчетного элемента LAA;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong _Zero - новый номер отсчетного элемента LAA.
//****************************************************************************************
ulong TUnEqLAA_ODA::SetOrigin(ulong Origin)
{
 return _Zero = (Origin < GetDimLAA()) ? Origin : 0;
}
//****************************************************************************************
//СТАТУС: I.5; public; TUnEqLAA_ODA class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double SetPn(double Pnoise)
//НАЗНАЧЕНИЕ: Установка уровня внутреннего шума в каналах LAA (_Pn > 0).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: double Pnoise - уровень внутреннего шума в каналах решетки;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double _Pn - новое значение внутреннего шума в каналах решетки
//****************************************************************************************
double TUnEqLAA_ODA::SetPn(double Pnoise)
{
 return _Pn = (Pnoise != 0) ? fabs(Pnoise) : 1.0;
}
//****************************************************************************************
//СТАТУС: I.6; public member-function of class TUnEqLAA_ODA
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Properties(string& s) const
//НАЗНАЧЕНИЕ: Формирование характеристик объекта TUnEqLAA_ODA в строке s, передаваемой по
//ссылке. Свойства LAA представляются в виде:
//----------------------------------------------------------------------------------------
// N: <_N>, Origin: <_Zero>, d: <_d>, Pn: <_Pn>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строковый объект, в котором формируются свойства LAA
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами объекта.
//****************************************************************************************
string& TUnEqLAA_ODA::Properties(string& s) const
{char buffer[81];
 ostrstream text(buffer, sizeof(buffer));
 text << "N: " << GetDimLAA() << ", Origin: " << GetOrigin() << ", d: " << GetRelDist()
      << ", Pn: " << GetPn() << ", Antenna: <ODA>" << ends;
 s.assign(text.str());
 return s;
}
//****************************************************************************************
//СТАТУС: I.7; public member-function of class TUnEqLAA_ODA
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Brief(string& s) const
//НАЗНАЧЕНИЕ: Получение свойств объекта TUnEqLAA_ODA в краткой форме в строке s, передавае-
//мой по ссылке. Свойства LAA представляются:
//----------------------------------------------------------------------------------------
// (<_N>, <_Origin>, <_d>, <_Pn>)
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строку, в которой заносятся свойства объекта в кратком виде
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами объекта в кратком виде
//****************************************************************************************
string& TUnEqLAA_ODA::Brief(string& s) const
{char buffer[81];
 ostrstream text(buffer, sizeof(buffer));
 text << '(' << GetDimLAA() << ", " << GetOrigin() << ", " << GetRelDist() << ", "
      << GetPn() << ", <ODA>" << ')' << ends;
 s.assign(text.str());
 return s;
}
//****************************************************************************************
//СТАТУС: I.8; public member-function of class TUnEqLAA_ODA
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool GetRss(cmatrix& R, const TEmissionSource_2D& Src, bool lNoise = true) const
//НАЗНАЧЕНИЕ: Расчет корреляционной матрицы на выходе LAA при воздействии источника излу-
//чения Src. Корреляционная матрица формируется в комплексной матрице R, передаваемой по
//ссылке. При значении опции lNoise = true в матрице R учитывается влияние внутреннего шума
//приемных каналов LAA. Матрица R будет эрмитовой и, кроме того, при учете Pn - положительно
//определенной. Коэффициенты матрицы R рассчитываются следующим образом:
//Rij = P*Exp[j*2PI*d*sin(Angle)*(i-j)], для i != j
//Rii = P + Pn, при учете внутреннего шума - Pn != 0, где
//P - мощность источника сигнала Src,
//Angle - угловое положение источника Src в радианах, относительно нормали к раскрыву LAA,
//d - относительное в длинах волн расстояние между соседними элементами LAA,
//i & j - порядковые номера антенных элементов LAA.
//Размерность R будет равна размерности LAA. Функция возвращает true в случае возможности
//формирования матрицы R размерности равной LAA и false - в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет сформирована корреляционная матрица;
//2. const TEmissionSource_2D& Src - источник излучения принимаемый LAA;
//3. bool lNoise (true) - учет влияния внутреннего шума приемных каналов LAA на формирова-
//   ние корреляционной матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат формирования корреляционной матрицы
//****************************************************************************************
bool TUnEqLAA_ODA::GetRss(cmatrix& R, const TEmissionSource_2D& Src, bool lNoise) const
{//Распределение памяти под корреляционную матрицу R без начальной инициализации в
 //соответствии с размерностью LAA
 if (R.Set(GetDimLAA(),false) == false) return false;
 double c = TwoPI*GetRelDist()*sin(Src.GetAngle(RAD));
 double P = Src.GetPower();
 //Формирование корреляционной матрицы
 for (ulong i = 0L; i < R.Rows(); i++)
  for (ulong j = 0L; j < i; j++)
  {R.Put(i,j,polar(P,c*((long)i-(long)j)));
   R.Put(j,i,conj(R.Get(i,j)));
  }
 //Формирование диагональных элементов матрицы
 if (lNoise) P = P + GetPn();
 for (ulong i = 0L; i < R.Rows(); i++) R.Put(i,i,P);

 return true;
}
//****************************************************************************************
//СТАТУС: I.9; public member-function of class TUnEqLAA_ODA
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool GetRjj(cmatrix& R, const TJammers_2D& Jams, bool lNoise = true) const
//НАЗНАЧЕНИЕ: Расчет корреляционной матрицы на выходе LAA при воздействии аддитивного сиг-
//нала (помехи), образованного источниками излучения, размещенными в объекте Jams, переда-
//ваемый в функцию по ссылке. Корреляционная матрица формируется в комплексной матрице R,
//передаваемой по ссылке. При значении опции lNoise = true в матрице R учитывается влияние
//внутреннего шума приемных каналов LAA. Матрица R будет эрмитовой и, кроме того, при учете
//Pn - положительно определенной. Коэффициенты матрицы R для каждого источника излучения из
//Jams рассчитываются следующим образом:
//Rij = P*Exp[j*2PI*d*sin(Angle)*(i-j)], для i != j
//Rii = P + Pn, при учете внутреннего шума - Pn != 0, где
//P - мощность источника сигнала Src,
//Angle - угловое положение источника Src в радианах, относительно нормали к раскрыву LAA,
//d - относительное в длинах волн расстояние между соседними элементами LAA,
//i & j - порядковые номера антенных элементов LAA.
//Все корреляционные матрицы источников излучения складываются и, таким образом, формируется
//АДДИТИВНАЯ ковариационная матрица.
//Размерность R будет равна размерности LAA. Функция возвращает true в случае возможности
//формирования матрицы R размерности равной LAA и false - в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет сформирована корреляционная матрица;
//2. const TJammers_2D& Jams  - контейнер с источниками излучения, принимаемые LAA;
//3. bool lNoise (true) - учет влияния внутреннего шума приемных каналов LAA на формирова-
//   ние корреляционной матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат формирования корреляционной матрицы
//****************************************************************************************
bool TUnEqLAA_ODA::GetRjj(cmatrix& R, const TJammers_2D& Jams, bool lNoise) const
{//Распределение памяти под корреляционную матрицу R без начальной инициализации в
 //соответствии с размерностью LAA
 if (R.Set(GetDimLAA(),C_ZERO) == false) return false;
 CIter_Jams2D I, EIter;
 Jams.GetIterators(I,EIter);
 double SumP = 0.0;
 double c, P;
 //---------------------------------------------------------------------------------------
 //Цикл расчета АДДИТИВНОЙ ковариационной матрицы источников излучения Jams на выходе LAA
 //---------------------------------------------------------------------------------------
 while (I != EIter)
 {c = TwoPI*GetRelDist()*sin(I->GetAngle(RAD));
  P = I->GetPower();
  SumP += P;
  //Формирование корреляционной матрицы
  for (ulong i = 0L; i < R.Rows(); i++)
   for (ulong j = 0L; j < i; j++)
   {R.Put(i,j,R.Get(i,j)+polar(P,c*((long)i-(long)j)));
    R.Put(j,i,conj(R.Get(i,j)));
   }
  ++I;
 }
 //Формирование диагональных элементов матрицы
 if (lNoise) SumP = SumP + GetPn();
 for (ulong i = 0L; i < R.Rows(); i++) R.Put(i,i,SumP);

 return true;

}
//****************************************************************************************
//СТАТУС: I.10; public member-function of class TUnEqLAA_ODA
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool GetAuxRjj(cmatrix& R, const TJammers_2D& Jams, bool lNoise = true) const
//НАЗНАЧЕНИЕ: Расчет корреляционной матрицы на выходе LAA при воздействии аддитивного сиг-
//нала (помехи), образованного источниками излучения, размещенными в объекте Jams, переда-
//ваемый в функцию по ссылке, без ОТСЧЕТНОГО (ОСНОВНОГО) канала с порядковым номером Origin.
//Корреляционная матрица формируется в комплексной матрице R, передаваемой по ссылке. При
//значении опции lNoise = true в матрице R учитывается влияние внутреннего шума приемных
//каналов LAA. Матрица R будет эрмитовой и, кроме того, при учете Pn - положительно опреде-
//ленной. Коэффициенты матрицы R для каждого источника излучения из Jams рассчитываются
//следующим образом:
//Rij = P*Exp[j*2PI*d*sin(Angle)*(i-j)], для i != j
//Rii = P + Pn, при учете внутреннего шума - Pn != 0, где
//P - мощность источника сигнала Src,
//Angle - угловое положение источника Src в радианах, относительно нормали к раскрыву LAA,
//d - относительное в длинах волн расстояние между соседними элементами LAA,
//i & j - порядковые номера антенных элементов LAA.
//Все корреляционные матрицы источников излучения складываются и, таким образом, формируется
//АДДИТИВНАЯ ковариационная матрица.
//Размерность R будет равна на ЕДИНИЦУ МЕНЬШЕ размерности LAA, так как отсчетный канал не
//учитывается. Функция возвращает true в случае возможности формирования матрицы R необхо-
//димой размерности и false - в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет сформирована корреляционная матрица;
//2. const TJammers_2D& Jams  - контейнер с источниками излучения, принимаемые LAA;
//3. bool lNoise (true) - учет влияния внутреннего шума приемных каналов LAA на формирова-
//   ние корреляционной матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат формирования корреляционной матрицы
//****************************************************************************************
bool TUnEqLAA_ODA::GetAuxRjj(cmatrix& R, const TJammers_2D& Jams, bool lNoise) const
{//Распределение памяти под корреляционную матрицу R без начальной инициализации в
 //соответствии с размерностью LAA минус один
 if (this->GetDimLAA() <= 1) {R.Set(0,false); return false;}
 if (R.Set(GetDimLAA()-1,C_ZERO) == false) return false;
 CIter_Jams2D I, EIter;
 Jams.GetIterators(I,EIter);
 double SumP = 0.0;
 double c, P;
 ulong i1, j1;
 //---------------------------------------------------------------------------------------
 //Цикл расчета АДДИТИВНОЙ ковариационной матрицы источников излучения Jams на выходе LAA
 //---------------------------------------------------------------------------------------
 while (I != EIter)
 {c = TwoPI*GetRelDist()*sin(I->GetAngle(RAD));
  P = I->GetPower();
  SumP += P;
  //Формирование корреляционной матрицы каналов LAA без ОТСЧЕТНОГО канала
  for (ulong i = 0L; i < R.Rows(); i++)
  {i1 = (i < _Zero) ? i : i+1;
   for (ulong j = 0L; j < i; j++)
   {j1 = (j < _Zero) ? j : j+1;
    R.Put(i,j,R.Get(i,j)+polar(P,c*((long)i1 - (long)j1)));
    R.Put(j,i,conj(R.Get(i,j)));
   }
  }
  ++I;
 }
 //Формирование диагональных элементов матрицы
 if (lNoise) SumP = SumP + GetPn();
 for (ulong i = 0L; i < R.Rows(); i++) R.Put(i,i,SumP);
 return true;
}
//****************************************************************************************
//СТАТУС: I.11; public member-function of class TUnEqLAA_ODA
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CalcCovVector(cvector& U, const TJammers_2D& Jams) const
//НАЗНАЧЕНИЕ: Расчет ковариационного вектора между отсчетным (основным) и остальными
//приемными каналами LAA при воздействии аддитивного сигнала (помехи), образованного источ-
//никами излучения, размещенными в объекте Jams, передаваемый в функцию по ссылке. Вектор
//ковариации формируется в комплексной векторе U, передаваемом по ссылке. Коэффициенты
//вектора U для каждого источника излучения из Jams рассчитываются следующим образом:
//Ui = SUM {Pk*Exp[j*2PI*d*sin(Ak)*(i-Origin)]} 0 <= k < N
//Pk - мощность k-го источника сигнала Src;
//Ak - угловое положение k-го источника Src в радианах, относительно нормали к раскрыву LAA;
//d - относительное в длинах волн расстояние между соседними элементами LAA;
//i - порядковые номера антенных элементов LAA;
//Origin - порядковый номер отсчетного (основного) канала;
//N - количество источников излучения, образующих АДДИТИВНЫЙ сигнал (помеху).
//Размерность U будет на ЕДИНИЦУ МЕНЬШЕ размерности LAA, так как отсчетный канал не входит
//отдельно в ковариационный вектор. Функция возвращает true при возможности формирования
//вектора R необходимой размерности и false - в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& U - ссылка на вектор, в котором будет сформирован ковариационный вектор
//   между отсчетным и остальными приемными каналами LAA;
//2. const TJammers_2D& Jams  - контейнер с источниками излучения, принимаемые LAA;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат формирования корреляционной матрицы
//****************************************************************************************
bool TUnEqLAA_ODA::CalcCovVector(cvector& U, const TJammers_2D& Jams) const
{//Распределение памяти под вектор ковариации U без начальной инициализации в соответствии
 //с размерностью LAA минус один
 if (this->GetDimLAA() <= 1) {U.Set(0,COL); return false;}
 if (U.Set(GetDimLAA()-1,COL,C_ZERO) == false) return false;
 CIter_Jams2D I, EIter;
 Jams.GetIterators(I,EIter);
 double c, P;
 ulong i1;
 //---------------------------------------------------------------------------------------
 //Цикл расчета вектора ковариации между отсчетным и остальными приемными каналами LAA
 //при приеме АДДИТИВНОГО сигнала Jams
 //---------------------------------------------------------------------------------------
 while (I != EIter)
 {c = TwoPI*GetRelDist()*sin(I->GetAngle(RAD));
  P = I->GetPower();
  //Формирование ковариационного вектора между ОТСЧЕТНЫМ и остальными каналами LAA
  for (ulong i = 0L; i < U.Size(); i++)
  {i1 = (i < _Zero) ? i : i+1;
   U.Put(i,U.Get(i)+polar(P,c*((long)i1 - (long)_Zero)));
  }
  ++I;
 }
 return true;
}
//****************************************************************************************
//СТАТУС: I.12; public member-function of class TUnEqLAA_ODA
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CalcCovVector(cvector& U, const TEmissionSource_2D& EmiSrc) const
//НАЗНАЧЕНИЕ: Расчет ковариационного вектора между отсчетным (основным) и остальными
//приемными каналами LAA при действии одного источниками излучения, размещенными в объекте
//EmiSrc, передаваемый в функцию по ссылке. Вектор ковариации формируется в комплексной
//векторе U, передаваемом по ссылке. Значения вектора U для источника излучения EmiSrc
//рассчитываются следующим образом:
//Ui = SUM {Ps*Exp[j*2PI*d*sin(As)*(i-Origin)]}
//Ps - мощность источника сигнала EmiSrc;
//As - угловое положение источника EmiSrc в радианах, относительно нормали к раскрыву LAA;
//d - относительное в длинах волн расстояние между соседними элементами LAA;
//i - порядковые номера антенных элементов LAA;
//Origin - порядковый номер отсчетного (основного) канала;
//Размерность U будет на ЕДИНИЦУ МЕНЬШЕ размерности LAA, так как отсчетный канал не входит
//отдельно в ковариационный вектор. Функция возвращает true при возможности формирования
//вектора U необходимой размерности и false - в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& U - ссылка на вектор, в котором будет сформирован ковариационный вектор
//   между отсчетным и остальными приемными каналами LAA;
//2. const TEmissionSource_2D& EmiSrc  - источник излучения, принимаемый LAA;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат формирования корреляционной матрицы
//****************************************************************************************
bool TUnEqLAA_ODA::CalcCovVector(cvector& U, const TEmissionSource_2D& EmiSrc) const
{//Распределение памяти под вектор ковариации U без начальной инициализации с размерностью
 //LAA минус один
 if (this->GetDimLAA() <= 1) {U.Set(0,COL); return false;}
 if (U.Set(GetDimLAA()-1,COL,C_ZERO) == false) return false;
 double c, P;
 ulong i1;
 //---------------------------------------------------------------------------------------
 //Цикл расчета вектора ковариации между отсчетным и остальными приемными каналами LAA
 //при приеме одного источника сигнала EmiSrc
 //---------------------------------------------------------------------------------------
 c = TwoPI*GetRelDist()*sin(EmiSrc.GetAngle(RAD));
 P = EmiSrc.GetPower();
 //Формирование ковариационного вектора между ОТСЧЕТНЫМ и остальными каналами LAA
 for (ulong i = 0L; i < U.Size(); i++)
 {i1 = (i < _Zero) ? i : i+1;
  U.Put(i,polar(P,c*((long)i1 - (long)_Zero)));
 }
 return true;
}
//****************************************************************************************
//СТАТУС: I.13; public member-function of class TUnEqLAA_ODA
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CalcBeamFactors(cvector& B, double Angle, bool unit = DEG, bool conj = false) const
//НАЗНАЧЕНИЕ: Расчет комплексных фазосдвигающих коэффициентов лучеобразующей схемы для
//формирования угла сканирования (максимума диаграммы направленности) для данной LAA в
//направлении Angle. Коэффициенты рассчитываются по следующей формуле:
// Bi = 1*EXP[j*(2PI*d*(i-Origin)*sin(Angle)], где
// Bi - значение фазосдвигающего коэффициента для элемента LAA с порядковым номером i;
// d - относительное в длинах волн расстояние между соседними элементами LAA;
// Origin - порядковый номер отсчетного элемента LAA;
// Angle - направление угла сканирования (максимум диаграммы направленности LAA) в RAD.
//Рассчитанные коэффициенты Bi сохраняются в векторе-столбце B, передаваемому по ссылке.
//Размерность вектора B будет равна размерности LAA. Функция возвращает true в случае воз-
//можности формирования вектора B размерности равной LAA и false - в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& B - ссылка на вектор, в котором формируется лучеобразующий вектор;
//2. double Angle - угол сканирования (максимум диаграммы направленности LAA);
//3. bool unit [DEG] - единица измерения Angle в градусах (DEG) или радианах (RAD)
//4. bool conj [false] - опция вычисления комплексно-сопряженных коэффициентов
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат формирования лучеобразующего луча
//****************************************************************************************
bool TUnEqLAA_ODA::CalcBeamFactors(cvector& B, double Angle, bool unit, bool conj) const
{//Создание вектора-столбца размерности равной LAA для хранения лучеобразующих
 //коэффициентов
 if (B.Set(GetDimLAA(),COL,false) == false) return false;
 //Перевод угла Angle в радианы (при необходимости)
 if (unit == DEG) Angle *= DegRad;
 double c = TwoPI*GetRelDist()*sin(Angle);
 if (conj) c *= -1.0;//Вычисление комплексно-сопряженных фазосдвигающих коэффициентов
 //Цикл расчета фазосдвигающих коэффициентов BeamFormer Circuit
 for (ulong i = 0; i < B.Size(); i++) B.Put(i,polar(1,c*((long)i-(long)GetOrigin())));
 return true;
}
//****************************************************************************************
//СТАТУС: I.13; public member-function of class TUnEqLAA_ODA
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CalcUs(cvector& U, const TEmissionSource_2D& EmiSrc) const
//НАЗНАЧЕНИЕ: Расчет вектора напряжений на выходах LAA при действии одного источника
//излучения EmiSrc, передаваемого по ссылке. Расчет комплексных амплитуды напряжений:
// Ui = sqrt(Ps)*EXP[j*(2PI*d*(i-Origin)*sin(Angle)], где
// Ui - значение комплексной амплитуды для элемента LAA с порядковым номером i;
// d - относительное в длинах волн расстояние между соседними элементами LAA;
// Origin - порядковый номер отсчетного элемента LAA;
// Ps - мощность источника излучения;
// Angle - угловое положение источника излучения относительно раскрыва LAA в радианах.
//Рассчитанные значения Ui сохраняются в векторе-столбце U, передаваемому по ссылке.
//Размерность вектора U будет равна размерности LAA. Функция возвращает true в случае воз-
//можности формирования вектора U размерности равной LAA и false - в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& U - ссылка на вектор, в котором формируется вектор напряжений на выходе LAA;
//2. const TEmissionSource_2D& EmiSrc - ссылка на источник излучения;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат формирования выходного вектора U
//****************************************************************************************
bool TUnEqLAA_ODA::CalcUs(cvector& U, const TEmissionSource_2D& EmiSrc) const
{//Создание вектора-столбца размерности равной LAA для хранения комплексных амплитуд
 if (U.Set(GetDimLAA(),COL,false) == false) return false;
 double Ampl = sqrt(EmiSrc.GetPower());
 double Phase;
 double c = TwoPI*GetRelDist()*sin(EmiSrc.GetAngle(RAD));
 //Цикл расчета комплексных амплитуд на выходе LAA при воздействии источника излучения
 for (ulong i = 0; i < U.Size(); i++)
 {Phase = c*((long)i-(long)GetOrigin());
  U.Put(i,polar(Ampl,Phase));
 }
 return true;
}
//****************************************************************************************
//СТАТУС: I.14; public member-function of class TUnEqLAA_ODA
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(cvector& U, double Angle, bool unit = DEG) const
//НАЗНАЧЕНИЕ: Формирование вектора напряжений на выходах LAA при действии источника излуче-
//ния ЕДИНИЧНОЙ МОЩНОСТИ с направления Angle относительно раскрыва LAA
//Расчет вектора напряжений на выходах LAA при действии источника ЕДИНИЧНОЙ МОЩНОСТИ:
// Ui = 1*EXP[j*(2PI*d*(i-Origin)*sin(Angle)], где
// Ui - значение комплексной амплитуды для элемента LAA с порядковым номером i;
// d - относительное в длинах волн расстояние между соседними элементами LAA;
// Origin - порядковый номер отсчетного элемента LAA;
// Ps = 1 - мощность источника излучения;
// Angle - угловое положение источника излучения относительно раскрыва LAA в радианах.
//Рассчитанные значения Ui сохраняются в векторе-столбце U, передаваемому по ссылке.
//Размерность вектора U будет равна размерности LAA. Функция возвращает true в случае воз-
//можности формирования вектора U размерности равной LAA и false - в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& U - ссылка на вектор, в котором формируется вектор напряжений на выходе LAA;
//2. double Angle - угловое положение источника относительно раскрыва LAA;
//3. bool unit [DEG] - единица измерения Angle в градусах (DEG) или радианах (RAD)
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат формирования выходного вектора U
//****************************************************************************************
bool TUnEqLAA_ODA::TFunc(cvector& U, double Angle, bool unit) const
{TEmissionSource_2D EmiSrc(1,Angle,unit);//Источник излучения ЕДИНИЧНОЙ МОЩНОСТИ
 return CalcUs(U,EmiSrc);
}
//****************************************************************************************
//СТАТУС: I.15; public member-function of class TUnEqLAA_ODA
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool TFunc(cmatrix& U, rvector& Angles, bool unit = DEG, bool lBaseCh = false) const
//НАЗНАЧЕНИЕ: Формирование матрицы напряжений на выходах LAA при действии источников излуче-
//ний ЕДИНИЧНОЙ МОЩНОСТИ с направлений Angles относительно раскрыва LAA. Количество строк
//матрицы U соответствует кол-ву каналов LAA, количество столбцов матрицы U соответствует
//размерности вектора Angles. Расчет вектора напряжений на выходах LAA при действии источ-
//ника ЕДИНИЧНОЙ МОЩНОСТИ:
// U(i,k) = 1*EXP[j*(2PI*d*(i-Origin)*sin(Angles[k])], где
// U(i,k) - значение комплексной амплитуды для элемента LAA с порядковым номером i при
//          действии источника излучения с k-го направления;
// d - относительное в длинах волн расстояние между соседними элементами LAA;
// Origin - порядковый номер отсчетного элемента LAA;
// Ps = 1 - мощность источника излучения;
// Angles[k] - угловое положение источника излучения относительно раскрыва LAA в радианах.
//Рассчитанные значения Ui сохраняются в k-м столбце матрицы U, передаваемой по ссылке.
//Функция позволяет учитывать или не учитывать основной (отсчетный) канал с помощью опции
//lBaseCh. Функция возвращает true в случае возможности формирования матрицы U и false -
//в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& U - ссылка на матрицу, в котором формируется матрица напряжений на выходе LAA;
//2. rvector& Angles - угловые положения источников относительно раскрыва LAA;
//3. bool unit [DEG] - единица измерения Angle в градусах (DEG) или радианах (RAD);
//4. bool lBaseCh [false] - учет основного (отсчетного) канала LAA
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат формирования выходной матрицы U
//****************************************************************************************
bool TUnEqLAA_ODA::TFunc(cmatrix& U, rvector& Angles, bool unit, bool lBaseCh) const
{ulong N = (lBaseCh) ? this->GetDimLAA() : this->GetDimLAA()-1;//Количество каналов
 ulong M = Angles.Size();//Количество направлений
 ulong Origin = this->GetOrigin();
 double Angle, Phase, c;
 int offset;
 //Проверка на возможность вычислений
 if (M == 0 || N == 0) {U.Set(0,0,false); return false;}
 //Формируем матрицу размерности NxM
 U.Set(N,M,C_ZERO);
 if (U.IsZeroSize()) return false;
 //Расчет значений матрицы U
 for (ulong j = 0; j < M; j++)
 {if (unit == DEG) Angle = Angles.Get(j) * DegRad;
  c = TwoPI*GetRelDist()*sin(Angle);
  offset = 0;
  for (ulong i = 0; i < GetDimLAA(); i++)
  {if ((!lBaseCh) && (i == Origin)) {offset = -1; continue;}
   if (i != GetOrigin())
   {Phase = c*((long)i-(long)Origin);
    U.Put(i+offset,j,polar(1.0,Phase));
   }
  }
 }
 return true;
}
//****************************************************************************************
//СТАТУС: I.15a; public member-function of class TUnEqLAA_ODA
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool TFunc(cmatrix& U, const TDoubleSet& Angles, bool lBaseCh = false) const
//НАЗНАЧЕНИЕ: Формирование матрицы напряжений на выходах LAA при действии источников излуче-
//ний ЕДИНИЧНОЙ МОЩНОСТИ с направлений Angles относительно раскрыва LAA. Количество строк
//матрицы U соответствует кол-ву каналов LAA, количество столбцов матрицы U соответствует
//размерности контейнера Angles. В контейнере Angles угловые значения источников задаются
//в градусах. Расчет вектора напряжений на выходах LAA при действии источника излучения
//ЕДИНИЧНОЙ МОЩНОСТИ:
// U(i,k) = 1*EXP[j*(2PI*d*(i-Origin)*sin(Angles[k])], где
// U(i,k) - значение комплексной амплитуды для элемента LAA с порядковым номером i при
//          действии источника излучения с k-го направления;
// d - относительное в длинах волн расстояние между соседними элементами LAA;
// Origin - порядковый номер отсчетного элемента LAA;
// Ps = 1 - мощность источника излучения;
// Angles[k] - угловое положение источника излучения относительно раскрыва LAA в радианах.
//Рассчитанные значения Ui сохраняются в k-м столбце матрицы U, передаваемой по ссылке.
//Функция позволяет учитывать или не учитывать основной (отсчетный) канал с помощью опции
//lBaseCh. Функция возвращает true в случае возможности формирования матрицы U и false -
//в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& U - ссылка на матрицу, в котором формируется матрица напряжений на выходе LAA;
//2. const TDoubleSet& Angles - значения угловых положений источников излучения относительно
//   раскрыва LAA в градусах;
//3. bool lBaseCh [false] - учет основного (отсчетного) канала LAA
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат формирования выходной матрицы U
//****************************************************************************************
bool TUnEqLAA_ODA::TFunc(cmatrix& U, const TDoubleSet& Angles, bool lBaseCh) const
{ulong N = (lBaseCh) ? this->GetDimLAA() : this->GetDimLAA()-1;//Количество каналов
 ulong M = Angles.Size();//Количество направлений
 ulong Origin = this->GetOrigin();
 double Angle, Phase, c;
 int offset;
 DblSet::const_iterator BIter, EIter;
 //Проверка на возможность вычислений
 if (M == 0 || N == 0) {U.Set(0,0,false); return false;}
 //Формируем матрицу размерности NxM
 U.Set(N,M,C_ZERO);
 if (U.IsZeroSize()) return false;
 //Получение начального и конечного итераторов на контейнер Angles
 Angles.GetIters(BIter,EIter);
 //Расчет значений матрицы U
 for (ulong j = 0; j < M; j++)
 {Angle = *BIter;
  Angle = Angle*DegRad;//Перевод градусов в радианы
  c = TwoPI*GetRelDist()*sin(Angle);
  offset = 0;
  for (ulong i = 0; i < GetDimLAA(); i++)
  {if ((!lBaseCh) && (i == Origin)) {offset = -1; continue;}
   if (i != GetOrigin())
   {Phase = c*((long)i-(long)Origin);
    U.Put(i+offset,j,polar(1.0,Phase));
   }
  }
  ++BIter;//Переход к следующему угловому значению
 }
 return true;
}
//****************************************************************************************
//СТАТУС: I.16; public member-function of class TUnEqLAA_ODA
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool TFunc(cvector& U, double Angle, bool unit = DEG) const
//bool TFunc(rmatrix& P, const TEvenCloseInterval& Sector, double ScanAngle = 0,
//           bool Norm = ON, bool Db = ON, double MinDb = -60.0) const
//НАЗНАЧЕНИЕ: Расчет передаточной функция (Transfer function), диаграммы направленности
//антенной решетки в секторе Sector с учетом подключения лучеобразующей схемы со значением
//угла сканирования (углового положения основного лепестка) ScanAngle. Передаточная функция
//формируется в матрице P. В первом столбце матрицы располагаются значения угловых коорди-
//нат для которых рассчитывается функция, а во втором столбце - значения передаточной функ-
//ции для данной угловой координаты. Передаточная функция может быть нормированы в пределах
//от нуля до единицы (опция Norm) или в децибелах (опция Db) с заданием минимального порога
//в децибелах.
//Для расчета диаграммы направленности LAA используется функция формирования тест-сигнала
//образованного источником излучения ЕДИНИЧНОЙ мощности, который последовательно перемещается
//в исследуемом секторе Sector. Полученной выходное напряжение со всех приемных каналов
//решетки скалярно умножается с лучеобразующим вектором, коэфициенты которого опеределяются
//углом сканирования ScanAngle. Норма полученного скалярного комплексного значения будет
//определять мощность на выходе LAA в заданном направлении приема.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& P - ссылка на матрицу со значениями угловых координат и мощности на выходе
//   антенной решетки при перемещении источника сигнала ЕДИНИЧНОЙ мощности в секторе Sector;
//2. const TEvenCloseInterval& Sector - сектор по углу места (азимуту), в  котором рассчи-
//   тывается передаточная функция (в градусах);
//3. double ScanAngle (0) - угол сканирования (угловое положение основного лепестка)
//4. bool Norm (ON) - опция нормирования выходных мощностей;
//5. bool Db (ON) - опция нормирования в децибелах (действует при Norm = ON);
//6. double MinDb - минимальный уровень в децибелах (действует при Db = ON).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета диаграммы направленности LAA
//****************************************************************************************
bool TUnEqLAA_ODA::TFunc(rmatrix& P, const TEvenCloseInterval& Sector, double ScanAngle,
     bool Norm, bool Db, double MinDb) const
{//Создание матрицы P необходимых размеров: rows=Sector.Size(); cols=2.
 P.Set(Sector.Size(),2,0.0);
 if (P.IsZeroSize()) return false;
 cvector Us, B;
 complex c_val;
 double Angle;
 //Расчет коэффициентов BeamFormer Circuit для угла сканирования ScanAngle
 this->CalcBeamFactors(B,ScanAngle,DEG,false);
 //---------------------------------------------------------------------------------------
 //Цикл расчета передаточной функции LAA в секторе Sector
 //---------------------------------------------------------------------------------------
 for (ulong i = 0L; i < P.Rows(); i++)
 {Angle = Sector(i);
  //1. Формирование тест-сигнала
  this->TFunc(Us,Angle,DEG);
  //2. Суммирование сигнала с выходов приемных каналов с учетом лучеобразующей схемы
  ScalarProduct(Us,B,c_val);
  //3. Запись результата в матрицу P
  P.Put(i,0,Angle);
  P.Put(i,1,norm(c_val));
 }
 //--------------------------------------------------------------------------------------
 //Нормирование полученных результатов
 if (Norm == ON)
 {double MaxPower = P.Get(0,1);
  for (ulong i = 1L; i < P.Rows(); i++)
  {if (MaxPower < P.Get(i,1)) MaxPower = P.Get(i,1);
  }
  //Нормирование значений мощности
  if (MaxPower <= 0.0) return true;
  for (ulong i = 0L; i < P.Rows(); i++) P.Put(i,1,P.Get(i,1)/MaxPower);
  //-------------------------------------------------------------------------------------
  //Нормирование в децибелах
  if (Db == ON)
  {double Power;
   MinDb = (MinDb >= 0.0) ? -60.0 : MinDb;//Минимальное значение в Db
   for (ulong i = 0L; i < P.Rows(); i++)
   {Power = (P.Get(i,1) == 0.0) ? MinDb : 10*log10(P.Get(i,1));
    Power = (Power < MinDb) ? MinDb : Power;
    P.Put(i,1,Power);
   }
  }
 }
 return true;
}

//========================================================================================
// РЕАЛИЗАЦИЯ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ КЛАССА TUnEqLAA_ODA
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TUnEqLAA_ODA class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: void operator =(const TUnEqLAA_ODA& LAA)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ  класса TUnEqLAA_ODA. Функция копирует
//свойств одного объекта  TUnEqLAA_ODA в другой.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TUnEqLAA_ODA& LAA - ссылка на копируемый объект
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TUnEqLAA_ODA::operator =(const TUnEqLAA_ODA& LAA)
{if (this == &LAA) return;//Предотвращение попытки присваивания объекта самому себе
 Set(LAA.GetDimLAA(),LAA.GetRelDist(),LAA.GetPn(),LAA.GetOrigin());
}
//****************************************************************************************
//СТАТУС: I.2; public; TUnEqLAA_ODA class overloading operator ==
//OVERLOADING COMPARE OPERATOR <EQUAL>
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ==(const TUnEqLAA_ODA& LAA) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СРАВНЕНИЯ объектов класса LAA. Функция сравнивает два
//объекта LAA по всем их свойствам. В случае эквивалентности значений всех свойств объектов
//функция возвращает true, в противном случае - false.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TUnEqLAA_ODA& LAA - ссылка на сравниваемый объект
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lCompare - результат сравнения двух объектов
//****************************************************************************************
bool TUnEqLAA_ODA::operator ==(const TUnEqLAA_ODA& LAA) const
{
 return ((GetDimLAA() == LAA.GetDimLAA()) && (GetOrigin() == LAA.GetOrigin()) &&
         (GetRelDist() == LAA.GetRelDist()) && (GetPn() == LAA.GetPn())) ? true : false;
}
//****************************************************************************************
//СТАТУС: I.3; public; TUnEqLAA_ODA class overloading operator <
//OVERLOADING COMPARE OPERATOR <LESS, SMALLER>
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator <(const const TUnEqLAA_ODA& LAA) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СРАВНЕНИЯ объектов класса TUnEqLAA_ODA. Функция срав-
//нивает два объектов TUnEqLAA_ODA на отношение <МЕНЬШЕ> только по размерности антенной
//решетки. При this->GetDimLAA() < LAA.GetDimLAA, функция возвращает true в противном
//случае - false.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TUnEqLAA_ODA& LAA - ссылка на сравниваемый объект
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lCompare - результат сравнения двух объектов
//****************************************************************************************
bool TUnEqLAA_ODA::operator <(const TUnEqLAA_ODA& LAA) const
{
 return (GetDimLAA() < LAA.GetDimLAA()) ? true : false;
}


//========================================================================================
//             РЕАЛИЗАЦИЯ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССА TUnEqLAA_ODA
//========================================================================================
//****************************************************************************************
//СТАТУС: 1;  TUnEqLAA_ODA class friend overloading operator <<
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend ostream& operator <<(ostream& out, const TUnEqLAA_ODA& LAA)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВЫВОДА класса TUnEqLAA_ODA.
//Функция предназначена для вывода в поток характеристик LAA в краткой форме. Функция воз-
//вращает ссылку на поток, что позволяет записывать в программе операторы вывода в поток
//каскадно. Формат вывода:
//----------------------------------------------------------------------------------------
// Uniform Equispaced LAA(<_N>, <_Origin>, <_d>, <_Pn>)
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на объект потока вывода
//2. сonst TUnEqLAA_ODA& LAA - ссылка на объект, выводимый в поток.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ostream& out - ссылка на объект потока вывода.
//***********************-****************************************************************
ostream& operator <<(ostream& out, const TUnEqLAA_ODA& LAA)
{string s;
 LAA.Brief(s);//Получение свойств источника излучения в виде строки (в краткой форме)
 out << "Uniform Equispaced LAA" << s;//Вывод характеристик объекта
 return out;
}
//****************************************************************************************
//СТАТУС: 2;  TUnEqLAA_ODA class friend function
//INPUT TUnEqLAA_ODA PROPERTIES by cin
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool Edit(TUnEqLAA_ODA& LAA)
//НАЗНАЧЕНИЕ: Редактирование свойств объекта класса TUnEqLAA_ODA через стандартный поток
//ввода cin. Функция редактирует свойства LAA, передаваемую по ссылке. Функция возвращает
//true - в случае изменения свойств объекта и false - в противоположном случае. После ввода
//новых свойств объекта осуществляется их отображение. Формат ввода свойств LAA:
//----------------------------------------------------------------------------------------
//ARRAY: <Uniform Equispaced LAA with Omnidirectional elements>
// N: <_N>, Origin: <_Zero>, d: <_d>, Pn: <_Pn>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TUnEqLAA_ODA& LAA - ссылка на редактируемый объект
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lChanged - результат редактирования
//***********************-****************************************************************
bool Edit(TUnEqLAA_ODA& LAA)
{//Рабочие переменные
 TUnEqLAA_ODA PrevLAA(LAA);
 char buffer[21];
 ostrstream text(buffer, sizeof(buffer));
 double r_val;
 ulong i_val;
 int y, row_start = wherey();
 char c;
 string s, line(78,'-');
 bool flag;
 gotoxy(1,row_start); clreol();

 do //Цикл ввода свойств однородной эквидистантной LAA с всенаправленными элементами
 {//--------------------------------------------------------------------------------------
  cout << line << endl;
  cout << "ARRAY: <Edit>, PrevLAA: " << PrevLAA << endl;
  //----------------------------------------------------------------------------------
  //1. Ввод размерности LAA
  //----------------------------------------------------------------------------------
  s = " N: "; y = wherey();
  cout << " LAA channels: "; cin >> i_val; LAA.SetDimLAA(i_val);
  text << LAA.GetDimLAA() << ends;
  s.append(text.str()); text.seekp(0);
  ClrScr(1,y);//Очистка экрана
  cout << s << endl;
  //----------------------------------------------------------------------------------
  //2. Ввод порядкового номера отсчетного элемента LAA
  //----------------------------------------------------------------------------------
  s.append(", Origin: ");
  cout << " Origin: "; cin >> i_val; LAA.SetOrigin(i_val);
  text << LAA.GetOrigin() << ends;
  s.append(text.str()); text.seekp(0);
  ClrScr(1,y);//Очистка экрана
  cout << s << endl;
  //----------------------------------------------------------------------------------
  //3. Ввод относительного расстояния между соседними элементами LAA
  //----------------------------------------------------------------------------------
  s.append(", d: ");
  cout << " Relative distance: "; cin >> r_val; LAA.SetRelDist(r_val);
  text << LAA.GetRelDist() << ends;
  s.append(text.str()); text.seekp(0);
  ClrScr(1,y);//Очистка экрана
  cout << s << endl;
  //----------------------------------------------------------------------------------
  //4. Ввод уровня внутреннего шума в приемных каналах LAA
  //----------------------------------------------------------------------------------
  s.append(", Pn: ");
  cout << " Pnoise: "; cin >> r_val; LAA.SetPn(r_val);
  text << LAA.GetPn() << ends;
  s.append(text.str()); text.seekp(0);
  ClrScr(1,y);//Очистка экрана
  cout << s << endl;
  //-----------------------------------------------------------------------------------
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
 //Проверка на изменение свойств редактируемого объекта
 return (PrevLAA == LAA) ? false : true;
}
//****************************************************************************************
//СТАТУС: 3;  TUnEqLAA_ODA class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool CalcRss(cmatrix& R, const TUnEqLAA_ODA& LAA, const TEmissionSource_2D& EmiSrc,
//                    bool lNoise, bool lBaseToEnd = true);
//НАЗНАЧЕНИЕ: Расчет ковариационной матрицы на выходе LAA с возможностью размещения столбца
//и строки матрицы R, связанных с отсчетным каналом, в последнем строке и столбце.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет сформирована ковариационная матрица;
//2. const TUnEqLAA_ODA& LAA - линейная антенная решетка: приемная система;
//3. const TEmissionSource_2D& EmiSrc - источник излучения принимаемый LAA;
//4. bool lNoise - учет влияния внутреннего шума приемных каналов LAA на формирование
//   ковариационной матрицы;
//5. bool lBaseToEnd (true) - опция размещения строки и столбца матрицы R, связанных с
//   отсчетным каналом LAA, в последнем строке и столбце матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета ковариационной матрицы
//***********************-****************************************************************
bool CalcRss(cmatrix& R, const TUnEqLAA_ODA& LAA, const TEmissionSource_2D& EmiSrc,
             bool lNoise, bool lBaseToEnd)
{//Расчет ковариационной матрицы источника излучения EmiSrc на выходе LAA
 if (LAA.GetRss(R,EmiSrc,lNoise) == false) return false;
 //Перемещение строки и столбца матрицы R, связанных с отсчетным каналом, в последнюю
 //строку и столбец
 if (lBaseToEnd)
 {ulong BaseIndex = LAA.GetOrigin();
  while (BaseIndex != R.Cols()-1)
  {R.ExchangeCols(BaseIndex,BaseIndex+1);
   R.ExchangeRows(BaseIndex,BaseIndex+1);
   BaseIndex++;
  }
 }
 return true;
}
//****************************************************************************************
//СТАТУС: 4;  TUnEqLAA_ODA class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool CalcRss(cmatrix& R, const TUnEqLAA_ODA& LAA, double P, double Phi,
//                    bool lNoise, bool lBaseToEnd = true)
//НАЗНАЧЕНИЕ: Расчет ковариационной матрицы на выходе LAA с возможностью размещения столбца
//и строки матрицы R, связанных с отсчетным каналом, в последнем строке и столбце.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет сформирована ковариационная матрица;
//2. const TUnEqLAA_ODA& LAA - линейная антенная решетка: приемная система;
//3. double P - мощность источника излучения;
//4. double Phi - угловое положение источника излучения относительно нормали к раскрыву
//   LAA в градусах;
//5. bool lNoise - учет влияния внутреннего шума приемных каналов LAA на формирование
//   ковариационной матрицы;
//6. bool lBaseToEnd (true) - опция размещения строки и столбца матрицы R, связанных с
//   отсчетным каналом LAA, в последнем строке и столбце матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета ковариационной матрицы
//***********************-****************************************************************
bool CalcRss(cmatrix& R, const TUnEqLAA_ODA& LAA, double P, double Phi, bool lNoise,
             bool lBaseToEnd)
{//Распределение памяти под корреляционную матрицу R без начальной инициализации в
 //соответствии с размерностью LAA
 if (R.Set(LAA.GetDimLAA(),false) == false) return false;
 double c = TwoPI*LAA.GetRelDist()*sin(Phi*DegRad);
 P = fabs(P);
 //Формирование корреляционной матрицы
 for (ulong i = 0L; i < R.Rows(); i++)
  for (ulong j = 0L; j < i; j++)
  {R.Put(i,j,polar(P,c*(long)(i-j)));
   R.Put(j,i,conj(R.Get(i,j)));
  }
 //Формирование диагональных элементов матрицы
 if (lNoise) P = P + LAA.GetPn();
 for (ulong i = 0L; i < R.Rows(); i++) R.Put(i,i,P);

 //Перемещение строки и столбца матрицы R, связанных с отсчетным каналом, в последнюю
 //строку и столбец
 if (lBaseToEnd)
 {ulong BaseIndex = LAA.GetOrigin();
  while (BaseIndex != R.Cols()-1)
  {R.ExchangeCols(BaseIndex,BaseIndex+1);
   R.ExchangeRows(BaseIndex,BaseIndex+1);
   BaseIndex++;
  }
 }
 return true;
}
//****************************************************************************************
//СТАТУС: 5;  TUnEqLAA_ODA class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool CalcRjj(cmatrix& R, const TUnEqLAA_ODA& LAA, const TJammers_2D& Jams,
//                    bool lNoise, bool lBaseToEnd = true);
//НАЗНАЧЕНИЕ: Расчет ковариационной матрицы на выходе LAA с возможностью размещения столбца
//и строки матрицы R, связанных с отсчетным каналом, в последнем строке и столбце.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& R - ссылка на матрицу, в которой будет сформирована ковариационная матрица;
//2. const TUnEqLAA_ODA& LAA - линейная антенная решетка: приемная система;
//3. const TJammers_2D& Jams - контейнер с источниками излучения, принимаемые LAA;;
//4. bool lNoise - учет влияния внутреннего шума приемных каналов LAA на формирование
//   ковариационной матрицы;
//5. bool lBaseToEnd (true) - опция размещения строки и столбца матрицы R, связанных с
//   отсчетным каналом LAA, в последнем строке и столбце матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат расчета ковариационной матрицы
//***********************-****************************************************************
bool CalcRjj(cmatrix& R, const TUnEqLAA_ODA& LAA, const TJammers_2D& Jams, bool lNoise,
             bool lBaseToEnd)
{//Расчет ковариационной матрицы аддитивной помехи Jams на выходе LAA
 if (LAA.GetRjj(R,Jams,lNoise) == false) return false;
 //Перемещение строки и столбца матрицы R, связанных с отсчетным каналом, в последнюю
 //строку и столбец
 if (lBaseToEnd)
 {ulong BaseIndex = LAA.GetOrigin();
  while (BaseIndex != R.Cols()-1)
  {R.ExchangeCols(BaseIndex,BaseIndex+1);
   R.ExchangeRows(BaseIndex,BaseIndex+1);
   BaseIndex++;
  }
 }
 return true;
}
//****************************************************************************************
//СТАТУС: 6;  TUnEqLAA_ODA class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool CalcSignal(cvector& Us, const TUnEqLAA_ODA& LAA, double P, double Phi,
//             bool lBaseToEnd = true)
//НАЗНАЧЕНИЕ: Расчет комплексных амплитуд в приемных каналах LAA при действии источника
//сигнала мощностью P с направления Phi [deg] (детерминированный сигнал). Результат работы
//функции формируется в векторе Us, передаваемом в функцию по ссылке. Размерность Us равна
//числу каналов LAA. Функция возвращает true в случае успешного проведения вычислений, в
//противном случае функция возвращает false.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& Us - ссылка на вектор-приемник значений комплексных амплитуд в каналах LAA
//   при действии одного источника излучения;
//2. const TUnEqLAA_ODA& LAA - линейная антенная решетка: приемная система;
//3. double P - мощность источника излучения принимаемый LAA;
//4. double Phi - угловое положение источника излучения в градусах относительно нормали
//   к раскрыву LAA (в градусах);
//5. bool lBaseToEnd (true) - опция размещения комплексной амплитуды отсчетного канала LAA
//   последним в векторе Us.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат расчета комплексных амплитуд приемных каналов LAA
//***********************-****************************************************************
bool CalcSignal(cvector& Us, const TUnEqLAA_ODA& LAA, double P, double Phi, bool lBaseToEnd)
{//Объявление и инициализация локальных переменных
 ulong N = LAA.GetDimLAA();//Число каналов LAA
 ulong Origin = LAA.GetOrigin();//Индекс отсчетного канала LAA
 double d = LAA.GetRelDist();//Относительное расстояние между соседними каналами LAA
 double c = TwoPI*d*sin(Phi*DegRad);
 double Ampl = sqrt(fabs(P));//Амплитуда детерминированного сигнала
 double Phase;

 //Устанавливаем размерность вектора Us равной числу каналов LAA
 if (Us.Set(N,COL,false) == false) return false;

 //Цикл расчета комплексных амплитуд в приемных каналах LAA в зависимости от их
 //пространственного положения относительно отсчетного канала LAA с индексом Origin
 for (ulong i = 0L; i < N; i++)
 {Phase = c*(long)(i-Origin);
  Us.Put(i,polar(Ampl,Phase));
 }

 //Размещение комплексной амплитуды отсчетного канала LAA последним в векторе Us
 if (lBaseToEnd)
 {complex z;
  ulong LastElem = N-1;
  ulong index = Origin;
  while (index != LastElem)
  {z = Us.Get(index);
   Us.Put(index,Us.Get(index+1));
   Us.Put(index+1,z);
   index++;
  }
 }
 return true;
}
//****************************************************************************************
//СТАТУС: 7;  TUnEqLAA_ODA class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool CalcSignal(cvector& Us, const TUnEqLAA_ODA& LAA, double P, double Phi,
//             TRandGen_64& RandGen, bool lBaseToEnd = true)
//НАЗНАЧЕНИЕ: Расчет комплексных амплитуд в приемных каналах LAA при действии источника
//сигнала мощностью P с направления Phi [deg] со случайными составляющими амплитуды и фазы
//(гауссовский закон распределения). Результат работы функции формируется в векторе Us,
//передаваемом в функцию по ссылке. Размерность Us равна размерности LAA. Функция возвращает
//true в случае успешного проведения вычислений, в противном случае функция возвращает false.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& Us - ссылка на вектор-приемник значений комплексных амплитуд в каналах LAA
//   при действии одного источника излучения;
//2. const TUnEqLAA_ODA& LAA - линейная антенная решетка: приемная система;
//3. double P - мощность источника излучения принимаемый LAA;
//4. double Phi - угловое положение источника излучения в градусах относительно нормали
//   к раскрыву LAA (в градусах);
//5. TRandGen_64& RandGen - ссылка на датчик случайных чисел;
//6. bool lBaseToEnd (true) - опция размещения комплексной амплитуды отсчетного канала LAA
//   последним в векторе Us.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат расчета комплексных амплитуд приемных каналов LAA
//***********************-****************************************************************
bool CalcSignal(cvector& Us, const TUnEqLAA_ODA& LAA, double P, double Phi,
                TRandGen_64& RandGen, bool lBaseToEnd)
{//Проверка работоспособности RandGen
 if (!RandGen.IsReady()) {Us.Set(0,COL,C_ZERO); return false;}
 //Объявление и инициализация локальных переменных
 ulong N = LAA.GetDimLAA();//Число каналов LAA
 ulong Origin = LAA.GetOrigin();//Индекс отсчетного канала LAA
 double d = LAA.GetRelDist();//Относительное расстояние между соседними каналами LAA
 double c = TwoPI*d*sin(Phi*DegRad);
 double RelayAmpl, RandPhase;//Случайные составляющие амплитуды и фазы принимаемого сигнала
 double Phase, Ampl;

 //Устанавливаем размерность вектора Us равной числу каналов LAA
 if (Us.Set(N,COL,false) == false) return false;
 //Вычисляем случайные составляющие амплитуды и фазы принимаемого сигнала
 RandGen.GaussSignal(RelayAmpl,RandPhase);
 Ampl = RelayAmpl*sqrt(fabs(P));//Вычисляем случайную амплитуду сигнала

 //Цикл расчета комплексных амплитуд в приемных каналах LAA в зависимости от их
 //пространственного положения относительно отсчетного канала LAA с индексом Origin
 for (ulong i = 0L; i < N; i++)
 {Phase = c*(long)(i-Origin);
  Us.Put(i,polar(Ampl,Phase+RandPhase));
 }
 //Размещение комплексной амплитуды отсчетного канала LAA последним в векторе Us
 if (lBaseToEnd)
 {complex z;
  ulong LastElem = N-1;
  ulong index = Origin;
  while (index != LastElem)
  {z = Us.Get(index);
   Us.Put(index,Us.Get(index+1));
   Us.Put(index+1,z);
   index++;
  }
 }
 return true;
}
//****************************************************************************************
//СТАТУС: 8;  TUnEqLAA_ODA class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool CalcJams(cvector& Ujam, const TUnEqLAA_ODA& LAA, const TJammers_2D& Jams,
//             TRandGen_64& RandGen, bool lBaseToEnd = true)
//НАЗНАЧЕНИЕ: Расчет комплексных амплитуд в приемных каналах LAA при действии аддитивной
//помехи Jams со случайными составляющими амплитуды и фазы (гауссовский закон распределения).
//Результат работы функции формируется в векторе Ujam, передаваемом в функцию по ссылке.
//Размерность Ujam равна размерности LAA. Функция возвращает true в случае успешного прове-
//дения вычислений, в противном случае функция возвращает false.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& Ujam - ссылка на вектор-приемник значений комплексных амплитуд в каналах LAA
//   при действии аддитивной помехи;
//2. const TUnEqLAA_ODA& LAA - линейная антенная решетка: приемная система;
//3. const TJammers_2D& Jams - константная ссылка на контейнер со свойствами источников
//   излучения, представляющих аддитивное воздействие;
//4. TRandGen_64& RandGen - ссылка на датчик случайных чисел;
//5. bool lBaseToEnd (true) - опция размещения комплексной амплитуды отсчетного канала LAA
//   последним в векторе Us.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат расчета комплексных амплитуд приемных каналов LAA
//***********************-****************************************************************
bool CalcJams(cvector& Ujam, const TUnEqLAA_ODA& LAA, const TJammers_2D& Jams,
     TRandGen_64& RandGen, bool lBaseToEnd)
{//Проверка работоспособности RandGen
 if (!RandGen.IsReady()) {Ujam.Set(0,COL,C_ZERO); return false;}
 //Объявление и инициализация локальных переменных
 ulong N = LAA.GetDimLAA();//Число каналов LAA
 ulong Origin = LAA.GetOrigin();//Индекс отсчетного канала LAA
 double d = LAA.GetRelDist();//Относительное расстояние между соседними каналами LAA
 double c;
 double RelayAmpl, RandPhase;//Случайные составляющие амплитуды и фазы принимаемого сигнала
 double Phase, Ampl;

 //Устанавливаем размерность вектора Ujam равной числу каналов LAA
 if (Ujam.Set(N,COL,C_ZERO) == false) return false;

 CIter_Jams2D J, EIter;
 Jams.GetIterators(J,EIter);

 //Цикл по всем составляющим аддитивной помехи
 while (J != EIter)
 {//Вычисляем случайные составляющие амплитуды и фазы каждой компоненты аддитивной помехи
  RandGen.GaussSignal(RelayAmpl,RandPhase);
  Ampl = RelayAmpl*sqrt(J->GetPower());//Вычисляем случайную амплитуду сигнала
  c = TwoPI*d*sin(J->GetAngle(RAD));
  //Цикл расчета комплексных амплитуд в приемных каналах LAA в зависимости от их
  //пространственного положения относительно отсчетного канала LAA с индексом Origin
  for (ulong i = 0L; i < N; i++)
  {Phase = c*(long)(i-Origin);
   Ujam.Put(i,Ujam.Get(i)+polar(Ampl,Phase+RandPhase));
  }
  ++J;//Переходим к следующей компоненте аддитивной помехи
 }

 //Размещение комплексной амплитуды отсчетного канала LAA последним в векторе Ujam
 if (lBaseToEnd)
 {complex z;
  ulong LastElem = N-1;
  ulong index = Origin;
  while (index != LastElem)
  {z = Ujam.Get(index);
   Ujam.Put(index,Ujam.Get(index+1));
   Ujam.Put(index+1,z);
   index++;
  }
 }
 return true;
}
//****************************************************************************************
//СТАТУС: 9;  TUnEqLAA_ODA class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool CalcNoise(cvector& Unoise, const TUnEqLAA_ODA& LAA, TRandGen_64& RandGen,
//             bool lBaseToEnd = true)
//НАЗНАЧЕНИЕ: Расчет комплексных амплитуд внутреннего шума приемных каналах LAA со случай-
//ными составляющими амплитуды и фазы (гауссовский закон распределения). Результат работы
//функции формируется в векторе Unoise, передаваемом в функцию по ссылке. Размерность Unoise
//равна размерности LAA. Функция возвращает true в случае успешного проведения вычислений,
//в противном случае функция возвращает false.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& Unoise - ссылка на вектор-приемник комплексных амплитуд внутреннего шума
//   приемных каналов LAA (статистический подход);
//2. const TUnEqLAA_ODA& LAA - линейная антенная решетка: приемная система;
//3. TRandGen_64& RandGen - ссылка на датчик случайных чисел;
//4. bool lBaseToEnd (true) - опция размещения комплексной амплитуды отсчетного канала LAA
//   последним в векторе Unoise.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат расчета комплексных амплитуд внутреннего шума приемных каналов LAA
//***********************-****************************************************************
bool CalcNoise(cvector& Unoise, const TUnEqLAA_ODA& LAA, TRandGen_64& RandGen, bool lBaseToEnd)
{//Проверка работоспособности RandGen
 if (!RandGen.IsReady()) {Unoise.Set(0,COL,C_ZERO); return false;}
 //Объявление и инициализация локальных переменных
 ulong N = LAA.GetDimLAA();//Число каналов LAA
 double RelayAmpl, RandPhase;//Случайные составляющие амплитуды и фазы принимаемого сигнала
 double Ampl = sqrt(LAA.GetPn());//Амплитуда внутреннего шума приемных каналов LAA

 //Устанавливаем размерность вектора Unoise равной числу каналов LAA
 if (Unoise.Set(N,COL,false) == false) return false;

 //Цикл расчета комплексных амплитуд внутреннего шума приемных каналах LAA
 for (ulong i = 0L; i < N; i++)
 {//Вычисляем случайные составляющие амплитуды и фазы внутреннего шума
  RandGen.GaussSignal(RelayAmpl,RandPhase);
  Unoise.Put(i,polar(RelayAmpl*Ampl,RandPhase));
 }

 //Размещение комплексной амплитуды отсчетного канала LAA последним в векторе Us
 if (lBaseToEnd)
 {complex z;
  ulong LastElem = N-1;
  ulong index = LAA.GetOrigin();
  while (index != LastElem)
  {z = Unoise.Get(index);
   Unoise.Put(index,Unoise.Get(index+1));
   Unoise.Put(index+1,z);
   index++;
  }
 }
 return true;
}


//========================================================================================
//II. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TUnEqLAA_ODA
//    PRIVATE MEMBER-FUNCTION OF TUnEqLAA_ODA CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: II.1., private, TUnEqLAA_ODA class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Init();
//НАЗНАЧЕНИЕ: Начальная установка свойств объекта класса TUnEqLAA_ODA. Начальная установка
//характеристик: _N = 1; _d = 0.5; _Zero = 0; _Pn = 1.0;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TUnEqLAA_ODA::Init()
{_N = 1;//Размерность LAA
 _d = 0.5;//Межэлементное относительное расстояние
 _Zero = 0;//Отсчетный элемент LAA
 _Pn = 1.0;//Уровень внутреннего шума в каналах LAA
}


//********************** Конец реализации класса TUnEqLAA_ODA ****************************


//****************************************************************************************
//                        РЕАЛИЗАЦИЯ КЛАССА TEmissionSource_2D
//Класс описывает математическую модель источника излучения с одной угловой координатой,
//которая характеризуется двумя параметрами:
//1) Power - мощностью излучения (Power >= 0);
//2) Angle - угловое положение источника, относительно нормали к раскрыву приемной системы
//  (например, антенной решетки), -Pi <= Angle <= Pi (в радианах).
//****************************************************************************************
//========================================================================================
// I. РЕАЛИЗАЦИЯ КОНСТРУКТОРОВ И ДЕСТРУКТОРОВ КЛАССА TEmissionSource_2D
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TEmissionSource_2D constructor by default
//НАИМЕНОВАНИЕ ФУНКЦИИ: TEmissionSource_2D()
//НАЗНАЧЕНИЕ: Конструктор по умолчанию класса TEmissionSource_2D - свойства модели источника
//излучения с одной угловой координатой. Начальная инициализация членов-данных класса
//осуществляется функцией Reset(). Значения членов-данных объекта по умолчанию:
//1. _Power = 0;
//2. _Angle = 0;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
TEmissionSource_2D::TEmissionSource_2D()
{Reset(); //Начальная установка свойств
}
//****************************************************************************************
//СТАТУС: I.2; public; TEmissionSource_2D constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TEmissionSource_2D(double Power, double Angle, bool unit = DEG)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TEmissionSource_2D. Функция создает экземпляр
//класса через вызов функции Set(...).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double Power - мощность источника;
//2. double Angle - угловое положение источника, относительно нормали к раскрыву приемной
//   системы;
//3. bool unit (DEG) - единица измерения Angle в градусах (DEG) или радианах (RAD);
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
TEmissionSource_2D::TEmissionSource_2D(double Power, double Angle, bool unit)
{Set(Power,Angle,unit);//Установка характеристик экземпляра класса
}
//****************************************************************************************
//СТАТУС: I.3; public; TEmissionSource_2D class destructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: TEmissionSource_2D
//НАЗНАЧЕНИЕ: Деструктор класса TEmissionSource_2D - разрушает объект.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
TEmissionSource_2D::~TEmissionSource_2D()
{Reset(); //Сброс свойств объекта класса
}

//========================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TEmissionSource_2D
//    PUBLIC MEMBER-FUNCTION OF TEmissionSource_2D CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TEmissionSource_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Set(double Power, double Angle, bool unit = DEG)
//НАЗНАЧЕНИЕ: Установка свойств модели источника излучения.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double Power - мощность источника;
//2. double Angle - угловое положение источника, относительно нормали к раскрыву приемной
//   системы;
//3. bool unit (DEG) - единица измерения Angle в градусах (DEG) или радианах (RAD);
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TEmissionSource_2D::Set(double Power, double Angle, bool unit)
{//Установка новых параметров
 SetPower(Power);
 SetAngle(Angle,unit);
}
//****************************************************************************************
//СТАТУС: I.2; public; TEmissionSource_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetPower(double Power)
//НАЗНАЧЕНИЕ: Установка мощности источника излучения.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: double Power - мощность источника;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TEmissionSource_2D::SetPower(double Power)
{//Установка новых параметров
 _Power = fabs(Power);
}
//****************************************************************************************
//СТАТУС: I.3; public; TEmissionSource_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SetAngle(double Angle, bool unit = true)
//НАЗНАЧЕНИЕ: Установка углового положения источника излучения относительно нормали к
//раскрыву приемной системы. Угол может быть задан в градусах или радианах. При задании
//угла в градусах, он будет пересчитан в РАДИАНЫ (для удобства вычислений, т.к. тригоно-
//метрические функции используют радианную меру угла) и приведен к интервалу [-PI..PI].
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double Angle - угловое положение источника, относительно нормали к раскрыву приемной
//   системы;
//2. bool unit (DEG) - единица измерения Angle в градусах (DEG) или радианах (RAD);
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TEmissionSource_2D::SetAngle(double Angle, bool unit)
{//Установка новых параметров (перевод радиан в градусы при необходимости)
 _Angle = (unit == DEG) ? Angle*DegRad : Angle;
 //Приведение угла (в радианах) к интервалу [-PI..PI]
 if (_Angle >= 0) //Положительное направление отсчета угла (по часовой стрелки)
  while (_Angle > OnePI) _Angle -= TwoPI;
 else //Отрицательное направление отсчета угла (против часовой стрелке)
 {while (_Angle < -OnePI) _Angle += TwoPI;
 }
}
//****************************************************************************************
//СТАТУС: I.4; public; TEmissionSource_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(const char* s)
//НАЗНАЧЕНИЕ: Установка свойств модели источника излучения из строки s. Функция извлекает
//из строки s свойства источника излучения и в случае успеха устанавливает новые свойства
//объекта. Формат символьного представления свойств класса:
//[<WS>]<(><Power>,[<WS>]<Angle><)>, где (например, (10,30) => Power: 10, Angle: 30 deg)
//Power, Angle - символьные представления вещ-х значений мощности и углового положения
//источника излучения.
//Функция возвращает false в случае отсутствия символьного представления свойств источника
//излучения в s или в случае обнаружения синтаксической ошибки при их извлечении из s.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const char* s - константный указатель на строку со свойствами источника излучения
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - индикатор обновления свойств объекта из строки
//****************************************************************************************
bool TEmissionSource_2D::Set(const char* s)
{bool lSuccess = false;
 TStrToDoubleArgs DArgs;//Объект извлечения из строки вещ-х аргументов в круглых скобках
 ulong pos = 0L;
 //Извлечение из строки s списка вещ-х чисел, заключенных в круглые скобки
 if (DArgs(s,pos) == 2) //Список должен содержать ровно 2 числа - Power & Angle
 {rvector params;
  DArgs.GetFirstChain(params);
  Set(params[0],params[1],DEG);
  lSuccess = true;
 }
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.5; public; TEmissionSource_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double GetAngle(bool unit = DEG) const
//НАЗНАЧЕНИЕ: Получение углового положения источника излучения относительно нормали к
//раскрыву приемной системы в градусах или радианах.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//bool unit (DEG) - единица измерения Angle в градусах (DEG) или радианах (RAD);
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double Angle - угловое положение источника в градусах (радианах)
//****************************************************************************************
double TEmissionSource_2D::GetAngle(bool unit) const
{
 return (unit == DEG) ? _Angle*RadDeg : _Angle;
}
//****************************************************************************************
//СТАТУС: I.6; public; TEmissionSource_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Get(double &Power, double &Angle, bool unit = DEG)
//НАЗНАЧЕНИЕ: Получение свойств модели источника излучения: мощности и его углового поло-
//жения относительно нормали к раскрыву приемной системы. Свойства объекта присваиваются
//переменным Power & Angle, передаваеммым по ссылке в функцию.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double &Power - мощность источника;
//2. double &Angle - угловое положение источника, относительно нормали к раскрыву приемной
//   системы;
//3. bool unit (DEG) - единица измерения Angle в градусах (DEG) или радианах (RAD);
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TEmissionSource_2D::Get(double &Power, double &Angle, bool unit) const
{//Получение свойств объекта
 Power = GetPower();
 Angle = GetAngle(unit);
}
//****************************************************************************************
//СТАТУС: I.7; public member-function of class TEmissionSource_2D
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Properties(string& s) const
//НАЗНАЧЕНИЕ: Формирование характеристик объекта TEmissionSource_2D в символьном виде в
//строке s, передаваемой в функцию по ссылке. Свойства источника излучения представляются:
//----------------------------------------------------------------------------------------
// Power: <_Power>, Angle: <_Angle in DEG>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строковый объект, в котором формируются свойства источника излучения
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами объекта.
//****************************************************************************************
string& TEmissionSource_2D::Properties(string& s) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 text << "Power: " << GetPower() << ", Angle: " << GetAngle(DEG) << ends;
 s.assign(text.str());
 return s;
}
//****************************************************************************************
//СТАТУС: I.8; public member-function of class TEmissionSource_2D
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Brief(string& s) const
//НАЗНАЧЕНИЕ: Получение свойств объекта TEmissionSource_2D в краткой форме в строке s,
//передаваемой в функцию по ссылке. Свойства источника излучения представляются:
//----------------------------------------------------------------------------------------
// (<_Power>, <_Angle in DEG>)
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//string& s - ссылка на строку, в которой заносятся свойства объекта в кратком виде
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами объекта в кратком виде
//****************************************************************************************
string& TEmissionSource_2D::Brief(string& s) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 text << '(' << this->GetPower() << ',' << this->GetAngle(DEG) << ')' << ends;
 s.assign(text.str());
 return s;
}
//****************************************************************************************
//СТАТУС: I.9; public; TEmissionSource_2D class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: void operator =(const TEmissionSource_2D& EmiSrc)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ  класса TEmissionSource_2D.
//Функция осуществляет копирование свойств одного объекта  TEmissionSource_2D в другой.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TEmissionSource_2D& EmiSrc - ссылка на копируемый объект
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TEmissionSource_2D::operator =(const TEmissionSource_2D& EmiSrc)
{//Предотвращение попытки присваивания объекта самому себе
 if (this == &EmiSrc) return;
 SetPower(EmiSrc.GetPower());
 SetAngle(EmiSrc.GetAngle(RAD),RAD);
}
//****************************************************************************************
//СТАТУС: I.10; public; TEmissionSource_2D class overloading operator ==
//OVERLOADING COMPARE OPERATOR <EQUAL>
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ==(const TEmissionSource_2D& EmiSrc) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СРАВНЕНИЯ объектов класса TEmissionSource_2D.
//Функция осуществляет сравнение свойств двух объектов TEmissionSource_2D. При равенстве
//их мощностей излучения и углых положений относительно приемной системы функция возвращает
//true в противном случае - false.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TEmissionSource_2D& EmiSrc - ссылка на сравниваемый объект
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lCompare - результат сравнения двух объектов
//****************************************************************************************
bool TEmissionSource_2D::operator ==(const TEmissionSource_2D& EmiSrc) const
{
 return ((GetPower() == EmiSrc.GetPower()) &&
        (GetAngle(RAD) == EmiSrc.GetAngle(RAD))) ? true : false;
}
//****************************************************************************************
//СТАТУС: I.11; public; TEmissionSource_2D class overloading operator <
//OVERLOADING COMPARE OPERATOR <LESS, SMALLER>
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator <(const TEmissionSource_2D& EmiSrc) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СРАВНЕНИЯ объектов класса TEmissionSource_2D.
//Функция осуществляет сравнение свойств двух объектов TEmissionSource_2D. Сравнение про-
//водиться по мощностям источников излучения. При this.Power < EmiSrc.Power, функция воз-
//вращает true в противном случае - false.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TEmissionSource_2D& EmiSrc - ссылка на сравниваемый объект
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lCompare - результат сравнения двух объектов
//****************************************************************************************
bool TEmissionSource_2D::operator <(const TEmissionSource_2D& EmiSrc) const
{
 return (GetPower() < EmiSrc.GetPower()) ? true : false;
}

//========================================================================================
//             РЕАЛИЗАЦИЯ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССА TEmissionSource_2D
//========================================================================================
//****************************************************************************************
//СТАТУС: 1;  TEmissionSource_2D class friend overloading operator <<
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend ostream& operator <<(ostream& out, const TEmissionSource_2D& EmiSrc)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВЫВОДА класса TEmissionSource_2D.
//Функция предназначена для вывода в поток характеристик источника излучения в краткой
//форме. Функция возвращает ссылку на поток, что позволяет записывать в программе операторы
//вывода в поток каскадно. Формат вывода: (<_Power>, <_Angle in DEG>)
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на объект потока вывода
//2. сonst TEmissionSource_2D& EmiSrc - ссылка на объект, выводимый в поток.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ostream& out - ссылка на объект потока вывода.
//***********************-****************************************************************
ostream& operator <<(ostream& out, const TEmissionSource_2D& EmiSrc)
{string s;
 EmiSrc.Brief(s);//Получение свойств источника излучения в виде строки (в краткой форме)
 out << s;//Вывод характеристик объекта
 return out;
}
//****************************************************************************************
//СТАТУС: 2;  TEmissionSource_2D class friend overloading operator >>
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool operator >>(istream& in, TEmissionSource_2D& EmiSrc)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВВОДА класса TEmissionSource_2D.
//Функция предназначена для ввода в поток in характеристик источника излучения в краткой
//форме. Формат ввода: (<_Power>, <_Angle in DEG>).
//Функция возвращает true в случае успешного ввода свойств источника излучения и false -
//в противоположном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. istream& in - ссылка на объект потока ввода;
//2. TEmissionSource_2D& EmiSrc - ссылка на объект, свойства которого будут вводиться из
//   потока in.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат ввода данных в объект из потока ввода
//***********************-****************************************************************
bool operator >>(istream& in, TEmissionSource_2D& EmiSrc)
{char buf[41];
 in.ignore();
 in.getline(buf,sizeof(buf));
 return EmiSrc.Set(buf);
}
//****************************************************************************************
//СТАТУС: 3;  TEmissionSource_2D class friend function
//INPUT TEmissionSource_2D PROPERTIES by cin
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool Edit(TEmissionSource_2D& EmiSrc, const char* sName = NULL)
//НАЗНАЧЕНИЕ: Редактирование свойств объекта класса TEmissionSource_2D через стандартный
//поток ввода cin.
//Функция предназначена для ввода характеристик источника излучения EmiSrc, передаваемый по
//ссылке. Функция возвращает true - в случае изменения свойств объекта и false - в противо-
//положном случае. После ввода новых свойств объекта осуществляется их отображение.
//Формат ввода характристик источника излучения:
//----------------------------------------------------------------------------------------
//EMISSION SOURCE: <Input Properties>
// Power: <value >= 0>, Angle: < -Pi <= value <= Pi >
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TEmissionSource_2D& EmiSrc - ссылка на редактируемый объект;
//2. const char* sName (NULL) - наименование редактируемого объекта (опционально).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lChanged - результат редактирования
//***********************-****************************************************************
bool Edit(TEmissionSource_2D& EmiSrc, const char* sName)
{//Рабочие переменные
 TEmissionSource_2D PrevEmiSrc(EmiSrc);
 char buffer[20];
 ostrstream text(buffer, sizeof(buffer));
 double value;
 int y, row_start = wherey();
 char c;
 string s, line(78,'-');
 string sEmiSrcName("EMISSION SOURCE");
 bool flag;
 gotoxy(1,row_start); clreol();

 if (sName != NULL) sEmiSrcName.assign(sName);//Имя редактируемого объекта

 do //Цикл ввода свойств источника излучения
 {//--------------------------------------------------------------------------------------
  cout << line << endl;
  cout << "Edit: <" << sEmiSrcName << ">, Before: " << PrevEmiSrc << endl;
  //--------------------------------------------------------------------------------------
  //1. Ввод значения мощности источника излучения
  //--------------------------------------------------------------------------------------
  s = " Power: "; y = wherey();
  cout << " Power: "; cin >> value; EmiSrc.SetPower(value);
  text << EmiSrc.GetPower() << ends;
  s.append(text.str()); text.seekp(0);
  ClrScr(1,y);//Очистка экрана
  cout << s << endl;
  //--------------------------------------------------------------------------------------
  //2. Ввод углового положения источника излучения относительно приемной системы
  //--------------------------------------------------------------------------------------
  s.append(", Angle: ");
  cout << " Angle [-180..180]: "; cin >> value; EmiSrc.SetAngle(value,DEG);
  text << EmiSrc.GetAngle(DEG) << ends;
  s.append(text.str()); text.seekp(0);
  ClrScr(1,y);//Очистка экрана
  cout << s << endl;
  //-----------------------------------------------------------------------------------
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
 //Проверка на изменение свойств редактируемого объекта
 return (PrevEmiSrc == EmiSrc) ? true : false;
}

//========================================================================================
//II. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TEmissionSource_2D
//    PROTECTED MEMBER-FUNCTION OF TEmissionSource_2D CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: II.1., protected, TEmissionSource_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Reset();
//НАЗНАЧЕНИЕ: Начальная установка свойств модели источника излучения на плоскости.
//Начальная установка характеристик:
//1. _Power = 0;
//2. _Angle = 0;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TEmissionSource_2D::Reset()
{_Power = 0.0;
 _Angle = 0.0;
}
//******************** Конец реализации класса TEmissionSource_2D ************************

//****************************************************************************************
//                        РЕАЛИЗАЦИЯ КЛАССА TJammers_2D
//Класс описывает математическую модель множества источников излучения с одной угловой
//координатой, каждый из которых характеризуется двумя параметрами:
//1) Power - мощностью излучения (Power >= 0);
//2) Angle - угловое положение источника, относительно нормали к раскрыву приемной системы
//  (например, антенной решетки), -Pi <= Angle <= Pi (в радианах).
//Каждый источник представляется объектом класса TEmissionSource_2D. Все источники хранятся
//в контейнерном классе библиотеки STL - <deque>. Класс не позволяет хранить два и более
//источника с равными угловыми координатами.
//Класс используется для моделирования аддитивной пространственной помехи на входе приемных
//систем (напр., LAA), которые пространственно могут различать источники с одной угловой
//координатой (например, только по углу места или только по углу азимута).
//****************************************************************************************
//========================================================================================
// I. РЕАЛИЗАЦИЯ КОНСТРУКТОРОВ И ДЕСТРУКТОРОВ КЛАССА TJammers_2D
//========================================================================================

//========================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TJammers_2D
//    PUBLIC MEMBER-FUNCTION OF TJammers_2D CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TJammers_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool FindByAngle(const TEmissionSource_2D& EmiSrc) const
//НАЗНАЧЕНИЕ: Определяет наличие в объекте источника излучения с угловой координатой равной
//EmiSrc, передаваемой в функцию по ссылке. Функция возвращает true, если источник с такой
//угловой координатой присутствует в контейнере _Jams, иначе возвращается false.
//Функция применяется при добавлении новых источников излучения в объект класса. В случае
//наличия в _Jams источника с угловой координатой равной угловой координате EmiSrc добавле-
//ние нового источника не происходит.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const TEmissionSource_2D& EmiSrc - ссылка на источник излучения;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lFind - результат поиска источника излучения в объекте с
//угловой координатой равной EmiSrc
//****************************************************************************************
bool TJammers_2D::FindByAngle(const TEmissionSource_2D& EmiSrc) const
{bool lFind = false;
 if (this->Count() == 0) return lFind;//Проверка на наличие в списке источников излучения
 double Angle = EmiSrc.GetAngle(RAD);
 deque<TEmissionSource_2D>::const_iterator I = _Jams.begin();
 //Цикл поиска в контейнере источника излучения с угловой координатой Angle
 while (I != _Jams.end())
 {if (I->GetAngle(RAD) == Angle) {lFind = true; break;}
  ++I;
 }
 return lFind;
}
//****************************************************************************************
//СТАТУС: I.2; public; TJammers_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Find(const TEmissionSource_2D& EmiSrc) const
//НАЗНАЧЕНИЕ: Определяет наличие в объекте источника излучения со свойствами аналогичными
//свойствам EmiSrc, передаваемому по ссылке. Функция возвращает true, если такой источник
//излучения присутствует в контейнере _Jams, иначе возвращается false.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const TEmissionSource_2D& EmiSrc - ссылка на источник излучения;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lFind - результат поиска источника излучения в объекте со
//свойствами аналогичными свойствам EmiSrc
//****************************************************************************************
bool TJammers_2D::Find(const TEmissionSource_2D& EmiSrc) const
{bool lFind = false;
 if (this->Count() == 0) return lFind;//Проверка на наличие в списке источников излучения
 deque<TEmissionSource_2D>::const_iterator I = _Jams.begin();
 //Цикл поиска в контейнере источника излучения со свойствами EmiSrc
 while (I != _Jams.end())
 {if (*I == EmiSrc) {lFind = true; break;}
  ++I;
 }
 return lFind;
}
//****************************************************************************************
//СТАТУС: I.3; public; TJammers_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Add(const TEmissionSource_2D& EmiSrc)
//НАЗНАЧЕНИЕ: Добавление в список нового источника излучения EmiSrc, передаваемого в функ-
//цию по ссылке. Функция возвращает true при добавление EmiSrc в список _Jams и false - в
//противном случае. Если источник с угловой координатой равной EmiSrc уже имеется в списке,
//то добавление не происходит. Вставка происходит в конец списка.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TEmissionSource_2D& EmiSrc - ссылка на источник излучения;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат добавления источника излучения в объект
//****************************************************************************************
bool TJammers_2D::Add(const TEmissionSource_2D& EmiSrc)
{bool lSuccess = false;
 if (!this->FindByAngle(EmiSrc)) {_Jams.push_back(EmiSrc); lSuccess = true;}
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.4; public; TJammers_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Add(double Power, double Angle, bool unit = DEG);
//НАЗНАЧЕНИЕ: Добавление в список нового источника излучения с параметрами Power и Angle.
//Функция возвращает true при добавление нового источника излучения в список _Jams и false
//- в противном случае. Если источник с угловой координатой Angle  уже имеется в списке,
//то добавление не происходит. Вставка происходит в конец списка.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double &Power - мощность источника;
//2. double &Angle - угловое положение источника, относительно нормали к раскрыву приемной
//   системы;
//3. bool unit (DEG) - единица измерения Angle в градусах (DEG) или радианах (RAD);
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат добавления источника излучения в объект
//****************************************************************************************
bool TJammers_2D::Add(double Power, double Angle, bool unit)
{TEmissionSource_2D EmiSrc(Power,Angle,unit);
 return this->Add(EmiSrc);
}
//****************************************************************************************
//СТАТУС: I.5; public; TJammers_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: long Import(const char* s, bool lClear = true)
//НАЗНАЧЕНИЕ: Извлечение списка источников излучения, представленных в символьном виде, из
//строки s. Источники излучения в строке должны быть представлены в виде:
// (P1,A1) (P2,A2) ... (Pn,An), где
// P1, P2 ... Pn - мощности источников излучения;
// A1, A2 ... An - угловые координаты источников излучения в градусах.
//Функция добавляет в объект только источники излучения с неповторяющимися угловыми коорди-
//натами. Опция lClear позволяет предварительно очистить (удалить) источники излучения,
//размещенные в нем ранее. Функция возвращает число добавленных в объект класса источников
//излучения.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const char* s - указатель на строку с источниками излучения в символьном виде;
//2. bool lClear (true) - опция удаления ранее размещенных источников излучения в объекте.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: long Count - кол-во новых источников излучения в объекте
//****************************************************************************************
long TJammers_2D::Import(const char* s, bool lClear)
{if (lClear) this->RemoveAll();//Удаление ранее размещенных источников излучения
 long PrevCount = this->Count();
 TStrToDoubleArgs DblArgList;
 list<double> d_list;
 //Извлечение из строки всех вещ-х списков аргументов, заключенных в круглые скобки
 DblArgList(s);
 //Импорт в список d_list вещ-х списков с двумя аргументами из объекта DblArgList
 DblArgList.GetAllChains(d_list,2);
 //Импорт из списка d_list в объект типа TJammers_2D вещ-х аргументов и их преобразование
 //в источники излучения типа TEmissionSource_2D
 if (d_list.size() != 0)
 {list<double>::const_iterator I = d_list.begin();
  double Power, Angle;
  while (I != d_list.end())
  {Power = *I++;
   Angle = *I++;
   this->Add(Power,Angle,DEG);
  }
 }
 return this->Count()-PrevCount;//Кол-во импортированных из строки источников излучения
}
//****************************************************************************************
//СТАТУС: I.6; public member-function of class TJammers_2D
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Brief(string& s, char delim = ' ') const
//НАЗНАЧЕНИЕ: Получение свойств источников излучения класса TEmissionSource_2D, размещенных
//в объекте класса TJammers_2D, в краткой форме в строке s, передаваемой в функцию по ссылке.
//Свойства каждого источника излучения представляются:
//----------------------------------------------------------------------------------------
// (<_Power>, <_Angle in DEG>)
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой заносятся свойства объекта в кратком виде
//2. char delim (' ') - символ-разделитель между свойствами соседних источников излучения
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами объекта в кратком виде
//****************************************************************************************
string& TJammers_2D::Brief(string& s, char delim) const
{s.clear();//Очистка строки
 if (this->Count() == 0) return s;
 deque<TEmissionSource_2D>::const_iterator I = _Jams.begin();
 string t;
 //Цикл формирования свойств источников излучения
 while (I != _Jams.end())
 {s.append(I->Brief(t));//Краткая форма представления объекта класса TEmissionSource_2D
  if (++I != _Jams.end()) s.append(1,delim);
 }
 return s;
}
//****************************************************************************************
//СТАТУС: I.7; public member-function of class TJammers_2D
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Properties(string& s, char delim = ' ') const
//НАЗНАЧЕНИЕ: Формирование характеристик объекта TJammers_2D в символьном виде в строке s,
//передаваемой в функцию по ссылке. Свойства представляются в виде:
//----------------------------------------------------------------------------------------
// One-coordinate Emission Sources: <N>
// (P1,A1) (P2,A2) ... (Pn,An), где
// N - кол-во источников излучения, размещенных в объекте;
// P1, P2 ... Pn - значения мощностей источников излучения;
// A1, A2 ... An - угловые координаты в градусах источников излучения.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строковый объект, в котором формируются свойства объекта
//2. char delim (' ') - символ-разделитель между свойствами соседних источников излучения
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами объекта.
//****************************************************************************************
string& TJammers_2D::Properties(string& s, char delim) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 string t;
 text << "One-coordinate Emission Sources: " << this->Count() << ", SumPower: "
      << this->TotalPower() << endl << ends;
 s.assign(text.str());
 this->Brief(t,delim);//Получение свойств источников излучения в виде строки (в краткой форме)
 s.append(t);
 return s;
}
//****************************************************************************************
//СТАТУС: I.8; public member-function of class TJammers_2D
//НАИМЕНОВАНИЕ ФУНКЦИИ: long GetIterators(CIter_Jams2D& BIter, CIter_Jams2D& EIter) const
//НАЗНАЧЕНИЕ: Получение константных итераторов на начало и конец списка _Jams. Итераторы
//на начало и конец дека _Jams заносятся в переменные BIter и EIter соответственно, пере-
//даваемые в функцию по ссылке. Функция возвращает кол-во источников излучения, размещенных
//в объекте-контейнере.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. CIter_Jams2D& BIter - ссылка на итератор, в который заносится итератор начала дека
//2. CIter_Jams2D& EIter - ссылка на итератор, в который заносится итератор конца дека
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: long Count - кол-во источников излучения, размещенных в объекте
//****************************************************************************************
long TJammers_2D::GetIterators(CIter_Jams2D& BIter, CIter_Jams2D& EIter) const
{BIter = (CIter_Jams2D) _Jams.begin();
 EIter = (CIter_Jams2D) _Jams.end();
 return this->Count();
}
//****************************************************************************************
//СТАТУС: I.9; public; TJammers_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SortByAngle()
//НАЗНАЧЕНИЕ: Сортировка источников излучения, расположенных в deque _Jams, по возрастанию
//угловых координат. Функция может изменить порядок расположения источников излучения в
//контейнере.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TJammers_2D::SortByAngle()
{if (this->Count() == 0) return;//Проверка на наличие в списке источников излучения
 deque<TEmissionSource_2D>::iterator IterBegin = _Jams.begin();
 deque<TEmissionSource_2D>::iterator IterEnd = _Jams.end();
 TEmiSrc2D_CompByAngle CompByAngle;
 stable_sort(_Jams.begin(),_Jams.end(),CompByAngle);
}
//****************************************************************************************
//СТАТУС: I.10; public; TJammers_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void SortByPower()
//НАЗНАЧЕНИЕ: Сортировка источников излучения, расположенных в deque _Jams, по возрастанию
//значений мощности. Функция может изменить порядок расположения источников излучения в
//контейнере.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TJammers_2D::SortByPower()
{if (this->Count() == 0) return;//Проверка на наличие в списке источников излучения
 deque<TEmissionSource_2D>::iterator IterBegin = _Jams.begin();
 deque<TEmissionSource_2D>::iterator IterEnd = _Jams.end();
 TEmiSrc2D_CompByPower CompByPower;
 stable_sort(_Jams.begin(),_Jams.end(),CompByPower);
}
//****************************************************************************************
//СТАТУС: I.11; public; TJammers_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SetPower(double Power)
//НАЗНАЧЕНИЕ: Установка одинаковых значений мощности Power для всех источников излучения.
//Функция возвращает false, если список источников излучения пустой, в остальных случаях
//возвращается true.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//double Power - устанавливаемое значение мощности для всех источников излучения
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения функции
//****************************************************************************************
bool TJammers_2D::SetPower(double Power)
{//Проверка на наличие в списке источников излучения
 if (this->Count() == 0) return false;
 deque<TEmissionSource_2D>::iterator Iter = _Jams.begin();
 deque<TEmissionSource_2D>::iterator EndIter = _Jams.end();
 while (Iter != EndIter)
 {Iter->SetPower(Power);
  ++Iter;
 }
 return true;
}
//****************************************************************************************
//СТАТУС: I.12; public; TJammers_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SetTotalPower(double Psum)
//НАЗНАЧЕНИЕ: Установка суммарной мощности для всех источников излучения с равномерным ее
//распределением для всех источников: Pi = Psum/N, N - число источников излучения, Pi -
//мощность i-го источника излучения (1 <= i <= N). Функция возвращает false, если список
//источников излучения пустой, в остальных случаях возвращается true.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//double Psum - устанавливаемая суммарная мощность всех источников излучения
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения функции
//****************************************************************************************
bool TJammers_2D::SetTotalPower(double Psum)
{//Проверка на наличие в списке источников излучения
 ulong N = this->Count();
 if (N == 0) return false;
 double Power = fabs(Psum)/N;
 deque<TEmissionSource_2D>::iterator Iter = _Jams.begin();
 deque<TEmissionSource_2D>::iterator EndIter = _Jams.end();
 while (Iter != EndIter)
 {Iter->SetPower(Power);
  ++Iter;
 }
 return true;
}
//****************************************************************************************
//СТАТУС: I.13; public; TJammers_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double TotalPower() const
//НАЗНАЧЕНИЕ: Суммарная мощность источников излучения, размещенных в объекте TJammers_2D.
//Функция возвращает суммарную мощность всех источников излучения.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double Power - мощность всех источников излучения
//****************************************************************************************
double TJammers_2D::TotalPower() const
{double Power = 0.0;
 //Проверка на наличие в списке источников излучения
 if (this->Count() == 0) return Power;
 deque<TEmissionSource_2D>::const_iterator Iter = _Jams.begin();
 deque<TEmissionSource_2D>::const_iterator EndIter = _Jams.end();
 while (Iter != EndIter)
 {Power += Iter->GetPower();
  ++Iter;
 }
 return Power;
}
//****************************************************************************************
//СТАТУС: I.14; public; TJammers_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: long Assign(const rvector& Angle, double Power = 1.0)
//НАЗНАЧЕНИЕ: Присваивание новых источников излучения (с удалением старых) с угловыми коор-
//динатами из вектора Angle, заданными в градусах и одинаковой мощностью Power.
//Функция возвращает количество источников излучения после выполнения операции присваивания.
//Дублирования источников с одинаковыми угловыми координатами не происходит.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector &Angle - вектор с угловыми положениями источников излучения (в градусах),
//   относительно нормали к раскрыву приемной системы;
//2. double Power (1.0) - мощность каждого источника излучения.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//long Count - кол-во источников излучения в списке после выполнения функции
//****************************************************************************************
long TJammers_2D::Assign(const rvector& Angle, double Power)
{this->RemoveAll();//Удаление старых источников излучения
 TEmissionSource_2D EmiSrc;
 for (ulong i = 0L; i < Angle.Size(); i++)
 {EmiSrc.Set(Power,Angle.Get(i),DEG);
  this->Add(EmiSrc);
 }
 return this->Count();
}
//****************************************************************************************
//СТАТУС: I.15; public; TJammers_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: long Assign(const TDoubleSet& Angle, double Power = 1.0)
//НАЗНАЧЕНИЕ: Присваивание новых источников излучения (с удалением старых) с угловыми коор-
//динатами из множества TDoubleSet, заданными в градусах и одинаковой мощностью Power.
//Функция возвращает количество источников излучения после выполнения операции присваивания.
//Дублирования источников с одинаковыми угловыми координатами не происходит.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TDoubleSet &Angle - множество с угловыми положениями источников излучения
//   (в градусах), относительно нормали к раскрыву приемной системы;
//2. double Power (1.0) - мощность каждого источника излучения.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//long Count - кол-во источников излучения в списке после выполнения функции
//****************************************************************************************
long TJammers_2D::Assign(const TDoubleSet& Angle, double Power)
{this->RemoveAll();//Удаление старых источников излучения
 //Получение начального и конечного итераторов на контейнер Angle
 DblSet::const_iterator Iter, EndIter;
 Angle.GetIters(Iter,EndIter);
 //Цикл по угловым положениям
 while (Iter != EndIter)
 {this->Add(Power,*Iter,DEG);
  ++Iter;//Переход к следующему угловому значению
 }
 return this->Count();
}
//****************************************************************************************
//СТАТУС: I.16; public; TJammers_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ulong GetAngleCoords(TDoubleSet& Angle) const
//НАЗНАЧЕНИЕ: Экспорт в объект Angle всех угловых координат источников излучения в
//градусах, размещенных в контейнере TJammers_2D. Функция возвращает число угловых коорди-
//нат, размещенных в списке Angle, передаваемом в функцию по ссылке. Предыдущие данные,
//размещенные в Angle уничтожаются.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TDoubleSet& Angle - ссылка на контейнер-приемник угловых
//координат в градусах источников излучения.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong Count - число угловых координат (источников излучения),
//размещенных в контейнере Angle.
//****************************************************************************************
ulong TJammers_2D::GetAngleCoords(TDoubleSet& Angle) const
{double AngleCoord;
 Angle.Clear();//Очистка контейнера Angle
 Angle.SetName("Angle Coordinates");//Присваивание имени контейнеру Angle
 //Проверка на наличие в списке источников излучения
 if (this->Count() == 0) return 0;
 deque<TEmissionSource_2D>::const_iterator Iter = _Jams.begin();
 deque<TEmissionSource_2D>::const_iterator EndIter = _Jams.end();
 while (Iter != EndIter)
 {Angle.Append(Iter->GetAngle(DEG));
  ++Iter;
 }
 return Angle.Size();
}

//========================================================================================
// РЕАЛИЗАЦИЯ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ КЛАССА TJammers_2D
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TJammers_2D class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: void operator =(const TJammers_2D& Jams)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ  класса TJammers_2D. Функция копирует
//свойства одного объекта  TJammers_2D в другой.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TJammers_2D& Jams - ссылка на копируемый объект
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TJammers_2D::operator =(const TJammers_2D& Jams)
{//Предотвращение попытки присваивания объекта самому себе
 if (this == &Jams) return;

 const deque<TEmissionSource_2D>* refJams = Jams.GetList();
 deque<TEmissionSource_2D>::const_iterator I = refJams->begin();

 this->RemoveAll();//Очистка списка источников излучения
 //Цикл копирования источников излучение из объекта Jams в объект this
 while (I != refJams->end())
 {//_Jams.push_back(*I++);
  //Добавление нового источника излучения с проверкой на его уникальность в списке
  //(по угловой координате)
  this->Add(*I++);
 }
}
//****************************************************************************************
//СТАТУС: I.2; public; TJammers_2D class overloading operator ==
//OVERLOADING COMPARE OPERATOR <EQUAL>
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ==(const TJammers_2D& Jams) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СРАВНЕНИЯ объектов класса TJammers_2D.
//Функция сравнение свойств двух объектов TEmissionSource_2D. При равенстве
//их мощностей излучения и углых положений относительно приемной системы функция возвращает
//true в противном случае - false.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TJammers_2D& Jams - ссылка на сравниваемый объект
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lCompare - результат сравнения двух объектов
//****************************************************************************************
bool TJammers_2D::operator ==(const TJammers_2D& Jams) const
{//Проверка на сравнение объекта с самим собой
 if (this == &Jams) return true;
 //Проверка на равенство количества источников излучения, хранящихся в двух объектах
 if (this->Count() != Jams.Count()) return false;
 //Поэлементное сравнение двух объектов
 bool lCompare = true;
 deque<TEmissionSource_2D>::const_iterator I = _Jams.begin();
 //Цикл сравнения источников излучения
 while (I != _Jams.end())
 {if (Jams.Find(*I) == false) {lCompare = false; break;}
  ++I;
 }
 return lCompare;
}

//========================================================================================
//             РЕАЛИЗАЦИЯ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССА TJammers_2D
//========================================================================================
//****************************************************************************************
//СТАТУС: 1;  TJammers_2D class friend overloading operator <<
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend ostream& operator <<(ostream& out, const TJammers_2D& Jams)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВЫВОДА класса TUnEqLAA_ODA.
//Функция предназначена для вывода в поток свойств источников излучения, размещенных в
//объекте Jams класса TJammers_2D в краткой форме. Функция возвращает ссылку на поток, что
//позволяет записывать в программе операторы вывода в поток каскадно. Формат вывода:
//----------------------------------------------------------------------------------------
// One-coordinate Emission Sources: <N>
// (P1,A1) (P2,A2) ... (Pn,An), где
// N - кол-во источников излучения, размещенных в объекте;
// P1, P2 ... Pn - значения мощностей источников излучения;
// A1, A2 ... An - угловые координаты в градусах источников излучения.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на объект потока вывода
//2. сonst TJammers_2D& Jams - ссылка на объект, выводимый в поток.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ostream& out - ссылка на объект потока вывода.
//***********************-****************************************************************
ostream& operator <<(ostream& out, const TJammers_2D& Jams)
{string s;
 Jams.Brief(s);//Получение свойств источников излучения в виде строки (в краткой форме)
 out << "One-coordinate Emission Sources: " << Jams.Count() << endl;
 out << s;//Вывод характеристик источников излучения
 return out;
}
//****************************************************************************************
//СТАТУС: 2;  TJammers_2D class friend function
//INPUT TJammers_2D PROPERTIES by cin
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend long Edit_VarPower(TJammers_2D& Jams)
//НАЗНАЧЕНИЕ: Редактирование свойств объекта класса TJammers_2D через стандартный поток
//ввода cin, передаваемый по ссылке в функцию. Функция возвращает количество введенных
//источников излучения. После ввода источников излучения осуществляется их отображение.
//Формат ввода источников излучения:
//----------------------------------------------------------------------------------------
//ADDITIVE NOISE: <Edit>
// (P1,A1) (P2,A2) ... (Pn,An);
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TJammers_2D& Jams - ссылка на редактируемый объект;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//long Count - количество источников излучения, размещенных в Jams, после редактирования
//****************************************************************************************
long Edit_VarPower(TJammers_2D& Jams)
{//Рабочие переменные
 int y, row_start = wherey();
 char c;
 string s, line(78,'-');
 bool flag, lClear;
 gotoxy(1,row_start); clreol();

 do //Цикл ввода источников излучения в форме: (Power, Angle)
 {//--------------------------------------------------------------------------------------
  cout << line << endl;
  cout << "ADDITIVE NOISE: < Edit > InputForm: (Power,Angle), Prev:" << endl;
  MultiLineFormat(s,Jams,78," ");
  cout << s << endl;
  //cout << "Prev: " << Jams.Brief(s,' ') << endl;
  cout << line << endl;
  //--------------------------------------------------------------------------------------
  //Выбор режима вставки или замещения ранее размещенных объектов
  //--------------------------------------------------------------------------------------
  y = wherey();
  cout << "Would you like to DELETE available jammers ? [y/n]: "; cin >> c;
  lClear = (c == 'Y' || c == 'y') ? true : false;
  s = (lClear) ? "Overwrite" : "Insert";
  ClrScr(1,y);//Очистка экрана
  cout << "Edit mode: " << s << endl;
  //--------------------------------------------------------------------------------------
  //Ввод источников излучения
  //--------------------------------------------------------------------------------------
  y = wherey();
  cout << "> ";
  cin.ignore();
  getline(cin,s,';');
  Jams.Import(s,lClear);//Импорт из строки s источников излучения
  ClrScr(1,y);//Очистка экрана
  cout << "Emission Sources: " << Jams.Count() << endl;
  MultiLineFormat(s,Jams,78," ");
  cout << s << endl;
  //cout << Jams.Brief(s,' ') << endl;
  //--------------------------------------------------------------------------------------
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
 return Jams.Count();//Кол-во источников излучения, размещенных в Jams, после редактирования
}
//****************************************************************************************
//СТАТУС: 3;  TJammers_2D class friend function
//INPUT TJammers_2D PROPERTIES by cin
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend long Edit_TheSamePower(TJammers_2D& Jams)
//НАЗНАЧЕНИЕ: Редактирование свойств объекта класса TJammers_2D через стандартный поток
//ввода cin, передаваемый по ссылке в функцию. Функция возвращает количество введенных
//источников излучения. Свойства источников излучения вводятся в два этапа. Вначале вводятся
//угловые координаты источников, затем - суммарная мощность Psum. Значение Psum затем рав-
//номерно распределяются среди всех введенных источников излучения. После ввода источников
//излучения осуществляется их отображение. Формат ввода источников излучения:
//----------------------------------------------------------------------------------------
//ADDITIVE NOISE: <Edit>
// 1) AngleCoord: Angle1 Angle2 ... AngleN;
// 2) Psum: <d_value>;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TJammers_2D& Jams - ссылка на редактируемый объект;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//long Count - количество источников излучения, размещенных в Jams, после редактирования
//****************************************************************************************
long Edit_TheSamePower(TJammers_2D& Jams)
{//Рабочие переменные
 TDoubleSet AngleCoords("","AngleCoords");
 TBelongClosedInterval<double,rvector> AnglePredicate(-90.0,90.0);
 double Psum;
 int y, row_start = wherey();
 char c;
 string s, line(78,'-');
 bool flag, lClear;
 gotoxy(1,row_start); clreol();
 //Копируем угловые координаты из Jams в AngleCoords
 Jams.GetAngleCoords(AngleCoords);

 do //Цикл ввода источников излучения в форме
 {//--------------------------------------------------------------------------------------
  cout << line << endl;
  cout << "ADDITIVE NOISE: < Edit As: Angle1 Angle2 ... AngleN; Psum >, Prev:" << endl;
  MultiLineFormat(s,Jams,78," ");
  cout << s << endl;
  cout << line << endl;
  //--------------------------------------------------------------------------------------
  //1. Ввод угловых координат источников излучения
  //--------------------------------------------------------------------------------------
  do
  {flag = false;
   AngleCoords.EditData(&AnglePredicate);
   if (AngleCoords.Size() == 0)
   {y = wherey();
    cout << "WARNING: There aren't Angle Coordinate of Emission Sources !!!" << endl;
    cout << "Would you like to input them again [y/n]?: "; cin >> c;
    if (c == 'Y' || c == 'y') flag = true;
    ClrScr(1,y);//Очистка экрана
   }
  } while (flag);
  //--------------------------------------------------------------------------------------
  //2. Ввод суммарной мощности всех источников излучения
  //--------------------------------------------------------------------------------------
  Psum = 0;
  if (AngleCoords.Size() != 0)
  {do
   {flag = false;
    InputNonNegateValue(Psum,"Psum");
    if (Psum == 0)
    {y = wherey();
     cout << "WARNING: Psum == 0 !!!" << endl;
     cout << "Would you like to input Psum again [y/n]?: "; cin >> c;
     if (c == 'Y' || c == 'y') flag = true;
     ClrScr(1,y);//Очистка экрана
    }
   } while (flag);
  }
  //--------------------------------------------------------------------------------------
  //Анализ результатов ввода
  //--------------------------------------------------------------------------------------
  if ((Psum == 0) || (AngleCoords.Size() == 0)) Jams.RemoveAll();
  else
  {Jams.Assign(AngleCoords,Psum/AngleCoords.Size());
   Jams.SortByAngle();//Сортировка источников по возрастанию угловой координаты
  }
  //Вывод результатов ввода свойств источников излучения
  cout << "Emission Sources: " << Jams.Count() << ", Psum: " << Psum << endl;
  MultiLineFormat(s,Jams,78," ");
  cout << s << endl;
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
 return Jams.Count();//Кол-во источников излучения, размещенных в Jams, после редактирования
}
//****************************************************************************************
//СТАТУС: 4; TJammers_2D class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend long Edit(TJammers_2D& Jams)
//НАЗНАЧЕНИЕ: Консольное редактирование свойств источников излучения, размещенных в
//контейнере Jams, передаваемых в функцию по ссылке. Функкция возвращает число источников
//излучения после редактирования. Предлагается два варианта редактирования свойств:
//1) (Power_1,Angle_1) (Power_2,Angle_2) ... (Power_n,Angle_n);
//2) Angle_1 Angle_2 ... Angle_n и Psum - суммарная мощность всех источников излучения.
//   Суммарная мощность Psum равномерно распределяется между всеми источниками излучения:
//   P1 = P2 = ... = Pn = Psum/N, N - число источников излучения.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// TJammers_2D& Jams - ссылка на редактируемый объект-контейнер источников излучения;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: long Count - количество источников излучения, размещенных в Jams,
//после редактирования
//****************************************************************************************
long Edit(TJammers_2D& Jams)
{STR_UINT Option[4] = {
  {1, "Edit as < (P_1,Angle_1) (P_2,Angle_2) ... (P_n,Angle_n); >" },
  {2, "Edit as < Angle1 Angle2 ... AngleN; Psum >" },
  {3, "View < Properties >" },
  {4, "Exit" } };
 TB_STR_UINT Menu = {4,Option};
 string head = " Choice menu option [1-4]: ";
 //Рабочие переменные
 string line(79,'-');
 const string sPressKey = "Press any key...";
 const string s = "ADDITIVE NOISE < Edit/View >";
 string t;
 bool flag = true;

 clrscr();//Очистка экрана
 do
 {cout << line << endl << s << endl << line << endl;
  uint choice = ConsoleChoice(Menu,3,head.c_str(),2);
  switch (choice)
  {case 1: //Выбор варианта редактир-я # 1: (P1,A1) (P2,A2) ... (Pn,An)
    if (Edit_VarPower(Jams) != 0)
     Jams.SortByAngle();//Сортировка источников по возрастанию угловой координаты
    break;

   case 2: //Выбор варианта редактир-я # 2: Angle_1 Angle_2 ... Angle_n и Psum
    Edit_TheSamePower(Jams);
    break;

   case 3: //Свойства источников излучения
    MultiLineFormat(t,Jams,78," ");
    cout << "Additive Jammer: " << Jams.Count() << ", Psum: " << Jams.TotalPower() << endl;
    cout << t << endl;
    cout << line << endl;
    cout << sPressKey; getch();
    break;

   case 4: //Выход из режима просмотра/редактирования
    flag = false;
    break;
  }
  clrscr();
 } while (flag);
 return true;
}
//****************************************************************************************
//СТАТУС: 5;  TJammers_2D class friend function
//MULTILINE OUTPUT TJammers_2D objects in string
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend ulong MultiLineFormat(string& s, const TJammers_2D& Jams, ulong MaxWidth = 80,
//       const char* sfx = NULL)
//НАЗНАЧЕНИЕ: Многострочный форматированный вывод источников излучения, размещенных в
//контейнере Jams в строку s, передаваемую по ссылке. Ширина строки определяется перемен-
//ной MaxWidth. Каждая новая строка начинается со строки sfx. Разбивка на строки предпола-
//гает размещение в каждой строке строки sfx и как минимум одного источника излучения,
//представленного в краткой форме - (Power,Angle) - независимо от величины MaxWidth.
//Функция возвращает количество строк Lines, в которых разместились все источники излуче-
//ния при ширине каждой строки - MaxWidth. Функция возвращает 0, если контейнер Jams не
//содержит источников излучения.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку с характеристиками источников излучения из Jams;
//2. const TJammers_2D& Jams - ссылка на контейнер с источниками излучения;
//3. ulong MaxWidth (80) - максимальная ширина каждой строки;
//4. const char* sfx (NULL) - начало каждой новой строки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//ulong Lines - количество строк, в которых разместились источники излучения из Jams.
//****************************************************************************************
ulong MultiLineFormat(string& s, const TJammers_2D& Jams, ulong MaxWidth, const char* sfx)
{ulong Lines = 0;
 s.resize(0);
 if (Jams.Count() == 0) return Lines;
 string t;
 bool lFirst = true;//Первый элемент в строке
 bool lNewLine = false;//Переход на новую строку
 ulong CurLen;//Текущая длина строки
 ulong SfxLen = (sfx == NULL) ? 0 : strlen(sfx);
 deque<TEmissionSource_2D>::const_iterator I;
 deque<TEmissionSource_2D>::const_iterator EndIter;
 Jams.GetIterators(I,EndIter);
 //Цикл по всем источникам излучения
 while (I != EndIter)
 {if (!lNewLine) I->Brief(t);
  if (lFirst) //Первый источник излучения в строке
  {Lines++;
   lFirst = false;
   lNewLine = false;
   if (SfxLen != 0) s.append(sfx);
   s.append(t);
   CurLen = SfxLen+t.length();
  }
  else //Источник излучения не первый в строке
  {//Проверка на возможность размещения источника излучения в текущей строке
   CurLen += t.length() + 1;
   if (CurLen <= MaxWidth)
   {s.append(1,' ');
    s.append(t);
   }
   else //Переход на новую строку
   {s.append(1,'\n');
    lFirst = true;
    lNewLine = true;
   }
  }
  if (!lNewLine) ++I;
 }//Конец цикла по источникам излучения

 return Lines;
}

//****************************************************************************************
//                        РЕАЛИЗАЦИЯ КЛАССА TGrayScaleImgSrc_2D
//Класс описывает источника излучения с одной угловой координатой,
//которая характеризуется двумя параметрами:
//1) Power - мощностью излучения (Power >= 0);
//2) Angle - угловое положение источника, относительно нормали к раскрыву приемной системы
//  (например, антенной решетки), -Pi <= Angle <= Pi (в радианах).
//****************************************************************************************

 std::string TGrayScaleImgSrc_2D::_MsgErr = std::string();

//========================================================================================
// I. РЕАЛИЗАЦИЯ КОНСТРУКТОРОВ И ДЕСТРУКТОРОВ КЛАССА TGrayScaleImgSrc_2D
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TGrayScaleImgSrc_2D constructor by default
//НАИМЕНОВАНИЕ ФУНКЦИИ: TGrayScaleImgSrc_2D()
//НАЗНАЧЕНИЕ: Конструктор по умолчанию класса TGrayScaleImgSrc_2D - свойства источника
//изображения в градациях серого с одной угловой координатой. Начальная инициализация
//членов-данных класса осуществляется функцией Reset(). Значения членов-данных объекта по
//умолчанию:
//1. Power = 0;
//2. Angle = 0;
//3. Raster (растр изображения) = матрица нулевого размера;
//4. Name = пустая строка.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
TGrayScaleImgSrc_2D::TGrayScaleImgSrc_2D()
{Reset(); //Начальная установка свойств
}
//****************************************************************************************
//СТАТУС: I.2; public; TGrayScaleImgSrc_2D constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// TGrayScaleImgSrc_2D(const string& fname, double Power, double Angle, bool unit = DEG)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TGrayScaleImgSrc_2D. Функция создает
//экземпляр класса.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& fname - имя файла с растром изображения в градациях серого;
//2. double Power - мощность источника;
//3. double Angle - угловое положение источника, относительно нормали к раскрыву приемной
//   системы;
//4. bool unit (DEG) - единица измерения Angle в градусах (DEG) или радианах (RAD);
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
TGrayScaleImgSrc_2D::TGrayScaleImgSrc_2D(const string& fname, double Power, double Angle, bool unit)
{SetSignal(Power,Angle,unit);//Установка характеристик источника излучения
 LoadRasterFromFile(fname);//Считывание растра изображения из файла
}
//****************************************************************************************
//СТАТУС: I.3; public; TGrayScaleImgSrc_2D class destructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: TGrayScaleImgSrc_2D
//НАЗНАЧЕНИЕ: Деструктор класса TGrayScaleImgSrc_2D - разрушает объект.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
TGrayScaleImgSrc_2D::~TGrayScaleImgSrc_2D()
{Reset(); //Сброс свойств объекта класса
}

//========================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TGrayScaleImgSrc_2D
//    PUBLIC MEMBER-FUNCTION OF TGrayScaleImgSrc_2D CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: I.1; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsReady() const
//НАЗНАЧЕНИЕ: Проверка "работоспособности" источника изображения с градациями серого.
//Объект класса считается "неработоспособным" (функция возвращает false), если мощность
//источника излучения равна 0 либо растр изображения отсутствует.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lReady - флаг работоспособности объекта
//****************************************************************************************
bool TGrayScaleImgSrc_2D::IsReady() const
{return (!this->IsSignal() || !this->IsRaster()) ? false : true;
}
//****************************************************************************************
//СТАТУС: I.2; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LoadRasterFromFile(const string& fname)
//НАЗНАЧЕНИЕ: Cчитывание растра изображения из файла. В случае успеха функция возвращает
//true. Растр изображения записывается в матрицу _Raster. Имя файла без расширения сохра-
//няется в строковой переменной _Name.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const string& fname - имя файла
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат считывания растра из файла.
//****************************************************************************************
bool TGrayScaleImgSrc_2D::LoadRasterFromFile(const string& fname)
{bool lSuccess = false;
 this->RasterClear();//Удаление предыдущего растра
 if (!FileExists(fname.c_str()))
 {_MsgErr = "Error: File <" + fname + "> doesn't exist !!!";
  return lSuccess;
 }
 //Получение расширения файла
 std::string::size_type idx = fname.find_last_of('.');
 std::string FileExt;
 if (idx != std::string::npos) FileExt.assign(fname,idx+1,fname.length()-idx);
 //Преобразование символов расширения файла к нижнему регистру
 transform(FileExt.begin(),FileExt.end(),FileExt.begin(),tolower);
 //Считывание растра из файла в зависимости от его расширения
 if (FileExt == "bmp") lSuccess = LoadRasterFromBMP(fname);
 else if (FileExt == "jpg") lSuccess = LoadRasterFromJPG(fname);
 else lSuccess = LoadRasterFromTXT(fname);

 if (lSuccess) //Присваиваем растру наименование файла с расширением
 {idx = fname.find_last_of('\\');
  if (idx != std::string::npos) _Name.assign(fname,idx+1,std::string::npos);
  else _Name.assign(fname);
 }
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.3; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& AboutSignal(string& s, bool lBriefly = true) const
//НАЗНАЧЕНИЕ: Формирование свойств источника сигнала _EmiSrc в символьном виде в строке s,
//передаваемой по ссылке, в краткой или полной форме. Форма представления:
//----------------------------------------------------------------------------------------
// Power: <_Power>, Angle: <_Angle in DEG>  - полная форма
// (<_Power>, <_Angle in DEG>)              - краткая форма
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& s - ссылка на строку-контейнер, в которой формируются свойства сигнала;
//2. bool lBriefly (true) - краткая или полная форма представления сигнала.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами источника сигнала
//****************************************************************************************
string& TGrayScaleImgSrc_2D::AboutSignal(string& s, bool lBriefly) const
{if (lBriefly) _EmiSrc.Brief(s);
 else _EmiSrc.Properties(s);
 return s;
}
//****************************************************************************************
//СТАТУС: I.4; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& AboutRaster(string& s, bool lBriefly = true) const
//НАЗНАЧЕНИЕ: Формирование свойств растра изображения в символьном виде в строке s,
//передаваемой по ссылке, в краткой или полной форме. Форма представления:
//----------------------------------------------------------------------------------------
// Полная форма:
// 256-grayscale image, Height: <RasterHeight>, Width: <RasterWidth>, Name: <RasterName>
// Краткая форма:
// 256-gray, <RasterHeight>x<RasterWidth>, <RasterName>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& s - ссылка на строку-контейнер, в которой формируются свойства растра;
//2. bool lBriefly (true) - краткая или полная форма представления растра.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами растра изображения
//****************************************************************************************
string& TGrayScaleImgSrc_2D::AboutRaster(string& s, bool lBriefly) const
{if (!this->IsRaster()) s.assign("No raster");
 else
 {char buffer[80];
  ostrstream text(buffer, sizeof(buffer));
  //Формируем имя растра
  if (_Name.empty()) s.assign("noname");
  else s.assign(_Name);

  if (lBriefly) //Вывод в краткой форме
  {text << "256-gray, " << this->GetHeight() << 'x' << this->GetWidth();
   text << ", <" << s << '>' << ends;
  }
  else //Вывод в полной форме
  {text << "256-Grayscale image";
   text << ", Height: " << this->GetHeight() << ", Width: " << this->GetWidth();
   text << ", Name: <" << s << '>' << ends;
  }
  s.assign(text.str());
 }
 return s;
}
//****************************************************************************************
//СТАТУС: I.5; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& About(string& s, bool lBriefly = true) const
//НАЗНАЧЕНИЕ: Формирование свойств объекта в символьном виде в строке s, передаваемой по
//ссылке, в краткой или полной форме. Функция формирует свойства источника сигнала и растра
//изображения, используя вызовы функций AboutSignal(...) и AboutRaster(...).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& s - ссылка на строку-контейнер, в которой формируются свойства объекта;
//2. bool lBriefly (true) - краткая или полная форма представления объекта.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами объекта
//****************************************************************************************
string& TGrayScaleImgSrc_2D::About(string& s, bool lBriefly) const
{string temp;
 s.assign("SIGNAL: ");
 s.append(this->AboutSignal(temp,lBriefly));
 s.append(", RASTER: ");
 s.append(this->AboutRaster(temp,lBriefly));
 return s;
}
//****************************************************************************************
//СТАТУС: I.6; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ImportSignal(const char* s, bool lClear = true)
//НАЗНАЧЕНИЕ: Извлечение из строки свойств источника сигнала - мощности и углового положе-
//ния (в градусах) в виде: < SIGNAL: (Power, Angle) >. Сигнатура свойств сигнала задается
//словом "SIGNAL:", набранном в верхнем регистре.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const char* s - ссылка на строку со свойствами источника сигнала;
//2. bool lClear (true) - удаление предыдущих свойств сигнала в случае ошибки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат извлечения из строки свойств сигнала
//****************************************************************************************
bool TGrayScaleImgSrc_2D::ImportSignal(const char* s, bool lClear)
{bool lSuccess = false;
 const char* pos;
 char Signature[] = "SIGNAL:";
 //Поиск в строке s строки Signature
 pos = strstr(s,Signature);
 if (pos != NULL) //Сигнатура найдена
 {pos = pos + sizeof(Signature) - 1;
  if (*pos != '\0') lSuccess = _EmiSrc.Set(pos);//Извлекаем параметры сигнала
 }
 if (!lSuccess && lClear) this->SetSignal(0.0,0.0);
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.7; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ImportRaster(const char* s, bool lClear = true)
//НАЗНАЧЕНИЕ: Извлечение из строки имени файла с растром изображения сигнала в виде:
//RASTER: <filename> с последующим копированием изображения из файла в матрицу _Raster.
//Сигнатура файла с изображением задается словом "RASTER:", набранном в верхнем регистре.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const char* s - ссылка на строку с именем файла, содержащего изображение;
//2. bool lClear (true) - удаление предыдущего растра в случае ошибки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат извлечения из строки растра
//****************************************************************************************
bool TGrayScaleImgSrc_2D::ImportRaster(const char* s, bool lClear)
{bool lSuccess = false;
 string fname;
 const char* pos;
 char Signature[] = "RASTER:";
 //Поиск в строке s строки Signature
 pos = strstr(s,Signature);
 if (pos != NULL) //Сигнатура найдена
 {pos = pos + sizeof(Signature) - 1;
  if (*pos != '\0') lSuccess = ImportFileName(fname,pos,'<','>');
  //При успешном извлечении имени файла из строки считываем растр
  if (lSuccess) lSuccess = this->LoadRasterFromFile(fname);
 }
 if (!lSuccess && lClear) this->RasterClear();
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.8; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Import(const char* s)
//НАЗНАЧЕНИЕ: Извлечение из строки свойств объекта, представленных в виде:
// SIGNAL: (Power, Angle[in deg]) RASTER: <filename>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const char* s - ссылка на строку с свойствами объекта
//2. bool lClear (true) - удаление предыдущих свойств объекта в случае ошибки.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат извлечения из строки свойств объекта
//****************************************************************************************
bool TGrayScaleImgSrc_2D::Import(const char* s, bool lClear)
{this->ImportSignal(s,lClear);
 this->ImportRaster(s,lClear);
 return this->IsReady();
}
//****************************************************************************************
//СТАТУС: I.9; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SaveRasterAsBMP(const char* fname) const
//НАЗНАЧЕНИЕ: Сохранение растра в файле BMP-формата с 24 битовым представлением цвета.
//Файл сохраняется под именем fname, передаваемым в функцию. В случае существования файла
//с таким именем растр не сохраняется и возвращается false.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const char* s - ссылка на строку с именем файла под которым будет сохранен растр.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат сохранения растра в файле
//****************************************************************************************
bool TGrayScaleImgSrc_2D::SaveRasterAsBMP(const char* fname) const
{bool lSuccess = false;
 std::string FName(fname);
 if (!this->IsRaster()) return false;//Проверка на существование растра
 //Проверка на существование файла с именем fname
 if (FileExists(fname))
 {_MsgErr = "Save error: File <" + FName + "> has already existed !!!";
  return lSuccess;
 }
 //Удаляем расширения из наименования файла
 std::string::size_type idx = FName.find_last_of('.');
 if (idx != std::string::npos) FName.erase(idx);
 FName.append(".bmp");
 //Преобразуем растр из матрицы _Raster в битовую матрицу типа TBitmap
 Graphics::TBitmap *BMP = new Graphics::TBitmap;
 BMP->Width = this->GetWidth();
 BMP->Height = this->GetHeight();
 BMP->PixelFormat = pf24bit;//pf24bit
 long color, r;

 for (unsigned int i = 0; i < _Raster.Rows(); i++)
  for (unsigned int j = 0; j < _Raster.Cols(); j++)
  {r = _Raster.Get(i,j);
   color = r + (r << 8) + (r << 16);
   BMP->Canvas->Pixels[j][i] = (TColor) color;
  }
 BMP->SaveToFile(FName.c_str());
 delete BMP;

 if (FileExists(FName.c_str())) lSuccess = true;
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.10; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool SaveRasterAsJPG(const char* fname, BYTE quality = 100) const
//НАЗНАЧЕНИЕ: Сохранение растра в файле JPEG-формата с 24 битовым представлением цвета.
//Файл сохраняется под именем fname, передаваемым в функцию. В случае существования файла
//с таким именем растр не сохраняется и возвращается false. Аргумент quality задает качество
//сжатия растра от 0 до 100.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const char* s - ссылка на строку с именем файла под которым будет сохранен растр;
//2. BYTE quality (100) - качество сжатия растра.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат сохранения растра в файле
//****************************************************************************************
bool TGrayScaleImgSrc_2D::SaveRasterAsJPG(const char* fname, BYTE quality) const
{bool lSuccess = false;
 std::string FName(fname);
 if (!this->IsRaster()) return false;//Проверка на существование растра
 //Проверка на существование файла с именем fname
 if (FileExists(fname))
 {_MsgErr = "Save error: File <" + FName + "> has already existed !!!";
  return lSuccess;
 }
 //Удаляем расширения из наименования файла
 std::string::size_type idx = FName.find_last_of('.');
 if (idx != std::string::npos) FName.erase(idx);
 FName.append(".jpg");
 //Преобразуем растр из матрицы _Raster в битовую матрицу типа TBitmap
 Graphics::TBitmap *BMP = new Graphics::TBitmap;
 BMP->Width = this->GetWidth();
 BMP->Height = this->GetHeight();
 BMP->PixelFormat = pf24bit;//pf24bit
 long color, r;

 for (unsigned int i = 0; i < _Raster.Rows(); i++)
  for (unsigned int j = 0; j < _Raster.Cols(); j++)
  {r = _Raster.Get(i,j);
   color = r + (r << 8) + (r << 16);
   BMP->Canvas->Pixels[j][i] = (TColor) color;
  }
 //---------------------------------------
 //Сохранение в формате jpeg
 //--------------------------------------
 TJPEGImage *jpg = new TJPEGImage();
 jpg->Grayscale = true;
 jpg->Assign(BMP);
 //Качество сжатия (100 - наилучшее качество)
 jpg->CompressionQuality = (quality < 1 || quality > 100) ? 100 : quality;
 jpg->Compress();//Сжатие файла
 jpg->SaveToFile(FName.c_str());
 delete jpg;
 delete BMP;//Удаление объекта класса TBitmap

 if (FileExists(FName.c_str())) lSuccess = true;
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.11; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: CalcAndSaveAsBMP(double Psjn, const char* sfx) const
//НАЗНАЧЕНИЕ: Расчет растра сигнала при воздействии на него аддитивной помехи при его
//распространении  на выходе адаптивной приемной системы и сохранение полученного растра в
//файле. Считается, что на все элементы растра действуют одинаковые значения Psjn.
//Формула учета влияния сигнала, аддитивной помехи, внутреннего шума и адаптивной приемной
//системы на элементы растра:
// P(i,j) = Psjn + sqrt[Pix(i,j)];
// if (P(i,j) < Po) P(i,j) = 0;
// if (P(i,j) > Po + sqrt(255)) P(i,j) = 255;
// else P(i,j) = (P(i,j)-Po)*(P(i,j)-Po);
// Pix(i,j) => амплитудное значение (i,j)-элемента матрицы _Raster;
// Po => опорная (эталонная) мощность сигнала _EmiSrc.GetPower() на входе адаптивного
// приемника.
//Строка sfx используется для построения имени файла с рассчитанным растром на выходе АПС.
//Строка sfx добавляется в конец имени растра _Name и может идентифицировать, например,
//номер опыта (шаг адаптации), на котором данный растр был рассчитан. Растр сохраняется в
//файле BMP-формата.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double Psjn - мощность сигнала, аддитивной помехи и внутреннего шума на выходе (АПС);
//2. const char* sfx - указатель на символьную строку, добавляемую к концу имени файла.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TGrayScaleImgSrc_2D::CalcAndSaveAsBMP(double Psjn, const char* sfx) const
{bool lSuccess = false;
 //Проверка на существование растра
 if (!this->IsRaster()) return lSuccess;
 if (Psjn < 0.0) return lSuccess;

 Graphics::TBitmap *BMP = new Graphics::TBitmap;
 BMP->Width  = this->GetWidth();
 BMP->Height = this->GetHeight();
 BMP->PixelFormat = pf24bit;
 long color, r;
 double x;
 double Pmin = this->GetPower();
 double Pmax = Pmin + sqrt(255.0);

 for (unsigned int i = 0; i < _Raster.Rows(); i++)
  for (unsigned int j = 0; j < _Raster.Cols(); j++)
  {
   x = Psjn + sqrt(_Raster.Get(i,j));
   if (x < Pmin) x = 0;
   else if (x > Pmax) x = 255;
   else {x = x - Pmin; x = x*x;}

   r = floor(x);
   color = r + (r << 8) + (r << 16);
   BMP->Canvas->Pixels[j][i] = (TColor) color;
  }
 //Сохранение растра в файле
 std::string FName(_Name);
 std::string::size_type idx = FName.find_last_of('.');
 if (idx != std::string::npos) FName.erase(idx);
 FName.append(1,'_');
 FName.append(sfx);
 FName.append(".bmp");
 BMP->SaveToFile(FName.c_str());
 if (FileExists(FName.c_str())) lSuccess = true;
 delete BMP;
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.12; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// CalcAndSaveAsJPG(double Psjn, const char* sfx, BYTE quality = 100) const
//НАЗНАЧЕНИЕ: Расчет растра сигнала при воздействии на него аддитивной помехи при его
//распространении  на выходе адаптивной приемной системы и сохранение полученного растра в
//файле. Считается, что на все элементы растра действуют одинаковые значения Psjn.
//Формула учета влияния полезного сигнала, аддитивной помехи, внутреннего шума и адаптивной
//приемной системы на элементы растра:
// P(i,j) = Psjn + sqrt[Pix(i,j)];
// if (P(i,j) < Po) P(i,j) = 0;
// if (P(i,j) > Po + sqrt(255)) P(i,j) = 255;
// else P(i,j) = (P(i,j)-Po)*(P(i,j)-Po);
// Pix(i,j) => амплитудное значение (i,j)-элемента матрицы _Raster;
// Po => опорная (эталонная) мощность сигнала _EmiSrc.GetPower() на входе адаптивного
// приемника.
//Строка sfx используется для построения имени файла с рассчитанным растром на выходе АПС.
//Строка sfx добавляется в конец имени растра _Name и может идентифицировать, например,
//номер опыта (шаг адаптации), на котором данный растр был рассчитан. Растр сохраняется в
//файле JPEG-формата. Аргумент quality задает качество сжатия в пределах от 0 до 100.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double Psjn  - мощность сигнала, аддитивной помехи и внутреннего шума на выходе
//   адаптивной приемной системы (АПС);
//2. const char* sfx - указатель на символьную строку, добавляемую к концу имени файла;
//3. BYTE quality (100) - качество сжатия растра.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TGrayScaleImgSrc_2D::CalcAndSaveAsJPG(double Psjn, const char* sfx, BYTE quality) const
{bool lSuccess = false;
 //Проверка на существование растра
 if (!this->IsRaster()) return lSuccess;
 if (Psjn < 0.0) return lSuccess;

 Graphics::TBitmap *BMP = new Graphics::TBitmap;
 BMP->Width  = this->GetWidth();
 BMP->Height = this->GetHeight();
 BMP->PixelFormat = pf24bit;
 long color, r;
 double x;
 double Pmin = this->GetPower();
 double Pmax = Pmin + sqrt(255.0);

 for (unsigned int i = 0; i < _Raster.Rows(); i++)
  for (unsigned int j = 0; j < _Raster.Cols(); j++)
  {
   x = Psjn + sqrt(_Raster.Get(i,j));
   if (x < Pmin) x = 0;
   else if (x > Pmax) x = 255;
   else {x = x - Pmin; x = x*x;}

   r = floor(x);
   color = r + (r << 8) + (r << 16);
   BMP->Canvas->Pixels[j][i] = (TColor) color;
  }
 //Сохранение растра в файле
 std::string FName(_Name);
 std::string::size_type idx = FName.find_last_of('.');
 if (idx != std::string::npos) FName.erase(idx);
 FName.append(1,'_');
 FName.append(sfx);
 FName.append(".jpg");

 TJPEGImage *jpg = new TJPEGImage();
 jpg->Assign(BMP);
 delete BMP;
 //Качество сжатия (100 - наилучшее качество)
 jpg->CompressionQuality = (quality < 1 || quality > 100) ? 100 : quality;
 jpg->Compress();//Сжатие файла
 jpg->SaveToFile(FName.c_str());
 delete jpg;

 if (FileExists(FName.c_str())) lSuccess = true;

 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.13; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// CalcAndSaveAsJPG(double Ps, double Pjn, const char* sfx, BYTE quality = 100) const
//НАЗНАЧЕНИЕ: Расчет растра сигнала при воздействии на него аддитивной помехи при его
//распространении  на выходе адаптивной приемной системы и сохранение полученного растра в
//файле. Считается, что на все элементы растра действуют одинаковые значения Ps и Pjn.
//Формула учета влияния полезного сигнала, аддитивной помехи, внутреннего шума и адаптивной
//приемной системы на элементы растра:
// P(i,j) = sqrt[Ps*Pix(i,j)/Po + Pjn];
// U(i,j) = P(i,j)^2;
// if (U(i,j) > 255) U(i,j) = 255;
// Pix(i,j) => амплитудное значение (i,j)-элемента матрицы _Raster;
// Po => опорная (эталонная) мощность сигнала _EmiSrc.GetPower() на входе адаптивного
// приемника.
// При таком представлении, мощность полезного сигнала находиться в  интервале [0..255)
// в случае Po = Ps.
//Строка sfx используется для построения имени файла с рассчитанным растром на выходе АПС.
//Строка sfx добавляется в конец имени растра _Name и может идентифицировать, например,
//номер опыта (шаг адаптации), на котором данный растр был рассчитан. Растр сохраняется в
//файле JPEG-формата. Аргумент quality задает качество сжатия в пределах от 0 до 100.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double Ps  - мощность сигнала на выходе адаптивной приемной системы (АПС);
//2. double Pjn  - мощность аддитивной помехи и внутреннего шума на выходе АПС;
//3. const char* sfx - указатель на символьную строку, добавляемую к концу имени файла;
//4. BYTE quality (100) - качество сжатия растра.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TGrayScaleImgSrc_2D::CalcAndSaveAsJPG(double Ps, double Pjn, const char* sfx,
     BYTE quality) const
{bool lSuccess = false;
 //Проверка на существование растра
 if (!this->IsRaster()) return lSuccess;

 Graphics::TBitmap *BMP = new Graphics::TBitmap;
 BMP->Width  = this->GetWidth();
 BMP->Height = this->GetHeight();
 BMP->PixelFormat = pf24bit;
 long color, r;
 double x;
 double Po = this->GetPower();

 //Алгоритм: P(i,j) = Ps*(U(i,j))*(Pmax-Po)/255*Po + 1) + Pjn
 double k = (3*Po - Po)/255.0;
 for (unsigned int i = 0; i < _Raster.Rows(); i++)
  for (unsigned int j = 0; j < _Raster.Cols(); j++)
  {
   x = Ps*((_Raster.Get(i,j)*k)/Po + 1) + Pjn;
   if (x < Po) x = 0;//Ограничение по минимуму (Минимальный порог: Po)
   else
   {x = x - Po;
    x = x/k;
    if (x > 255.0) x = 255;//Ограничение по максимуму Pmax = 3*Po
   }
   r = floor(x);
   color = r + (r << 8) + (r << 16);
   BMP->Canvas->Pixels[j][i] = (TColor) color;
  }
  //Алгоритм: P(i,j) = Ps*(sqrt(U(i,j))/Po + 1) + Pjn
 /*
 for (unsigned int i = 0; i < _Raster.Rows(); i++)
  for (unsigned int j = 0; j < _Raster.Cols(); j++)
  {
   x = Ps*(sqrt(_Raster.Get(i,j))/Po + 1) + Pjn;
   if (x < Po) x = 0;//Ограничение по минимуму (Минимальный порог: Po)
   else
   {x = x - Po;
    x *= x;
    if (x > 255.0) x = 255;//Ограничение по максимуму
   }
   r = floor(x);
   color = r + (r << 8) + (r << 16);
   BMP->Canvas->Pixels[j][i] = (TColor) color;
  }
 */
 /*
 for (unsigned int i = 0; i < _Raster.Rows(); i++)
  for (unsigned int j = 0; j < _Raster.Cols(); j++)
  {
   x = sqrt((Ps/Po)*_Raster.Get(i,j) + Pjn);
   x *= x;//Возведение в квадрат
   if (x > 255.0) x = 255;
   r = floor(x);
   color = r + (r << 8) + (r << 16);
   BMP->Canvas->Pixels[j][i] = (TColor) color;
  }
 */
 //Сохранение растра в файле
 std::string FName(_Name);
 std::string::size_type idx = FName.find_last_of('.');
 if (idx != std::string::npos) FName.erase(idx);
 FName.append(1,'_');
 FName.append(sfx);
 FName.append(".jpg");

 TJPEGImage *jpg = new TJPEGImage();
 jpg->Assign(BMP);
 delete BMP;
 //Качество сжатия (100 - наилучшее качество)
 jpg->CompressionQuality = (quality < 1 || quality > 100) ? 100 : quality;
 jpg->Compress();//Сжатие файла
 jpg->SaveToFile(FName.c_str());
 delete jpg;

 if (FileExists(FName.c_str())) lSuccess = true;

 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.14; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Modulate(rmatrix& P) const
//НАЗНАЧЕНИЕ: Расчет модуляционной матрицы мощностей по значениям амплитуд растра по
//формуле: P(i,j) = Ps + sqrt(_Raster(i,j)), Ps - мощность источника излучения.
//Модуляционная матрица мощности формируется в матрице P, передаваемой по ссылке. Функция
//возвращает true при успешном расчете модуляционной матрицы (при наличии растра) и false
//в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//rmatrix& P - ссылка на матрицу-приемник модуляционной матрицы мощности растра сигнала.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TGrayScaleImgSrc_2D::Modulate(rmatrix& P) const
{//Проверка на существование растра
 if (!this->IsRaster()) {P.Set(0,false); return false;}
 if (P.Set(this->_Raster.Rows(),this->_Raster.Cols(),false) == false) return false;
 //Расчет модуляционной матрицы растра сигнала
 double Ps = this->GetPower();
 for (ulong i = 0; i < P.Rows(); i++)
  for (ulong j = 0; j < P.Cols(); j++)
   P.Put(i,j,Ps+sqrt(this->_Raster.Get(i,j)));
 return true;
}
//****************************************************************************************
//СТАТУС: I.15; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool DemodulateAndSaveAsJPG(const rmatrix& P, const char* sfx, BYTE quality = 100) const
//НАЗНАЧЕНИЕ: Демодуляция матрицы мощности, соответствующая растру сигнала, и ее сохранение
//в виде графического файла JPEG. Демодуляционная формула: _Raster(i,j) = [P(i,j)-Ps]^2.
//Размерности матриц P и _Raster должны быть согласованы. Ps - мощность источника сигнала.
//Строка sfx используется для построения имени файла с рассчитанным растром на выходе АПС.
//Строка sfx добавляется в конец имени растра _Name и может идентифицировать, например,
//номер опыта (шаг адаптации), на котором данный растр был рассчитан. Растр сохраняется в
//файле JPEG-формата. Аргумент quality задает качество сжатия в пределах от 0 до 100.
//Функция возвращает true при успешном построении растра изображения по модуляционной
//матрице мощности P и false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& P  - модуляционная матрица мощности на выходе адаптивной приемной
//системы (АПС);
//2. const char* sfx - указатель на символьную строку, добавляемую к концу имени файла;
//3. BYTE quality (100) - качество сжатия растра.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TGrayScaleImgSrc_2D::DemodulateAndSaveAsJPG(const rmatrix& P, const char* sfx,
     BYTE quality) const
{bool lSuccess = false;
 //Проверка на существование растра
 if (!this->IsRaster()) return lSuccess;
 //Проверка на согласованность размеров модуляционной матрицы P и растра сигнала
 if ((P.Rows() != this->_Raster.Rows()) || (P.Cols() != this->_Raster.Cols()))
  return lSuccess;

 Graphics::TBitmap *BMP = new Graphics::TBitmap;
 BMP->Width  = this->GetWidth();
 BMP->Height = this->GetHeight();
 BMP->PixelFormat = pf24bit;
 long color, r;
 double x;
 double Ps = this->GetPower();

 //Алгоритм: _Raster(i,j) = [P(i,j)-Ps]^2
 for (unsigned int i = 0; i < P.Rows(); i++)
  for (unsigned int j = 0; j < P.Cols(); j++)
  {x = P.Get(i,j) - Ps;
   if (x < 0) x = 0;//Ограничение по минимуму (Xmin = 0)
   else
   {x = x*x;
    if (x > 255.0) x = 255;//Ограничение по максимуму Xmax = 255
   }
   r = floor(x);
   color = r + (r << 8) + (r << 16);
   BMP->Canvas->Pixels[j][i] = (TColor) color;
  }
 //Сохранение растра в файле
 std::string FName;
 MakeFileNameAsJPG(FName,sfx);

 TJPEGImage *jpg = new TJPEGImage();
 jpg->Assign(BMP);
 delete BMP;
 //Качество сжатия (100 - наилучшее качество)
 jpg->CompressionQuality = (quality < 1 || quality > 100) ? 100 : quality;
 jpg->Compress();//Сжатие файла
 jpg->SaveToFile(FName.c_str());
 delete jpg;
 if (FileExists(FName.c_str())) lSuccess = true;
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.16; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LAM_Modulate(rmatrix& P, double dP = 100.0) const
//НАЗНАЧЕНИЕ: Расчет модуляционной матрицы мощности растра по закону линейной амплитудной
//модуляции: P(i,j) = k*U(i,j) + Ps, k = (Pmax-Ps)/(Umax-Umin) = dP/255,
//Ps - мощность источника сигнала, соответствующая U = Umin = 0; Umax = 255;
//dP - максимальное превышение мощности сигнала над Ps для U == Umax (255), dP > 0
//Модуляционная матрица мощности формируется в матрице P, передаваемой по ссылке. Функция
//возвращает true при успешном расчете модуляционной матрицы (при наличии растра) и false
//в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& P - ссылка на матрицу-приемник модуляционной матрицы мощности растра сигнала;
//2. double dP (100) - максимальное превышение мощности над уровнем Ps (для Umax).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TGrayScaleImgSrc_2D::LAM_Modulate(rmatrix& P, double dP) const
{//Проверка на существование растра
 if (!this->IsRaster()) {P.Set(0,false); return false;}
 if (P.Set(this->_Raster.Rows(),this->_Raster.Cols(),false) == false) return false;
 if (dP <= 0.0) dP = 100.0;//Установка корректного значения dP
 double k = dP/255.0;
 double Ps = this->GetPower();
 //Расчет модуляционной матрицы растра сигнала
 for (ulong i = 0; i < P.Rows(); i++)
  for (ulong j = 0; j < P.Cols(); j++)
   P.Put(i,j,k*(this->_Raster.Get(i,j))+Ps);
 return true;
}
//****************************************************************************************
//СТАТУС: I.17; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool LAM_DemodAndSaveAsJPG(const rmatrix& P, const char* sfx, BYTE quality = 100,
//      double dP = 100.0) const
//НАЗНАЧЕНИЕ: Демодуляция матрицы мощности, соответствующая растру сигнала, и ее сохранение
//в виде графического файла JPEG. Демодуляция матрицы мощности, рассчитанной по закону ли-
//нейной амплитудной модуляции, выполняется по формуле:
//U(i,j) = |P(i,j)-Ps|/k = |P(i,j)-Ps|*255/dP, (Umax-Umin) == 255;
//Ps - мощность источника сигнала, соответствующая U = Umin = 0; Umax = 255;
//dP - максимальное превышение мощности сигнала над Ps для U == Umax (255), dP > 0
//Размерности матриц P и _Raster должны быть согласованы. Ps - мощность источника сигнала.
//Строка sfx используется для построения имени файла с рассчитанным растром на выходе АПС.
//Строка sfx добавляется в конец имени растра _Name и может идентифицировать, например,
//номер опыта (шаг адаптации), на котором данный растр был рассчитан. Растр сохраняется в
//файле JPEG-формата. Аргумент quality задает качество сжатия в пределах от 0 до 100.
//Функция возвращает true при успешном построении растра изображения по модуляционной
//матрице мощности P и false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& P  - модуляционная матрица мощности на выходе адаптивной приемной
//системы (АПС);
//2. const char* sfx - указатель на символьную строку, добавляемую к концу имени файла;
//3. BYTE quality (100) - качество сжатия растра;
//4. double dP (100) - максимальное превышение мощности над уровнем Ps (для Umax).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TGrayScaleImgSrc_2D::LAM_DemodAndSaveAsJPG(const rmatrix& P, const char* sfx,
     BYTE quality, double dP) const
{bool lSuccess = false;
 //Проверка на существование растра
 if (!this->IsRaster()) return lSuccess;
 //Проверка на согласованность размеров модуляционной матрицы P и растра сигнала
 if ((P.Rows() != this->_Raster.Rows()) || (P.Cols() != this->_Raster.Cols()))
  return lSuccess;
 if (dP <= 0.0) dP = 100.0;//Установка корректного значения dP

 Graphics::TBitmap *BMP = new Graphics::TBitmap;
 BMP->Width  = this->GetWidth();
 BMP->Height = this->GetHeight();
 BMP->PixelFormat = pf24bit;
 long color, r;
 double x;
 double Ps = this->GetPower();
 double k = 255.0/dP;

 //Алгоритм: _Raster(i,j) = |P(i,j)-Ps|*255.0/dP = k*|P(i,j)-Ps|
 for (unsigned int i = 0; i < P.Rows(); i++)
  for (unsigned int j = 0; j < P.Cols(); j++)
  {x = P.Get(i,j) - Ps;
   if (x < 0) x = 0;//Ограничение по минимуму (Xmin = 0)
   else
   {x = k*x;
    if (x > 255.0) x = 255;//Ограничение по максимуму Xmax = 255
   }
   r = floor(x);
   color = r + (r << 8) + (r << 16);
   BMP->Canvas->Pixels[j][i] = (TColor) color;
  }
 //Сохранение растра в файле
 std::string FName(_Name);
 std::string::size_type idx = FName.find_last_of('.');
 if (idx != std::string::npos) FName.erase(idx);
 FName.append(1,'_');
 FName.append(sfx);
 FName.append(".jpg");

 TJPEGImage *jpg = new TJPEGImage();
 jpg->Assign(BMP);
 delete BMP;
 //Качество сжатия (100 - наилучшее качество)
 jpg->CompressionQuality = (quality < 1 || quality > 100) ? 100 : quality;
 jpg->Compress();//Сжатие файла
 jpg->SaveToFile(FName.c_str());
 delete jpg;
 if (FileExists(FName.c_str())) lSuccess = true;
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.18; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double CalcAvPower(const TFuncGen_DSClipper* pCoDec) const
//НАЗНАЧЕНИЕ: Расчет среднего уровня мощности изображения в зависимости от растра изображе-
//ния и типа кодирования - декодирования при его передаче и приеме. Тип кодирования (моду-
//лирования) отсчетов (пикселов) изображения определяется указателем pCoDec. Функция возв-
//ращает усредненное значение мощности изображения.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const TFuncGen_DSClipper* pCoDec - указатель на кодер-декодер 2D-сигнала
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double AvPower - усредненная величина мощности растра изображения
//****************************************************************************************
double TGrayScaleImgSrc_2D::CalcAvPower(const TFuncGen_DSClipper* pCoDec) const
{double AvPower = 0.0;
 //Проверка на существование растра
 if (!this->IsRaster() || (pCoDec == NULL)) return AvPower;
 double N = _Raster.Rows()*_Raster.Cols();
 double Pij;
 //Расчет усредненной мощности
 for (ulong i = 0L; i < _Raster.Rows(); i++)
  for (ulong j = 0L; j < _Raster.Cols(); j++)
  {Pij = pCoDec->Encode(_Raster.Get(i,j));
   AvPower += Pij/N;
  }
 return AvPower;
}
//****************************************************************************************
//СТАТУС: I.19; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Modulate(rmatrix& P, const TFuncGen_DSClipper* pCoDec) const
//НАЗНАЧЕНИЕ: Расчет модуляционной матрицы мощностей по растру сигнала в соответствии с
//алгоритмом кодирования кодера-декодера определяемым pCoDec. pCoDec является ссылкой на
//абстрактный класс, определяющий семейство функциональных преобразователей с ограничением
//по максимальным и минимальным уровням напряжений и мощностей с разными алгоритмами коди-
//рования и декодирования. Модуляционная матрица мощности формируется в матрице P, переда-
//ваемой по ссылке. Функция возвращает true при успешном расчете модуляционной матрицы
//(при наличии растра и кодека) и false в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& P - ссылка на матрицу-приемник модуляционной матрицы мощности растра сигнала;
//2. const TFuncGen_DSClipper* pCoDec - указатель на тип кодека, выполняющего модуляцию.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TGrayScaleImgSrc_2D::Modulate(rmatrix& P, const TFuncGen_DSClipper* pCoDec) const
{//Проверка на существование растра
 if (!this->IsRaster() || (pCoDec == NULL)) {P.Set(0,false); return false;}
 if (P.Set(this->_Raster.Rows(),this->_Raster.Cols(),false) == false) return false;
 //Расчет модуляционной матрицы растра сигнала
 for (ulong i = 0; i < P.Rows(); i++)
  for (ulong j = 0; j < P.Cols(); j++)
   P.Put(i,j,pCoDec->Encode(_Raster.Get(i,j)));
 return true;
}
//****************************************************************************************
//СТАТУС: I.20; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool DemodulateAndSaveAsJPG(const rmatrix& P, const TFuncGen_DSClipper* pCoDec,
//      const char* sfx, BYTE quality = 100) const
//НАЗНАЧЕНИЕ: Демодуляция матрицы мощности в растру 2D-сигнала в соответствии с алгоритмом
//декодирования кодера-декодера pCoDec, и сохранение полученного растра в JPEG-формате.
//pCoDec является ссылкой на абстрактный класс TFuncGen_DSClipper, определяющий семейство
//функциональных преобразователей с ограничением по максимальным и минимальным уровням
//напряжений и мощностей с разными алгоритмами кодирования и декодирования.
//Размерности матриц P и _Raster должны быть согласованы.
//Строка sfx используется для построения имени файла с рассчитанным растром на выходе АПС.
//Строка sfx добавляется в конец имени растра _Name и может идентифицировать, например,
//номер опыта (шаг адаптации), на котором данный растр был рассчитан. Растр сохраняется в
//файле JPEG-формата. Аргумент quality задает качество сжатия в пределах от 0 до 100.
//Функция возвращает true при успешном построении растра изображения по модуляционной
//матрице мощности P и false - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& P  - модуляционная матрица мощности на выходе адаптивной приемной
//системы (АПС);
//2. const TFuncGen_DSClipper* pCoDec - указатель на тип кодека, выполняющего демодуляцию.
//3. const char* sfx - указатель на символьную строку, добавляемую к концу имени файла;
//4. BYTE quality (100) - качество сжатия растра.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TGrayScaleImgSrc_2D::DemodulateAndSaveAsJPG(const rmatrix& P,
      const TFuncGen_DSClipper* pCoDec, const char* sfx, BYTE quality) const
{bool lSuccess = false;
 //Проверка на существование растра
 if (!this->IsRaster() || (pCoDec == NULL)) return lSuccess;
 //Проверка на согласованность размеров модуляционной матрицы P и растра сигнала
 if ((P.Rows() != this->_Raster.Rows()) || (P.Cols() != this->_Raster.Cols()))
  return lSuccess;

 Graphics::TBitmap *BMP = new Graphics::TBitmap;
 BMP->Width  = this->GetWidth();
 BMP->Height = this->GetHeight();
 BMP->PixelFormat = pf24bit;
 long color, r;
 double U;

 for (unsigned int i = 0; i < P.Rows(); i++)
  for (unsigned int j = 0; j < P.Cols(); j++)
  {U = pCoDec->Decode(P.Get(i,j)); //Декодирование (демодуляция) сигнала
   if (U < 0) U = 0;//Ограничение по минимуму (Xmin = 0)
   if (U > 255) U = 255;//Ограничение по максимуму (Xmax = 255)
   r = floor(U);
   color = r + (r << 8) + (r << 16);
   BMP->Canvas->Pixels[j][i] = (TColor) color;
  }
 //Сохранение растра в файле
 std::string FName;
 MakeFileNameAsJPG(FName,sfx);

 TJPEGImage *jpg = new TJPEGImage();
 jpg->Assign(BMP);
 delete BMP;
 //Качество сжатия (100 - наилучшее качество)
 jpg->CompressionQuality = (quality < 1 || quality > 100) ? 100 : quality;
 jpg->Compress();//Сжатие файла
 jpg->SaveToFile(FName.c_str());
 delete jpg;
 if (FileExists(FName.c_str())) lSuccess = true;
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.21; public; TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool MakeFileNameAsJPG(string& FName, const char* sfx) const
//НАЗНАЧЕНИЕ: Создание имени файла с расширением JPG по имени растра изображения _Name и
//строки sfx, присоединяемую к концу _Name. Структура имени файла выглядит следующим
//образом: <_Name>_<sfx>.jpg. Имя файла формируется в строке FName, передаваемую в функцию
//по ссылке. Функция возвращает true в случае удачного формирования имени файла в строке
//FName и false - при неблагоприятном исходе (отсутствие растра изображения).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& FName - ссылка на строку, в которой формируется имя файла с расширением jpg;
//2. const char* sfx - указатель на символьную строку, добавляемую к концу имени файла;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: lSuccess - результат работы функции
//****************************************************************************************
bool TGrayScaleImgSrc_2D::MakeFileNameAsJPG(string& FName, const char* sfx) const
{FName.clear();
 //Проверка на наличие растра изображения
 if (!this->IsRaster()) return false;
 //Формируем имя файла изображения с расширением jpg
 FName.assign(_Name);
 std::string::size_type idx = FName.find_last_of('.');
 if (idx != std::string::npos) FName.erase(idx);
 if (sfx != NULL) {FName.append(1,'_'); FName.append(sfx);}
 FName.append(".jpg");
 return true;
}


//========================================================================================
//II. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TGrayScaleImgSrc_2D
//    PROTECTED MEMBER-FUNCTION OF TGrayScaleImgSrc_2D CLASS
//========================================================================================
//****************************************************************************************
//СТАТУС: II.1, protected, TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Reset();
//НАЗНАЧЕНИЕ: Начальная установка свойств 2D источника изображения в градациях серого.
//Начальная установка характеристик:
//1. Power = 0;
//2. Angle = 0;
//3. Raster (растр изображения) = матрица нулевого размера;
//4. Name = пустая строка;
//5. MsgErr = пустая строка.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TGrayScaleImgSrc_2D::Reset()
{_EmiSrc.Set(0,0);
 this->RasterClear();
 _MsgErr.clear();
}
//****************************************************************************************
//СТАТУС: II.2, protected, TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void RasterClear()
//НАЗНАЧЕНИЕ: Начальная установка характеристик растра:
//1. Raster (растр изображения) = матрица нулевого размера;
//2. Name = пустая строка;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TGrayScaleImgSrc_2D::RasterClear()
{_Raster.Set(0,false);
 _Name.clear();
}
//****************************************************************************************
//СТАТУС: II.3, protected, TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LoadRasterFromBMP(const string& fname)
//НАЗНАЧЕНИЕ: При успешном открытии файла fname функция считывает растр в матрицу _Raster
//с автоматическим преобразованием растра в изображение с градациями серого. Максимальный
//уровень цвета может быть равен 255.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const string& fname - ссылка на имя файла BMP формата
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат считывания растра из BMP файла
//****************************************************************************************
bool TGrayScaleImgSrc_2D::LoadRasterFromBMP(const string& fname)
{Graphics::TBitmap *BMP = new Graphics::TBitmap;
 try
 { BMP->LoadFromFile(fname.c_str());
 }
 catch(...)
 { _MsgErr = "Error ! File <" + fname + "> can't be opened !";
   if (BMP) delete BMP;
   return false;
 }
 //Проверка на загрузку файла в объект Bitmap
 if (BMP->Empty)
 {delete BMP;
  _MsgErr = "Error ! BMP file <" + fname + "> is empty !";
  return false;
 }
 //Считывание данных из bmp-файла в матрицу _Raster
 _Raster.Set(BMP->Height,BMP->Width,false);
 if (_Raster.IsZeroSize())
 {delete BMP;
  _MsgErr = "Error ! There's not enough memory to load raster from <" + fname + "> !";
  return false;
 }
 DWORD Color;
 BYTE R, G, B;
 BYTE Mask = 0xFF;//255L;
 //Цикл считывания цветов пикселов изображения из TBitmap с автоматическим преобразованием
 //в растр с градациями серого
 for (unsigned int i = 0; i < _Raster.Rows(); i++)
  for (unsigned int j = 0; j < _Raster.Cols(); j++)
  {Color = BMP->Canvas->Pixels[j][i];
   //Выделяем R, G, B компоненты
   R = Color & Mask;
   G = (Color >> 8) & Mask;
   B = (Color >> 16) & Mask;
   if ((R == G) && (R == B)) Color = R;
   //Преобразование цветов из пространства RGB в grayscale
   //Grayscale = 0.299*R + 0.587*G + 0.114*B или
   //Grayscale = (77*R + 150*G + 29*B + 128)/256
   else Color = 0.299*R + 0.587*G + 0.114*B;
   _Raster.Put(i,j,Color);
  }
 delete BMP;

 return true;
}
//****************************************************************************************
//СТАТУС: II.4, protected, TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LoadRasterFromJPG(const string& fname)
//НАЗНАЧЕНИЕ: При успешном открытии файла fname функция считывает растр в матрицу _Raster
//с автоматическим преобразованием растра в изображение с градациями серого. Максимальный
//уровень цвета может быть равен 255.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const string& fname - ссылка на имя файла BMP формата
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат считывания растра из BMP файла
//****************************************************************************************
bool TGrayScaleImgSrc_2D::LoadRasterFromJPG(const string& fname)
{TJPEGImage *jpg = new TJPEGImage();
 try
 { jpg->LoadFromFile(fname.c_str());
 }
 catch(...)
 { _MsgErr = "Error ! File <" + fname + "> can't be opened !";
   if (jpg) delete jpg;
   return false;
 }

 //Импорт jpeg-файла в TBitmap
 Graphics::TBitmap *BMP = new Graphics::TBitmap;
 BMP->Assign(jpg);
 BMP->PixelFormat = pf24bit;
 delete jpg;

 //Проверка на загрузку файла в объект Bitmap
 if (BMP->Empty)
 {delete BMP;
  _MsgErr = "Error ! JPG file <" + fname + "> can't be loaded !";
  return false;
 }
 //Считывание данных из bmp-файла в матрицу _Raster
 _Raster.Set(BMP->Height,BMP->Width,false);
 if (_Raster.IsZeroSize())
 {delete BMP;
  _MsgErr = "Error ! There's not enough memory to load raster from <" + fname + "> !";
  return false;
 }
 DWORD Color;
 BYTE R, G, B;
 BYTE Mask = 0xFF;//255L;
 //Цикл считывания цветов пикселов изображения из TBitmap с автоматическим преобразованием
 //в растр с градациями серого
 for (unsigned int i = 0; i < _Raster.Rows(); i++)
  for (unsigned int j = 0; j < _Raster.Cols(); j++)
  {Color = BMP->Canvas->Pixels[j][i];
   //Выделяем R, G, B компоненты
   R = Color & Mask;
   G = (Color >> 8) & Mask;
   B = (Color >> 16) & Mask;
   if ((R == G) && (R == B)) Color = R;
   //Преобразование цветов из пространства RGB в grayscale
   //Grayscale = 0.299*R + 0.587*G + 0.114*B или
   //Grayscale = (77*R + 150*G + 29*B + 128)/256
   else Color = 0.299*R + 0.587*G + 0.114*B;
   _Raster.Put(i,j,Color);
  }
 delete BMP;

 return true;
}
//****************************************************************************************
//СТАТУС: II.5, protected, TGrayScaleImgSrc_2D class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LoadRasterFromTXT(const string& fname)
//НАЗНАЧЕНИЕ: При успешном открытии файла fname функция считывает дискретное представление
//изображения в матрицу _Raster с автоматическим масштабированием уровней яркости от 0 до
//255.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const string& fname - ссылка на имя файла TXT формата
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат считывания дискретного изображения из TXT файла
//****************************************************************************************
bool TGrayScaleImgSrc_2D::LoadRasterFromTXT(const string& fname)
{
 //----------------------------------------------------------------------------------
 //Открытие файла в текстовом режиме для чтения
 //----------------------------------------------------------------------------------
 ifstream ifs;
 ifs.open(fname.c_str(), ios::in);//ios_base::in
 if (!ifs)
 {_MsgErr = "Error: Unable to open file <" + fname + "> !!!";
  return false;
 }
 //----------------------------------------------------------------------------------
 // Работа с файлом fname открытым в режиме для чтения (построчное считывание данных)
 //----------------------------------------------------------------------------------
 const int sz_buf = 1025;
 char buf[sz_buf];
 string s;
 ulong pos = 0L;

 ifs.seekg(0);//Установка указателя на начало файла
 do //Поблочное считывание из файла с изображение с размером блока - sz_buf
 {ifs.get(buf,sz_buf,EOF);//delim = '\n'
  if (ifs.gcount() != 0) s.append(buf);
 } while (!ifs.eof());

 ifs.close();//Закрываем файл

 //Извлечение из строки массива вещественных чисел
 TStrToDoubleList DList(" \t","\n");
 DList.StrToMultiList(s,pos);
 if (DList.IsError())
 {_MsgErr = "Error: File <" + fname + "> consists incorrect data !!!";
  return false;
 }
 rmatrix X;
 double Max, Min, NormFactor;
 DList.GetData(X);
 _Raster.Set(X.Rows(),X.Cols(),false);
 if (_Raster.IsZeroSize())
 {_MsgErr = "Error ! There's not enough memory to load raster from <" + fname + "> !";
  return false;
 }
 X.MaxMin(Max,Min);
 if (Min < 0.0)
 {Abs(X);
  if (Max < fabs(Min)) Max = fabs(Min);
 }
 NormFactor = 255.0/Max;
 for (ulong i = 0; i < _Raster.Rows(); i++)
  for (ulong j = 0; j < _Raster.Cols(); j++)
   _Raster.Put(i,j,X.Get(i,j)*NormFactor);

 return true;
}
//========================================================================================
//             РЕАЛИЗАЦИЯ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССА TGrayScaleImgSrc_2D
//========================================================================================
//****************************************************************************************
//СТАТУС: 1;  TGrayScaleImgSrc_2D class friend overloading operator <<
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend ostream& operator <<(ostream& out, const TGrayScaleImgSrc_2D& ImgSrc)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВЫВОДА класса TGrayScaleImgSrc_2D.
//Функция предназначена для вывода в поток характеристик источника изображения в градациях
//серого в краткой форме. Функция возвращает ссылку на поток, что позволяет записывать в
//программе операторы вывода в поток каскадно.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на объект потока вывода;
//2. сonst TGrayScaleImgSrc_2D& ImgSrc - ссылка на объект, выводимый в поток.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ostream& out - ссылка на объект потока вывода.
//***********************-****************************************************************
ostream& operator <<(ostream& out, const TGrayScaleImgSrc_2D& ImgSrc)
{string s;
 ImgSrc.About(s,true);//Получение свойств объекта в виде строки (в краткой форме)
 out << s;//Вывод характеристик объекта
 return out;
}
//****************************************************************************************
//СТАТУС: 2;  TGrayScaleImgSrc_2D class friend function
//INPUT TGrayScaleImgSrc_2D PROPERTIES by cin
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool Edit(TGrayScaleImgSrc_2D& Signal_2D)
//НАЗНАЧЕНИЕ: Редактирование свойств объекта класса через стандартный поток ввода cin,
//передаваемый по ссылке в функцию. Функция возвращает работоспособность объекта после
//редактирования. После изменения свойств объекта осуществляется их отображение. Формат
//ввода свойств объекта:
//----------------------------------------------------------------------------------------
//256-GRAYED 2D-SIGNAL: <Edit>
// SIGNAL: (Power, Angle[in deg]) RASTER: <filename>
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TGrayScaleImgSrc_2D& Signal_2D - ссылка на редактируемый объект;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lReady - работоспособность объекта после его редактирования
//****************************************************************************************
bool Edit(TGrayScaleImgSrc_2D& Signal_2D)
{//Рабочие переменные
 int y, row_start = wherey();
 char c;
 string s, line(78,'-');
 string sPrevStatus;
 bool flag, lClear;
 gotoxy(1,row_start); clreol();

 Signal_2D.About(sPrevStatus);//Свойства объекта до редактирования

 do //Цикл ввода источников излучения в форме: (Power, Angle)
 {//--------------------------------------------------------------------------------------
  cout << line << endl;
  cout << "256-GRAYED 2D-SIGNAL: <Edit>, Before: " << sPrevStatus << endl;
  cout << "InputForm: SIGNAL: (Power,Angle[deg]) RASTER: <filename>" << endl;
  cout << line << endl;
  //--------------------------------------------------------------------------------------
  //Ввод свойств объекта в символьном виде
  //--------------------------------------------------------------------------------------
  y = wherey();
  cout << "> ";
  cin.ignore();
  getline(cin,s,'\n');
  Signal_2D.Import(s,false);//Импорт из строки s источников излучения
  ClrScr(1,y);//Очистка экрана
  cout << "After: " << Signal_2D << endl;
  //--------------------------------------------------------------------------------------
  cout << line << endl;
  //Подтверждение введенных данных
  cout << "Confirm data entry, please [y/n]: "; cin >> c;
  if (c == 'Y' || c == 'y') flag = false;
  else //Повторный ввод данных
  {flag = true;
   ClrScr(1,row_start);//Очистка экрана
  }
 } while (flag);
 ClrScr(1,row_start);//Очистка экрана
 return Signal_2D.IsReady();//Работоспособность объекта после редактирования
}
//****************************************************************************************
//СТАТУС: 3;  TGrayScaleImgSrc_2D class friend overloading operator >>
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool operator >>(istream& in, TGrayScaleImgSrc_2D& Signal_2D)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВВОДА класса TGrayScaleImgSrc_2D.
//Функция предназначена для ввода в поток in характеристик объекта в символьном виде.
//Формат ввода: SIGNAL: (Power, Angle[in deg]) RASTER: <filename>
//Функция возвращает признак работоспособности объекта после его редактирования.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. istream& in - ссылка на объект потока ввода;
//2. TGrayScaleImgSrc_2D& Signal_2D - ссылка на объект, свойства которого будут вводиться
//   из потока in.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// bool lReady - работоспособность объекта после ввода его свойств из потока in.
//***********************-****************************************************************
bool operator >>(istream& in, TGrayScaleImgSrc_2D& Signal_2D)
{char buf[80];
 in.ignore();
 in.getline(buf,sizeof(buf));
 return Signal_2D.Import(buf,false);
}
//******************** Конец реализации класса TGrayScaleImgSrc_2D ***********************
