//matrix.cpp
//Реализация классов TComplexMatrix, TRealMatrix & TIntMatrix
//Initial date: February,13,1999. Final date:
//Copyright (c) JohnSoft 1999-2002. All rights reserved. Borland C++ 5.02
#include "matrix.h"

//***********************************************************************************
//     Таблица соответствия наименования действительной матрицы ее подтипу
//***********************************************************************************
const uint szRMatrName = 16;
const MATRIX_NAME RMatrName[16] = {
//Type          RUSSIAN NAME                   ENGLISH NAME
{RM_ZEROSIZE,   "Матрица нулевого размера",    "Zero-size matrix"   },     //0
{RM_ZERO,       "Нулевая матрица",             "Zero matrix"        },     //1
{RM_NUMBER,     "Действительное число",        "Real number"        },     //2
{RV_ROW,        "Вектор-строка",               "Vector-row"         },     //3
{RV_COLUMN,     "Вектор-столбец",              "Vector-column"      },     //4
{RM_RECTANG,    "Прямоугольная матрица",       "Rectangular matrix" },     //5
{RM_SQUARE,     "Квадратная матрица",          "Square matrix"      },     //6
{RM_DIAGONAL,   "Диагональная матрица",        "Diagonal matrix"    },     //7
{RM_SCALAR,     "Скалярная матрица",           "Scalar matrix"      },     //8
{RM_UNIT,       "Единичная матрица",           "Unit matrix"        },     //9
{RM_BAND,       "Ленточная матрица",           "Band matrix"        },     //10
{RM_UTRIANG,    "Верхняя треугольная матрица", "Upper triangular matrix"}, //11
{RM_LTRIANG,    "Нижняя треугольная матрица",  "Left triangular matrix" }, //12
{RM_SYMMETR,    "Симметрическая матрица",      "Symmetrical matrix"     }, //13
{RM_SKEWSYMMETR,"Кососимметрическая матрица",  "Skewsymmetric matrix"   }, //14
{RM_ALTSIGN,    "Знакопеременная матрица",     "Alternatingsign matrix" }};//15

//***********************************************************************************
//       Таблица соответствия наименования комплексной матрицы ее подтипу
//***********************************************************************************
const uint szCMatrName = 17;
const MATRIX_NAME CMatrName[17] = {
//Type         RUSSIAN NAME
//             ENGLISH NAME
{CM_ZEROSIZE, "Комплексная матрица нулевого размера",
              "Complex zero-size matrix"                }, //0
{CM_ZERO,     "Комплексная нулевая матрица",
              "Complex zero matrix"                     }, //1
{CM_NUMBER,   "Комплексное число",
              "Complex number"                          }, //2
{CV_ROW,      "Комплексный вектор-строка",
              "Complex vector-row"                      }, //3
{CV_COLUMN,   "Комплексный вектор-столбец",
              "Complex vector-column"                   }, //4
{CM_RECTANG,  "Комплексная прямоугольная матрица",
              "Complex rectangular matrix"              }, //5
{CM_SQUARE,   "Комплексная квадратная матрица",
              "Complex square matrix"                   }, //6
{CM_DIAGONAL, "Комплексная диагональная матрица",
              "Complex diagonal matrix"                 }, //7
{CM_SCALAR,   "Комплексная скалярная матрица",
              "Complex scalar matrix"                   }, //8
{CM_UNIT,     "Комплексная единичная матрица",
              "Complex unit matrix"                     }, //9
{CM_BAND,     "Комплексная ленточная матрица",
              "Complex band matrix"                     }, //10
{CM_UTRIANG,  "Комплексная верхняя треугольная матрица",
              "Complex upper triangular matrix"         }, //11
{CM_LTRIANG,  "Комплексная нижняя треугольная матрица",
              "Complex left triangular matrix"          }, //12
{CM_SYMMETR,  "Комплексная симметрическая матрица",
              "Complex symmetrical matrix"              }, //13
{CM_SKEWSYM,  "Комплекная кососимметрическая матрица",
              "Complex skewsymmetric matrix"            }, //14
{CM_ALTSIGN,  "Комплексная знакопеременная матрица",
              "Complex alternatingsign matrix"          }, //15
{CM_HERMITIAN,"Эрмитовая матрица",
              "Hermitian matrix"                        } };//16

const double EPS = 1e-10; //Точность представления чисел типа double

//***********************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TRealMatrix
//***********************************************************************************
//===================================================================================
//  РЕАЛИЗАЦИЯ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TRealMatrix
//   TRealMatrix CLASS CONSTRUCTORs & DESTRUCTOR REALIZATION
//===================================================================================

//***********************************************************************************
//СТАТУС: 1; public TRealMatrix constructor by default
//НАИМЕНОВАНИЕ ФУНКЦИИ: TRealMatrix()
//НАЗНАЧЕНИЕ: Конструктор по умолчанию класса TRealMatrix создает объект класса по
//умолчанию - вещественную матрицу нулевого размера - RM_ZEROSIZE.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
TRealMatrix::TRealMatrix() { Initial(); }
//***********************************************************************************
//СТАТУС: 2; public TRealMatrix constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TRealMatrix(ulong row, ulong col, double value)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TRealMatrix создает квадратную или
//прямоугольную матрицу и инициализирует ее элементы значением value.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong row - количество строк матрицы;
//2. ulong col - количество столбцов матрицы;
//3. double value - инициализирующее значение.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
TRealMatrix::TRealMatrix(ulong row, ulong col, double value)
{Initial();//Начальная инициализация членов-данных класса
 Set(row,col,value);
}
//***********************************************************************************
//СТАТУС: 3; public TRealMatrix constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TRealMatrix(ulong row, ulong col, bool init)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TRealMatrix создает вещественную матрицу
//с инициализацией ее случайными значениями при init = true и без нее в противном
//случае.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong row - количество строк матрицы;
//2. ulong col - количество столбцов матрицы;
//3. bool init - опция инициализации матрицы случайными значениями.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
TRealMatrix::TRealMatrix(ulong row, ulong col, bool init)
{Initial();//Начальная инициализация членов-данных класса
 Set(row,col,init);
}
//***********************************************************************************
//СТАТУС: 4; public TRealMatrix constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TRealMatrix(ulong size, double value)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TRealMatrix создает квадратную матрицу
//и инициализирует ее элементы значением value.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong size - размерность квадратной матрицы;
//2. double value - инициализирующее значение.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
TRealMatrix::TRealMatrix(ulong size, double value)
{Initial();//Начальная инициализация членов-данных класса
 Set(size,value);
}
//***********************************************************************************
//СТАТУС: 5; public TRealMatrix constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TRealMatrix(ulong size, bool init)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TRealMatrix создает квадратную матрицу
//с инициализацией случайными значениями при init=true и без нее в противном случае.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong size - размерность квадратной матрицы;
//2. bool init - опция инициализации матрицы случайными значениями.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
TRealMatrix::TRealMatrix(ulong size, bool init)
{Initial();//Начальная инициализация членов-данных класса
 Set(size,init);
}
//***********************************************************************************
//СТАТУС: 6; public TRealMatrix constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TRealMatrix(ulong size, uint sq_type, ulong diag = 3L)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TRealMatrix создает квадратную матрицу
//типа sq_type и инициализирует ее случайными значениями. Параметр diag используется
//при конструировании ленточной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong size - размерность квадратной матрицы;
//2. uint sq_type - тип квадратной матрицы;
//3. ulong diag - кол-во диагоналей ленточной матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
TRealMatrix::TRealMatrix(ulong size, uint sq_type, ulong diag)
{Initial();//Начальная инициализация членов-данных класса
 Set(size, sq_type, diag);
}
//***********************************************************************************
//СТАТУС: 7; public TRealMatrix constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TRealMatrix(const PF_MATRIX& Info)
//НАЗНАЧЕНИЕ: Конструктор класса TRealMatrix создает матрицу по данным структуры типа
//PF_MATRIX, передаваемой по ссылке.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const PF_MATRIX& Info - ссылка на структуру свойств, создаваемой матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
TRealMatrix::TRealMatrix(const PF_MATRIX& Info)
{Initial();//Начальная инициализация членов-данных класса
 Set(Info);
}
//***********************************************************************************
//СТАТУС: 8; public; TRealMatrix class copy constructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: TRealMatrix(const TRealMatrix& R)
//НАЗНАЧЕНИЕ: Конструктор копирования создает объект класса TRealMatrix по характе-
//ристикам матрицы R и осуществляет корректное копирование членов-указателей на данные
//копируемого класса в создаваемый класс с целью недопущения ссылок указателей разных
//объектов класса на одно и то же место памяти. Для процедуры копирования используется
//ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TRealMatrix& R - ссылка на объект типа TRealMatrix
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
TRealMatrix::TRealMatrix(const TRealMatrix& R)
{Initial();//Начальная инициализация членов-данных класса
 *this = R;//Установка характеристик матрицы, вызовом перегруженного оператора =
}
//***********************************************************************************
//СТАТУС: 9; public; TRealMatrix class destructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: ~TRealMatrix()
//НАЗНАЧЕНИЕ: ДЕСТРУКТОР класса TRealMatrix удаляет объекта класса после завершения
//работы с ним, освобождая оперативную память занятую элементами матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
TRealMatrix::~TRealMatrix() {Delete();}

//===================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TRealMatrix
//    PUBLIC MEMBER-FUNCTION OF TRealMatrix CLASS REALIZATION
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1, public, TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsZeroSize() const
//НАЗНАЧЕНИЕ: Проверка вещественной матрицы на матрицу нулевого размера. В случае удачи
//функция возвращает - true и false - в противном случае. Свойства матрицы нулевого
//размера: m = n = 0 - кол-во строк или столбцов равно нулю.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица нулевого размера (false - не RM_ZEROSIZE).
//***********************************************************************************
bool TRealMatrix::IsZeroSize() const
{//Проверка на m == n == 0L
 return ((Rows() == 0L) || (Cols() == 0L)) ? true : false;
}
//***********************************************************************************
//СТАТУС: I.2., public, TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsZero() const
//НАЗНАЧЕНИЕ: Проверка на матрицу со всеми нулевыми элементами. В случае удачи функция
//возвращает - true и false - в противном случае. Свойства матрицы со всеми нулевыми
//элементами: A[i][j] = 0 - ВСЕ элементы матрицы должны быть равны НУЛЮ.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица со всеми нулевыми элементами (false - не RM_ZERO).
//***********************************************************************************
bool TRealMatrix::IsZero() const
{for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
  {if (fabs(data[i][j]) > EPS) return false;} //Все элементы д.б. нулевыми
 return true;
}
//***********************************************************************************
//СТАТУС: I.3, public, TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsSymmetric() const
//НАЗНАЧЕНИЕ: Проверка вещественной матрицы на СИММЕТРИЧНОСТЬ. В случае ее симметрич-
//ности функция возвращает - true и false - в противном случае. Свойства симметричес-
//кой вещественной матрицы:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = A[j][i] - элементы матрицы, расположенные симметрично друг друга
//   относительно главной диагонали матрицы должны быть равными.
//3. Должен существовать внедиагональный элемент матрицы отличный от нуля.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица симметрическая (false - не симметрическая).
//***********************************************************************************
bool TRealMatrix::IsSymmetric() const
{if (!IsSquare() || (Rows() < 2)) return false; //Проверка на квадратную матрицу
 bool lNonZero = false;
 //Цикл проверки свойства 2 & 3
 for (ulong i = 1L; i < Rows(); i++)
  for (ulong j = 0L; j < i; j++)
  {if (lNonZero == false) lNonZero = (fabs(data[i][j]) > EPS) ? true : false;
   if (fabs(data[i][j] - data[j][i]) > EPS) return false;
  }
 return lNonZero;
}
//***********************************************************************************
//СТАТУС: I.4, public, TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsSkewSymmetric() const
//НАЗНАЧЕНИЕ: Проверка вещественной матрицы на кососимметричность. В случае ее косо-
//симметричности функция возвращает - true и false - в противном случае. Свойства
//кососимметрической вещественной матрицы:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = -A[j][i] - элементы матрицы, расположенные симметрично друг друга
//   относительно главной диагонали матрицы должны быть равными по модулю и противо-
//   положными по знаку.
//3. Должен существовать внедиагональный элемент матрицы отличный от нуля.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица кососимметрическая (false - не кососимметрическая).
//***********************************************************************************
bool TRealMatrix::IsSkewSymmetric() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 bool lNonZero = false;
 //Цикл проверки свойства 2 & 3
 for (ulong i = 1L; i < Rows(); i++)
  for (ulong j = 0L; j < i; j++)
  {if (lNonZero == false) lNonZero = (fabs(data[i][j]) > EPS) ? true : false;
   if (fabs(data[i][j] + data[j][i]) > EPS) return false;
  }
 return lNonZero;
}
//***********************************************************************************
//СТАТУС: I.5, public, TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsAltSign() const
//НАЗНАЧЕНИЕ: Проверка вещественной матрицы на знакопеременность. В случае ее знако-
//переменности функция возвращает - true и false - в противном случае. Свойства знако-
//переменной вещественной матрицы:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = -A[j][i] - элементы матрицы, расположенные симметрично друг друга отно-
//   сительно главной диагонали матрицы должны быть равными по модулю и противополож-
//   ными по знаку.
//3. A[i][i] = 0 - элементы матрицы, расположенные на главной диагонали должны быть
//   равными нулю.
//4. Должен существовать внедиагональный элемент матрицы отличный от нуля.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица знакопеременная (false - не знакопеременная).
//***********************************************************************************
bool TRealMatrix::IsAltSign() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 bool lNonZero = false;
 //Цикл проверки свойства 2 и 3
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i ; j++)
  {if (i != j) //Элемент матрицы размещен не на главной диагонали
   {if (lNonZero == false) lNonZero = (fabs(data[i][j]) > EPS) ? true : false;
    if (fabs(data[i][j] + data[j][i]) > EPS) return false;
   }
   else //Элемент матрицы размещен на главной диагонали
    if (fabs(data[i][j]) > EPS) return false;
  }
return lNonZero;
}
//***********************************************************************************
//СТАТУС: I.6, public, TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsUpperTriang() const
//НАЗНАЧЕНИЕ: Проверка вещественной матрицы на верхнюю треугольную. Если матрица -
//верхняя треугольная, то функция возвращает - true и false - в противном случае.
//Свойства верхней треугольной вещественной матрицы:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 2;
//2. A[i][j] = 0, для всех i > j - элементы матрицы, расположенные ниже главной
//   диагонали матрицы должны быть равны нулю.
//3. Должны существовать элементы матрицы отличные от нуля, расположенные выше
//   главной диагонали.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица верхняя треугольная (false - не верхняя треугольная).
//***********************************************************************************
bool TRealMatrix::IsUpperTriang() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 bool lNonZero = false;
 //Цикл проверки свойства 2
 for (ulong i = 1L; i < Rows(); i++)
  for (ulong j = 0L; j < i; j++)
  {if (lNonZero == false) lNonZero = (fabs(data[j][i]) > EPS) ? true : false;
   //Элемент матрицы, размещенные ниже главной диагонали
   if (fabs(data[i][j]) > EPS) return false;
  }
 return lNonZero;
}
//***********************************************************************************
//СТАТУС: I.7., public, TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsLowerTriang() const
//НАЗНАЧЕНИЕ: Проверка вещественной матрицы на нижнюю треугольную. Если матрица -
//нижняя треугольная, то функция возвращает - true и false - в противном случае.
//Свойства нижней треугольной вещественной матрицы следующие:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = 0, для всех i < j - элементы матрицы, расположенные выше главной
//   диагонали матрицы должны быть равны нулю.
//3. Должны существовать элементы матрицы отличные от нуля, расположенные ниже
//   главной диагонали.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица нижняя треугольная (false - не нижняя треугольная).
//***********************************************************************************
bool TRealMatrix::IsLowerTriang() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 bool lNonZero = false;
 //Цикл проверки свойства 2
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = i+1; j < Cols(); j++)
  {if (lNonZero == false) lNonZero = (fabs(data[j][i]) > EPS) ? true : false;
   //Элементы матрицы, размещенные выше главной диагонали
   if (fabs(data[i][j]) > EPS) return false;
  }
 return lNonZero;
}
//***********************************************************************************
//СТАТУС: I.8, public, TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsDiagonal() const
//НАЗНАЧЕНИЕ: Проверка вещественной матрицы на диагональную. Если матрица - диагональ-
//ная, то функция возвращает - true и false - в противном случае. Свойства диагональ-
//ной вещественной матрицы следующие:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = 0, для всех i != j - элементы матрицы, расположенные не на главной
//   диагонали матрицы должны быть равны нулю.
//3. Должен существовать элемент матрицы отличный от нуля, расположенный на главной
//   диагонали.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица диагональная (false - не диагональная).
//***********************************************************************************
bool TRealMatrix::IsDiagonal() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 bool lNonZero = false;
 //Цикл проверки свойства 2
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {//Элемент матрицы размещенный не на главной диагонали
   if ((i != j) && (fabs(data[i][j]) > EPS)) return false;
   //Диагональный элемент
   else if (lNonZero == false) lNonZero = (fabs(data[i][j]) > EPS) ? true : false;
  }
return lNonZero;
}
//***********************************************************************************
//СТАТУС: I.9., public, TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsScalar() const
//НАЗНАЧЕНИЕ: Проверка вещественной матрицы на скалярную. Если матрица - скалярная,
//то функция возвращает - true и false - в противном случае. Свойства скалярной вещест-
//венной матрицы:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = 0, для всех i != j - элементы матрицы, расположенные не на главной
//   диагонали матрицы должны быть равны нулю.
//3. A[i][i] = c, для всех i = j - элементы матрицы, расположенные на главной
//   диагонали равны между собой (c != 1 && c != 0).
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица скалярная (false - не скалярная).
//***********************************************************************************
bool TRealMatrix::IsScalar() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 double c = data[0][0];
 if (fabs(c) < EPS) return false;//Проверка на c == 0.0
 if (fabs(c - 1.0) < EPS) return false;//Проверка на c == 1.0
 //Цикл проверки свойства 2 & 3
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {//Внедиагональный элемент матрицы
   if ((i != j) && (fabs(data[i][j]) > EPS)) return false;
   //Диагональный элемент матрицы
   else if (fabs(data[i][j] - c) > EPS) return false;
  }
 return true;
}
//***********************************************************************************
//СТАТУС: I.10, public, TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsUnit() const
//НАЗНАЧЕНИЕ: Проверка вещественной матрицы на единичную. Если матрица - единичная,
//функция возвращает - true и false - в противном случае. Свойства единичной матрицы:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = 0, для всех i != j - элементы матрицы, расположенные не на главной
//   диагонали матрицы должны быть равны нулю.
//3. A[i][i] = 1, для всех i = j - элементы матрицы, расположенные на главной
//   диагонали равны между собой.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица единичная (false - не единичная).
//***********************************************************************************
bool TRealMatrix::IsUnit() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 //Цикл проверки свойства 2 & 3
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
  {//Внедиагональный элемент матрицы
   if ((i != j) && (fabs(data[i][j]) > EPS)) return false;
   //Внедиагональный элемент матрицы
   else if (fabs(data[i][j] - 1.0) > EPS) return false;
  }
 return true;
}
//***********************************************************************************
//СТАТУС: I.11, public, TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsBand(ulong& diags) const
//НАЗНАЧЕНИЕ: Проверка вещественной матрицы на ленточную с автоматическим определением
//числа дигоналей. На ленточную проверяется квадратная  матрица размерностью не меньше
//трех, максимальное число диагоналей матрицы определяется формулой:
//maxdiag = 2*Rows()-1. Проверка начинается с максимально возможного числа диагоналей.
//Это позволяет определить сразу является матрица ленточной или нет. Число диагоналей
//у ленточной матрицы может быть только НЕЧЕТНЫМ. Если матрица является ленточной, то
//функция возвращает - true и false - в противном случае. В переменную diags, переда-
//ваемую по ссылке, заносится число диагоналей квадратной матрицы (1<=diags<= maxdiag).
//Матрица считается ленточной:
// - при diags != 1 (диагональная матрица) и diags != maxdiag (обыкновенная квадратная
//   матрица). При diags == 0 - матрица прямоугольная.
//Свойства ленточной вещественной матрицы следующие:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 2;
//2. A[i][j] = 0, для элементов матрицы, индексы которых должны удовлетворять
//   следующему неравенству: 2*|i-j| > diag-1.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong& diags - число диагоналей матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица ленточная (false - не ленточная).
//***********************************************************************************
bool TRealMatrix::IsBand(ulong& diags) const
{//Проверка на квадратную матрицу
 if (!IsSquare() || (Rows() < 3)) {diags = 0L; return false;}
 diags = 2*Rows()-1;//Максимальное число диагоналей данной матрицы
 for (ulong n = Rows()-1; n > 0; n--)
 {ulong j = 0L;
  bool lZeroDiag = true;
  for (ulong i = n; i < Rows(); i++)
  {if ((fabs(data[i][j]) > EPS) || (fabs(data[j][i]) > EPS))
   {lZeroDiag = false; break;}
   j++;
  }
  if (lZeroDiag == false) break;
  diags -= 2;//Уменьшаем число диагоналей ленточной матрицы от значения maxdiag
 }
 //Анализ результатов
 return ((diags == 1L) || (diags == 2*Rows()-1)) ? false : true;
}
//***********************************************************************************
//СТАТУС: I.12, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: uint SubType() const
//НАЗНАЧЕНИЕ: Определение подтипа вещественной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint type - подтип матрицы
//***********************************************************************************
uint TRealMatrix::SubType() const
{if (IsZeroSize()) return RM_ZEROSIZE;//Матрица нулевого размера
 //Действительное число - матрица размером 1 x 1
 if ((Rows() == 1) && (Cols() == 1)) return RM_NUMBER;
 //Матрица со всеми нулевыми элементами
 if (IsZero()) return RM_ZERO;

 if (IsRectang()) //Прямоугольная матрица
 {if ((Rows() == 1) && (Cols() > 1)) return RV_ROW;//Вектор-строка
  if ((Cols() == 1) && (Rows() > 1)) return RV_COLUMN;//Вектор-столбец
  return RM_RECTANGULAR;
 }
 else //Квадратная матрица
 {//Проверка подклассов класса <КВАДРАТНАЯ МАТРИЦА> ...
  //---------------------------------------------------------------------------------
  //Проверка на диагональную матрицу
  if (IsDiagonal())
  {if (IsScalar()) return RM_SCALAR;//Проверка на скалярную матрицу
   if (IsUnit()) return RM_UNIT;//Проверка на единичную матрицу
   return RM_DIAGONAL;
  }
  //---------------------------------------------------------------------------------
  if (IsSymmetric()) return RM_SYMMETRICAL;//Проверка на симметричность
  if (IsSkewSymmetric()) //Проверка на кососимметричность
  {//Проверка на знакопеременность
   if (IsAltSign()) return RM_ALTERNATINGSIGN;
   return RM_SKEWSYMMETRIC;
  }
  //---------------------------------------------------------------------------------
  //Проверка на верхнюю треугольную матрицу
  if (IsUpperTriang()) return RM_UPPERTRIANG;
  //Проверка на нижнюю треугольную матрицу
  if (IsLowerTriang()) return RM_LOWERTRIANG;
  //---------------------------------------------------------------------------------
  //Проверка на ленточную матрицу с определением числа ее диагоналей
  ulong diags = 0L;
  if (IsBand(diags)) return RM_BAND;
 }
return RM_SQUARE;
}
//***********************************************************************************
//СТАТУС: I.13, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: uint SubType(ulong& n) const
//НАЗНАЧЕНИЕ: Определение подтипа вещественной матрицы. В переменную n, передаваемую
//по ссылке, в зависимости от подтипа матрицы заноситься дополнительная информация о
//матрице. Для квадратной матрицы и векторов - n будет содержать размерности, для
//ленточной матрицы - количество диагоналей.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong& n - ссылка на переменную, в которую заносится
//дополнительная информация о матрице
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint type - подтип матрицы
//***********************************************************************************
uint TRealMatrix::SubType(ulong& n) const
{n = 0L;
 if (IsZeroSize()) return RM_ZEROSIZE;//Матрица нулевого размера
 //Действительное число - матрица размером 1 x 1
 if ((Rows() == 1) && (Cols() == 1)) {n = 1L; return RM_NUMBER;}
 //Матрица со всеми нулевыми элементами
 if (IsZero()) return RM_ZERO;

 if (IsRectang()) //Прямоугольная матрица
 {if ((Rows() == 1) && (Cols() > 1)) {n = Cols(); return RV_ROW;}//Вектор-строка
  if ((Cols() == 1) && (Rows() > 1)) {n = Rows(); return RV_COLUMN;}//Вектор-столбец
  return RM_RECTANGULAR;
 }
 else //Квадратная матрица
 {//Проверка подклассов класса <КВАДРАТНАЯ МАТРИЦА> ...
  //---------------------------------------------------------------------------------
  n = Rows();//Размерность квадратной матрицы
  //Проверка на диагональную матрицу
  if (IsDiagonal())
  {if (IsScalar()) return RM_SCALAR;//Проверка на скалярную матрицу
   if (IsUnit()) return RM_UNIT;//Проверка на единичную матрицу
   return RM_DIAGONAL;
  }
  //---------------------------------------------------------------------------------
  if (IsSymmetric()) return RM_SYMMETRICAL;//Проверка на симметричность
  if (IsSkewSymmetric()) //Проверка на кососимметричность
  {//Проверка на знакопеременность
   if (IsAltSign()) return RM_ALTERNATINGSIGN;
   return RM_SKEWSYMMETRIC;
  }
  //---------------------------------------------------------------------------------
  //Проверка на верхнюю треугольную матрицу
  if (IsUpperTriang()) return RM_UPPERTRIANG;
  //Проверка на нижнюю треугольную матрицу
  if (IsLowerTriang()) return RM_LOWERTRIANG;
  //---------------------------------------------------------------------------------
  //Проверка на ленточную матрицу с определением числа ее диагоналей
  ulong diags;
  if (IsBand(diags)) {n = diags; return RM_BAND;}
 }
return RM_SQUARE;
}
//***********************************************************************************
//СТАТУС: I.14, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Properties(PF_MATRIX& Info) const
//НАЗНАЧЕНИЕ: Определение свойств вещественной матрицы. Функция размещает характерис-
//тики матрицы в структуре Info, передаваемой по ссылке. Для ленточной матрицы поле
//Info.cols будет содержать количество ее диагоналей.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: PF_MATRIX& Info - ссылка на структуру свойств матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRealMatrix::Properties(PF_MATRIX& Info) const
{Info.type = Type(); Info.rows = Rows(); Info.cols = Cols();
 //----------------------------------------------------------------------------------
 //Определение подтипа матрицы
 //----------------------------------------------------------------------------------
 ulong n; Info.subtype = SubType(n);
 //Число диагоналей для ленточной матрицы
 if (Info.subtype == RM_BAND) Info.cols = n;
}
//***********************************************************************************
//СТАТУС: I.15, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// void Properties(ulong& rows, ulong& cols, bool& type, uint& subtype) const
//НАЗНАЧЕНИЕ: Определение свойств вещественной матрицы. Функция размещает характерис-
//тики матрицы в переменных rows, cols, type, subtype, передаваемых по ссылке. Для
//ленточной матрицы cols будет содержать количество ее диагоналей.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong& rows - ссылка на число строк матрицы;
//2. ulong& cols - ссылка на число столбцов (диагоналей) матрицы;
//3. bool& type  - ссылка на тип матрицы (SQUARE || RECTANG);
//4. uint& subtype - ссылка на подтип матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRealMatrix::Properties(ulong& rows, ulong& cols, bool& type, uint& subtype) const
{type = Type(); rows = Rows(); cols = Cols();
 ulong n; subtype = SubType(n);//Определение подтипа матрицы
 if (subtype == RM_BAND) cols = n;//Число диагоналей для ленточной матрицы
}
//***********************************************************************************
//СТАТУС: I.16, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetType(string& s, uint language = ENG) const
//НАЗНАЧЕНИЕ: Формирование наименования типа матрицы на русском или английском языке.
//Допускается многоязычный интерфейс корректировкой кода функции. Язык по умолчанию -
//английский. Формирование типа матрицы (SQUARE || RECTANG) осуществляется в строке s,
//передаваемой по ссылке. Функция возвращает ссылку на строку с наименованием типа
//матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку для формирования имени типа вектора;
//2. uint language [ENG] - язык наименования типа вектора.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// string& s - ссылка на строку с сформированным именем типа вектора
//***********************************************************************************
string& TRealMatrix::GetType(string& s, uint language) const
{if (language == RUS) //Формирование наименования типа матрицы на русском языке
  s = (IsSquare()) ? "Квадратная матрица" : "Прямоугольная матрица";
 else //Формирование наименования типа матрицы на английском языке
  s = (IsSquare()) ? "Square matrix" : "Rectangular matrix";
 return s;
}
//***********************************************************************************
//СТАТУС: I.17, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetSubType(string& s, uint language = ENG) const
//НАЗНАЧЕНИЕ: Получение наименования подтипа матрицы. Таблица соответствия подтипа
//матрицы с ее наименованиями представлена массивом RMatrName. В массиве хранятся
//наименования матриц на русском и английском языке. Индексом для получения имени
//матрицы служит ее подтип (subtype). Осуществляется обработка некорректного задания
//языка, на  котором  должно  быть получено имя. Допускается многоязычный интерфейс
//путем корректировки структуры MATRIX_NAME и внесения изменений в массив RMatrName.
//Язык по умолчанию - английский.  При формировании наименования матрицы в строке s,
//прежнее содержимое строки уничтожается.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку;
//2. uint language (ENG) - язык, на котором формируется наименование матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с именем подтипа матрицы
//***********************************************************************************
string& TRealMatrix::GetSubType(string& s, uint language) const
{uint index = SubType();//Определяем подтип матрицы
 switch (language)
 { case RUS: //указать наименование типа матрицы на русском языке
    s = RMatrName[index].rus_name; break;
   case ENG: //указать наименование типа матрицы на английском языке
    s = RMatrName[index].eng_name; break;
   //Наименование типа матрицы на заданном языке отсутствует
   default: //указать наименование типа матрицы на английском языке
    s = RMatrName[index].eng_name; break;
 }
 return s;
}
//***************************************************************************************
//СТАТУС: I.18; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& GetData(string& s, uint precision, string delim) const;
//НАЗНАЧЕНИЕ: Функция размещает в строке s, передаваемой по ссылке, значения элементов
//матрицы в отформатированном виде. Формат вывода значений элементов матрицы:
// < X11<delim>X12<delim>X13...X1n\n >
// < X21<delim>X22<delim>X23...X1n\n >
// < .............................\n >
// < Xm1<delim>Xm2<delim>Xm3...Xmn\n >, где Xij - значениe элемента матрицы.
//При выводе элементов вещественной матрицы приняты следующие соглашения:
//1. Все элементы матрицы имеют ширину вывода равную наибольшей символьной длине
//   элемента в данном столбце матрицы, который определяется функцией WidthCols(...)
//2. Выводятся только отрицательные знаки чисел.
//3. Точность вывода чисел с плавающей точкой определяется установленным до вывода
//   элементов матрицы значением функции потокового вывода precision. Максимально
//   возможное количество значащих цифр - 19.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которую заносятся элементы матрицы;
//2. uint precision - точность представления чисел с плавающей точкой;
//3. string& delim - строка символов-разделителей между двумя соседними числами.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с элементами матрицы.
//***********************************************************************************
string& TRealMatrix::GetData(string& s, uint precision, string& delim) const
{s.resize(0);
 if (IsZeroSize()) return s.append("Zero-size matrix.");
 if (delim.empty()) delim.assign(1,' ');//Разделитель между двумя соседними числами
 //Определение максимальной символьной длины элемента матрицы
 ivector WCols;
 WidthCols(WCols,precision);

 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 text.setf(ios::right);//Выравнивание по правому краю.
 //Вывод значений элементов вещественной матрицы в строку
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {//Формирование символьного представления вещественного числа
   text << setw(WCols.Get(j)) << setprecision(precision) << data[i][j];
   if ((Cols()-j) > 1) text << delim << ends;
   else text << endl << ends;//Каждая строка матрицы выводится с новой строки
   s.append(text.str()); text.seekp(0);
  }
return s;
}
//****************************************************************************************
//СТАТУС: I.19; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: uint WidthCols(ivector& Width, uint Precision) const
//НАЗНАЧЕНИЕ: Определение максимального символьного размера элементов вещественной матрицы
//и максимальной ширины каждого столбца матрицы. Функция применяется для форматированного
//вывода элементов вещественной матрицы. При вычислении максимальной символьной длины при-
//няты следующие соглашения:
//1. Точность представления действительного числа равна precision.
//В ходе работы функции создается вектор V, передаваемый по ссылке, для хранения максималь-
//ной ширины каждого столбца матрицы и максимального символьного размера элемента данной
//матрицы - Width[Cols()+1]. Максимальный размер элемента матрицы хранится в последнем эле-
//менте вектора Width.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ivector& Width - вектор, в который записывается ширина каждого столбца матрицы;
//2. uint Precision - количество выводимых цифр чисел с плавающей точкой.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint MaxLen - максимальная символьная длина элемента матрицы
//****************************************************************************************
uint TRealMatrix::WidthCols(ivector& Width, uint Precision) const
{uint MaxLen = 0;
 //Проверка матрицы на нулевой размер
 if (IsZeroSize()) {Width.Resize(0); return MaxLen;}
 //Установка нового размера вектора Width и его начальная инициализация
 Width.Set(Cols()+1,0L);
 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 uint count;
 //Цикл считывания элементов вещественной матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {//Формирование символьного представления вещественного числа
   text << setprecision(Precision) << data[i][j] << ends;
   //Определение максимальной символьной длины элемента вещественной матрицы и
   //каждого столбца матрицы
   count = text.pcount()-1;
   if (count > (ulong) Width.Get(j))
   {Width.Put(j,count);
    if (MaxLen < count) MaxLen = count;
   }
   text.seekp(0);
  }
 Width.Put(Cols(),MaxLen);
return MaxLen;
}
//****************************************************************************************
//СТАТУС: I.20; public member-function of class TRealMatrix
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Properties(string& s) const
//НАЗНАЧЕНИЕ: Формирование свойств TRealMatrix в виде строки.
//ПРИМЕР: TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строковый объект
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами матрицы
//***********************************************************************************
string& TRealMatrix::Properties(string& s) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 s.resize(0);
 PF_MATRIX Info;
 Properties(Info);//Определение свойств матрицы
 //----------------------------------------------------------------------------------
 //1. Формирование наименования типа матрицы
 s.append("TYPE: ");
 text << RMatrName[Info.subtype].eng_name << "; " << ends;
 s.append(text.str()); text.seekp(0);
 //2. Формирование размерности матрицы
 s.append("DIMENSION: ");
 text << Rows() << " x " << Cols() << ends;
 s.append(text.str()); text.seekp(0);
 //Для ленточной матрицы формируем количество ее диагоналей
 if (Info.subtype == RM_BAND)
 {text << "; " << Info.cols << "-diags" << ends;
  s.append(text.str()); text.seekp(0);
 }
 s.append("\n");//'\n'
return s;
}
//***********************************************************************************
//СТАТУС: I.21, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(ulong rows, ulong cols, double value)
//НАЗНАЧЕНИЕ: Установка новых размеров вещественной матрицы и их инициализация значе-
//нием value. При невозможности создания матрицы новых размеров функция возвращает
//false, матрица становится нулевой размерности.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong rows - количество строк матрицы;
//2. ulong cols - количество столбцов матрицы;
//3. double value - инициализирующая величина
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак создания матрицы новых размеров
//***********************************************************************************
bool TRealMatrix::Set(ulong rows, ulong cols, double value)
{//Анализ на соответствие размеров старой и новой матрицы
 if ((rows != Rows()) || (cols != Cols()))
 {Delete();//1. Удаление элементов матрицы со старыми размерами
  //2. Установка новых размеров и типа матрицы
  m = rows; n = cols; type = (m == n) ? SQUARE : RECTANG;
  //3. Распределение памяти под хранение элементов матрицы с новыми размерами
  if (Create() == false) return false;
 }
 //Инициализация элементов матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = value;
 return true;
}
//***********************************************************************************
//СТАТУС: I.22, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(ulong rows, ulong cols, bool init)
//НАЗНАЧЕНИЕ: Установка новых размеров вещественной матрицы и их инициализация cлучай-
//ными значениями при init = true. По умолчанию матрица не инициализируется. При
//невозможности создания матрицы новых размеров возвращается false, матрица становит-
//ся нулевой размерности.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong rows - количество строк матрицы;
//2. ulong cols - количество столбцов матрицы;
//3. bool init - опция инициализации случайными значениями элементов матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак создания матрицы новых размеров
//***********************************************************************************
bool TRealMatrix::Set(ulong rows, ulong cols, bool init)
{//Анализ на соответствие размеров старой и новой матрицы
 if ((rows != Rows()) || (cols != Cols()))
 {Delete();//1. Удаление элементов матрицы со старыми размерами
  //2. Установка новых размеров и типа матрицы
  m = rows; n = cols; type = (m == n) ? SQUARE : RECTANG;
  //3. Распределение памяти под хранение элементов матрицы с новыми размерами
  if (Create() == false) return false;
 }
 if (init) InitMatrix();//Инициализация элементов матрицы случайными значениями
 return true;
}
//***********************************************************************************
//СТАТУС: I.23, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(ulong size, uint sq_type, ulong diags = 3L)
//НАЗНАЧЕНИЕ: Установка новых свойств квадратной вещественной матрицы и ее инициализа-
//ция. При невозможности создания квадратной матрицы новых размеров функция возвращает
//false, матрица становится нулевой размерности.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong size - размерность квадратной матрицы;
//2. uint sq_type - подтип квадратной матрицы;
//3. ulong diags (3) - количество диагоналей для ленточной матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак создания матрицы новых размеров
//***********************************************************************************
bool TRealMatrix::Set(ulong size, uint sq_type, ulong diags)
{//Анализ на соответствие размеров старой и новой матрицы
 if ((size != Rows()) || (size != Cols()))
 {Delete();//1. Удаление элементов матрицы со старыми размерами
  //2. Установка новых размеров и типа матрицы
  m = n = size; type = SQUARE;
  //3. Распределение памяти под хранение элементов матрицы с новыми размерами
  if (Create() == false) return false;
 }
 switch (sq_type) //Инициализация элементов квадратной матрицы
 { case RM_DIAGONAL:
    InitDiagonal(); break;
   case RM_SCALAR:
    InitScalar(); break;
   case RM_UNIT:
    InitUnit(); break;
   case RM_BAND:
    InitBand(diags); break;
   case RM_UPPERTRIANG:
    InitUTriang(); break;
   case RM_LOWERTRIANG:
    InitLTriang(); break;
   case RM_SYMMETRICAL:
    InitSymmetric(); break;
   case RM_SKEWSYMMETRIC:
    InitSkewSymmetric(); break;
   case RM_ALTSIGN:
    InitAltSign(); break;
   case RM_ZERO:
    InitZeroMatrix(); break;
   default: //По умолчанию - квадратная матрица
    InitMatrix(); break;
 }
 return true;
}
//***********************************************************************************
//СТАТУС: I.24, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(const PF_MATRIX& Info)
//НАЗНАЧЕНИЕ: Установка новых свойств вещественной матрицы по данным из структуры Info
//типа PF_MATRIX, передаваемой по ссылке. При невозможности создания матрицы с новыми
//свойствами функция возвращает false и матрица становится нулевой размерности.
//При создании квадратной матрицы (Info.type == SQUARE), размерность матрицы опреде-
//ляется полем Info.rows.
//При создании ленточной матрицы (Info.type == SQUARE && Info.subtype == RM_BAND)
//размерность матрицы определяется полем Info.rows, количество диагоналей - полем
//Info.cols.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const PF_MATRIX& Info - ссылка на структуру со свойствами создаваемой матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак создания матрицы с новыми свойствами
//***********************************************************************************
bool TRealMatrix::Set(const PF_MATRIX& Info)
{if (Info.type == RECTANG) //Создание прямоугольной матрицы
  return Set(Info.rows,Info.cols,true);
 else //Создание квадратной матрицы
  return Set(Info.rows, Info.subtype, Info.cols);
}
//***********************************************************************************
//СТАТУС: I.25, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Random(double a = 0.0, double b = 1.0)
//НАЗНАЧЕНИЕ: Инициализация элементов матрицы случайными величинами, распределенными
//по равновероятному закону в интервале [a..b]. Функция возвращает false для матрицы
//нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double a (0) - нижняя граница интервала изменения равномерной СВ
//2. double b (1) - верхняя граница интервала изменения равномерной СВ
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//***********************************************************************************
bool TRealMatrix::Random(double a, double b)
{//Матрица нулевого размера не инициализируется
 if (IsZeroSize()) return false;
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 //Инициализация элементов вектора СВ
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = RNG.Random(a, b);
 return true;
}
//***********************************************************************************
//СТАТУС: I.26, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Rand2PI()
//НАЗНАЧЕНИЕ: Инициализация элементов матрицы случайными величинами, распределенными
//по равновероятному закону в интервале [0..2PI]. Функция возвращает false для матрицы
//нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//***********************************************************************************
bool TRealMatrix::Rand2PI()
{//Матрица нулевого размера не инициализируется
 if (IsZeroSize() == 0L) return false;
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 //Инициализация элементов матрицы СВ
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = RNG.Rand2PI();
 return true;
}
//***********************************************************************************
//СТАТУС: I.27, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Gauss(double E = 0.0, double D = 1.0)
//НАЗНАЧЕНИЕ: Инициализация элементов матрицы случайными величинами, распределенными
//по нормальному закону с математическим ожиданием E и дисперсией D. Функция возвра-
//щает false для матрицы нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double E (0) - математическое ожидание гауссовой СВ
//2. double D (1) - дисперсия гауссовой СВ
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//***********************************************************************************
bool TRealMatrix::Gauss(double E, double D)
{//Матрица нулевого размера не инициализируется
 if (IsZeroSize() == 0L) return false;
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 //Инициализация элементов матрицы СВ
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++) data[i][j] = RNG.Gauss(E, D);
 return true;
}
//***********************************************************************************
//СТАТУС: I.28, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Relay()
//НАЗНАЧЕНИЕ: Инициализация элементов матрицы случайными величинами, распределенными
//по закону Рэлея. Функция возвращает false для матрицы нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//***********************************************************************************
bool TRealMatrix::Relay()
{//Матрица нулевого размера не инициализируется
 if (IsZeroSize() == 0L) return false;
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 //Инициализация элементов матрицы СВ
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = RNG.Relay();
 return true;
}
//***********************************************************************************
//СТАТУС: I.29, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Exp(double t = 1.0)
//НАЗНАЧЕНИЕ: Инициализация элементов матрицы случайными величинами, распределенными
//по экспоненциальному закону с параметром t. Функция возвращает false для матрицы
//нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: double t (1.0) - параметр экспоненциальной СВ
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//***********************************************************************************
bool TRealMatrix::Exp(double t)
{//Матрица нулевого размера не инициализируется
 if (IsZeroSize() == 0L) return false;
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 //Инициализация элементов матрицы СВ
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = RNG.Exp(t);
 return true;
}
//****************************************************************************************
//СТАТУС: I.30, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНОЕ РЕДАКТИРОВАНИЕ СВОЙСТВ и ЭЛЕМЕНТОВ МАТРИЦЫ
//Функция предназначена для ввода/редактирования ВСЕХ элементов матрицы, а также ее
//свойств в консольном режиме. В зависимости от типа действительной матрицы подключается
//функция ввода элементов для данной матрицы. Предусмотрен режим ввода элементов матрицы с
//подтверждением введенных данных по каждому элементу матрицы. Строка name задает
//наименование матрицы. При вводе каждого элемента матрицы предусматривается контроль
//корректности вводимых данных. При работе функции значения элементов матрицы изменяются
//безвозвратно. Формат ввода следующий:
//----------------------------------------------------------------------------------------
//MODE: EDIT MATRIX <name>
//TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//Select option:
//1. Change matrix properties;
//2. Edit matrix elements;
//3. Exit
//Enter number [1-3]: _
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование матрицы.
//2. bool confirm (true) - режим подтверждения введеных данных по каждому элементу
//   вещественной матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TRealMatrix::Edit(const string& name, bool confirm)
{const string line(78,'-');
 STR_UINT Option[3] = {
  {1, "Edit matrix properties" },
  {2, "Edit matrix elements" },
  {3, "Exit" } };
 TB_STR_UINT TbOption = {3, Option};
 string head;
 uint nChoice;
 do //Начало цикла редактирования
 {//---------------------------------------------------------------------------------
  //Вывод заголовка и свойств редактируемой матрицы
  clrscr(); //Очистка экрана
  cout << line << endl;
  cout << "MODE: EDIT REAL MATRIX - <" << name << ">" << endl;
  cout << "     " << Properties(head);
  cout << line << endl;
  //---------------------------------------------------------------------------------
  head.assign(" Select option: ");
  nChoice = ConsoleChoice(TbOption, 3, head.c_str(), 2);
  //Анализируем выбор пользователя
  if (nChoice == 1) //Изменение характеристик редактируемой матрицы
  {PF_MATRIX Info;
   InPutPF_RMATRIX(Info, name.c_str());
   Set(Info);
   cout << "New real matrix's properties have just installed!" << endl;
   cout << "Matrix is initialized according to its extended type." << endl;
   cout << "Press any key..."; getch();
  }
  else if (nChoice == 2) //Редактирование элементов матрицы
  {ulong diags;
   uint RM_Type = SubType(diags);
   clrscr(); //Очистка экрана
   switch (RM_Type)
   {case RM_ZEROSIZE: //Матрица нулевого размера
     cout << "\nMODE: INPUT ELEMENTS of ZeroSize Matrix" << endl;
     cout << "WARNING! Input elements of this matrix are impossible." << endl;
     cout << "Press any key...\a"; getch();
     break;
    case RM_DIAGONAL: //Ввод элементов диагональной матрицы
     InPutDiagonal(name,confirm);
     break;
    case RM_SCALAR: //Ввод элементов скалярной матрицы
     InPutScalar(name,confirm);
     break;
    case RM_BAND: //Ввод элементов ленточной матрицы
     InPutBand(diags,name,confirm);
     break;
    case RM_UTRIANG: //Ввод элементов верхней треугольной матрицы
     InPutUTriang(name,confirm);
     break;
    case RM_LTRIANG: //Ввод элементов нижней треугольной матрицы
     InPutLTriang(name,confirm);
     break;
    case RM_SYMMETRICAL: //Ввод элементов симметрической матрицы
     InPutSymmetric(name,confirm);
     break;
    case RM_SKEWSYMMETR: //Ввод элементов кососимметрической матрицы
     InPutSkewSymmetric(name,confirm);
     break;
    case RM_ALTSIGN: //Ввод элементов знакопеременной матрицы
     InPutAltSign(name,confirm);
     break;
    default: //Стандартный ввод элементов действительной матрицы
     InPutRealMatrix(name,confirm);
   }
  }
  else if (nChoice == 3) //Выход из режима редактирования
  {//Запрос на выход из режима редактирования
   char c;
   cout << "Would you like to finish matrix editing? [y/n]: "; cin >> c;
   if ((c == 'y') || (c == 'Y')) {clrscr(); break;}
  }
 } while (true); //Завершение цикла редактирования
}
//***********************************************************************************
//СТАТУС: I.31; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector Row(ulong index) const
//НАЗНАЧЕНИЕ: Получение строки матрицы с заданным индексом от 0 до Rows()-1.
//Если индекс строки матрицы некорректен, то функция возвращает вектор нулевого разме-
//ра. Функция возвращает вещественный вектор со следующими параметрами:
//size = Cols(); type = ROW.
//Корректные значения индекса строки: 0 <= index < Rows().
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong index - индекс копируемой строки матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector Row - строка матрицы с номером index
//***********************************************************************************
rvector TRealMatrix::Row(ulong index) const
{rvector Row(0L,ROW);
 if ((IsZeroSize()) || (index >= Rows())) return Row;
 //Формируем вектор Row с элементами строки матрицы с номером index
 Row.Resize(Cols());
 //Копирование значений элементов строки матрицы в вектор Row
 for (ulong j = 0; j < Cols(); j++) Row.Put(j,data[index][j]);
 return Row;
}
//***********************************************************************************
//СТАТУС: I.32; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Row(rvector& V, ulong index) const
//НАЗНАЧЕНИЕ: Получение строки матрицы с заданным индексом от 0 до Rows()-1.
//Строка матрицы с индексом index формируется в векторе V, передаваемом по ссылке.
//Если индекс строки матрицы некорректен или матрица нулевого размера, то функция воз-
//вращает false и вектор V становится вектором нулевого размера. Вектор V будет иметь
//следующие свойства: size = Cols(); type = ROW.
//Корректные значения индекса строки: 0 <= index < Rows().
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong index - индекс копируемой строки матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::Row(rvector& V, ulong index) const
{V.Resize(Cols()); V.SetType(ROW);
 if ((IsZeroSize()) || (index >= Rows())) return false;
 //Копирование значений элементов строки матрицы в вектор V
 for (ulong j = 0L; j < Cols(); j++) V.Put(j,data[index][j]);
 return true;
}
//***********************************************************************************
//СТАТУС: I.33; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector Col(ulong index) const
//НАЗНАЧЕНИЕ: Получение столбца матрицы с заданным индексом от 0 до Cols()-1.
//Если индекс столбца матрицы некорректен, то возвращается вектор-столбец нулевого
//размера. Функция возвращает вещественный вектор со следующими параметрами:
//size = Rows(); type = COL.
//Корректные значения индекса столбца: 0 <= index < Cols().
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong index - индекс копируемого столбца матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector Col - столбец матрицы с номером index
//***********************************************************************************
rvector TRealMatrix::Col(ulong index) const
{rvector Col(0L,COL);
 if ((IsZeroSize()) || (index >= Cols())) return Col;
  //Формируем вектор Col с элементами столбца матрицы с номером index
  Col.Resize(Rows());
  //Копирование значений элементов столбца матрицы в вектор Col
  for (ulong i = 0L; i < Rows(); i++) Col.Put(i,data[i][index]);
 return Col;
}
//***********************************************************************************
//СТАТУС: I.34; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Col(rvector& V, ulong index) const
//НАЗНАЧЕНИЕ: Получение столбца матрицы с заданным индексом от 0 до Cols()-1.
//Столбец матрицы с индексом index формируется в векторе V, передаваемом по ссылке.
//Если индекс столбца матрицы некорректен или матрица нулевого размера, то функция
//возвращает false и вектор V становится вектором нулевого размера.
//Вектор V будет иметь следующие свойства: size = Rows(); type = COL.
//Корректные значения индекса строки: 0 <= index < Cols().
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong index - индекс копируемого столбца матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::Col(rvector& V, ulong index) const
{V.Resize(Rows()); V.SetType(COL);
 if ((IsZeroSize()) || (index >= Cols())) return false;
 //Копирование значений элементов столбца матрицы в вектор V
 for (ulong i = 0L; i < Rows(); i++) V.Put(i,data[i][index]);
 return true;
}
//***********************************************************************************
//СТАТУС: I.35; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ExchangeRows(ulong i, ulong j)
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ДВУХ СТРОК МАТРИЦЫ
//Функция переставляет две строки матрицы с индексами от 0 до Rows()-1. Функция возв-
//ращает признак успешно или нет произошла перестановка двух строк. Функция изменяет
//элементы исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong i - индекс первой строки матрицы, которую необходимо переставить
//2. ulong j - индекс второй строки матрицы, которую необходимо переставить с
//   первой строкой.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool Success - признак выполнения операции перестановки
//***********************************************************************************
bool TRealMatrix::ExchangeRows(ulong i, ulong j)
{if ((IsZeroSize()) || (i >= Rows()) || (j >= Rows())) return false;
 //Проверка на совпадение индексов переставляемых строк
 if (i == j) return true;//Перестановка не требуется
 //Операция перестановки двух строк матрицы
 double x;
 for (ulong k = 0L; k < Cols(); k++)
 {x = data[i][k]; data[i][k] = data[j][k]; data[j][k] = x;}
 return true; //Перестановка двух строк выполнена
}
//***********************************************************************************
//СТАТУС: I.36; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ExchangeRows(const ivector& permutation)
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА СТРОК МАТРИЦЫ
//Функция переставляет строки матрицы согласно вектору перестановок permutation.
//Функция возвращает признак успешно или нет произошла перестановка строк. Функция
//изменяет элементы исходной матрицы. Вектор перестановок может быть больше или меньше
//числа строк матрицы. i-ый элемент вектора хранит индекс строки матрицы с которой
//необходимо совершить перестановку. Перестановка двух строк выполняется функцией
//ExchangeRows(i, permutation[i]), где i - индекс первой переставляемой строки,
//permutation[i] - индекс второй строки матрицы переставляемой с первой строкой.
//Если индексы переставляемых строк матрицы некорректны, то возвращается false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const ivector& permutation - ссылка на вектор перестановок строк матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool Success - признак выполнения операции перестановки
//***********************************************************************************
bool TRealMatrix::ExchangeRows(const ivector& permutation)
{if ((IsZeroSize()) || (permutation.IsZeroSize())) return false;
 //Операция перестановки строк матрицы по вектору перестановок
 bool lSuccess;
 ulong Count = (Rows() < permutation.Size()) ? Rows() : permutation.Size();
 for (ulong k = 0L; k < Count; k++)
 {lSuccess = ExchangeRows(k, permutation[k]);
  if (lSuccess == false) return lSuccess;
 }
 return lSuccess;//Перестановка строк выполнена успешно
}
//***********************************************************************************
//СТАТУС: I.37; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ExchangeCols(ulong i, ulong j)
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ДВУХ СТОЛБЦОВ МАТРИЦЫ
//Функция переставляет два столбца матрицы с индексами от 0 до Cols()-1. Возвращается
//признак успешно или нет произошла перестановка двух столбцов. Функция изменяет эле-
//менты исходной матрицы. Если индексы переставляемых столбцов матрицы некорректны,
//то возвращается false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong i - индекс первого столбца матрицы, который необходимо переставить
//2. ulong j - индекс второго столбца матрицы, который необходимо переставить с
//   первым столбцом.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool Success - признак выполнения операции перестановки
//***********************************************************************************
bool TRealMatrix::ExchangeCols(ulong i, ulong j)
{if ((IsZeroSize()) || (i >= Cols()) || (j >= Cols())) return false;
 //Проверка на совпадение индексов переставляемых столбцов
 if (i == j) return true;//Перестановка не требуется
 //Операция перестановки двух столбцов матрицы
 double x;
 for (ulong k = 0L; k < Rows(); k++)
 {x = data[k][i]; data[k][i] = data[k][j]; data[k][j] = x;}
 return true; //Перестановка двух столбцов выполнена
}
//***********************************************************************************
//СТАТУС: I.38; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ExchangeCols(const ivector& permutation)
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА СТОЛБЦОВ МАТРИЦЫ
//Функция переставляет столбцы матрицы согласно вектору перестановок permutation.
//Возвращается признак успешно или нет произошла перестановка столбцов. Функция изме-
//няет элементы исходной матрицы. Вектор перестановок может быть больше или меньше
//числа столбцов матрицы. i-ый элемент вектора хранит индекс столбца матрицы с кото-
//рым необходимо совершить перестановку. Перестановка пары столбцов выполняется функ-
//цией ExchangeCols(i,permutation[i]), где i - индекс первой переставляемого столбца,
//permutation[i] - индекс второго столбца матрицы переставляемой с первым столбцом.
//Если индексы переставляемых столбцов матрицы некорректны, то возвращается false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const ivector& permutation - ссылка на вектор перестановок столбцов матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool Success - признак выполнения операции перестановки
//***********************************************************************************
bool TRealMatrix::ExchangeCols(const ivector& permutation)
{if ((IsZeroSize()) || (permutation.IsZeroSize())) return false;
 bool lSuccess;
 //Операция перестановки столбцов матрицы по вектору перестановок
 ulong Count = (Cols() < permutation.Size()) ? Cols() : permutation.Size();
 for (ulong k = 0L; k < Count; k++)
 {lSuccess = ExchangeCols(k, permutation[k]);
  if (lSuccess == false) return lSuccess;
 }
 return lSuccess; //Перестановка столбцов выполнена
}
//***********************************************************************************
//СТАТУС: I.39; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix U_SubMatrix(ulong k, ulong g) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ КВАДРАТНОЙ ПОДМАТРИЦЫ
//Функция формирует квадратную подматрицу из исходной матрицы следующего вида:
//SubMatrix(0 1 ... k-1 k, 0 1 ... k-1 g), где
// 0 1 ... k-1 k - строки исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы;
// 0 1 ... k-1 g - столбцы исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы, g > k.
//Подматрица формируется из элементов, стоящих на пересечении строк и столбцов, кото-
//рые принадлежат вышеуказанному множеству столбцов и строк, исходной матрицы. Функ-
//ция возвращает сформированную подматрицу.
//Верхние границы строк k и столбцов g исходной матрицы, которые участвуют в формиро-
//вании элементов подматрицы входят в данное допустимое множество. Нумерация строк и
//столбцов начинается с 0.
//Если индексы столбцов и строк из которых будет формироваться подматрица будут некор-
//ректны, то возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong k - верхняя граница строк матрицы, участвующих в формировании подматрицы;
//2. ulong g - верхняя граница столбцов матрицы, участвующих в формировании подматрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix SubMatrix - квадратная подматрица
//***********************************************************************************
rmatrix TRealMatrix::U_SubMatrix(ulong k, ulong g) const
{rmatrix SubMatrix;
 //Проверка исходной матрицы на матрицу нулевого размера
 if (IsZeroSize()) return SubMatrix;
 //Проверка на допустимые индексы k & g, 0 <= k < Rows(), k < g < Cols()
 if ((k >= Rows()) || (g <= k) || (g >= Cols())) return SubMatrix;
 //----------------------------------------------------------------------------------
 //Формирование подматрицы
 //----------------------------------------------------------------------------------
 SubMatrix.Set(k+1,false);
 //Цикл формирования элементов подматрицы
 //Rows: 0 1 ... k-1 k; Cols: 0 1 ... k-1 g
 for (ulong i = 0L; i < Rows(); i++)
 {if (i > k) break; //Выход из цикла - подматрица сформирована
  for (ulong j = 0L; j < Cols(); j++)
  {if (j < k) SubMatrix.Put(i,j,data[i][j]);
   //Формирование последнего столбца подматрицы
   else {SubMatrix.Put(i,k,data[i][g]); break;}
  }
 }
 return SubMatrix;//Квадратная подматрица
}
//***********************************************************************************
//СТАТУС: I.40; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix L_SubMatrix(ulong g, ulong k) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ КВАДРАТНОЙ ПОДМАТРИЦЫ
//Функция формирует квадратную подматрицу из исходной матрицы следующего вида:
//SubMatrix(0 1 ... k-1 g, 0 1 ... k-1 k), где
// 0 1 ... k-1 g - строки исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы;
// 0 1 ... k-1 k - столбцы исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы, g > k.
//Подматрица формируется из элементов, стоящих на пересечении строк и столбцов, кото-
//рые принадлежат вышеуказанному множеству столбцов и строк, исходной матрицы. Функ-
//ция возвращает сформированную подматрицу.
//Верхние границы строк g и столбцов k исходной матрицы, которые участвуют в формиро-
//вании элементов подматрицы входят в данное допустимое множество. Нумерация строк и
//столбцов начинается с 0.
//Если индексы столбцов и строк из которых будет формироваться подматрица некорректны,
//то возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong g - верхняя граница строк матрицы, участвующих в формировании подматрицы;
//2. ulong k - верхняя граница столбцов матрицы, участвующих в формировании подматрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix SubMatrix - квадратная подматрица
//***********************************************************************************
rmatrix TRealMatrix::L_SubMatrix(ulong g, ulong k) const
{rmatrix SubMatrix;
 //Проверка исходной матрицы на матрицу нулевого размера
 if (IsZeroSize()) return SubMatrix;
 //Проверка на допустимые индексы k & g, 0 < g < Rows(), 0 <= k < g, k < Cols()
 if ((k >= Cols()) || (g <= k) || (g >= Rows())) return SubMatrix;
 //----------------------------------------------------------------------------------
 //Формирование подматрицы
 //----------------------------------------------------------------------------------
 SubMatrix.Set(k+1,false);
 //Цикл формирования элементов подматрицы
 //Rows: 0 1 ... k-1 g; Cols: 0 1 ... k-1 k
 for (ulong i = 0L; i < Rows(); i++)
 {if (i == k) i = g;//Формирование последней строки матрицы
  for (ulong j = 0L; j <= k ; j++)
  {if (i != g) SubMatrix.Put(i,j,data[i][j]);
   else SubMatrix.Put(k,j,data[i][j]);
  }
  if (i == g) break;//Выход из цикла - подматрица сформирована
 }
 return SubMatrix;//Квадратная подматрица
}
//***********************************************************************************
//СТАТУС: I.41; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix P_SubMatrix(ulong k) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ КВАДРАТНОЙ ПОДМАТРИЦЫ
//Функция формирует квадратную подматрицу из исходной матрицы следующего вида:
//SubMatrix(0 1 ... k-1 k, 0 1 ... k-1 k), где
// 0 1 ... k-1 k - строки исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы;
// 0 1 ... k-1 k - столбцы исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы.
//Подматрица формируется из элементов, стоящих на пересечении первых k строк и первых
//k столбцов - ГЛАВНЫЕ ПОДМАТРИЦЫ. Функция возвращает сформированную подматрицу.
//Верхние границы строк k и столбцов k исходной матрицы, которые участвуют в формиро-
//вании элементов подматрицы входят в данное допустимое множество. Нумерация строк и
//столбцов начинается с 0.
//Если индексы столбцов и строк из которых будет формироваться подматрица некорректны,
//то возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//ulong k - верхняя граница строк и столбцов матрицы, формирующих подматрицу
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix SubMatrix - главная подматрица k-го порядка
//***********************************************************************************
rmatrix TRealMatrix::P_SubMatrix(ulong k) const
{rmatrix SubMatrix;
 //Проверка исходной матрицы на матрицу нулевого размера
 if (IsZeroSize()) return SubMatrix;
 //Проверка на допустимость индекса k, 0 <= k < Rows(), 0 <= k < Cols()
 if ((k >= Cols()) || (k >= Rows())) return SubMatrix;
 //----------------------------------------------------------------------------------
 //Формирование главной подматрицы
 //----------------------------------------------------------------------------------
 SubMatrix.Set(k+1,false);
 //Цикл формирования элементов подматрицы
 //Rows: 0 1 ... k-1 k; Cols: 0 1 ... k-1 k
 for (ulong i = 0L; i <= k; i++)
  for (ulong j = 0L; j <= k ; j++)
   SubMatrix.Put(i,j,data[i][j]);
 return SubMatrix;//Квадратная подматрица
}
//***********************************************************************************
//СТАТУС: I.42; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rmatrix SubMatrixByCols(const ivector& IndexCols, bool Check = false) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДМАТРИЦЫ ПО ИНДЕКСАМ СТОЛБЦОВ ИСХОДНОЙ МАТРИЦЫ
//Количество  строк подматрицы определяется количеством строк исходной матрицы.
//Переменная Check - это опция проверки на принадлежность номеров индексов в векторе
//IndexCols допустимым значениям индексов столбцов исходной матрицы. При проверке фор-
//мируется объект-предикат типа TBelongClosedInterval, проверяющий каждое значение
//индекса столбца на допустимость и на основе его работы формируется подвектор вектора
//IndexCols с корректными значениями индексов столбцов. Если Check == false, то про-
//верка не проводится, что ускоряет работу функции, но ответственность за корректные
//значения индексов столбцов возлагается на пользователя.
//Функция может вернуть подматрицу нулевого размера в следующих случаях:
//1. Исходная матрица является матрицей нулевого размера;
//2. Вектор индексов столбцов является вектором нулевого размера;
//3. При Check == true, подвектор вектора IndexCols оказался вектором нулевого размера
//   - все индексы столбцов находятся вне границ размерности матрицы по столбцам.
//Возможно аварийное завершение работы программы при Check == false, если индекс
//столбца в векторе IndexCols является некорректным.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& IndexCols - ссылка на вектор с индексами столбцов исходной матрицы;
//2. bool Check (false) - индикатор проверки значений индексов столбцов в векторе
//   IndexCols на корректность
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rmatrix SubMatrix - подматрица, формируемая из столбцов исходной матрицы, индексы
//которых размещены в векторе IndexCols.
//***********************************************************************************
rmatrix TRealMatrix::SubMatrixByCols(const ivector& IndexCols, bool Check) const
{rmatrix SubMatrix;
 //Проверка исходной матрицы и вектора с индексами столбцов на нулевой размер
 if (IsZeroSize() || IndexCols.IsZeroSize()) return SubMatrix;
 //Формирование вектора корректных индексов столбцов для исходной матрицы
 ivector Index = IndexCols;
 if (Check)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Cols()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  if (Index.IsZeroSize()) return SubMatrix;
 }
 //----------------------------------------------------------------------------------
 //Формирование подматрицы с индексами столбцов исходной матрицы, размещенных
 //в векторе Index, и количеством строк равным их числу исходной матрицы
 SubMatrix.Set(Rows(),Index.Size(),false);
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Index.Size(); j++)
   SubMatrix.Put(i,j,data[i][Index.Get(j)]);
 return SubMatrix; //Подматрица, составленная из столбцов исходной матрицы
}
//***********************************************************************************
//СТАТУС: I.43; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rmatrix SubMatrixByRows(const ivector& IndexRows, bool Check = false) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДМАТРИЦЫ ПО ИНДЕКСАМ СТРОК ИСХОДНОЙ МАТРИЦЫ
//Количество столбцов подматрицы определяется количеством столбцов исходной матрицы.
//Check - опция проверки на принадлежность номеров индексов в векторе IndexCols допу-
//стимым значениям индексов строк исходной матрицы. При проверке формируется объект-
//предикат типа TBelongClosedInterval<long,ivector>, проверяющий все значения индек-
//сов строки на допустимость и на основе его работы формируется подвектор вектора
//IndexRows с корректными значениями индексов строк. Если Check == false, то проверка
//не проводится, что ускоряет работу, но ответственность за корректные значения индек-
//сов строк возлагается на пользователя.
//Функция может вернуть подматрицу нулевого размера в следующих случаях:
//1. Исходная матрица является матрицей нулевого размера;
//2. Вектор индексов строк является вектором нулевого размера;
//3. При Check == true, подвектор вектора IndexRows оказался вектором нулевого размера
//  - все индексы строк находятся вне границ размерности матрицы по строкам.
//Возможно аварийное завершение работы программы при Check == false, если индекс строки
//в векторе IndexRows является некорректным.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& IndexRows - ссылка на вектор с индексами строк исходной матрицы;
//2. bool Check (false) - индикатор проверки значений индексов строк в векторе
//  IndexRows на корректность
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rmatrix SubMatrix - подматрица, формируемая из строк исходной матрицы, индексы ко-
//торых размещены в векторе IndexRows.
//***********************************************************************************
rmatrix TRealMatrix::SubMatrixByRows(const ivector& IndexRows, bool Check) const
{rmatrix SubMatrix;
 //Проверка исходной матрицы и вектора с индексами строк на нулевой размер
 if (IsZeroSize() || IndexRows.IsZeroSize()) return SubMatrix;
 //Формирование вектора корректных индексов строк для исходной матрицы
 ivector Index = IndexRows;
 if (Check)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Rows()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  if (Index.IsZeroSize()) return SubMatrix;
 }
 //----------------------------------------------------------------------------------
 //Формирование подматрицы с индексами строк исходной матрицы, размещенных в векторе
 //Index, и количеством столбцов равным числу столбцов исходной матрицы
 SubMatrix.Set(Index.Size(),Cols(),false);
 for (ulong i = 0L; i < Index.Size(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   SubMatrix.Put(i,j,data[Index.Get(i)][j]);
 return SubMatrix; //Подматрица, составленная из строк исходной матрицы
}
//***********************************************************************************
//СТАТУС: I.44; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rmatrix SubMatrix(const ivector& IndexRows, const ivector& IndexRows,
//                   bool Check = false) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДМАТРИЦЫ ПО ИНДЕКСАМ СТРОК И СТОЛБЦОВ ИСХОДНОЙ
//МАТРИЦЫ, передавемым через векторы IndexRows и IndexCols. Размерность подматрицы
//определяется по строкам - размерностью вектора IndexRows, по столбцам - размерностью
//вектора IndexCols. Переменная Check - опция проверки на принадлежность номеров индек-
//сов в векторах IndexRows и IndexCols допустимым значениям индексов строк и столбцов
//исходной матрицы. При проверке формируются объекты-предикаты типа TBelongClosedInter-
//val, проверяющие каждое значение индекса строки и столбца на допустимость и на основе
//их работы формируется подвекторы векторов IndexRows и IndexCols с корректными зна-
//чениями индексов строк и столбцов. При Check == false то проверка не проводится, что
//ускоряет работу, но ответственность за корректные значения индексов строк и столбцов
//возлагается на пользователя. Фильтрация некорректных значений индексов столбцов и
//строк может привести к уменьшению размеров исходных векторов IndexRows и IndexCols
//либо привести их к вектору нулевого размера, при отсутствии в них корректных значе-
//ний индексов. Функция может вернуть подматрицу нулевого размера в следующих случаях:
//1. Исходная матрица является матрицей нулевого размера;
//2. Вектор индексов строк или столбцов является вектором нулевого размера;
//3. При Check == true, подвектор вектора IndexRows или IndexCols оказались векторами
//   нулевого размера - все индексы строк или столбцов находятся вне границ размерности
//   матрицы по строкам или по столбцам.
//Возможно аварийное завершение работы программы при Check == false, если индекс строки
//или столбца в векторе IndexRows или IndexCols является некорректным.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& IndexRows - ссылка на вектор с индексами строк исходной матрицы;
//2. const ivector& IndexCols - ссылка на вектор с индексами столбцов исходной матрицы;
//3. bool Check (false) - индикатор проверки значений индексов строк и столбцов в век-
//   торах IndexRows и IndexCols на корректность
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rmatrix SubMatrix - подматрица, формируемая из строк и столбцов исходной матрицы,
//индексы которых размещены в векторах IndexRows и IndexCols.
//***********************************************************************************
rmatrix TRealMatrix::SubMatrix(const ivector& IndexRows, const ivector& IndexCols,
        bool Check) const
{rmatrix SubMatrix;
 //Проверка исходной матрицы и векторов с индексами строк и столбцов на нулевой размер
 if (IsZeroSize() || IndexRows.IsZeroSize() || IndexCols.IsZeroSize())
  return SubMatrix;
 //Формирование вектора корректных индексов строк для исходной матрицы
 ivector Row = IndexRows;
 if (Check)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Rows()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Row = Row.SubVector(Predicate);
  if (Row.IsZeroSize()) return SubMatrix;
 }
 //Формирование вектора корректных индексов столбцов для исходной матрицы
 ivector Col = IndexCols;
 if (Check)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Cols()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Col = Col.SubVector(Predicate);
  if (Col.IsZeroSize()) return SubMatrix;
 }
 //----------------------------------------------------------------------------------
 //Формирование подматрицы с индексами строк и столбцов исходной матрицы, размещенных
 //в векторах Row и Col
 SubMatrix.Set(Row.Size(),Col.Size(),false);
 //Цикл формирования значений элементов подматрицы SubMatrix
 for (ulong i = 0L; i < Row.Size(); i++)
  for (ulong j = 0L; j < Col.Size(); j++)
   SubMatrix.Put(i,j,data[Row.Get(i)][Col.Get(j)]);
 return SubMatrix;//Подматрица, составленная из строк и столбцов исходной матрицы
}
//***********************************************************************************
//СТАТУС: I.45, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rmatrix ReverseByCol(ulong left = 0L, ulong right = MAX_SIZE) const
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ЭЛЕМЕНТОВ МАТРИЦЫ В ЗАДАННОМ ИНТЕРВАЛЕ СТОЛБЦОВ В ОБРАТНОМ
//ПОРЯДКЕ ПО СТОЛБЦАМ
//Функция изменяет порядок следования элементов матрицы по столбцам в интервале от ин-
//декса столбца со значением left до индекса столбца со значением right (включая его)
//на обратный.
//Значения верхней и нижней границ интервала столбцов, в которой должна осуществляться
//обратная перестановка должны удовлетворять следующим условиям:
// left <= right && right < Cols(), в противном случае функция не выполняется.
//По умолчанию, осуществляется перестановка всех элементов матрицы по всем столбцам.
//Функция не изменяет внутренную структуру исходной матрицы, так как функция работает
//с ее копией. Результат работы функции - матрица, совпадающая по размерам с исходной,
//но с переставленными в обратном порядке элементами по столбцам.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left (0) - нижний индекс столбца, с которого будет происходить перестановка
//   элементов матрицы в обратном порядке;
//2. ulong right (MAX_SIZE ~ Size()-1) - верхний индекс столбца матрицы, до которого
//   будет происходить перестановка элементов вектора в обратном порядке, включая
//   значение индекса right.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rmatrix result - матрица с переставленными в обратном порядке столбцами относительно
//исходной матрицы элементами.
//***********************************************************************************
rmatrix TRealMatrix::ReverseByCol(ulong left, ulong right) const
{rmatrix result;//Создание результирующей матрицы
 right = (right == MAX_SIZE) ? Cols()-1 : right;
 //Проверка на возможность или необходимость осуществления перестановки
 if ((Cols() < 2) || (left >= right) || (right >= Cols())) return result;
 //Выполнение перестановки элементов матрицы по столбцам в обратном порядке
 result = *this;//Копирование исходной матрицы
 ulong r = right;
 ulong l = left;
 double temp;
 for (ulong i = 0; i < result.Rows(); i++)
 {while (l < r)
  {temp = result.Get(i,l); result.Put(i,l,result.Get(i,r)); result.Put(i,r,temp);
   l++; r--; //Переход к другим индексам переставляемых элементов
  }
  r = right; l = left;
 }
 return result;//Матрица с переставленными в обратном порядке элементами
}
//***********************************************************************************
//СТАТУС: I.46, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rmatrix ReverseByRow(ulong left = 0L, ulong right = MAX_SIZE) const;
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ЭЛЕМЕНТОВ МАТРИЦЫ В ЗАДАННОМ ИНТЕРВАЛЕ СТРОК В ОБРАТНОМ
//ПОРЯДКЕ ПО СТРОКАМ
//Функция изменяет порядок следования элементов матрицы по строкам в интервале от ин-
//декса строки со значением left до индекса строки со значением right (включая его)
//на обратный.
//Значения верхней и нижней границ интервала строк, в которой должна выполняться обрат-
//ная перестановка должны удовлетворять следующим условиям:
// left <= right && right < Cols(), в противном случае функция не выполняется.
//По умолчанию, осуществляется перестановка всех элементов матрицы по всем строкам.
//Функция не изменяет внутренней структуры исходной матрицы, так как функция работает
//с ее копией. Результат работы функции - матрица, совпадающая по размерам с исходной,
//но с переставленными в обратном порядке элементами по строкам.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left (0) - нижний индекс строки, с которого будет происходить перестановка
//   элементов матрицы в обратном порядке;
//2. ulong right (MAX_SIZE ~ Size()-1) - верхний индекс строки матрицы, до которого
//   будет происходить перестановка элементов вектора в обратном порядке, включая
//   значение индекса right.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rmatrix result - матрица с переставленными в обратном порядке по строкам относительно
//исходной матрицы элементами.
//***********************************************************************************
rmatrix TRealMatrix::ReverseByRow(ulong left, ulong right) const
{rmatrix result;//Создание результирующей матрицы
 right = (right == MAX_SIZE) ? Rows()-1 : right;
 //Проверка на возможность или необходимость осуществления перестановки
 if ((Rows() < 2) || (left >= right) || (right >= Rows())) return result;
 //Выполнение перестановки элементов матрицы по строкам в обратном порядке
 result = *this;//Копирование исходной матрицы
 ulong r = right;
 ulong l = left;
 double temp;
 for (ulong i = 0; i < result.Cols(); i++)
 {while (l < r)
  {temp = result.Get(l,i); result.Put(l,i,result.Get(r,i)); result.Put(r,i,temp);
   l++; r--; //Переход к другим индексам переставляемых элементов
  }
  r = right; l = left;
 }
 return result;//Матрица с переставленными в обратном порядке элементами
}
//***********************************************************************************
//СТАТУС: I.47, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ReverseCols()
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ВСЕХ СТОЛБЦОВ МАТРИЦЫ В ОБРАТНОМ ПОРЯДКЕ
//Функция изменяет внутренную структуры исходной матрицы. Если матрица нулевого раз-
//мера, то функция возвращает false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения функции
//***********************************************************************************
bool TRealMatrix::ReverseCols()
{if (IsZeroSize()) return false;
 ulong r = Cols()-1;
 ulong l = 0L;
 double temp;
 for (ulong i = 0; i < Rows(); i++)
 {while (l < r)
  {temp = data[i][l]; data[i][l] = data[i][r]; data[i][r] = temp;
   l++; r--; //Переход к другим индексам переставляемых элементов
  }
  r = Cols()-1; l = 0L;
 }
 return true;//Обратная перестановка элементов матрицы по столбцам завершена
}
//***********************************************************************************
//СТАТУС: I.48, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ReverseRows()
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ВСЕХ СТРОК МАТРИЦЫ В ОБРАТНОМ ПОРЯДКЕ
//Функция изменяет внутренную структуры исходной матрицы. Если матрица нулевого раз-
//мера, то функция возвращает false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения функции
//***********************************************************************************
bool TRealMatrix::ReverseRows()
{if (IsZeroSize()) return false;
 ulong up = 0L;
 ulong down = Rows()-1;
 double temp;
 for (ulong j = 0L; j < Cols(); j++)
 {while (up < down)
  {temp = data[up][j]; data[up][j] = data[down][j]; data[down][j] = temp;
   up++; down--; //Переход к другим индексам переставляемых элементов
  }
  up = 0L; down = Rows()-1;
 }
 return true;//Обратная перестановка элементов матрицы по строкам завершена
}
//****************************************************************************************
//СТАТУС: I.48, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: Rotate(rmatrix& A, bool clockwise = true) const
//НАЗНАЧЕНИЕ: Поворот элементов матрицы на 90 градусов по или против часовой стрелки.
//Исходная матрица остается без изменений, изменения происходят в матрице A, передаваемой
//по ссылке. Переменная clockwise показывает направление вращения: true - по часовой стрелке,
//false - против часовой стрелки.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& A - ссылка на результирующую матрицу;
//2. bool clockwise (true) - направление поворота.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения функции
//****************************************************************************************
bool TRealMatrix::Rotate(rmatrix& A, bool clockwise) const
{if (this == &A || IsZeroSize()) return false;
 A.Set(Cols(),Rows(),false);
 if (A.IsZeroSize()) return false;
 if (clockwise) //Поворот по часовой стрелке на 90 градусов
 {ulong MAX_ROW = Rows()-1;
  for (ulong j = 0; j < Cols(); j++)
   for (ulong i = 0; i < Rows(); i++)
    A.Put(j,MAX_ROW-i,Get(i,j));
 }
 else //Поворот против часовой стрелки на 90 градусов
 {ulong MAX_COL = Cols()-1;
  for (ulong j = 0; j < Cols(); j++)
   for (ulong i = 0; i < Rows(); i++)
    A.Put(MAX_COL-j,i,Get(i,j));
 }
 return true;
}
//***********************************************************************************
//СТАТУС: I.49, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rmatrix AssignRow(const rvector& V, ulong row, ulong pos = 0L) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТРОКЕ МАТРИЦЫ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Присваивание строке исходной матрицы с индексом row, начиная со столбца с индексом
//pos, элементов вектора V, передавемого по ссылке. По умолчанию индекс первого столб-
//ца, с которого начинается присваивание, равен 0. Вектор V может иметь любую размер-
//ность. Функция присваивает значения элементов вектора V копии исходной матрицы, на-
//чиная с первого элемента вектора V, до последнего элемента вектора V или последнего
//столбца матрицы, в зависимости от соотношения начального индекса столбца pos матри-
//цы, с которого начинается присваивание, размеров матрицы и вектора V.
//   Значения элементов исходной матрицы и его структура не изменяются в результате
//работы данной функции, так как все необходимые операции присваивания осуществляются
//с копией исходной матрицы, которая и является результатом работы функции.
//Функция возвращает результирующую матрицу нулевого размера в следующих исключитель-
//ных ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Номер строки row превышает количество строк для данной матрицы;
//4. Начальный  индекс столбца pos в исходной матрице, начиная с которого выпол-
//   няется присваивание, превышает количество столбцов исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка  на вектор-источник, значения  элементов которого
//   будут присваиваться строке исходной матрицы;
//2. ulong row - номер строки матрицы, которой будут присваиваться элементы
//   вектора V;
//3. ulong pos - начальный индекс столбца матрицы, с которого начнется  присваи-
//   вание значений элементов вектора V строке c номером row матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - результирующая матрица
//***********************************************************************************
rmatrix TRealMatrix::AssignRow(const rvector& V, ulong row, ulong pos) const
{rmatrix result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (row >= Rows()) || (pos >= Cols()))
  return result;
 result = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора строке матрицы
 ulong col;
 for (ulong i = 0L; i < V.Size(); i++)
 {col = i+pos;
  if (col < result.Cols()) result.Put(row,col,V.Get(i));
  else break; //Выход из цикла
 }
 return result;
}
//***********************************************************************************
//СТАТУС: I.50, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rmatrix AssignRow(const rvector& V, ulong left, ulong right, ulong pos) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТРОКАМ МАТРИЦЫ ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА,
//            ИНДЕКСЫ КОТОРЫХ ПРИНАДЛЕЖАТ ИНТЕРВАЛУ [left..right]
//Присваивание строкам исходной матрицы с индексами в интервале [left..right], начи-
//ная со столбца с индексом pos, элементов вектора V, передавемого по ссылке. Вектор
//V может иметь любую размерность. Функция присваивает значения элементов вектора V
//копии исходной матрицы, начиная с первого элемента вектора V, вплоть до последнего
//элемента вектора V или последнего столбца матрицы, в зависимости от соотношения на-
//чального индекса столбца pos матрицы, с которого начинается присваивание, размеров
//матрицы и вектора V.
//Значения элементов исходной матрицы и его структура не изменяются функцией, все опе-
//рации присваивания происходят с копией исходной матрицы, которая является результа-
//том работы функции.
//Функция возвращает матрицу нулевого размера в следующих исключительных ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Граничные индексы left или right строк превышают количество строк исходной
//   матрицы или left > right;
//4. Начальный  индекс столбца pos в исходной матрице, начиная с которого выполняется
//   присваивание, превышает количество столбцов исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на вектор-источник, элементы которого присваиваются
//   строкам исходной матрицы;
//2. ulong left - нижняя граница интервала индексов строк матрицы, которым присваивают-
//   ся элементы вектора V;
//3. ulong right - верхняя граница интервала индексов строк матрицы, которым присваи-
//   ваются элементы вектора V;
//4. ulong pos - начальный индекс столбца матрицы, с которого начнется присваивание
//   элементов вектора V строкам матрицы, принадлежащим интервалу [left..right];
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - результирующая матрица
//***********************************************************************************
rmatrix TRealMatrix::AssignRow(const rvector& V, ulong left, ulong right,
                               ulong pos) const
{rmatrix result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (pos >= Cols())) return result;
 right = (right == MAX_SIZE) ? Rows()-1 : right;
 if ((right >= Rows()) || (left > right)) return result;
 result = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора строкам матрицы
 ulong col;
 for (ulong row = left; row <= right; row++)
 {for (ulong i = 0L; i < V.Size(); i++)
  {col = i+pos;
   if (col < result.Cols()) result.Put(row,col,V.Get(i));
   else break; //Выход из цикла по столбцам матрицы
  }
 }
return result;
}
//***********************************************************************************
//СТАТУС: I.51, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//rmatrix AssignRow(const rvector& V, const ivector& rows, ulong pos = 0) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТРОКАМ МАТРИЦЫ ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА, ИНДЕКСЫ
//КОТОРЫХ ПЕРЕДАЮТСЯ ВЕКТОРОМ rows
//Присваивание строкам исходной матрицы с индексами, расположенными в векторе rows,
//начиная со столбца с индексом pos, элементов вектора V, передавемого по ссылке. По
//умолчанию индекс столбца pos, с которого начинается присваивание, равен 0. Вектор V
//может иметь любую размерность. Функция присваивает значения элементов вектора V ко-
//пии исходной матрицы, начиная с первого до последнего элемента вектора V или послед-
//него столбца матрицы, в зависимости от соотношения начального индекса столбца pos
//матрицы, с которого начинается присваивание, размеров матрицы и вектора V.
//Вектор rows, передаваемый по ссылке, содержит индексы строк, которым присваиваются
//значения элементов вектора V. Перед выполнением операции присваивания индексы строк,
//хранимые в векторе rows, фильтруются. Из элементов вектора rows формируется его под-
//вектор Index, который не содержит повторяющихся индексов строк и индексов, значения
//которых превышают количество строк исходной матрицы.
//Исходная матрицы не изменяется функцией, все операции присваивания происходят с ко-
//пией исходной матрицы, которая является результатом работы функции.
//Функция возвращает матрицу нулевого размера в следующих исключительных ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Вектор-индексов строк rows - вектор нулевого размера;
//4. Подвектор Index - нулевого размера - корректные значения индексов строк для
//   данной исходной матрицы в векторе-индексов строк rows не найдены;
//5. Начальный  индекс столбца pos в исходной матрице, начиная с которого выполняется
//   присваивание, превышает количество столбцов исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка  на вектор-источник, элементы которого присваиваются
//   строкам исходной матрицы;
//2. const ivector& rows - ссылка на вектор с индексами строк, которым присваиваются
//   значения элементов вектора V;
//3. ulong pos - начальный индекс столбца матрицы, с которого начинется присваивание
//   значений элементов вектора V строкам матрицы, индексы которых расположены в век-
//   торе rows;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - результирующая матрица
//***********************************************************************************
rmatrix TRealMatrix::AssignRow(const rvector& V, const ivector& rows, ulong pos) const
{rmatrix result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (rows.IsZeroSize()) ||
     (pos >= Cols())) return result;
 //Формирование вектора корректных индексов строк для исходной матрицы
 ivector Index = rows;
 ivector interval(2,0L);
 interval[0] = 0; interval[1] = Rows()-1;
 TBelongClosedInterval<long, ivector> Predicate =
 TBelongClosedInterval<long,ivector>(interval);
 Index = Index.SubVector(Predicate);
 Index = Index.Unique();//Фильтрация повторяющихся индексов строк
 if (Index.IsZeroSize()) return result;//Корректные индексы строк не найдены

 result = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора строкам матрицы
 ulong col;
 for (ulong i = 0L; i < Index.Size(); i++)
 {for (ulong j = 0L; j < V.Size(); j++)
  {col = j+pos;
   if (col < result.Cols()) result.Put(Index.Get(i),col,V.Get(j));
   else break; //Выход из цикла по столбцам матрицы
  }
 }
return result;
}
//***********************************************************************************
//СТАТУС: I.52, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rmatrix AssignCol(const rvector& V, ulong col, ulong pos = 0L) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТОЛБЦУ МАТРИЦЫ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Присваивание столбцу исходной матрицы с индексом col, начиная со строки с индексом
//pos, элементов вектора V, передавемого по ссылке. По умолчанию, индекс первой строки,
//с которой начинается присваивание, равен 0. Вектор V может иметь любую размерность.
//Функция присваивает значения элементов  вектора V копии исходной матрицы, начиная с
//первого элемента вектора V, вплоть до последнего элемента вектора V или последней
//строки матрицы, в зависимости от соотношения начального индекса строки pos матрицы,
//с которой начинается присваивание, размеров матрицы и вектора V.
//Значения элементов исходной матрицы и его структура не изменяются функцией, все опе-
//рации присваивания происходят с копией исходной матрицы, которая является результа-
//том работы функции.
//Функция возвращает матрицу нулевого размера в следующих ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Номер столбца col превышает количество столбцов для данной матрицы;
//4. Начальный  индекс строки pos в исходной матрице, начиная с которого выполняется
//   присваивание, превышает количество строк исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка  на вектор-источник, значения которого присваиваются
//   столбцу исходной матрицы;
//2. ulong col - номер столбца матрицы, которому присваиваются элементы вектора V;
//3. ulong pos - начальный индекс строки матрицы, с которой начнется присваивание
//   значений элементов вектора V столбцу c номером col матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - результирующая матрица
//***********************************************************************************
rmatrix TRealMatrix::AssignCol(const rvector& V, ulong col, ulong pos) const
{rmatrix result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (col >= Cols()) || (pos >= Rows()))
  return result;
 result = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора столбцу матрицы
 ulong row;
 for (ulong i = 0L; i < V.Size(); i++)
 {row = i+pos;
  if (row < result.Rows()) result.Put(row,col,V.Get(i));
  else break; //Выход из цикла
 }
 return result;
}
//***********************************************************************************
//СТАТУС: I.53, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rmatrix AssignCol(const rvector& V, ulong left = 0L, ulong right = MAX_SIZE,
//                   ulong pos = 0L) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТОЛБЦАМ МАТРИЦЫ ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА, ИНДЕКСЫ
//КОТОРЫХ ПРИНАДЛЕЖАТ ИНТЕРВАЛУ [left..right]
//Функция присваивает столбцам исходной матрицы с индексами в интервале [left..right],
//начиная со строки с индексом pos, элементов вектора V, передавемого по ссылке. По
//умолчанию индекс строки pos, с которого начинается присваивание, равен 0. По умолча-
//нию, элементы вектора V присваиваются всем столбцам матрицы. Вектор V может иметь
//любую размерность. Функция присваивает значения элементов вектора V копии исходной
//матрицы, начиная с первого элемента вектора V, вплоть до последнего элемента вектора
//V или последней строки матрицы, в зависимости от соотношения начального индекса
//строки pos матрицы, с которой начинается присваивание, размеров матрицы и вектора V.
//Значения элементов исходной матрицы и его структура не изменяются функцией, все опе-
//рации присваивания происходят с копией исходной матрицы, которая является результа-
//том ее работы.
//Функция возвращает матрицу нулевого размера в следующих ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Граничные индексы left или right столбцов превышают количество столбцов исходной
//   матрицы или left > right;
//4. Начальный  индекс  строки  pos в исходной матрице, начиная с которой выполняется
//   присваивание, превышает количество строк исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на вектор-источник, значения которого присваиваются
//   строкам исходной матрицы;
//2. ulong left -  нижняя граница интервала индексов столбцов матрицы, которым прис-
//   ваиваются элементы вектора V;
//3. ulong right - верхняя граница интервала индексов столбцов матрицы, которым прис-
//   ваиваются элементы вектора V;
//4. ulong pos - начальный индекс строки матрицы, с которой начнется присваивание
//   значений вектора V столбцам матрицы, принадлежащим интервалу [left..right];
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - результирующая матрица
//***********************************************************************************
rmatrix TRealMatrix::AssignCol(const rvector& V, ulong left, ulong right, ulong pos)
 const
{rmatrix result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (pos >= Rows())) return result;
 right = (right == MAX_SIZE) ? Cols()-1 : right;
 if ((right >= Cols()) || (left > right)) return result;
 result = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора столбцам матрицы
 ulong row;
 for (ulong col = left; col <= right; col++)
 {for (ulong i = 0L; i < V.Size(); i++)
  {row = i+pos;
   if (row < result.Rows()) result.Put(row,col,V.Get(i));
   else break; //Выход из цикла по строкам матрицы
  }
 }
 return result;
}
//***********************************************************************************
//СТАТУС: I.54, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//rmatrix AssignCol(const rvector& V, const ivector& cols, ulong pos = 0L) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТОЛБЦАМ МАТРИЦЫ ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА,
//            ИНДЕКСЫ КОТОРЫХ ПЕРЕДАЮТСЯ ВЕКТОРОМ cols
//Функция присваивает столбцам исходной  матрицы с индексами, расположенными в векторе
//cols, начиная со строки с индексом pos, элементов вектора V, передавемого по ссылке.
//По умолчанию, индекс строки pos, с которого начинается присваивание, равен 0. Вектор
//V может иметь любую размерность. Функция присваивает значения элементов вектора V
//копии исходной матрицы, начиная с первого элемента вектора V до последнего элемента
//вектора V или последней строки матрицы, в зависимости от соотношения начального ин-
//декса строки pos матрицы, с которого начинается присваивание, размеров матрицы и
//вектора V.
//Вектор cols, передаваемый по ссылке, содержит индексы столбцов, которым присваивают-
//ся значения элементов вектора V. Перед выполнением операции присваивания индексы
//столбцов, хранимые в векторе cols, фильтруются.
//Из элементов вектора cols формируется его подвектор Index, не содержащий повторяющих-
//ся индексов столбцов и индексов, значения которых превышают количество столбцов ис-
//ходной матрицы.
//Исходная матрицы и его структура не изменяются функцией, все операции присваивания
//происходят с копией исходной матрицы, которая является результатом работы функции.
//Функция возвращает матрицу нулевого размера в следующих ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Вектор-индексов столбцов cols - вектор нулевого размера;
//4. Подвектор Index - нулевого размера - корректные значения  индексов столбцов для
//   данной исходной матрицы в векторе-индексов столбцов cols не найдены;
//5. Начальный индекс строки pos в исходной матрице, начиная с которого выполняется
//   присваивание, превышает количество строк исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на вектор-источник, значения которого присваиваются
//   столбцам исходной матрицы;
//2. const ivector& cols - ссылка на вектор с индексами столбцов, которым присваиваются
//   значения элементов вектора V;
//3. ulong pos - начальный индекс строки матрицы, с которого начнется присваивание
//   значений вектора V столбцам матрицы, индексы которых расположены в векторе cols;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - результирующая  матрица
//***********************************************************************************
rmatrix TRealMatrix::AssignCol(const rvector& V, const ivector& cols, ulong pos) const
{rmatrix result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (cols.IsZeroSize()) ||
     (pos >= Rows())) return result;
 //Формирование вектора корректных индексов столбцов для исходной матрицы
 ivector Index = cols;
 ivector interval(2,0L);
 interval[0] = 0; interval[1] = Cols()-1;
 TBelongClosedInterval<long, ivector> Predicate =
 TBelongClosedInterval<long,ivector>(interval);
 Index = Index.SubVector(Predicate);
 Index = Index.Unique();//Фильтрация повторяющихся индексов столбцов
 if (Index.IsZeroSize()) return result;//Корректные индексы столбцов не найдены

 result = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора столбцам матрицы
 ulong row;
 for (ulong j = 0L; j < Index.Size(); j++)
 {for (ulong i = 0L; i < V.Size(); i++)
  {row = i+pos;
   if (row < result.Rows()) result.Put(row,Index.Get(j),V.Get(i));
   else break; //Выход из цикла по строкам матрицы
  }
 }
 return result;
}
//***********************************************************************************
//СТАТУС: I.55, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//rmatrix Assign(const rmatrix& M, ulong row = 0L, ulong col = 0L) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ ИСХОДНОЙ МАТРИЦЕ ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ
//Функция выполняет присваивание элементам исходной матрицы значений элементов матрицы
//M, передаваемой по ссылке. Присваивание начинается с элемента исходной матрицы, ко-
//торый размещается на пересечении строки с индексом row и столбца с индексом col. По
//умолчанию присваивание начинается с первого элементы исходной матрицы с координатами
//(0,0). Далее присваивание осуществляется элементам исходной матрицы, индексы которых
//располагаются правее (по столбцам) и ниже (по строкам) индексов начального элемента
//исходной матрицы. Матрица M может иметь любую размерность. Присваивание значений
//матрицы M начинается с первого элемента данной матрицы - M(0,0) и осуществляется
//либо до последнего значения данной матрицы по координатам строки или столбца, либо
//до последних значений исходной матрицы по ее координатам строк и столбцов в зависи-
//мости от соотношения размерностей исходной  матрицы, матрицы-источника M по строкам
//и столбцам и координаты начального элемента исходной матрицы, с которого начинается
//присваивание. При осуществлении операции присваивания размеры исходной матрицы не
//изменяются, так как присваивание осуществляется в крайнем случае до граничных значе-
//ний индексов исходной матрицы по строкам и столбцам.
//Исходная матрица не изменяется функцией, так как все необходимые операции присваива-
//ния осуществляются с копией исходной матрицы, которая является результатом работы
//функции.
//Функция возвращает матрицу нулевого размера в следующих ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Матрица-источник M - матрица нулевого размера;
//3. Координаты начального элемента, с которого начинается присваивание выходят за
//   пределы граничных значений по строкам или столбцам для исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& M - ссылка  на матрицу-источник, значения  элементов которой
//   будут присваиваться элементам исходной матрицы;
//2. ulong row - индекс строки начального элемента исходной матрицы;
//3. ulong col - индекс столбца начального элемента исходной матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - результирующая  матрица
//***********************************************************************************
rmatrix TRealMatrix::Assign(const rmatrix& M, ulong row, ulong col) const
{rmatrix result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (M.IsZeroSize()) || (row >= Rows()) || (col >= Cols()))
  return result;
 result = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора столбцам матрицы
 ulong Row, Col;
 for (ulong i = 0L; i < M.Rows(); i++)
 {Row = i+row;
  if (Row >= result.Rows()) break;//Выход из цикла по строкам
  for (ulong j = 0L; j < M.Cols(); j++)
  {Col = j+col;
   if (Col < result.Cols()) result.Put(Row,Col,M.Get(i,j));
   else break; //Выход из цикла по столбцам матрицы
  }
 }
return result;
}

//-----------------------------------------------------------------------------------
// Реализация операций умножения матрицы на элементарную матрицу и элементарные
// матрицы специального вида (elementary matrix)
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: I.1, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool DiagonalEM(const rmatrix& Q, bool Disp, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ДИАГОНАЛЬНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Dk.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицу Dk. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Dk;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong k - k-й диагональный элемент матрицы отличный от нуля и единицы,
//   0 <= k < Q.Rows().
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::DiagonalEM(const rmatrix& Q, bool Disp, ulong k)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong j = 0L; j < Cols(); j++) //По столбцам
   data[k][j] *= Q.Get(k,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong i = 0L; i < Rows(); i++) //По строкам
   data[i][k] *= Q.Get(k,k);
return true;
}
//***********************************************************************************
//СТАТУС: I.2, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool DiagonalEM(const rmatrix& Q, bool Disp, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ГРУППУ ДИАГОНАЛЬНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Dk.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Dk. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Dk;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong first - индекс первой диагональной элементарной матрицы;
//4. ulong last -  индекс последней диагональной элементарной матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::DiagonalEM(const rmatrix& Q, bool Disp, ulong first, ulong last)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = first; k <= last; k++)
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    data[k][j] *= Q.Get(k,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = first; k <= last; k++)
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][k] *= Q.Get(k,k);
return true;
}
//***********************************************************************************
//СТАТУС: I.3, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool DiagonalEM(const rmatrix& Q, bool Disp)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВСЕ ДИАГОНАЛЬНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Dk.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Dk. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Dk;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::DiagonalEM(const rmatrix& Q, bool Disp)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L)) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = 0L; k < Rows(); k++)
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    data[k][j] *= Q.Get(k,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = 0L; k < Cols(); k++)
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][k] *= Q.Get(k,k);
return true;
}
//***********************************************************************************
//СТАТУС: I.4, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LowerColumnEM(const rmatrix& Q, bool Disp, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА НИЖНЮЮ СТОЛБЦОВУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Lkc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицу Lkc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Lkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong k - k-й столбец матрицы с отличными от нуля поддиагональными  элемен-
//   тами 0 <= k < Q.Rows().
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::LowerColumnEM(const rmatrix& Q, bool Disp, ulong k)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong i = k+1; i < Rows(); i++) //По строкам
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    data[i][j] += data[k][j]*Q.Get(i,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong i = 0L; i < Rows(); i++) //По строкам
   for (ulong j = k+1; j < Cols(); j++) //По столбцам
    data[i][k] += data[i][j]*Q.Get(j,k);
return true;
}
//***********************************************************************************
//СТАТУС: I.5, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool LowerColumnEM(const rmatrix& Q, bool Disp, ulong first, ulong last);
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ГРУППУ НИЖНИХ СТОЛБЦОВЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Lkc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Lkc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Lkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong first - индекс первой нижней столбцовой элементарной матрицы;
//4. ulong last -  индекс последней нижней столбцовой элементарной матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::LowerColumnEM(const rmatrix& Q, bool Disp, ulong first, ulong last)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = first; k <= last; k++)
   for (ulong i = k+1; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = first; k <= last; k++)
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = k+1; j < Cols(); j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
return true;
}
//***********************************************************************************
//СТАТУС: I.6, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LowerColumnEM(const rmatrix& Q, bool Disp)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВСЕ НИЖНИЕ СТОЛБЦОВЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Lkc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Lkc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Lkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::LowerColumnEM(const rmatrix& Q, bool Disp)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) || (Rows() == 0L))
  return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = 0L; k < Rows(); k++)
   for (ulong i = k+1; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = 0L; k < Cols(); k++)
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = k+1; j < Cols(); j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
return true;
}
//***********************************************************************************
//СТАТУС: I.7, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool UpperColumnEM(const rmatrix& Q, bool Disp, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВЕРХНЮЮ СТОЛБЦОВУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Ukc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицу Ukc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Ukc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong k - k-й столбец матрицы с отличными от нуля наддиагональными  элемен-
//   тами 0 <= k < Q.Rows().
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::UpperColumnEM(const rmatrix& Q, bool Disp, ulong k)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong i = 0L; i < k; i++) //По строкам
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    data[i][j] += data[k][j]*Q.Get(i,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong i = 0L; i < Rows(); i++) //По строкам
   for (ulong j = 0L; j < k; j++) //По столбцам
    data[i][k] += data[i][j]*Q.Get(j,k);
return true;
}
//***********************************************************************************
//СТАТУС: I.8, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool UpperColumnEM(const rmatrix& Q, bool Disp, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ГРУППУ ВЕРХНИХ СТОЛБЦОВЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Ukc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Ukc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Lkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong first - индекс первой верхней столбцовой элементарной матрицы;
//4. ulong last -  индекс последней верхней столбцовой элементарной матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::UpperColumnEM(const rmatrix& Q, bool Disp, ulong first, ulong last)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = first; k <= last; k++)
   for (ulong i = 0L; i < k; i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = first; k <= last; k++)
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < k; j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
return true;
}
//***********************************************************************************
//СТАТУС: I.9, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool UpperColumnEM(const rmatrix& Q, bool Disp)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВСЕ НИЖНИЕ СТОЛБЦОВЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Ukc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Ukc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Lkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::UpperColumnEM(const rmatrix& Q, bool Disp)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L)) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = 0L; k < Rows(); k++)
   for (ulong i = 0L; i < k; i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = 0L; k < Cols(); k++)
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < k; j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
return true;
}
//***********************************************************************************
//СТАТУС: I.10, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CompleteColumnEM(const rmatrix& Q, bool Disp, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА СТОЛБЦОВУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Tkc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицу Tkc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Tkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong k - k-й столбец матрицы с отличными от нуля элементами
//   0 <= k < Q.Rows().
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::CompleteColumnEM(const rmatrix& Q, bool Disp, ulong k)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
 {for (ulong i = 0L; i < k; i++) //По строкам
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    data[i][j] += data[k][j]*Q.Get(i,k);

  for (ulong i = k+1; i < Rows(); i++) //По строкам
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    data[i][j] += data[k][j]*Q.Get(i,k);
 }
 else //Умножение СПРАВА: R' = R * Q
 {for (ulong i = 0L; i < Rows(); i++) //По строкам
   for (ulong j = 0L; j < k; j++) //По столбцам
    data[i][k] += data[i][j]*Q.Get(j,k);

  for (ulong i = 0L; i < Rows(); i++) //По строкам
   for (ulong j = k+1; j < Cols(); j++) //По столбцам
    data[i][k] += data[i][j]*Q.Get(j,k);
 }
return true;
}
//***********************************************************************************
//СТАТУС: I.11, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CompleteColumnEM(const rmatrix& Q, bool Disp, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ГРУППУ СТОЛБЦОВЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Tkc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Tkc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Lkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong first - индекс первой столбцовой элементарной матрицы;
//4. ulong last -  индекс последней столбцовой элементарной матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::CompleteColumnEM(const rmatrix& Q, bool Disp, ulong first, ulong last)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
 {for (ulong k = first; k <= last; k++)
  {for (ulong i = 0L; i < k; i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
   for (ulong i = k+1; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
  }
 }
 else //Умножение СПРАВА: R' = R * Q
 {for (ulong k = first; k <= last; k++)
  {for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < k; j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = k+1; j < Cols(); j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
  }
 }
return true;
}
//***********************************************************************************
//СТАТУС: I.12, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CompleteColumnEM(const rmatrix& Q, bool Disp)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВСЕ СТОЛБЦОВЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Tkc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Tkc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Tkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::CompleteColumnEM(const rmatrix& Q, bool Disp)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) || (Rows() == 0L))
  return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
 {for (ulong k = 0L; k < Rows(); k++)
  {for (ulong i = 0L; i < k; i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
   for (ulong i = k+1; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
  }
 }
 else //Умножение СПРАВА: R' = R * Q
 {for (ulong k = 0L; k < Cols(); k++)
  {for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < k; j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = k+1; j < Cols(); j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
  }
 }
return true;
}
//***********************************************************************************
//СТАТУС: I.13, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LeftRowEM(const rmatrix& Q, bool Disp, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ЛЕВУЮ СТРОЧНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Lkr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицу Lkr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Lkr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong k - k-я строка матрицы с ненулевыми элементами, расположенными  слева
//   от диагонали 0 <= k < Q.Rows().
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::LeftRowEM(const rmatrix& Q, bool Disp, ulong k)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong j = 0L; j < Cols(); j++) //По столбцам
   for (ulong i = 0L; i < k; i++) //По строкам
    data[k][j] += data[i][j]*Q.Get(k,i);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong j = 0L; j < k; j++) //По столбцам
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][j] += data[i][k]*Q.Get(k,j);
return true;
}
//***********************************************************************************
//СТАТУС: I.14, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool LeftRowEM(const rmatrix& Q, bool Disp, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ГРУППУ ЛЕВЫХ СТРОЧНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Lkr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Lkr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Lkr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong first - индекс первой левой строчной элементарной матрицы;
//4. ulong last -  индекс последней левой строчной элементарной матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::LeftRowEM(const rmatrix& Q, bool Disp, ulong first, ulong last)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = first; k <= last; k++)
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < k; i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = first; k <= last; k++)
   for (ulong j = 0L; j < k; j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
return true;
}
//***********************************************************************************
//СТАТУС: I.15, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LeftRowEM(const rmatrix& Q, bool Disp)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВСЕ ЛЕВЫЕ СТРОЧНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Lkr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Lkr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Lkr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::LeftRowEM(const rmatrix& Q, bool Disp)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L)) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = 0L; k < Rows(); k++)
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < k; i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);

 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = 0L; k < Cols(); k++)
   for (ulong j = 0L; j < k; j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
return true;
}
//***********************************************************************************
//СТАТУС: I.16, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool RightRowEM(const rmatrix& Q, bool Disp, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ПРАВУЮ СТРОЧНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Ukr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицу Ukr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Ukr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong k - k-я строка матрицы с ненулевыми элементами, расположенными  справа
//   от диагонали 0 <= k < Q.Rows().
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::RightRowEM(const rmatrix& Q, bool Disp, ulong k)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong j = 0L; j < Cols(); j++) //По столбцам
   for (ulong i = k+1; i < Rows(); i++) //По строкам
    data[k][j] += data[i][j]*Q.Get(k,i);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong j = k+1; j < Cols(); j++) //По столбцам
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][j] += data[i][k]*Q.Get(k,j);
return true;
}
//***********************************************************************************
//СТАТУС: I.17, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool RightRowEM(const rmatrix& Q, bool Disp, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ГРУППУ ПРАВЫХ СТРОЧНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Ukr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Ukr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Ukr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong first - индекс первой правой строчной элементарной матрицы;
//4. ulong last -  индекс последней правой строчной элементарной матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::RightRowEM(const rmatrix& Q, bool Disp, ulong first, ulong last)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = first; k <= last; k++)
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = k+1; i < Rows(); i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = first; k <= last; k++)
   for (ulong j = k+1; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
return true;
}
//***********************************************************************************
//СТАТУС: I.18, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool RightRowEM(const rmatrix& Q, bool Disp)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВСЕ ПРАВЫЕ СТРОЧНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Ukr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Ukr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Ukr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::RightRowEM(const rmatrix& Q, bool Disp)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) || (Rows() == 0L))
  return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = 0L; k < Rows(); k++)
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = k+1; i < Rows(); i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);

 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = 0L; k < Cols(); k++)
   for (ulong j = k+1; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
return true;
}
//***********************************************************************************
//СТАТУС: I.19, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CompleteRowEM(const rmatrix& Q, bool Disp, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ПОЛНУЮ СТРОЧНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Tkr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицу Tkr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Tkr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong k - k-я строка матрицы с ненулевыми элементами, 0 <= k < Q.Rows().
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::CompleteRowEM(const rmatrix& Q, bool Disp, ulong k)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
 {for (ulong j = 0L; j < Cols(); j++) //По столбцам
   for (ulong i = 0L; i < k; i++) //По строкам
    data[k][j] += data[i][j]*Q.Get(k,i);

  for (ulong j = 0L; j < Cols(); j++) //По столбцам
   for (ulong i = k+1; i < Rows(); i++) //По строкам
    data[k][j] += data[i][j]*Q.Get(k,i);
 }
 else //Умножение СПРАВА: R' = R * Q
 {for (ulong j = 0L; j < k; j++) //По столбцам
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][j] += data[i][k]*Q.Get(k,j);

  for (ulong j = k+1; j < Cols(); j++) //По столбцам
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][j] += data[i][k]*Q.Get(k,j);
 }
return true;
}
//***********************************************************************************
//СТАТУС: I.20, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CompleteRowEM(const rmatrix& Q, bool Disp, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ГРУППУ СТРОЧНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Tkr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Tkr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Tkr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong first - индекс первой строчной элементарной матрицы;
//4. ulong last -  индекс последней строчной элементарной матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::CompleteRowEM(const rmatrix& Q, bool Disp, ulong first, ulong last)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
 {for (ulong k = first; k <= last; k++)
  {for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < k; i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = k+1; i < Rows(); i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);
  }
 }
 else //Умножение СПРАВА: R' = R * Q
 {for (ulong k = first; k <= last; k++)
  {for (ulong j = 0L; j < k; j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
   for (ulong j = k+1; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
  }
 }
return true;
}
//***********************************************************************************
//СТАТУС: I.21, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CompleteRowEM(const rmatrix& Q, bool Disp)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВСЕ СТРОЧНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Tkr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Tkr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Ukr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::CompleteRowEM(const rmatrix& Q, bool Disp)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) || (Rows() == 0L))
  return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
 {for (ulong k = 0L; k < Rows(); k++)
  {for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < k; i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = k+1; i < Rows(); i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);
  }
 }
 else //Умножение СПРАВА: R' = R * Q
 {for (ulong k = 0L; k < Cols(); k++)
  {for (ulong j = 0L; j < k; j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
   for (ulong j = k+1; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
  }
 }
return true;
}
//***********************************************************************************
//СТАТУС: I.22, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool OrdinaryEM(const rmatrix& Q, bool Disp, ulong row, ulong col)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ЭЛЕМЕНТАРНУЮ МАТРИЦУ Bij.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую элементарную матрицу Bij. При умножении исходной матрицы на элемен-
//тарную матрицу значения элементов исходной матрицы изменяются.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Bij;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong row - строка матрицы с ненулевым элементом, 0 <= row < Q.Rows();
//4. ulong col - столбец матрицы с ненулевым элементом, 0 <= col < Q.Cols();
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//***********************************************************************************
bool TRealMatrix::OrdinaryEM(const rmatrix& Q, bool Disp, ulong row, ulong col)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (row >= Rows()) || (col >= Cols())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
 {if (row != col)
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[row][j] += data[col][j]*Q.Get(row,col);
  else //row == col
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[row][j] *= Q.Get(row,col);
 }
 else //Умножение СПРАВА: R' = R * Q
 {if (row != col)
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][col] += data[i][row]*Q.Get(row,col);
  else //row == col
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][col] *= Q.Get(row,col);
 }
return true;
}
//-----------------------------------------------------------------------------------
//              РЕАЛИЗАЦИЯ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: I.1; public; TRealMatrix class overloading operator()
//OVERLOADING OPERATOR OF FUNCTION CALL
//НАИМЕНОВАНИЕ ФУНКЦИИ: double& operator() (ulong i, ulong j)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЗОВА ФУНКЦИИ класса TRealMatrix
//Функция предназначена для доступа к элементу матрицы. Осуществляется проверка кор-
//ректности индексов строки и столбца, по которым располагается требуемый элемент мат-
//рицы. Функция вызывается во всех пользовательских функциях, кроме вызова в операторе
//присваивания и конструкторе копирования, т.к. в качестве аргументов последних пере-
//дается константный объект.
//Доступ к членам-данным константных объектов можно осуществлять только с использова-
//нием константных функций.
//ПРИМЕР ВЫЗОВА: A(3,2), где i=3 - индекс строки, j=2 - индекс столбца вещественной
//матрицы. Нумерация строк и столбцов начинается с 0.
//Если индекс элемента матрицы некорректен, то возвращается data[0][0].
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint i - индекс строки матрицы, в котором располагается компонент
//2. uint j - индекс столбца матрицы, в котором располагается компонент
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double& value - ссылка на a[i][j] компонент матрицы
//***********************************************************************************
double& TRealMatrix::operator() (ulong i, ulong j)
{if (IsZeroSize()) return data[0][0];
 //Проверка корректности индексов доступа к элементу матрицы
 if ((i >= Rows()) || (j >= Cols())) return data[0][0];
 return data[i][j];
}
//***********************************************************************************
//СТАТУС: I.2; public; TRealMatrix class overloading operator()
//OVERLOADING OPERATOR OF FUNCTION CALL
//НАИМЕНОВАНИЕ ФУНКЦИИ: const double& operator() (ulong i, ulong j) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЗОВА ФУНКЦИИ класса TRealMatrix
//Функция предназначена для доступа к одному элементу матрицы или вектора. Осуществ-
//ляется проверка корректности индексов строки и столбца, по которым располагается
//требуемый элемент матрицы. Функция вызывается в операторе присваивания и конструк-
//торе копирования, т.к. в качестве их аргументов передается константный объект. Дос-
//туп к членам-данным константных объектов можно осуществлять только с использованием
//константных функций.
//ПРИМЕР ВЫЗОВА: A(3,2), где i=3 - индекс строки, j=2 - индекс столбца вещественной
//матрицы. Нумерация строк и столбцов начинается с 0.
//Если индекс элемента матрицы некорректен, то возвращается data[0][0].
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint i - индекс строки матрицы, в котором располагается компонент
//2. uint j - индекс столбца матрицы, в котором располагается компонент
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// const double& value - ссылка на a[i][j] компонент матрицы
//***********************************************************************************
const double& TRealMatrix::operator() (ulong i, ulong j) const
{if (IsZeroSize()) return data[0][0];//Матрица нулевого размера
 //Проверка корректности индексов доступа к элементу матрицы
 if ((i >= Rows()) || (j >= Cols())) return data[0][0];
 return data[i][j];
}
//***********************************************************************************
//СТАТУС: I.3; public; TRealMatrix class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator =(const TRealMatrix& R)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ класса TRealMatrix.
//Копирование характеристик и значений элементов из одной вещественной матрицы в дру-
//гую. Осуществляется корректное копирование членов-указателей на данные копируемого
//класса в создаваемый класс с целью недопущения ссылок указателей разных объектов
//класса на одно и то же место памяти. При невозможности работы выполнения оператора
//присваивания возвращается false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TRealMatrix& R - ссылка на копируемую матрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::operator =(const TRealMatrix& R)
{//Предотвращение попытки присваивания объекта самому себе
 if (this == &R) return false;
 //Установка свойств копирующей матрицы
 if (Set(R.Rows(),R.Cols(),false) == false) return false;
 //Копирование значений элементов матрицы R
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = R.Get(i,j);
 return true;
}
//***********************************************************************************
//СТАТУС: I.4; public; TRealMatrix class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator =(const TIntMatrix& A)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ класса TIntMatrix.
//Копирование характеристик и значений элементов из целочисленной в вещественную мат-
//рицу. Осуществляется корректное копирование членов-указателей на данные копируемого
//класса в создаваемый класс с целью недопущения ссылок указателей разных объектов
//класса на одно и то же место памяти. При невозможности работы выполнения оператора
//присваивания возвращается false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TIntMatrix& A - ссылка на копируемую матрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::operator =(const TIntMatrix& A)
{//Установка свойств копирующей матрицы
 if (Set(A.Rows(),A.Cols(),false) == false) return false;
 //Копирование значений элементов матрицы A
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = A.Get(i,j);
 return true;
}
//***********************************************************************************
//СТАТУС: I.5; public; TRealMatrix class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator =(const TComplexMatrix& C)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ класса TComplexMatrix.
//Функция осуществляет ПРЕОБРАЗОВАНИЕ КОМПЛЕКСНОЙ МАТРИЦЫ M x N в ДЕЙСТВИТЕЛЬНУЮ МАТ-
//РИЦУ 2M x 2N. Осуществляется корректное копирование членов-указателей на данные ко-
//пируемого класса в создаваемый класс с целью недопущения ссылок указателей разных
//объектов класса на одно и то же место памяти. Преобразование комплексной матрицы в
//действительную основано, на представлении комплексной матрицы C в виде A + iB, где
//A - матрица действительных частей C, B - матрица мнимых частей комплексной матрицы
//C. Таким образом, любую комплексную матрицу размера M x N, можно представить в виде
//действительной матрицы размера 2M x 2N. Действительная матрица записывается в виде:
// | A  -B |
// | B   A |.
//При невозможности преобразования матрицы C в исходную матрицу, возвращается false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// const TComplexMatrix& C - ссылка на копируемую комплексную матрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::operator =(const TComplexMatrix& C)
{const ulong limit = 2147483648L;
 //Предотвращение попытки преобразования комплексной матрицы большого размера
 if ((C.Rows() > limit) || (C.Cols() > limit)) return false;
 double Real, Image;
 complex z;
 ulong x = C.Rows(), y = C.Cols();
 //Установка свойств действительной матрицы
 if (Set(2*C.Rows(),2*C.Cols(),false) == false) return false;
 //Копирование значений элементов матрицы C
 for (ulong i = 0L; i < C.Rows(); i++)
  for (ulong j = 0L; j < C.Cols(); j++)
  {z = C.Get(i,j); Real = real(z); Image = imag(z);
   data[i][j] = Real; data[i+x][j+y] = Real;
   data[i][j+y] = -Image; data[i+x][j] = Image;
  }
 return true;
}
//***********************************************************************************
//СТАТУС: I.6; public; TRealMatrix class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator =(const double value)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ КОМПОНЕНТАМ МАТРИЦЫ ДЕЙСТВИТЕЛЬНОГО
//ЧИСЛА. ВСЕМ элементам матрицы присваивается значение value. При присваивании матри-
//це нулевой размерности действительного числа возвращается false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const double value - присваиваемое матрице значение
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения операции
//***********************************************************************************
bool TRealMatrix::operator =(const double value)
{if (IsZeroSize()) return false;//Матрица нулевого размера
 //Цикл присваивания компонентам вектора значения value
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
    data[i][j] = value;
 return true;
}
//***********************************************************************************
//СТАТУС: I.7; public TRealMatrix class overloading operator ==
//OVERLOADING COMPARISON OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ==(const TRealMatrix& A) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СРАВНЕНИЯ ДВУХ МАТРИЦ.
//Две матрицы считаются РАВНЫМИ, если:
//1) Размерности матриц равны Rows()==A.Rows() && Cols()==A.Cols()
//2) data[i][j] == A.data[i][j], для всех i,j (0<=i<Rows(), 0<=j<Cols()).
//В случае равентства матриц функция возвращает true, в противном случае - false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TRealMatrix& A - ссылка на сравниваемую матрицу
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool compare - результат сравнения
//***********************************************************************************
bool TRealMatrix::operator ==(const TRealMatrix& A) const
{//Матрица сравнивается сама с собой
 if (this == &A) return true;
 //Размерности матриц не совпадают
 if ((Rows() != A.Rows()) || (Cols() != A.Cols())) return false;
 //Поэлементное сравнение матриц
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {if (fabs(data[i][j] - A.Get(i,j)) > EPS) return false;}
 return true;//Результат сравнения двух матриц
}
//***********************************************************************************
//СТАТУС: I.8;  TRealMatrix class friend overloading operator <<
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend ostream& operator <<(ostream& out, const TRealMatrix& R)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВЫВОДА класса TRealMatrix.
//Функция предназначена для вывода в поток характеристик матрицы и ее элементов. Функ-
//ция возвращает ссылку на поток, что позволяет записывать в программе операторы вы-
//вода в поток каскадно. Формат вывода значений элементов матрицы:
// <x11  x12  x13  ...>, где x - значениe элемента матрицы.
//При выводе элементов вещественной матрицы приняты следующие соглашения:
//1. Все элементы матрицы имеют ширину вывода равную наибольшей символьной длине
//   элемента в данном столбце матрицы, который определяется функцией MaxStrLen(...)
//2. Выводятся только отрицательные знаки чисел.
//3. Точность вывода чисел с плавающей точкой определяется установленным до вывода
//   элементов матрицы значением функции потокового вывода precision. Максимально
//   возможное количество значащих цифр - 19.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на объект потока вывода
//2. сonst TRealMatrix& R - ссылка на матрицу, выводимую в поток.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ostream& out - ссылка на объект потока вывода.
//***********************-***********************************************************
ostream& operator <<(ostream& out, const TRealMatrix& R)
{string s;
 uint precision = out.precision();
 long flags = out.flags();
 R.Properties(s); //Получение свойств матрицы R в виде строки
 //Вывод характеристик матрицы
 out << s;
 if (R.IsZeroSize()) return out;
 //Формирование символьного представления элементов вещественной матрицы
 string StrMatrElem;
 out.setf(ios::right);//Выравнивание по правому краю.
 out << R.GetData(StrMatrElem, precision, string("  ")) << endl;
 out.flags(flags);
return out;
}
//===================================================================================
//    РЕАЛИЗАЦИЯ ОПЕРАЦИЙ ЛИНЕЙНОЙ АЛГЕБРЫ над ДЕЙСТВИТЕЛЬНЫМИ МАТРИЦАМИ
// Все операции линейной алгебры не изменяют значений компонент исходных матриц,
// над которыми выполняются операции линейной алгебры.
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Reverse()
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ЭЛЕМЕНТОВ КВАДРАТНОЙ МАТРИЦЫ ОТНОСИТЕЛЬНО
//            ДОПОЛНИТЕЛЬНОЙ ДИАГОНАЛИ
//Операция проводится с исходной квадратной матрицей. Алгоритм перестановки элементов
//квадратной матрицы относительно дополнительной диагонали:
// A[i,j] -> A'[ |j-n|, |i-n| ], где n = Rows()-1.
//Если матрица - не квадратная или нулевого размера, то возвращается false и исходная
//матрица не изменяется.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат перестановки
//***********************************************************************************
bool TRealMatrix::Reverse()
{if (IsZeroSize() || IsRectang()) return false;
 //----------------------------------------------------------------------------------
 //Перестановка элементов матрицы относительно дополнительной диагонали
 //----------------------------------------------------------------------------------
 ulong new_i, new_j, n = Rows()-1;
 double temp;
 for (ulong i = 0L; i < n; i++)
  for (ulong j = 0L; j < (n-i); j++)
  {temp = data[i][j]; new_i = n-j; new_j = n-i;
   data[i][j] = data[new_i][new_j];
   data[new_i][new_j] = temp;
  }
 return true;
}
//***********************************************************************************
//СТАТУС: I.2, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix Transpose() const
//НАЗНАЧЕНИЕ: ТРАНСПОНИРОВАНИЕ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ
//Операция транспонирования проводится с копией исходной матрицы, которая возвращается
//данной функцией. Результатом транспонирования матрицы A(m x n) является матрица
//B(n x m). Столбцы матрицы B совпадают со строками матрицы A. При транспонировании
//матрицы нулевого размера возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - транспонированная матрицу
//***********************************************************************************
rmatrix TRealMatrix::Transpose() const
{rmatrix result;
 if (IsZeroSize()) return result;//Матрица нулевого размера
 result.Set(Cols(),Rows(),false);//Создание транспонированной матрицы
 //Транспонирование элементов матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(j,i,data[i][j]);
 return result;
}
//***********************************************************************************
//СТАТУС: I.2, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Transpose(rmatrix& A) const
//НАЗНАЧЕНИЕ: ТРАНСПОНИРОВАНИЕ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ
//Исходная матрица транспонируется в матрицу A, передаваемую по ссылке. Результатом
//транспонирования матрицы (m x n) является матрица (n x m). Столбцы транспонированной
//матрицы совпадают со строками исходной матрицы. Функция возвращает false и преобра-
//зует матрицу A в матрицу нулевого размера в следующих случаях:
//1) Исходная матрица - матрица нулевого размера;
//2) Адреса исходной и передаваемой по ссылке матрицы совпадают;
//3) Не удалось выделить память под размещение транспонированной матрицы A.
//Функция не изменяет размеры и элементы исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//rmatrix& A - ссылка на матрицу, в которой разместится транспонированная матрица к
//исходной матрице.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения транспонирования
//***********************************************************************************
bool TRealMatrix::Transpose(rmatrix& A) const
{//Проверка на возможность проведения операции транспонирования
 if ((this == &A) || IsZeroSize()) {A.Set(0L,false); return false;}
 //Выделение памяти под размещение элементов транспонированнной к исходной матрице
 if (!A.Set(Cols(),Rows(),false)) return false;
 //Транспонирование элементов исходной матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   A.Put(j,i,data[i][j]);
 return true;//Транспонирование исходной матрицы выполнено успешно
}
//***********************************************************************************
//СТАТУС: I.3, TRealMatrix class overloading operator !
//OVERLOADING UNARY OPERATOR < ! >
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix operator !() const
//Функция осуществляет транспонирование матрицы. Операция транспонирования производится
//с копией исходной матрицы, которая возвращается данной функцией. Результатом транс-
//понирования матрицы A(m x n) является матрица B(n x m). Столбцы матрицы B совпадают
//со строками матрицы A. При транспонировании матрицы нулевого размера возвращается
//матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - транспонированная матрица
//***********************************************************************************
rmatrix TRealMatrix::operator !() const {return Transpose();}
//****************************************************************************************
//СТАТУС: I.4, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double Trace() const
//НАЗНАЧЕНИЕ: ВЫЧИСЛЕНИЕ СЛЕДА ДЕЙСТВИТЕЛЬНОЙ КВАДРАТНОЙ МАТРИЦЫ
//След вещественной квадратной матрицы вычисляется СУММИРОВАНИЕМ ДИАГОНАЛЬНЫХ
//ЭЛЕМЕНТОВ.
//При попытке определения следа матрицы нулевого размера или прямоугольной матрицы
//возвращается 0.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double Spur - след квадратной матрицы
//****************************************************************************************
double TRealMatrix::Trace() const
{double Spur = 0.0;
 //Матрица нулевого размера или прямоугольная матрица
 if ((IsZeroSize()) || (IsRectang())) return Spur;
 //Вычисление следа квадратной вещественной матрицы
 for (ulong i = 0L; i < Rows(); i++) Spur += data[i][i];
 return Spur;
}
//****************************************************************************************
//СТАТУС: I.5, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool MaxMin(double& Max, double& Min) const
//НАЗНАЧЕНИЕ: ОПРЕДЕЛЕНИЕ MAX & MIN ЗНАЧЕНИЙ ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОЙ КВАДРАТНОЙ МАТРИЦЫ
//Значения максимального и минимального значений элементов матрицы заносятся в переменные
//Max & Min, передаваемые в функцию по ссылке.
//При попытке определения Max & Min значений элементов матрицы нулевого размера
//возвращается false, переменным Max & Min присваиваются нулевые значения.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double& Max - переменная, в которую заносится максимальное значение элемента матрицы
//2. double& Min - переменная, в которую заносится минимальное значение элемента матрицы
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//1. bool lSuccess - признак выполнения операции определения MAX & MIN значений элементов
//   матрицы.
//****************************************************************************************
bool TRealMatrix::MaxMin(double& Max, double& Min) const
{Max = Min = 0.0;
 //Матрица нулевого размера
 if (IsZeroSize()) return false;
 //Поиск максимального и минимального элементов вещественной матрицы
 Max = Min = data[0][0];
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {if (Max < data[i][j]) Max = data[i][j];
   if (Min > data[i][j]) Min = data[i][j];
  }
 return true;
}
//****************************************************************************************
//СТАТУС: I.6, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double FirstNorm() const
//НАЗНАЧЕНИЕ: ПЕРВАЯ (КУБИЧЕСКАЯ) НОРМА ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ
//Функция осуществляет определение первой (кубической) нормы вещественной матрицы.
//Для матрицы A(m x n) первая норма вычисляется по формуле:
// ||A|| = max|Aij| by i & j, максимальное абсолютное значение элемента матрицы A размера
//n. Функция возвращает 0 для матрицы нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - первая норма матрицы
//****************************************************************************************
double TRealMatrix::FirstNorm() const
{if (IsZeroSize()) return 0.0;//Матрица нулевого размера
 //Поиск максимального по абсолютной величины элемента вещественной матрицы
 double norm = 0.0, value;
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {value = fabs(data[i][j]);
   if (norm < value) norm = value;
  }
 return norm;
}
//****************************************************************************************
//СТАТУС: I.7, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double NFirstNorm() const
//НАЗНАЧЕНИЕ: МАТРИЧНАЯ НОРМА ДЕЙСТВИТЕЛЬНОЙ КВАДРАТНОЙ МАТРИЦЫ вида N*max|Aij|
//Норма определена для квадратной матрицы A(n x n) и вычисляется по формуле:
// ||A|| = n*max|Aij| by i & j, максимальное абсолютное значение элемента матрицы A
//размера n. Функция возвращает 0 для прямоугольной и нулевого размера матриц.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - норма матрицы
//****************************************************************************************
double TRealMatrix::NFirstNorm() const {return Rows()*FirstNorm();}
//****************************************************************************************
//СТАТУС: I.8, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double SecondNorm() const
//НАЗНАЧЕНИЕ: ВТОРАЯ (ОКТАЭДРИЧЕСКАЯ) НОРМА ДЕЙСТВИТЕЛЬНОЙ КВАДРАТНОЙ МАТРИЦЫ
//Вторая (октаэдрическая) норма вещественной квадратной матрицы вычисляется по формуле:
// ||A|| = SUM|Aij| by i & j, сумма абсолютных значений элементов матрицы A.
//Функция возвращает norm == 0 для прямоугольной и нулевого размера матриц.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - вторая норма матрицы
//****************************************************************************************
double TRealMatrix::SecondNorm() const
{double norm = 0.0;
 //Матрица нулевого размера или прямоугольная матрица
 if ((IsZeroSize()) || (IsRectang())) return norm;
 //Суммирование абсолютных величин компонент вещественной квадратной матрицы
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++) norm += fabs(data[i][j]);
 return norm;
}
//***********************************************************************************
//СТАТУС: I.9, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double ThirdNorm() const
//НАЗНАЧЕНИЕ: ТРЕТЬЯ (СФЕРИЧЕСКАЯ, ЕВКЛИДОВА) НОРМА КВАДРАТНОЙ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ
//Для матрицы A(n x n) евклидова норма вычисляется по формуле:
// ||A|| = sqrt(SUM|Aij|^2 by i & j).
//Функция возвращает norm == 0 для прямоугольной и нулевого размера матриц.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - евклидова норма матрицы
//***********************************************************************************
double TRealMatrix::ThirdNorm() const
{double norm = 0.0;
 //Матрица нулевого размера или прямоугольная матрица
 if ((IsZeroSize()) || (IsRectang())) return norm;
 //Суммирование квадратов абсолютных величин элементов квадратной матрицы
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++) norm += data[i][j]*data[i][j];
 norm = sqrt(norm);//Вычисление нормы вещественной квадратной матрицы
 return norm;
}
//****************************************************************************************
//СТАТУС: I.10, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double PNorm(uint p = 2) const
//НАЗНАЧЕНИЕ: P-НОРМА (НОРМЫ ГЕЛЬДЕРА) ДЕЙСТВИТЕЛЬНОЙ КВАДРАТНОЙ МАТРИЦЫ
//Для матрицы A(n x n) p-норма вычисляется по формуле:
// ||A|| = {SUM|Aij|^p by i,j}^(1/p).
//Функция возвращает norm == 0 для прямоугольной и нулевого размера матриц.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint p - p-норма матрицы, default p=2 - Евклидова норма.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - p-норма квадратной матрицы
//****************************************************************************************
double TRealMatrix::PNorm(uint p) const
{double norm = 0.0;
 //Матрица нулевого размера или прямоугольная матрица
 if ((IsZeroSize()) || (IsRectang())) return norm;
 if (p == 0) norm = FirstNorm();
 else if (p == 1) norm = SecondNorm();//Вторая норма
 else if (p == 2) norm = ThirdNorm();//Третья норма
 else //Вычисление p-нормы вещественного вектора
 {for (ulong i = 0L; i < Rows(); i++)
   for (ulong j = 0L; j < Cols(); j++)
    norm += pow(fabs(data[i][j]),p);
  norm = pow(norm,1/p);
 }
 return norm;
}
//****************************************************************************************
//СТАТУС: I.11, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double Norm(uint type, uint p = 2) const
//НАЗНАЧЕНИЕ: НОРМА ДЕЙСТВИТЕЛЬНОЙ КВАДРАТНОЙ МАТРИЦЫ
//Определение нормы вещественной квадратной матрицы в зависимости от значения переменной
//type. Аргумент p необходим для определения p-нормы матрицы. По умолчанию функция
//определяет ЕВКЛИДОВУ НОРМУ матрицы A.
//Функция возвращает norm == 0 для прямоугольной или нулевого размера матриц, а также
//для нормы несуществующего типа.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint type - тип определяемой нормы вещественной квадратной матрицы;
//2. uint p - параметр для p-нормы матрицы, (by default p=2 - Евклидова норма)
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - норма матрицы заданного типа
//****************************************************************************************
double TRealMatrix::Norm(uint type, uint p) const
{double norm;
  switch (type)
  {//Определение первой (кубической) нормы
   case FIRST_NORM:
    norm = FirstNorm(); break;
   //Определение второй (октаэдрической) нормы
   case SECOND_NORM:
    norm = SecondNorm(); break;
   //Определение третьей (сферической, евклидовой) нормы
   case THIRD_NORM:
    norm = ThirdNorm(); break;
   //Определение p-нормы или нормы Гельдера
   case P_NORM:
    norm = PNorm(p); break;
   //Несуществующий тип нормы
   default:
    norm = 0.0;
  }
return norm;
}
//****************************************************************************************
//СТАТУС: I.12, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// double NormRow(ulong row, uint type = EUCLIDEAN_NORM, uint p = 2) const
//НАЗНАЧЕНИЕ: ВЫЧИСЛЕНИЕ НОРМЫ СТРОКИ МАТРИЦЫ с ИНДЕКСОМ row.
//Тип вычисляемой нормы строки матрицы определяется переменной type. Аргумент p служит
//для определения p-нормы матрицы. По умолчанию функция определяет ЕВКЛИДОВУ НОРМУ
//строки row.
//При определении нормы строки матрицы нулевого размера или строки с несуществующим
//индексом возвращается 0.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong row - номер строки матрицы для которой вычисляется норма;
//2. uint type - тип определяемой нормы вещественной квадратной матрицы;
//3. uint p - параметр для p-нормы вектора (by default: p=2 - Евклидова норма).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - норма строки матрицы с номером row
//****************************************************************************************
double TRealMatrix::NormRow(ulong row, uint type, uint p) const
{rvector V;
 if (Row(V,row) == false) return 0.0;//Получение строки матрицы с индексом row
 return V.Norm(type,p);
}
//***********************************************************************************
//СТАТУС: I.10, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// double NormCol(ulong col, uint type = EUCLIDEAN_NORM, uint p = 2) const
//НАЗНАЧЕНИЕ: ВЫЧИСЛЕНИЕ НОРМЫ СТОЛБЦА МАТРИЦЫ с ИНДЕКСОМ col.
//Тип вычисляемой нормы столбца матрицы определяется переменной type. Аргумент p слу-
//жит для определения p-нормы матрицы. По умолчанию определяется ЕВКЛИДОВА НОРМА
//столбца col.
//При определении нормы столбца матрицы нулевого размера или столбца с несуществующим
//индексом возвращается 0.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong col - номер столбца матрицы для которого вычисляется норма;
//2. uint type - тип определяемой нормы вещественной квадратной матрицы;
//3. uint p - параметр для p-нормы вектора (by default: p=2 - Евклидова норма).
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - норма столбца матрицы с номером col
//***********************************************************************************
double TRealMatrix::NormCol(ulong col, uint type, uint p) const
{rvector V;
 if (Col(V,col) == false) return 0.0;//Получение столбца матрицы с индексом col
 return V.Norm(type,p);
}
//***********************************************************************************
//СТАТУС: I.11, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool NormAllRows(rvector& V, uint type = EUCLIDEAN_NORM, uint p = 2) const
//НАЗНАЧЕНИЕ: ВЫЧИСЛЕНИЕ НОРМ ВСЕХ СТРОК МАТРИЦЫ.
//Тип вычисляемых норм строк матрицы определяется переменной type. Аргумент p служит
//для определения p-нормы матрицы. По умолчанию определяется ЕВКЛИДОВА НОРМА для всех
//строк матрицы. Нормы всех строк формируются в векторе V, передаваемом по ссылке.
//Вектор V будет иметь следующие свойства: V.Size() == Rows(), V.Type() == ROW.
//При определении норм строк матрицы нулевого размера возвращается false, вектор V
//становиться вектором нулевой длины.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& V - результирующий вектор с нормами всех строк матрицы;
//2. uint type - тип определяемой нормы строк матрицы;
//3. uint p - параметр для p-нормы строки (by default: p=2 - Евклидова норма).
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::NormAllRows(rvector& V, uint type, uint p) const
{V.Resize(Rows()); V.SetType(ROW);
 if (IsZeroSize()) return false;//Матрица нулевого размера
 rvector Temp;
 for (ulong i = 0L; i < Rows(); i++)
 {Row(Temp,i);//Получение строки матрицы с индексом i
  V.Put(i,Temp.Norm(type,p));//Расчет нормы i-ой строки матрицы
 }
 return true;
}
//***********************************************************************************
//СТАТУС: I.12, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool NormAllCols(rvector& V, uint type = EUCLIDEAN_NORM, uint p = 2) const
//НАЗНАЧЕНИЕ: ВЫЧИСЛЕНИЕ НОРМ ВСЕХ СТОЛБЦОВ МАТРИЦЫ.
//Тип вычисляемых норм столбцов матрицы определяется переменной type. Аргумент p слу-
//жит для определения p-нормы матрицы. По умолчанию определяется ЕВКЛИДОВА НОРМА для
//всех столбцов матрицы. Нормы всех столбцов формируются в векторе V, передаваемом по
//ссылке. Вектор V будет иметь следующие свойства: V.Size()==Cols(), V.Type()==COL.
//При определении норм столбцов матрицы нулевого размера возвращается false, вектор V
//становиться вектором нулевой длины.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& V - результирующий вектор с нормами всех столбцов матрицы;
//2. uint type - тип определяемой нормы столбцов матрицы;
//3. uint p - параметр для p-нормы столбца (by default: p=2 - Евклидова норма).
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::NormAllCols(rvector& V, uint type, uint p) const
{V.Resize(Cols()); V.SetType(COL);
 if (IsZeroSize()) return false;//Матрица нулевого размера
 rvector Temp;
 for (ulong j = 0L; j < Cols(); j++)
 {Col(Temp,j);//Получение столбца матрицы с индексом j
  V.Put(j,Temp.Norm(type,p));//Расчет нормы j-го столбца матрицы
 }
 return true;
}
//***********************************************************************************
//СТАТУС: I.13, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Normalize(rmatrix& A, uint NormType, uint p=0) const
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОЙ КВАДРАТНОЙ МАТРИЦЫ
//С целью нормирования функция определяет норму квадратной матрицы, затем каждый эле-
//мент матрицы делится на норму матрицы. Определяемая норма определяется переменной
//type. Аргумент p необходим для определения p-нормы матрицы. Исходная матрица при
//нормировании не изменяется, так как все операции производятся с матрицей A, в кото-
//рую копируется исходная матрица.
//При нормировании матрицы с нормой равной 0 возвращается false, матрица A становится
//матрицей нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& A - ссылка на результирующую матрицу;
//2. uint NormType - тип нормы квадратной матрицы;
//3. uint p - параметр для p-нормы матрицы (by default p=0)
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::Normalize(rmatrix& A, uint NormType, uint p) const
{double norm = Norm(NormType,p);
 if (norm == 0.0) {A.Set(0L,0L,false); return false;}
 A = *this;
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   A.Put(i,j,A.Get(i,j)/norm);
 return true;
}
//***********************************************************************************
//СТАТУС: I.14, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Normalize(uint NormType, uint p=0)
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОЙ КВАДРАТНОЙ МАТРИЦЫ
//С целью нормирования функция определяет норму квадратной матрицы, затем каждый эле-
//мент матрицы делится на норму матрицы. Норма определяется переменной type. Аргумент
//p необходим для определения p-нормы матрицы. Исходная матрица изменяется при норми-
//ровании. При нормировании матрицы с нормой равной 0 возвращается false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint NormType - тип нормы квадратной матрицы;
//2. uint p - параметр для p-нормы матрицы (by default p=0).
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::Normalize(uint NormType, uint p)
{double norm = Norm(NormType,p);
 if (norm == 0.0) return false;
 //Нормирование элементов матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = data[i][j]/norm;
 return true;
}
//***********************************************************************************
//СТАТУС: I.15, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool NormalizeToDB(rmatrix& A, bool Power = true, double MindB = -60) const
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ в ДЕЦИБЕЛАХ
//С этой целью, во-первых, вычисляется первая норма матрицы. Во-вторых, каждый элемент
//матрицы делится на первую норму матрицы. В-третьих, элементы матрицы логарифмируются:
//a) Power = true: 10*log10(R(i,j));
//b) Power = false: 20*log10(R(i,j)).
//Все элементы матрицы должны быть ПОЛОЖИТЕЛЬНЫМИ, (data(i,j) > 0), иначе функция
//возвращает false и нормирование не осуществляется.
//При попытке нормировки матрицы нулевого размера функция возвращает false.
//Функция не изменяет исходную матрицу, результаты нормировки заносятся в матрицу A,
//передаваемую по ссылке.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& A - ссылка на результирующую матрицу
//2. bool Power (true) - опция логарифмирования (по мощности или напряжению)
//3. double MindB (-60 dB) - минимальный пороговый уровень
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::NormalizeToDB(rmatrix& A, bool Power, double MindB) const
{if (IsZeroSize()) {A.Set(0L,0L,false); return false;}//Матрица нулевого размера
 //Поиск максимального значения, отрицательных или нулевых значений
 bool Negative = false;
 double Max = 0.0;
 for (ulong i = 0L; i < Rows(); i++)
 {for (ulong j = 0L; j < Cols(); j++)
  {if (data[i][j] < 0.0) {Negative = true; break;}
   if (Max < data[i][j]) Max = data[i][j];
  }
  if (Negative) break;
 }
 if ((Max == 0.0) || (Negative)) {A.Set(0L,0L,false); return false;}
 A.Set(Rows(),Cols(),false);
 //Нормирование компонент матрицы A в пределах (0..1]
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   A.Put(i,j,data[i][j]/Max);
 //Нормирование в dB с установкой нижнего порогового уровня [0..MindB]
 double value;
 MindB = (MindB >= 0.0) ? -60.0 : MindB;
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
  {value = A.Get(i,j);
   if (fabs(value) == 0.0) A.Put(i,j,MindB);//Нулевое значение
   else
   {value = (Power) ? 10*log10(value) : 20*log10(value);
    if (value < MindB) value = MindB;
    A.Put(i,j,value);
   }
  }
 return true;
}
//***********************************************************************************
//СТАТУС: I.16, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool NormalizeToDB(bool Power=true, double MindB=-60)
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ в ДЕЦИБЕЛАХ
//С этой целью, во-первых, вычисляется первая норма матрицы. Во-вторых, каждый элемент
//матрицы делится на первую норму матрицы. В-третьих, элементы матрицы логарифмируются:
//a) Power = true: 10*log10(R(i,j));
//b) Power = false: 20*log10(R(i,j)).
//Все элементы матрицы должны быть ПОЛОЖИТЕЛЬНЫМИ, (R(i,j) > 0), иначе функция возвра-
//щает false и нормирование не осуществляется. При попытке нормировки матрицы нулевого
//размера функция возвращает false. Функция изменяет исходную матрицу.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. bool Power (true) - опция логарифмирования (по мощности или напряжению)
//2. double MindB (-60 dB) - минимальный пороговый уровень
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::NormalizeToDB(bool Power, double MindB)
{if (IsZeroSize()) return false;//Матрица нулевого размера
 //Поиск максимального значения, отрицательных или нулевых значений
 bool Negative = false;
 double Max = 0.0;
 for (ulong i = 0L; i < Rows(); i++)
 {for (ulong j = 0L; j < Cols(); j++)
  {if (data[i][j] < 0.0) {Negative = true; break;}
   if (Max < data[i][j]) Max = data[i][j];
  }
  if (Negative) break;
 }
 if ((Max == 0.0) || (Negative)) return false;
 //Нормирование компонент матрицы в пределах (0..1]
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = data[i][j]/Max;
 //Нормирование в dB с установкой нижнего порогового уровня [0..MindB]
 double value;
 MindB = (MindB >= 0.0) ? -60.0 : MindB;
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {value = data[i][j];
   if (fabs(value) == 0.0) data[i][j] = MindB;//Нулевое значение
   else
   {value = (Power) ? 10*log10(value) : 20*log10(value);
    if (value < MindB) value = MindB;
    data[i][j] = value;
   }
  }
 return true;
}
//***********************************************************************************
//СТАТУС: I.17, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool NormalizeRows(rmatrix& A, uint NormType, uint p=0) const
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ ПО КАЖДОЙ СТРОКЕ
//Во-первых, функция определяет нормы всех строк матрицы, затем каждая строка матрицы
//делится на норму данной строки. Тип нормы определяется переменной type. Аргумент p
//необходим для определения p-нормы матрицы. Исходная матрица при нормировании не из-
//меняется, так как все операции производятся с матрицей A, в которую копируется
//исходная матрица.
//Если какая-либо норма строки матрицы равна 0, то возвращается false, а матрица A
//становится матрицей нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& A - ссылка на результирующую матрицу;
//2. uint NormType - тип норм строк матрицы;
//3. uint p - параметр для p-норм строк матрицы (by default p=0)
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::NormalizeRows(rmatrix& A, uint NormType, uint p) const
{rvector Norms;
 //Определение норм всех строк матрицы
 if (NormAllRows(Norms,NormType,p) == false) {A.Set(0L,0L,false); return false;}
 //Поиск нормы равной 0
 for (ulong i = 0L; i < Norms.Size(); i++)
 {if (Norms.Get(i) == 0.0) {A.Set(0L,0L,false); return false;}}
 //Построчное нормирование матрицы
 A.Set(Rows(),Cols(),false);
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   A.Put(i,j,data[i][j]/Norms.Get(i));
 return true;
}
//***********************************************************************************
//СТАТУС: I.18, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool NormalizeRows(uint NormType, uint p=0)
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ ПО КАЖДОЙ СТРОКЕ
//Во-первых, функция определяет нормы всех строк матрицы, затем каждая строка матрицы
//делится на норму данной строки. Тип нормы определяется переменной type. Аргумент p
//необходим для определения p-нормы матрицы. Исходная матрица при нормировании изме-
//няется. Если какая-либо норма строки матрицы равна 0, то возвращается false и нор-
//мирование не осуществляется.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint NormType - тип норм строк матрицы;
//2. uint p - параметр для p-норм строк матрицы (by default p=0)
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - норма матрицы заданного типа
//***********************************************************************************
bool TRealMatrix::NormalizeRows(uint NormType, uint p)
{rvector Norms;
 //Определение норм всех строк матрицы
 if (NormAllRows(Norms,NormType,p) == false) return false;
 //Поиск нормы равной 0
 for (ulong i = 0L; i < Norms.Size(); i++) {if (Norms.Get(i) == 0.0) return false;}
 //Построчное нормирование матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = data[i][j]/Norms.Get(i);
 return true;
}
//***********************************************************************************
//СТАТУС: I.19, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool NormalizeRowsToDB(rmatrix& A, bool Power=true, double MindB=-60) const
//НАЗНАЧЕНИЕ: ПОСТРОЧНОЕ НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ в ДЕЦИБЕЛАХ
//С этой целью, во-первых, вычисляются первые нормы каждой строки матрицы. Во-вторых,
//каждая строка матрицы делится на норму для этой строки. В-третьих, элементы матрицы
//логарифмируются:
//a) Power = true: 10*log10(R(i,j));
//b) Power = false: 20*log10(R(i,j)).
//Все элементы матрицы должны быть ПОЛОЖИТЕЛЬНЫМИ, (data(i,j) > 0), иначе функция воз-
//вращает false и построчное нормирование в dB не осуществляется. При попытке норми-
//ровки матрицы нулевого размера функция возвращает false.
//Функция не изменяет исходную матрицу, результаты нормировки заносятся в матрицу A,
//передаваемую по ссылке.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& A - ссылка на результирующую матрицу
//2. bool Power (true) - опция логарифмирования (по мощности или напряжению)
//3. double MindB (-60 dB) - минимальный пороговый уровень
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::NormalizeRowsToDB(rmatrix& A, bool Power, double MindB) const
{if (IsZeroSize()) {A.Set(0L,0L,false); return false;}//Матрица нулевого размера
 //Определение первых норм строк с поиском отрицательных или нулевых значений
 rvector Norm(Rows(),ROW);
 bool Negative = false;
 for (ulong i = 0L; i < Rows(); i++)
 {double Max = 0.0;
  for (ulong j = 0L; j < Cols(); j++)
  {if (data[i][j] < 0) {Negative = true; break;}
   if (Max < data[i][j]) Max = data[i][j];
  }
  if ((Negative) || (Max == 0.0)) {A.Set(0L,0L,false); return false;}
  Norm.Put(i,Max);
 }
 A.Set(Rows(),Cols(),false);
 //Нормирование компонент матрицы A в пределах (0..1]
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   A.Put(i,j,data[i][j]/Norm.Get(i));
 //Нормирование в dB с установкой нижнего порогового уровня [0..MindB]
 double value;
 MindB = (MindB >= 0.0) ? -60.0 : MindB;
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
  {value = A.Get(i,j);
   if (fabs(value) == 0.0) A.Put(i,j,MindB);//Нулевое значение
   else
   {value = (Power) ? 10*log10(value) : 20*log10(value);
    if (value < MindB) value = MindB;
    A.Put(i,j,value);
   }
  }
 return true;
}
//***********************************************************************************
//СТАТУС: I.20, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//  bool NormalizeRowsToDB(bool Power = true, double MindB = -60)
//НАЗНАЧЕНИЕ: ПОСТРОЧНОЕ НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ в ДЕЦИБЕЛАХ
//С этой целью, во-первых, вычисляются первые нормы каждой строки матрицы.
//Во-вторых, каждая строка матрицы делится на норму для этой строки.
//В-третьих, элементы матрицы логарифмируются:
//a) Power = true: 10*log10(R(i,j));
//b) Power = false: 20*log10(R(i,j)).
//Все элементы матрицы должны быть ПОЛОЖИТЕЛЬНЫМИ, (R(i,j) > 0), иначе функция
//возвращает false и построчное нормирование в dB не осуществляется.
//При попытке нормировки матрицы нулевого размера функция возвращает false.
//Функция изменяет исходную матрицу при проведении построчного нормирования.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. bool Power (true) - опция логарифмирования (по мощности или напряжению)
//2. double MindB (-60 dB) - минимальный пороговый уровень
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::NormalizeRowsToDB(bool Power, double MindB)
{if (IsZeroSize()) return false;//Матрица нулевого размера
 //Определение первых норм строк с поиском отрицательных или нулевых значений
 rvector Norm(Rows(),ROW);
 bool Negative = false;
 for (ulong i = 0L; i < Rows(); i++)
 {double Max = 0.0;
  for (ulong j = 0L; j < Cols(); j++)
  {if (data[i][j] < 0) {Negative = true; break;}
   if (Max < data[i][j]) Max = data[i][j];
  }
  if ((Negative) || (Max == 0.0)) return false;
  Norm.Put(i,Max);
 }
 //Нормирование компонент матрицы в пределах (0..1]
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = data[i][j]/Norm.Get(i);
 //Нормирование в dB с установкой нижнего порогового уровня [0..MindB]
 double value;
 MindB = (MindB >= 0.0) ? -60.0 : MindB;
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {value = data[i][j];
   if (fabs(value) == 0.0) data[i][j] = MindB;//Нулевое значение
   else
   {value = (Power) ? 10*log10(value) : 20*log10(value);
    if (value < MindB) value = MindB;
    data[i][j] = value;
   }
  }
 return true;
}
//***********************************************************************************
//СТАТУС: I.21, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool NormalizeCols(rmatrix& A, uint NormType, uint p=0) const
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ ПО КАЖДОМУ СТОЛБЦУ
//Во-первых, определяются нормы всех столбцов матрицы, затем каждая столбец матрицы
//делится на норму данного столбца. Тип нормы определяется переменной type. Аргумент
//p необходим для определения p-нормы матрицы. Исходная матрица при нормировании не
//изменяется, так как все операции производятся с матрицей A, в которую копируется
//исходная матрица. Если какая-либо норма столбца матрицы равна 0, то возвращается
//false, а матрица A становится матрицей нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& A - ссылка на результирующую матрицу;
//2. uint NormType - тип норм столбцов матрицы;
//3. uint p - параметр для p-норм столбцов матрицы (by default p=0)
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::NormalizeCols(rmatrix& A, uint NormType, uint p) const
{rvector Norms;
 //Определение норм всех столбцов матрицы
 if (NormAllCols(Norms,NormType,p) == false) {A.Set(0L,0L,false); return false;}
 //Поиск нормы равной 0
 for (ulong i = 0L; i < Norms.Size(); i++)
 {if (Norms.Get(i) == 0.0) {A.Set(0L,0L,false); return false;}}
 //Постолбцовое нормирование матрицы
 A.Set(Rows(),Cols(),false);
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   A.Put(i,j,data[i][j]/Norms.Get(j));
 return true;
}
//***********************************************************************************
//СТАТУС: I.22, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool NormalizeCols(uint NormType, uint p=0)
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ ПО КАЖДОМУ СТОЛБЦУ
//Во-первых, определяются нормы всех столбцов матрицы, затем каждый столбец матрицы
//делится на норму данного столбца. Тип нормы определяется переменной type. Аргумент
//p необходим для определения p-нормы матрицы. Исходная матрица при постолбцовом нор-
//мировании изменяется. Если какая-либо норма столбца матрицы равна 0, то возвращается
//false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint NormType - тип норм столбцов матрицы;
//2. uint p - параметр для p-норм столбцов матрицы (by default p=0)
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::NormalizeCols(uint NormType, uint p)
{rvector Norms;
 //Определение норм всех столбцов матрицы
 if (NormAllCols(Norms,NormType,p) == false) return false;
 //Поиск нормы равной 0
 for (ulong i = 0L; i < Norms.Size(); i++)
 {if (Norms.Get(i) == 0.0) return false;}
 //Постолбцовое нормирование матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = data[i][j]/Norms.Get(j);
 return true;
}
//***********************************************************************************
//СТАТУС: I.23, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool NormalizeColsToDB(rmatrix& A, bool Power=true, double MindB=-60) const
//НАЗНАЧЕНИЕ: ПОСТОЛБЦОВОЕ НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ в ДЕЦИБЕЛАХ
//С этой целью, во-первых, вычисляются первые нормы каждого столбца матрицы. Во-вторых,
//каждый столбец матрицы делится на норму для этой столбца. В-третьих, элементы матрицы
//логарифмируются:
//a) Power = true: 10*log10(R(i,j));
//b) Power = false: 20*log10(R(i,j)).
//Все элементы матрицы должны быть ПОЛОЖИТЕЛЬНЫМИ, (data(i,j) > 0), иначе функция воз-
//вращает false и постолбцовое нормирование в dB не осуществляется. При попытке норми-
//ровки матрицы нулевого размера функция возвращает false. Функция не изменяет исход-
//ную матрицу, результаты нормировки заносятся в матрицу A, передаваемую по ссылке.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& A - ссылка на результирующую матрицу
//2. bool Power (true) - опция логарифмирования (по мощности или напряжению)
//3. double MindB (-60 dB) - минимальный пороговый уровень
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::NormalizeColsToDB(rmatrix& A, bool Power, double MindB) const
{if (IsZeroSize()) {A.Set(0L,0L,false); return false;}//Матрица нулевого размера
 //Определение первых норм столбцов с поиском отрицательных или нулевых значений
 rvector Norm(Cols(),COL);
 bool Negative = false;
 for (ulong j = 0L; j < Cols(); j++)
 {double Max = 0.0;
  for (ulong i = 0L; i < Rows(); i++)
  {if (data[i][j] < 0.0) {Negative = true; break;}
   if (Max < data[i][j]) Max = data[i][j];
  }
  if ((Negative) || (Max == 0.0)) {A.Set(0L,0L,false); return false;}
  Norm.Put(j,Max);
 }
 A.Set(Rows(),Cols(),false);
 //Нормирование компонент матрицы A в пределах (0..1]
 for (ulong j = 0L; j < Cols(); j++)
  for (ulong i = 0L; i < Rows(); i++)
   A.Put(i,j,data[i][j]/Norm.Get(j));
 //Нормирование в dB с установкой нижнего порогового уровня [0..MindB]
 double value;
 MindB = (MindB >= 0.0) ? -60.0 : MindB;
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
  {value = A.Get(i,j);
   if (fabs(value) == 0.0) A.Put(i,j,MindB);//Нулевое значение
   else
   {value = (Power) ? 10*log10(value) : 20*log10(value);
    if (value < MindB) value = MindB;
    A.Put(i,j,value);
   }
  }
 return true;
}
//***********************************************************************************
//СТАТУС: I.24, TRealVector class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool NormalizeColsToDB(bool Power=true, double MindB=-60)
//НАЗНАЧЕНИЕ: ПОСТОЛБЦОВОЕ НОРМИРОВАНИЕ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ в ДЕЦИБЕЛАХ
//С этой целью, во-первых, вычисляются первые нормы каждого столбца матрицы. Во-вторых,
//каждый столбец матрицы делится на норму для этой столбца. В-третьих, элементы матрицы
//логарифмируются:
//a) Power = true: 10*log10(data(i,j));
//b) Power = false: 20*log10(data(i,j)).
//Все элементы матрицы должны быть ПОЛОЖИТЕЛЬНЫМИ, (data(i,j) > 0), иначе функция воз-
//вращает false и постолбцовое нормирование в dB не осуществляется. При попытке норми-
//ровки матрицы нулевого размера функция возвращает false. Функция изменяет исходную
//матрицу при постолбцовом нормировании.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. bool Power (true) - опция логарифмирования (по мощности или напряжению)
//2. double MindB (-60 dB) - минимальный пороговый уровень
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TRealMatrix::NormalizeColsToDB(bool Power, double MindB)
{if (IsZeroSize()) return false;//Матрица нулевого размера
 //Определение первых норм столбцов с поиском отрицательных или нулевых значений
 rvector Norm(Cols(),COL);
 bool Negative = false;
 for (ulong j = 0L; j < Cols(); j++)
 {double Max = 0.0;
  for (ulong i = 0L; i < Rows(); i++)
  {if (data[i][j] < 0.0) {Negative = true; break;}
   if (Max < data[i][j]) Max = data[i][j];
  }
  if ((Negative) || (Max == 0.0)) return false;
  Norm.Put(j,Max);
 }
 //Нормирование компонент матрицы в пределах (0..1]
 for (ulong j = 0L; j < Cols(); j++)
  for (ulong i = 0L; i < Rows(); i++)
   data[i][j] = data[i][j]/Norm.Get(j);
 //Нормирование в dB с установкой нижнего порогового уровня [0..MindB]
 double value;
 MindB = (MindB >= 0.0) ? -60.0 : MindB;
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {value = data[i][j];
   if (fabs(value) == 0.0) data[i][j] = MindB;//Нулевое значение
   else
   {value = (Power) ? 10*log10(value) : 20*log10(value);
    if (value < MindB) value = MindB;
    data[i][j] = value;
   }
  }
 return true;
}

//-----------------------------------------------------------------------------------
//Реализация операций линейной алгебры перегрузкой операторов (+-*/) для TRealMatrix
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: I.1, friend function of the TRealMatrix class
//OVERLOADING ADDITION OPERATION (+) by Increasing Matrix on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend rmatrix operator +(const double value, const rmatrix& A)
//НАЗНАЧЕНИЕ: УВЕЛИЧЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Операция сложения матрицы с действительным числом. Число прибавляется слева.
//B = const + A, B(i,j) = A(i,j) + const
//Для осуществления операции сложения матрицы с числом необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОГО РАЗМЕРА.
//Если условие не выполняется, то возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const double value - вещественное число, складываемое с матрицей.
//2. const rmatrix& A - ссылка на вещественную матрицу, к компонентам которой
//   добавляется вещественное число value.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - матрица A, увеличенная на значение value
//***********************************************************************************
rmatrix operator +(const double value, const rmatrix& A)
{if (A.IsZeroSize()) return A;//Матрица нулевого размера
 //Конструирование результирующей матрицы
 rmatrix result(A.Rows(),A.Cols(),false);
 //Цикл увеличения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)+value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.2, friend function of the TRealMatrix class
//OVERLOADING ADDITION OPERATION (+) by Increasing Matrix on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend rmatrix operator +(const rmatrix& A, const double value)
//НАЗНАЧЕНИЕ: УВЕЛИЧЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Операция сложения матрицы с действительным числом. Число прибавляется справа.
//B = A + const, B(i,j) = A(i,j) + const
//Для осуществления операции сложения матрицы с числом необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОГО РАЗМЕРА.
//Если условие не выполняется, то возвращается матрица нулевого размера.
//Результатом сложения матрицы с числом всегда является МАТРИЦА.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& A - ссылка на вещественную матрицу, к компонентам которой
//   добавляется вещественное число value.
//2. const double value - вещественное число, складываемое с матрицей.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - матрица A, увеличенная на значение value
//***********************************************************************************
rmatrix operator +(const rmatrix& A, const double value)
{if (A.IsZeroSize()) return A;//Матрица нулевого размера
 //Конструирование результирующей матрицы
 rmatrix result(A.Rows(),A.Cols(),false);
 //Цикл увеличения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)+value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.3, friend function of the TRealMatrix class
//OVERLOADING DECREASE OPERATION (-) by Decreasing Matrix on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend rmatrix operator -(const rmatrix& A, const double value)
//НАЗНАЧЕНИЕ: УМЕНЬШЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Операция вычитания из компонент матрицы действительного числа value. Действительное
//число value должно располагаться ТОЛЬКО СПРАВА от матрицы A.
// B = A - const, B(i,j) = A(i,j) - const
//Для осуществления операции вычитания из матрицы числа необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОГО РАЗМЕРА.
//Если условие не выполняется, то возвращается матрица нулевого размера. Результатом
//вычитания из матрицы числа всегда является МАТРИЦА.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& A - ссылка на вещественную матрицу, компоненты которой
//   уменьшаются на вещественное число value.
//2. const double value - вещественное число, вычитаемое из матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - матрица A, уменьшенная на значение value
//***********************************************************************************
rmatrix operator -(const rmatrix& A, const double value)
{if (A.IsZeroSize()) return A;//Матрица нулевого размера
 //Конструирование результирующей матрицы
 rmatrix result(A.Rows(),A.Cols(),false);
 //Цикл уменьшения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; i < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)-value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.4, friend function of the TRealMatrix class
//OVERLOADING MULTIPLICATION OPERATION (*) by Multiply Matrix to the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend rmatrix operator *(const double value, const rmatrix& A)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Операция умножения матрицы на действительное число. Число умножается слева:
// B = const * A, B(i,j) = A(i,j) * const
//Для осуществления операции умножения матрицы на число необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОГО РАЗМЕРА.
//Если условие не выполняется, то возвращается матрица нулевого размера. Результатом
//умножения матрицы на число всегда является МАТРИЦА.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const double value - вещественное число, умножаемое на матрицу.
//2. const rmatrix& A - ссылка на вещественную матрицу, компоненты которой
//   умножаются на вещественное число value.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - матрица А, умноженная на значение value
//***********************************************************************************
rmatrix operator *(const double value, const rmatrix& A)
{if (A.IsZeroSize()) return A;//Матрица нулевого размера
 //Конструирование результирующей матрицы
 rmatrix result(A.Rows(),A.Cols(),false);
 //Цикл умножения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)*value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.5, friend function of the TRealMatrix class
//OVERLOADING MULTIPLICATION OPERATION (*) by Multiply Matrix to the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend rmatrix operator *(const rmatrix& A, const double value)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Операция умножения матрицы на действительное число. Число умножается справа:
// B = A * const, B(i,j) = A(i,j) * const
//Для осуществления операции умножения матрицы на число необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОГО РАЗМЕРА.
//Если условие не выполняется, то возвращается матрица нулевого размера. Результатом
//умножения матрицы на число всегда является МАТРИЦА.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& A - ссылка на вещественную матрицу, компоненты которой
//   умножаются на вещественное число value.
//2. const double value - вещественное число, умножаемое на матрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - матрица А, умноженная на значение value
//***********************************************************************************
rmatrix operator *(const rmatrix& A, const double value)
{if (A.IsZeroSize()) return A;//Матрица нулевого размера
 //Конструирование результирующей матрицы
 rmatrix result(A.Rows(),A.Cols(),false);
 //Цикл умножения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)*value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.6, public function of the TRealMatrix class
//OVERLOADING DIVISION OPERATION (/) by Dividing Matrix on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix operator /(const double value) const
//НАЗНАЧЕНИЕ: ДЕЛЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Операция деления матрицы на действительное число. Операция деления некоммутативна и
//делитель - число value - должно быть расположено слева от вещественной матрицы.
//B = A / const, B(i,j) = A(i,j) / const
//Для осуществления операции деления матрицы на число необходимо два условия:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕГО РАЗМЕРА.
//2. Делитель value не должен быть РАВНЫМ НУЛЮ.
//Если условия не выполняются, то возвращается матрица нулевого размера. Результатом
//умножения матрицы на число всегда является МАТРИЦА.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const double value - число, делимое на матрицу
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - матрица A, поделенная на value
//***********************************************************************************
rmatrix TRealMatrix::operator /(const double value) const
{rmatrix result;
 if (IsZeroSize()) return result;//Матрица нулевого размера
 //Попытка деления на ноль
 if (fabs(value) < EPS) return result;
 result.Set(Rows(),Cols(),false);//Создание результирующей матрицы
 //Цикл деления компонент матрицы A на величину value
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(i,j,data[i][j]/value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.7; public; TRealMatrix class overloading operator +
//OVERLOADING ADDITION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix operator +(const TRealMatrix& A) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СЛОЖЕНИЯ ДВУХ МАТРИЦ.
//Перегрузка оператора (+) с целью сложения двух вещественных матриц A и B:
// C = A + B, C(i,j) = A(i,j) + B(i,j).
//При сложении двух матриц должны выполняться следующие правила:
//1. Матрицы не должны быть матрицами НУЛЕВОГО РАЗМЕРА;
//2. Матрицы должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ:
//   A.Rows() == B.Rows() || A.Cols() == B.Cols()
//Если данные условия не выполняются, то возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TRealMatrix& A - ссылка на складываемую матрицу
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - матрица суммы двух матриц.
//***********************************************************************************
rmatrix TRealMatrix::operator +(const TRealMatrix& A) const
{rmatrix result;
 //Матрица (матрицы) нулевого размера
 if ((IsZeroSize()) || (A.IsZeroSize())) return result;
 //Матрицы разных размерностей
 if ((Rows() != A.Rows()) || (Cols() != A.Cols())) return result;
 result.Set(Rows(),Cols(),false);//Создание результирующей матрицы
 //Операция сложения двух матриц
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
    result.Put(i,j,data[i][j]+A.Get(i,j));
 return result; //Матрица суммы двух матриц
}
//***********************************************************************************
//СТАТУС: I.8; public; TRealMatrix class overloading operator -
//OVERLOADING SUBTRACTION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix operator -(const TRealMatrix& A) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЧИТАНИЯ ДВУХ МАТРИЦ
//Перегрузка оператора (-) с целью вычитания двух вещественных матриц A и B:
// C = A - B, C(i,j) = A(i,j) - B(i,j).
//При вычитании двух матриц должны выполняться следующие правила:
//1. Матрицы не должны быть матрицами НУЛЕВОГО РАЗМЕРА;
//2. Матрицы должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ:
//   A.Rows() == B.Rows() || A.Cols() == B.Cols()
//Если данные условия не выполняются, то возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TRealMatrix& A - ссылка на вычитаемую матрицу
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - матрица разности двух матриц.
//***********************************************************************************
rmatrix TRealMatrix::operator -(const TRealMatrix& A) const
{rmatrix result;
 //Матрица (матрицы) нулевого размера
 if ((IsZeroSize()) || (A.IsZeroSize())) return result;
 //Матрицы разной размерности
 if ((Rows() != A.Rows()) || (Cols() != A.Cols())) return result;
 result.Set(Rows(),Cols(),false);//Создание результирующей матрицы
 //Операция вычитания двух матриц
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
    result.Put(i,j,data[i][j]-A.Get(i,j));
 return result; //Матрица разности двух матриц
}
//***********************************************************************************
//СТАТУС: I.9; public; TRealMatrix class overloading operator *
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix operator *(const TRealMatrix& A) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ ДВУХ ВЕЩЕСТВЕННЫХ МАТРИЦ.
//Перегрузка оператора (*) с целью умножения двух вещественных матриц A(m x n) и
//B(n x p): C(m x p) = A(m x n) * B(n x p), где каждый элемент матрицы С вычисляется
//по формуле: C(i,j) = SUM{A(i,k)*B(k,j) by k, 0 <= k < n}
//Правила умножения матрицы на матрицу следующие:
//1. Количество СТОЛБЦОВ матрицы слева A(m x n) должно быть РАВНО количеству СТРОК
//   матрицы справа B(n x p).
//2. Размерности матриц A & B не должны быть нулевыми.
//3. При умножении матриц согласно правил 1 и 2 всегда получается МАТРИЦА размерности
//   равной числу СТРОК матрицы слева и числу СТОЛБЦОВ матрицы справа:
//   C(m x p) = A(m x n) * B(n x p).
//Если условия 1, 2 не выполняются, то возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TRealMatrix& A - ссылка на умножаемую матрицу справа
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - матрица умножения двух матриц
//***********************************************************************************
rmatrix TRealMatrix::operator *(const TRealMatrix& A) const
{rmatrix result;
 //Матрица (матрицы) нулевого размера
 if ((IsZeroSize()) || (A.IsZeroSize())) return result;
 //Операция умножения производится с матрицами неподходящих для умножения
 //размерностей
 if (Cols() != A.Rows()) return result;
 result.Set(Rows(),A.Cols(),false);
 //Операция перемножения двух матриц
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
  {double sum = 0.0;
   for (ulong k = 0L; k < Cols(); k++) sum += data[i][k]*A.Get(k,j);
   result.Put(i,j,sum);
  }
 return result; //Матрица перемножения двух матриц
}
//***********************************************************************************
//СТАТУС: I.10; public; TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool MultByTransposedMatrixOnRight(rmatrix& A) const
//НАЗНАЧЕНИЕ: Умножение матрицы на свою транспонированную матрицу справа:
// B(m x m) = A * trA = A(m x n) * trA(n x m).
//В этом случае получается квадратная матрица с размерностью равной числу строк исход-
//ной матрицы. Результат умножения размещается в матрице A, передаваемой по ссылке.
//Элементы и размерность исходной матрицы функцией не изменяются.
//Умножение A*trA дает квадратную симметрическую матрицу, поэтому вычисляются только
//диагональные и поддиагональные элементы результирующей матрицы. Далее наддиагональным
//элементам присваиваются соответствующие им поддиагональные элементы. Такой алгоритм
//уменьшает время вычисления произведения матриц A*trA по сравнению с общим алгоритмом
//умножения матриц (N^2+N против N^3 операций умножения в общем случае).
//Функция возвращает false и прекращает свою работу, если адреса исходной и результи-
//рующей A матриц совпадают (одна и та же матрица).
//Функция формирует матрицу A нулевого размера и возвращает false в cлучаях:
//1) Исходная матрица - матрица нулевого размера;
//2) Операционная система не может выделить память под размещение элементов
//   результирующей матрицы A^2 = A x A.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TRealMatrix& A - ссылка на результирующую матрицу A*trA
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения операции A*trA
//***********************************************************************************
bool TRealMatrix::MultByTransposedMatrixOnRight(TRealMatrix& A) const
{//Исходная и результирующая матрица совпадают (по адресам)
 if (this == &A) return false;
 //Матрица (матрицы) нулевого размера
 if (IsZeroSize()) {A.Set(0L,false); return false;}
 //Создание результирующей квадратной матрицы A c размерностью Rows()
 if (!A.Set(Rows(),false)) return false;
 //Операция перемножения матрицы на транспонированную к ней матрицу справа A*trA
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j <= i; j++)
  {double sum = 0.0;
   for (ulong k = 0; k < Cols(); k++) sum += data[i][k]*data[j][k];
   A.Put(i,j,sum);
   if (i != j) A.Put(j,i,sum);
  }
 return true; //Матрица вида A*trA вычислена успешно
}
//***********************************************************************************
//СТАТУС: I.11; public; TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix& MultByTransposedMatrixOnLeft(rmatrix& A) const
//НАЗНАЧЕНИЕ: Умножение матрицы на свою транспонированную матрицу слева:
// B(n x n) = trA * A = trA(n x m) * A(m x n).
//В этом случае получается квадратная матрица с размерностью равной числу столбцов
//исходной матрицы. Результат умножения размещается в матрице A, передаваемой по ссылке.
//Элементы и размер исходной матрицы функцией не изменяются.
//При умножении trA*A получается квадратная симметрическая матрица, поэтому вычисляются
//только диагональные и поддиагональные элементы произведения. Далее наддиагональным
//элементам присваиваются соответствующие им поддиагональные элементы. Такой алгоритм
//уменьшает время вычисления произведения trA*A по сравнению с общим алгоритмом умно-
//жения двух матриц (N^2+N операций умножения против N^3).
//Функция возвращает false и прекращает свою работу, если адреса исходной и результи-
//рующей A матриц совпадают (одна и та же матрица).
//Функция формирует матрицу A нулевого размера и возвращает false в cлучаях:
//1) Исходная матрица - матрица нулевого размера;
//2) Операционная система не может выделить память под размещение элементов
//   результирующей матрицы A^2 = A x A.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TRealMatrix& A - ссылка на результирующую матрицу trA*A
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения операции A*trA
//***********************************************************************************
bool TRealMatrix::MultByTransposedMatrixOnLeft(TRealMatrix& A) const
{//Исходная и результирующая матрица совпадают (по адресам)
 if (this == &A) return false;
 //Матрица (матрицы) нулевого размера
 if (IsZeroSize()) {A.Set(0L,false); return false;}
 //Создание результирующей квадратной матрицы A c размерностью Cols()
 if (!A.Set(Cols(),false)) return false;
 //Операция перемножения матрицы на транспонированную к ней матрицу слева trA*A
 for (ulong i = 0; i < Cols(); i++)
  for (ulong j = 0; j <= i; j++)
  {double sum = 0.0;
   for (ulong k = 0; k < Rows(); k++) sum += data[k][i]*data[k][j];
   A.Put(i,j,sum);
   if (i != j) A.Put(j,i,sum);
  }
 return true; //Матрица вида trA*A вычислена успешно
}
//***********************************************************************************
//СТАТУС: I.12; public; TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Squaring(rmatrix& A, bool lSymmetrical = false) const
//НАЗНАЧЕНИЕ: ВОЗВЕДЕНИЕ КВАДРАТНОЙ МАТРИЦЫ В КВАДРАТ: A^2 = A x A
//Функция возводит исходную квадратную матрицу в квадрат. Результат операции помещается
//в матрицу A, передаваемую по ссылке. Опция lSymmetrical (true) позволяет учесть
//свойства симметричности матрицы при умножении ее саму на себя. Для симметрической
//матрицы: A = trA, при умножении A x trA или trA x A (для квадратной симметрической
//матрицы умножения слева или справа на ее транспонированную матрицу эквивалентны)
//количество операций умножения - N^2+N меньше, если матрица A несимметрическая, то
//количество операций умножения - N^3. Опция lSymmetrical устанавливается пользовате-
//лем и функция НЕ ПРОВЕРЯЕТ исходную матрицу на СИММЕТРИЧНОСТЬ c целью уменьшения
//времени вычислений. По умолчанию исходная матрица считается несимметрической.
//Функция не изменяет размерности и элементов исходной матрицы, матрица A изменяется
//функцией.
//Функция возвращает false и прекращает свою работу, если адреса исходной и результи-
//рующей матриц совпадают (одна и та же матрица).
//Функция возвращает матрицу A нулевого размера в следующих случаях:
//1) Исходная матрица - матрица нулевого размера;
//2) Исходная матрица не является КВАДРАТНОЙ;
//3) Операционная система не может выделить память под размещение элементов
//   результирующей матрицы A^2 = A x A.
//Функция возвращает false, если результирующая матрица - матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: TRealMatrix& A - ссылка на матрицу, в которой формируется
//результат возведения в квадрат исходной матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат возведения
//***********************************************************************************
bool TRealMatrix::Squaring(TRealMatrix& A, bool lSymmetrical) const
{//Результирующая матрица совпадает с исходной
 if (this == &A) return false;
 //Проверка на возможность возведения матрицы в квадрат
 if (IsZeroSize() || IsRectang()) {A.Set(0L,false); return false;}
 //Создание результирующей квадратной матрицы A c размерностью Rows()
 if (!A.Set(Rows(),false)) return false;
 //----------------------------------------------------------------------------------
 //Возведение квадратной матрицы в квадрат
 //----------------------------------------------------------------------------------
 //Исходная матрица - симметрическая A*trA (N^2+N операций умножения)
 if (lSymmetrical)
 {for (ulong i = 0; i < Rows(); i++)
   for (ulong j = 0; j <= i; j++)
   {double sum = 0.0;
    for (ulong k = 0; k < Cols(); k++) sum += data[i][k]*data[j][k];
    A.Put(i,j,sum);
    if (i != j) A.Put(j,i,sum);
   }
 }
 else //Исходная матрица - несимметрическая A*A (N^3 операций умножения)
 {for (ulong i = 0; i < Rows(); i++)
   for (ulong j = 0; j < Cols(); j++)
   {double sum = 0.0;
    for (ulong k = 0; k < Cols(); k++) sum += data[i][k]*data[k][j];
    A.Put(i,j,sum);
   }
 }
 return true; //Исходная матрица возведена в квадрат
}
//***********************************************************************************
//СТАТУС: I.12, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix MultByCols(const rvector& V) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ ВСЕХ СТОЛБЦОВ МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
//            ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Функция последовательно перемножает все столбцы матрицы на значения элементов вектора.
//Размерность вектора должна быть равна количеству строк матрицы. Результатом работы
//функции является действительная матрица, совпадающая по размерам с исходной матрицей.
//Функция не изменяет значений и структуры исходной матрицы, так как все операции пе-
//ремножения значений элементов матрицы на значения элементов вектора происходят с ее
//копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const rvector& V - ссылка на действительный вектор, умножаемый поэлементно на все
//столбцы исходной матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rmatrix result - результирующая матрица поэлементного умножения столбцов исходной
// матрицы на значения элементов действительного вектора.
//***********************************************************************************
rmatrix TRealMatrix::MultByCols(const rvector& V) const
{rmatrix result;
 //Проверка на выполнение условий поэлементного умножения столбцов исходной матрицы
 //на значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows()))
  return result;
 //Поэлементное умножение всех столбцов исходной матрицы на вектор V
 result.Set(Rows(),Cols(),false);
 for (ulong j = 0L; j < Cols(); j++)
  for (ulong i = 0L; i < Rows(); i++)
   result.Put(i,j,data[i][j]*V.Get(i));
 return result;
}
//***********************************************************************************
//СТАТУС: I.13, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix MultByCols(const rvector& V, ulong index) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ СТОЛБЦА МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
//            ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Функция перемножает столбец матрицы с индексом index на значения элементов вектора V.
//Размерность вектора должна быть равна количеству строк матрицы. Результатом работы
//функции является действительная матрица, совпадающая по размерам с исходной матрицей.
//Функция не изменяет значений и структуры исходной матрицы, так как все операции пе-
//ремножения значений элементов матрицы на значения элементов вектора происходят с ее
//копией. Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы;
//4. Значение индекса столбца index является недопустимым для данной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на действительный вектор, умножаемый поэлементно
//   на столбец исходной матрицы с индексом index;
//2. ulong index - индекс столбца, перемножаемого поэлементно с вектором V.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rmatrix result - результирующая матрица поэлементного умножения столбца с индексом
// index матрицы на значения элементов действительного вектора.
//***********************************************************************************
rmatrix TRealMatrix::MultByCols(const rvector& V, ulong index) const
{rmatrix result;
 //Проверка на выполнение условий поэлементного умножения столбца исходной матрицы на
 //значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows()) || (index >= Cols()))
  return result;
 //Поэлементное умножение столбца с индексом index исходной матрицы на вектор V
 result = *this;
 for (ulong i = 0L; i < Rows(); i++) result.Put(i,index,data[i][index]*V.Get(i));
 return result;
}
//***********************************************************************************
//СТАТУС: I.14, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rmatrix MultByCols(const rvector& V, ulong left, ulong right) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ СТОЛБЦОВ МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
//            ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА, РАСПОЛОЖЕННЫХ В ИНТЕРВАЛЕ [left..right]
//Функция перемножает столбцы матрицы с индексами, расположенными последовательно в
//интервале целых чисел [left..right], на значения элементов вектора V. Размерность
//вектора должна быть равна количеству строк матрицы. Аргумент left определяет началь-
//ное значение интервала индексов столбцов, а аргумент right - конечное значение интер-
//вала индексов столбцов, элементы которых перемножаются на вектор V.
//Результатом работы функции является действительная матрица, совпадающая по размерам
//с исходной матрицей. Функция не изменяет значений и структуры исходной матрицы, так
//как все операции перемножения значений элементов матрицы на значения элементов вектора
//происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы;
//4. Значения индексов left или right являются недопустимыми для данной матрицы;
//5. Значение индекса left > right.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на действительный вектор, умножаемый поэлементно на
//   столбцы с индексами исходной матрицы, расположенными в интервале [left..right];
//2. ulong left - начальное значение интервала индексов столбцов, перемножаемых
//   поэлементно с вектором V.
//3. ulong right - конечное значение интервала индексов столбцов, перемножаемых
//   поэлементно с вектором V.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rmatrix result - результирующая матрица поэлементного умножения столбцов матрицы на
// значения элементов действительного вектора, индексы которых расположены в интервале
// [left..right].
//***********************************************************************************
rmatrix TRealMatrix::MultByCols(const rvector& V, ulong left, ulong right) const
{rmatrix result;
 //Проверка на выполнение условий поэлементного умножения столбцов исходной матрицы на
 //значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows()) ||
     (left >= Cols()) || (right >= Cols()) || (left > right))
  return result;
 //Поэлементное умножение столбцов с индексами, расположенными в интервале
 //[left..right], исходной матрицы на вектор V
 result = *this;
 for (ulong j = left; j <= right ; j++)
  for (ulong i = 0L; i < Rows(); i++)
   result.Put(i,j,data[i][j]*V.Get(i));
 return result;
}
//***********************************************************************************
//СТАТУС: I.15, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//rmatrix MultByCols(const rvector& V, const ivector& index, bool check = false) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ СТОЛБЦОВ МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
// ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА, ИНДЕКСЫ КОТОРЫХ СОДЕРЖАТСЯ В ВЕКТОРЕ index
//  Функция перемножает столбцы матрицы с индексами, значения которых передаются
//целочисленным вектором index, на значения элементов вектора V. Размерность вектора V
//должна быть равна количеству строк матрицы.
//  Аргумент check указывает на проведение проверки значений индексов на соответствие
//допустимым значениям индексов столбцов исходной матрицы и формированию подвектора
//вектора index, который содержит только корректные значения индексов столбцов для
//данной матрицы. Если check = true, создается объект-предикат, который осуществляет
//селекцию корректных значений индексов, и формируется подвектор вектора index с кор-
//ректными значениями индексов. Созданный подвектор далее используется для выбора
//столбцов матрицы перемножаемых поэлементно с вектором V.
//При check = false фильтрация некорректных значений индексов не осуществляется. В этом
//случае ответственность за корректность всех значений индексов возлагается на пользо-
//вателя и при некорректном задании значения индекса, выходящего за пределы допустимого
//значения индекса столбца для данной матрицы, приведет к аварийному завершению работы
//всей программы. При check = false функция быстрее выполняет необходимые действия,
//так как не тратится время на фильтрацию некорректных значений индексов, передавемых
//вектором index.
//Результатом работы функции является действительная матрица, совпадающая по размерам
//с исходной матрицей. Функция не изменяет значений и структуры исходной матрицы, так
//как все операции перемножения значений элементов матрицы на значения элементов вектора
//происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы;
//4. Вектор index - вектор нулевого размера;
//5. При check == true, получился подвектор вектора индексов столбцов нулевого размера,
//   т.е. исходный вектор индексов столбцов index не содержал ни одного допустимого
//   значения индекса столбца для данной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на действительный вектор, умножаемый поэлементно
//   на столбцы исходной матрицы с индексами, расположенными в векторе index;
//2. const ivector& index - ссылка на вектор с индексами столбцов, перемножаемых
//   поэлементно с вектором V.
//3. bool check (false) - индикатор отбора допустимых значений индексов столбцов
//   исходной матрицы, перемножаемых поэлементно с вектором V, из вектора index.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rmatrix result - результирующая матрица поэлементного умножения столбцов на
// значения элементов действительного вектора V, индексы которых передаются через
// целочисленный вектор index.
//***********************************************************************************
rmatrix TRealMatrix::MultByCols(const rvector& V, const ivector& index, bool check) const
{rmatrix result;
 //Проверка на выполнение условий поэлементного умножения столбцов исходной матрицы на
 //значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows()) || (index.IsZeroSize()))
  return result;
 //Выбор подвектора Index корректных индексов столбцов из вектора index
 ivector Index = index;//Копирование вектора index
 if (check == ON)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Cols()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  Index = Index.Unique();
  if (Index.IsZeroSize()) return result;
 }
 //Поэлементное умножение столбцов с индексами, значения которых расположены в
 //целочисленном векторе Index, исходной матрицы на вектор V
 result = *this;//Копирование исходной матрицы
 for (ulong j = 0; j < Index.Size(); j++)
  for (ulong i = 0L; i < Rows(); i++)
   result.Put(i,Index.Get(j),data[i][Index.Get(j)]*V.Get(i));
 return result;
}
//***********************************************************************************
//СТАТУС: I.16, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix MultByRows(const rvector& V) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ ВСЕХ СТРОК МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
//            ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Функция последовательно перемножает все строки матрицы на значения элементов вектора.
//Размерность вектора должна быть равна количеству столбцов матрицы. Результатом работы
//функции является действительная матрица, совпадающая по размерам с исходной матрицей.
//Функция не изменяет значений и структуры исходной матрицы, так как все операции пе-
//ремножения значений элементов матрицы на значения элементов вектора происходят с ее
//копией. Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const rvector& V - ссылка на действительный вектор, умножаемый
// поэлементно на все строки исходной матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rmatrix result - результирующая матрица поэлементного умножения строк исходной
// матрицы на значения элементов действительного вектора.
//***********************************************************************************
rmatrix TRealMatrix::MultByRows(const rvector& V) const
{rmatrix result;
 //Проверка на выполнение условий поэлементного умножения строк исходной матрицы
 //на значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols())) return result;
 //Поэлементное умножение всех строк исходной матрицы на вектор V
 result.Set(Rows(),Cols(),false);
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(i,j,data[i][j]*V.Get(j));
 return result;
}
//***********************************************************************************
//СТАТУС: I.17, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix MultByRows(const rvector& V, ulong index) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ СТРОКИ МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
//            ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Функция перемножает строку матрицы с индексом index на значения элементов вектора V.
//Размерность вектора должна быть равна количеству столбцов матрицы. Результатом работы
//функции является действительная матрица, совпадающая по размерам с исходной матрицей.
//Функция не изменяет значений и структуры исходной матрицы, так как все операции пе-
//ремножения значений элементов матрицы на значения элементов вектора происходят с ее
//копией. Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы;
//4. Значение индекса строки index является недопустимым для данной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на действительный вектор, умножаемый поэлементно на строку
//   исходной матрицы с индексом index;
//2. ulong index - индекс строки, перемножаемого поэлементно с вектором V.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rmatrix result - результирующая матрица поэлементного умножения строки с индексом
// index матрицы на значения элементов действительного вектора.
//***********************************************************************************
rmatrix TRealMatrix::MultByRows(const rvector& V, ulong index) const
{rmatrix result;
 //Проверка на выполнение условий поэлементного умножения строки исходной матрицы на
 //значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols()) || (index >= Rows()))
  return result;
 //Поэлементное умножение строки с индексом index исходной матрицы на вектор V
 result = *this;
 for (ulong j = 0L; j < Cols(); j++) result.Put(index,j,data[index][j]*V.Get(j));
 return result;
}
//***********************************************************************************
//СТАТУС: I.18, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rmatrix MultByRows(const rvector& V, ulong left, ulong right) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ СТРОК МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
//            ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА, РАСПОЛОЖЕННЫХ В ИНТЕРВАЛЕ [left..right]
//Функция перемножает строки матрицы с индексами, расположенными последовательно в
//интервале целых чисел [left..right], на значения элементов вектора V. Размерность
//вектора должна быть равна количеству столбцов матрицы. Аргумент left определяет на-
//чальное значение интервала индексов строк, а аргумент right - конечное значение ин-
//тервала индексов строк, элементы которых перемножаются на вектор V.
//Результатом работы функции является действительная матрица, совпадающая по размерам
//с исходной матрицей. Функция не изменяет значений и структуры исходной матрицы, так
//как все операции перемножения значений элементов матрицы на значения элементов век-
//тора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы;
//4. Значения индексов left или right являются недопустимыми для данной матрицы;
//5. Значение индекса left > right.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на действительный вектор, умножаемый поэлементно на
//   строки исходной матрицы с индексами в интервале [left..right];
//2. ulong left - начальное значение интервала индексов строк, перемножаемых
//   поэлементно с вектором V.
//3. ulong right - конечное значение интервала индексов строк, перемножаемых
//   поэлементно с вектором V.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rmatrix result - результирующая матрица поэлементного умножения строк матрицы на
// значения элементов действительного вектора, индексы которых расположены в интервале
// [left..right].
//***********************************************************************************
rmatrix TRealMatrix::MultByRows(const rvector& V, ulong left, ulong right) const
{rmatrix result;
 //Проверка на выполнение условий поэлементного умножения строк исходной матрицы на
 //значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols()) || (left >= Rows()) ||
     (right >= Rows()) || (left > right))
  return result;
 //Поэлементное умножение строк с индексами, расположенными в интервале [left..right],
 //исходной матрицы на вектор V
 result = *this;
 for (ulong i = left; i <= right ; i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(i,j,data[i][j]*V.Get(j));
 return result;
}
//***********************************************************************************
//СТАТУС: I.19, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//rmatrix MultByRows(const rvector& V, const ivector& index, bool check = false) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ СТРОК МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
//            ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА, ИНДЕКСЫ КОТОРЫХ СОДЕРЖАТСЯ В ВЕКТОРЕ index
//  Функция перемножает строки матрицы с индексами, значения которых передаются цело-
//численным вектором index, на значения элементов вектора V. Размерность вектора V
//должна быть равна количеству столбцов матрицы.
//  Аргумент check указывает на проведение проверки значений индексов на соответствие
//допустимым значениям индексов строк исходной матрицы и формированию подвектора век-
//тора index, который содержит только корректные значения индексов строк для данной
//матрицы. Если check = true, создается объект-предикат, который осуществляет селекцию
//корректных значений индексов, и формируется подвектор вектора index с корректными
//значениями индексов. Созданный подвектор далее используется для выбора строк матрицы
//перемножаемых поэлементно с вектором V.
//  При check = false фильтрация некорректных значений индексов не осуществляется. В
//этом случае ответственность за корректность всех значений индексов строк возлагается
//на пользователя и при некорректном задании значения индекса, выходящего за пределы
//допустимого значения индекса строки для данной матрицы, приведет к аварийному завер-
//шению работы всей программы. При check = false функция быстрее выполняет необходимые
//действия, так как не тратится время на фильтрацию некорректных значений индексов,
//передавемых вектором index.
//Результатом работы функции является действительная матрица, совпадающая по размерам
//с исходной матрицей. Функция не изменяет значений и структуры исходной матрицы, так
//как все операции перемножения значений элементов матрицы на значения элементов век-
//тора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы;
//4. Вектор index - вектор нулевого размера;
//5. При check == true, получился подвектор вектора индексов строк нулевого размера,
//   т.е. исходный вектор индексов строк index не содержал ни одного допустимого зна-
//   чения индекса строки для данной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на действительный вектор, умножаемый поэлементно на
//   строки исходной матрицы с индексами, размещенными в векторе index;
//2. const ivector& index - ссылка на вектор с индексами строк, перемножаемых
//   поэлементно с вектором V.
//3. bool check (false) - индикатор отбора допустимых значений индексов строк исходной
//   матрицы, перемножаемых поэлементно с вектором V, из вектора index.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rmatrix result - результирующая матрица поэлементного умножения строк на значения
// элементов действительного вектора V, индексы которых передаются через целочисленный
// вектор index.
//***********************************************************************************
rmatrix TRealMatrix::MultByRows(const rvector& V, const ivector& index, bool check) const
{rmatrix result;
 //Проверка выполнения условий поэлементного умножения строк исходной матрицы на
 //значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols()) || (index.IsZeroSize()))
  return result;
 //Выбор подвектора Index корректных индексов строк из вектора index
 ivector Index = index;//Копирование вектора index
 if (check == ON)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Cols()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  Index = Index.Unique();
  if (Index.IsZeroSize()) return result;
 }
 //Поэлементное умножение строк с индексами, значения которых расположены в
 //целочисленном векторе Index, исходной матрицы на вектор V
 result = *this;
 for (ulong i = 0; i < Index.Size(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(Index.Get(i),j,data[Index.Get(i)][j]*V.Get(j));
 return result;
}
//***********************************************************************************
//СТАТУС: I.20, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix AddByCols(const rvector& V) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ ВСЕХ СТОЛБЦОВ МАТРИЦЫ С ДЕЙСТВИТЕЛЬНЫМ ВЕКТОРОМ
//Функция последовательно прибавляет ко всем столбцам матрицы вектор V. Размерность
//вектора V должна быть равна количеству строк матрицы.
//Результатом работы функции является действительная матрица, совпадающая по размерам
//с исходной матрицей. Функция не изменяет значений и структуры исходной матрицы, так
//как все операции сложения значений элементов матрицы на значения элементов вектора
//происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const rvector& V - ссылка на действительный вектор, склады-
//ваемый со всеми столбцами исходной матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rmatrix result - результирующая матрица прибавления ко всем столбцам исходной
// матрицы действительного вектора V.
//***********************************************************************************
rmatrix TRealMatrix::AddByCols(const rvector& V) const
{rmatrix result;
 //Проверка на выполнение условий поэлементного умножения столбцов исходной матрицы на
 //значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows())) return result;
 //Поэлементное умножение всех столбцов исходной матрицы на вектор V
 result.Set(Rows(),Cols(),false);
 for (ulong j = 0L; j < Cols(); j++)
  for (ulong i = 0L; i < Rows(); i++)
   result.Put(i,j,data[i][j]+V.Get(i));
 return result;
}
//***********************************************************************************
//СТАТУС: I.21, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix AddByCols(const rvector& V, ulong index) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТОЛБЦА МАТРИЦЫ С ДЕЙСТВИТЕЛЬНЫМ ВЕКТОРОМ
//Функция прибавляет к столбцу матрицы с индексом index вектор V. Размерность вектора
//V должна быть равна количеству строк матрицы. Результатом работы функции является
//действительная матрица, совпадающая по размерам с исходной матрицей. Функция не из-
//меняет значений и структуры исходной матрицы, так как все операции сложения значений
//элементов матрицы на значения элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы;
//4. Значение индекса столбца index является недопустимым для данной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на действительный вектор, складываемый со столбцом
//   исходной матрицы с индексом index;
//2. ulong index - индекс столбца, складываемого с вектором V.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rmatrix result - результирующая матрица прибавления к столбцу с индексом
// index матрицы действительного вектора.
//***********************************************************************************
rmatrix TRealMatrix::AddByCols(const rvector& V, ulong index) const
{rmatrix result;
 //Проверка на выполнение условий поэлементного умножения столбца исходной матрицы на
 //значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows()) || (index >= Cols()))
  return result;
 //Поэлементное умножение столбца с индексом index исходной матрицы на вектор V
 result = *this;
 for (ulong i = 0L; i < Rows(); i++) result.Put(i,index,data[i][index]+V.Get(i));
 return result;
}
//***********************************************************************************
//СТАТУС: I.22, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//  rmatrix AddByCols(const rvector& V, ulong left, ulong right) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТОЛБЦОВ МАТРИЦЫ С ДЕЙСТВИТЕЛЬНЫМ ВЕКТОРОМ, РАСПОЛОЖЕННЫХ
//            В ИНТЕРВАЛЕ [left..right]
//Функция  прибавляет  к столбцам матрицы с индексами, расположенными последовательно
//в интервале целых чисел [left..right], вектор V. Размерность вектора должна быть равна
//количеству строк матрицы. Аргумент left определяет начальное значение интервала
//индексов столбцов, а аргумент right - конечное значение интервала индексов столбцов,
//элементы которых складываются со значениями элементов вектора V.
//Результатом работы функции является действительная матрица, совпадающая по размерам
//с исходной матрицей. Функция не изменяет значений и структуры исходной матрицы, так
//как все операции сложения значений элементов матрицы на значения элементов вектора
//происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы;
//4. Значения индексов left или right являются недопустимыми для данной матрицы;
//5. Значение индекса left > right.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на действительный вектор, прибавляемый к столбцам
//   с индексами исходной матрицы, расположенными в интервале [left..right];
//2. ulong left - начальное значение интервала индексов столбцов, складываемых
//   с вектором V.
//3. ulong right - конечное значение интервала индексов столбцов, складываемых
//   поэлементно с вектором V.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rmatrix result - результирующая матрица сложения столбцов матрицы с действительным
// вектором V, индексы которых расположены в интервале [left..right].
//***********************************************************************************
rmatrix TRealMatrix::AddByCols(const rvector& V, ulong left, ulong right) const
{rmatrix result;
 //Проверка выполнения условий сложения столбцов исходной матрицы с вектором V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows()) ||
     (left >= Cols()) || (right >= Cols()) || (left > right))
  return result;
 //Поэлементное сложение столбцов с индексами, расположенными в интервале [left..right],
 //исходной матрицы на вектор V
 result = *this;
 for (ulong j = left; j <= right ; j++)
  for (ulong i = 0L; i < Rows(); i++)
   result.Put(i,j,data[i][j]+V.Get(i));
 return result;
}
//***********************************************************************************
//СТАТУС: I.23, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//rmatrix AddByCols(const rvector& V, const ivector& index, bool check = false) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТОЛБЦОВ МАТРИЦЫ С ДЕЙСТВИТЕЛЬНЫМ ВЕКТОРОМ, ИНДЕКСЫ КОТОРЫХ
//            СОДЕРЖАТСЯ В ВЕКТОРЕ index
//  Функция складывает столбцы матрицы с индексами, значения которых передаются цело-
//численным вектором index, с вектором V. Размерность вектора V должна быть равна ко-
//личеству строк матрицы.
//  Аргумент check указывает на проведение проверки значений индексов на соответствие
//допустимым значениям индексов столбцов исходной матрицы и формированию подвектора
//вектора index, который содержит только корректные значения индексов столбцов для
//данной матрицы. Если check = true, создается объект-предикат, который осуществляет
//селекцию корректных значений индексов, и формируется подвектор вектора index с кор-
//ректными значениями индексов. Созданный подвектор далее используется для выбора
//столбцов матрицы складываемых с вектором V. При check = false фильтрация некорректных
//значений индексов не осуществляется. В этом случае ответственность за корректность
//всех значений индексов возлагается на пользователя и при некорректном задании значе-
//ния индекса, выходящего за пределы допустимого значения индекса столбца для данной
//матрицы, приведет к аварийному завершению работы всей программы. При check = false
//функция быстрее выполняет необходимые действия, так как не тратится время на фильт-
//рацию некорректных значений индексов, передавемых вектором index.
//Результатом работы функции является действительная матрица, совпадающая по размерам
//с исходной матрицей. Функция не изменяет значений и структуры исходной матрицы, так
//как все операции сложения значений элементов матрицы на значения элементов вектора
//происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы;
//4. Вектор index - вектор нулевого размера;
//5. При check == true, получился подвектор вектора индексов столбцов нулевого размера,
//   т.е. исходный вектор индексов столбцов index не содержал ни одного допустимого
//   значения индекса столбца для данной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на действительный вектор, прибавляемый к столбцам
//   исходной матрицы с индексами, расположенными в векторе index;
//2. const ivector& index - ссылка на вектор с индексами столбцов, складываемых
//   с вектором V.
//3. bool check (false) - индикатор отбора допустимых значений индексов столбцов
//   исходной матрицы, складываемых с вектором V, из вектора index.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rmatrix result - результирующая матрица сложения столбцов с действительным
// вектором V, индексы которых передаются через целочисленный вектор index.
//***********************************************************************************
rmatrix TRealMatrix::AddByCols(const rvector& V, const ivector& index, bool check) const
{rmatrix result;
 //Проверка выполнения условий сложения столбцов исходной матрицы с вектором V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows()) || (index.IsZeroSize()))
  return result;
 //Выбор подвектора Index корректных индексов столбцов из вектора index
 ivector Index = index;//Копирование вектора index
 if (check == ON)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Cols()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  Index = Index.Unique();
  if (Index.IsZeroSize()) return result;
 }
 //Поэлементное сложение столбцов с индексами, значения которых расположены в
 //целочисленном векторе Index, исходной матрицы с вектором V
 result = *this;
 for (ulong j = 0L; j < Index.Size(); j++)
  for (ulong i = 0L; i < Rows(); i++)
   result.Put(i,Index.Get(j),data[i][Index.Get(j)]+V.Get(i));
 return result;
}
//***********************************************************************************
//СТАТУС: I.24, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix AddByRows(const rvector& V) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ ВСЕХ СТРОК МАТРИЦЫ С ДЕЙСТВИТЕЛЬНЫМ ВЕКТОРОМ
//Функция последовательно прибавляет ко всем строкам матрицы вектор V. Размерность
//вектора должна быть равна количеству столбцов матрицы. Результатом работы функции
//является действительная матрица, совпадающая по размерам с исходной матрицей. Функция
//не изменяет значений и структуры исходной матрицы, так как все операции сложения
//значений элементов матрицы на значения элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: сonst rvector& V - ссылка на действительный вектор,
//прибавляемый ко всем строкам исходной матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - результирующая матрица сложения строк
//исходной матрицы с действительным вектором.
//***********************************************************************************
rmatrix TRealMatrix::AddByRows(const rvector& V) const
{rmatrix result;
 //Проверка выполнения условий сложения строк исходной матрицы с вектором V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols())) return result;
 //Поэлементное сложение всех строк исходной матрицы на вектор V
 result.Set(Rows(),Cols(),false);
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(i,j,data[i][j]+V.Get(j));
 return result;
}
//***********************************************************************************
//СТАТУС: I.25, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix AddByRows(const rvector& V, ulong index) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТРОКИ МАТРИЦЫ С ДЕЙСТВИТЕЛЬНЫМ ВЕКТОРОМ
//Функция прибавляет к строке матрицы с индексом index вектор V. Размерность вектора
//должна быть равна количеству столбцов матрицы. Результатом работы функции является
//действительная матрица, совпадающая по размерам с исходной матрицей. Функция не из-
//меняет значений и структуры исходной матрицы, так как все операции сложения значений
//элементов матрицы на значения элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы;
//4. Значение индекса строки index является недопустимым для данной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на действительный вектор, прибавляемый к строке
//   исходной матрицы с индексом index;
//2. ulong index - индекс строки, складываемой с вектором V.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - результирующая матрица сложения строки с
//индексом index матрицы с действительным вектором.
//***********************************************************************************
rmatrix TRealMatrix::AddByRows(const rvector& V, ulong index) const
{rmatrix result;
 //Проверка выполнения условий сложения строки исходной матрицы с вектором V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols()) || (index >= Rows()))
  return result;
 //Сложение строки с индексом index исходной матрицы на вектор V
 result = *this;//Копирование исходной матрицы
 for (ulong j = 0L; j < Cols(); j++) result.Put(index,j,data[index][j]+V.Get(j));
 return result;
}
//***********************************************************************************
//СТАТУС: I.26, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rmatrix AddByRows(const rvector& V, ulong left, ulong right) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТРОК МАТРИЦЫ С ДЕЙСТВИТЕЛЬНЫМ ВЕКТОРОМ, РАСПОЛОЖЕННЫХ
//            В ИНТЕРВАЛЕ [left..right]
//Функция прибавляет к строкам матрицы с индексами, расположенными последовательно в
//интервале целых чисел [left..right], с вектором V.
//Размерность вектора должна быть равна количеству столбцов матрицы. Аргумент left
//определяет начальное значение интервала индексов строк, а аргумент right - конечное
//значение интервала индексов строк, элементы которых складываются с элементами
//вектора V.
//Результатом работы функции является действительная матрица, совпадающая по размерам
//с исходной матрицей. Функция не изменяет значений и структуры исходной матрицы, так
//как все операции сложения значений элементов матрицы на значения элементов вектора
//происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы;
//4. Значения индексов left или right являются недопустимыми для данной матрицы;
//5. Значение индекса left > right.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на действительный вектор, складываемый со строками
//   исходной матрицы с индексами в интервале [left..right];
//2. ulong left - начальное значение интервала индексов строк, складываемых с вектором V.
//3. ulong right - конечное значение интервала индексов строк, складываемых с вектором V.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - результирующая матрица сложения строк матрицы
//с действительным вектором, индексы которых расположены в интервале [left..right].
//***********************************************************************************
rmatrix TRealMatrix::AddByRows(const rvector& V, ulong left, ulong right) const
{rmatrix result;
 //Проверка выполнения условий сложения строк исходной матрицы с вектором V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols()) ||
     (left >= Rows()) || (right >= Rows()) || (left > right))
  return result;
 //Поэлементное сложение строк с индексами, расположенными в интервале [left..right],
 //исходной матрицы на вектор V
 result = *this;
 for (ulong i = left; i <= right ; i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(i,j,data[i][j]+V.Get(j));
 return result;
}
//***********************************************************************************
//СТАТУС: I.27, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//rmatrix AddByRows(const rvector& V, const ivector& index, bool check = false) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТРОК МАТРИЦЫ С ДЕЙСТВИТЕЛЬНЫМ ВЕКТОРОМ, ИНДЕКСЫ КОТОРЫХ
//            СОДЕРЖАТСЯ В ВЕКТОРЕ index
//Функция прибавляет к строкам матрицы с индексами, значения которых передаются цело-
//численным вектором index, вектор V. Размерность вектора V должна быть равна количеству
//столбцов матрицы.
//Аргумент check указывает на проведение проверки значений индексов на соответствие
//допустимым значениям индексов строк исходной матрицы и формированию подвектора век-
//тора index, который содержит только корректные значения индексов строк для данной
//матрицы. Если check = true, создается объект-предикат, который осуществляет селекцию
//корректных значений индексов, и формируется подвектор вектора index с корректными
//значениями индексов. Созданный подвектор далее используется для выбора строк матрицы
//складываемых поэлементно с вектором V.
//При check = false фильтрация некорректных значений индексов не осуществляется. В этом
//случае ответственность за корректность всех значений индексов строк возлагается на
//пользователя и при некорректном задании значения индекса, выходящего за пределы до-
//пустимого значения индекса строки для данной матрицы, приведет к аварийному заверше-
//нию работы всей программы. При check = false функция быстрее выполняет необходимые
//действия, так как не тратится время на фильтрацию некорректных значений индексов,
//передавемых вектором index.
//Результатом работы функции является действительная матрица, совпадающая по размерам
//с исходной матрицей. Функция не изменяет значений и структуры исходной матрицы, так
//как все операции сложения значений элементов матрицы на значения элементов вектора
//происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы;
//4. Вектор index - вектор нулевого размера;
//5. При check == true, получился подвектор вектора индексов строк нулевого размера,
//   т.е. исходный вектор индексов строк index не содержал ни одного допустимого зна-
//   чения индекса строки для данной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - ссылка на действительный вектор, складываемый со строками
//   исходной матрицы с индексами, размещенными в векторе index;
//2. const ivector& index - ссылка на вектор с индексами строк, складываемых с
//   вектором V.
//3. bool check (false) - индикатор отбора допустимых значений индексов строк исходной
//   матрицы, складываемых с вектором V, из вектора index.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - результирующая матрица сложения строк с
//действительным вектором V, индексы которых передаются через целочисленный вектор index.
//***********************************************************************************
rmatrix TRealMatrix::AddByRows(const rvector& V, const ivector& index, bool check) const
{rmatrix result;
 //Проверка выполнения условий сложения строк исходной матрицы с вектором V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols()) || (index.IsZeroSize()))
  return result;
 //Выбор подвектора Index корректных индексов строк из вектора index
 ivector Index = index;//Копирование вектора index
 if (check == ON)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Cols()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  Index = Index.Unique();
  if (Index.IsZeroSize()) return result;
 }
 //Сложение строк с индексами, значения которых расположены в целочисленном векторе
 //Index, исходной матрицы на вектор V
 result = *this;
 for (ulong i = 0; i < Index.Size(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(Index.Get(i),j,data[Index.Get(i)][j]+V.Get(j));
 return result;
}
//***********************************************************************************
//СТАТУС: I.28, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector SumCols(ulong left = 0L, ulong right = MAX_SIZE) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТОЛБЦОВ МАТРИЦЫ, РАСПОЛОЖЕННЫХ В ИНТЕРВАЛЕ [left..right]
//   Функция складывает столбцы матрицы с индексами, расположенными в интервале целых
//чисел [left..right]. Аргумент left определяет начальное значение интервала индексов
//столбцов, а аргумент right - конечное значение интервала индексов столбцов, которые
//складываются друг с другом. По умолчанию складываются все столбцы матрицы.
//   Результатом работы функции является вектор-столбец с размерностью равной количеству
//строк исходной матрицы. Функция не изменяет значений и структуры исходной матрицы.
//Функция возвращает вектор result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Значения индексов left или right являются недопустимыми для столбцов данной
//   матрицы;
//3. Значение индекса left > right.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left - начальное значение интервала индексов столбцов, складываемых друг с
//   другом.
//2. ulong right - конечное значение интервала индексов столбцов, складываемых друг с
//   другом.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rvector result - результирующий вектор-столбец сложения столбцов исходной матрицы
// с индексами определенными на интервале [left..right].
//***********************************************************************************
rvector TRealMatrix::SumCols(ulong left, ulong right) const
{rvector result;
 //Проверка выполнения условий сложения столбцов исходной матрицы
 if (IsZeroSize()) return result;
 if (right == MAX_SIZE) right = Cols()-1;
 //Проверка выполнения условий сложения столбцов исходной матрицы
 if ((left >= Cols()) || (right >= Cols()) || (left > right)) return result;
 //Cложение столбцов с индексами, расположенными в интервале [left..right], исходной
 //матрицы между собой
 result.Set(Rows(),COL,0.0);
 for (ulong i = 0L; i < Rows() ; i++)
  for (ulong j = left; j <= right; j++)
   result.Put(i,result.Get(i) + data[i][j]);
 return result;
}
//***********************************************************************************
//СТАТУС: I.29, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector SumCols(const ivector& index) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТОЛБЦОВ МАТРИЦЫ, ИНДЕКСЫ КОТОРЫХ СОДЕРЖАТСЯ В ВЕКТОРЕ
//Функция складывает столбцы матрицы с индексами, значения которых передаются целочис-
//ленным вектором index, между собой. При выполнении операции сложения столбцов каждый
//индекс столбца анализируется на допустимость для данной исходной матрицы. Если зна-
//чение индекса выходит за допустимые пределы возможных индексов столбцов данной мат-
//рицы, то он игнорируется.
//Результат работы функции - вектор-столбец с размерностью равной количеству строк
//исходной матрицы. Функция не изменяет значений и структуры исходной матрицы.
//Функция возвращает вектор result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор index - вектор нулевого размера;
//3. При селекции корректных значений индексов столбцов получился подвектор вектора
//   индексов столбцов нулевого размера, т.е. исходный вектор индексов столбцов index
//   не содержал ни одного допустимого значения индекса столбца для данной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const ivector& index - ссылка на вектор с индексами складываемых столбцов
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector result - результирующий вектор сложения столбцов,
//индексы которых передаются через целочисленный вектор index.
//***********************************************************************************
rvector TRealMatrix::SumCols(const ivector& index) const
{rvector result;
 //Проверка выполнения условий сложения столбцов исходной матрицы
 if ((IsZeroSize()) || (index.IsZeroSize())) return result;
 //Выбор подвектора Index корректных индексов столбцов из вектора index
 ivector col(index);//Копирование вектора index
 ivector interval(2,0L);
 interval[0] = 0; interval[1] = Cols()-1;
 TBelongClosedInterval<long, ivector> Predicate =
 TBelongClosedInterval<long,ivector>(interval);
 col = col.SubVector(Predicate);
 if (col.IsZeroSize()) return result;
 //Сложение столбцов с индексами, значения которых расположены в целочисленном
 //векторе Index, исходной матрицы друг с другом
 result.Set(Rows(),COL,0.0);//Создание результирующего вектора
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < col.Size(); j++)
   result.Put(i,result.Get(i) + data[i][col.Get(j)]);
 return result;
}
//***********************************************************************************
//СТАТУС: I.30, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector SumRows(ulong left = 0L, ulong right = MAX_SIZE) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТРОК МАТРИЦЫ, РАСПОЛОЖЕННЫХ В ИНТЕРВАЛЕ [left..right]
//Функция складывает строки матрицы с индексами, расположенными в интервале целых чи-
//сел [left..right]. Аргумент left определяет начальное значение интервала индексов
//строк, а аргумент right - конечное значение интервала индексов строк, которые скла-
//дываются друг с другом. По умолчанию складываются все строки матрицы.
//Результат работы функции - вектор-строка с размерностью равной количеству столбцов
//исходной матрицы. Функция не изменяет значений и структуры исходной матрицы.
//Функция возвращает вектор result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Значения индексов left или right являются недопустимыми для строк данной матрицы;
//3. Значение индекса left > right.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left - начальное значение интервала индексов строк, складываемых друг с другом.
//2. ulong right - конечное значение интервала индексов строк, складываемых друг с другом.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector result - результирующий вектор-строка сложения строк
//исходной матрицы с индексами определенными на интервале [left..right].
//***********************************************************************************
rvector TRealMatrix::SumRows(ulong left, ulong right) const
{rvector result;
 //Проверка выполнения условий сложения строк исходной матрицы
 if (IsZeroSize()) return result;
 if (right == MAX_SIZE) right = Rows()-1;
 //Проверка выполнения условий сложения строк исходной матрицы
 if ((left >= Rows()) || (right >= Rows()) || (left > right)) return result;
 //Cложение строк с индексами, расположенными в интервале [left..right], исходной мат-
 //рицы между собой
 result.Set(Cols(),ROW,0.0) ;//Создание результирующего вектора
 for (ulong j = 0L; j < Cols(); j++)
  for (ulong i = left; i <= right; i++)
   result.Put(j,result.Get(j) + data[i][j]);
 return result;
}
//***********************************************************************************
//СТАТУС: I.31, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector SumRows(const ivector& index) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТРОК МАТРИЦЫ, ИНДЕКСЫ КОТОРЫХ СОДЕРЖАТСЯ В ВЕКТОРЕ
//Функция складывает строки матрицы с индексами, значения которых передаются целочис-
//ленным вектором index, между собой. При выполнении операции сложения строк каждый
//индекс строки анализируется на допустимость для исходной матрицы. Если значение ин-
//декса выходит за допустимые пределы возможных индексов строк матрицы, то он игнори-
//руется.
//Результат работы функции - вектор-строка с размерностью равной количеству столбцов
//исходной матрицы. Функция не изменяет значений и структуры исходной матрицы.
//Функция возвращает вектор result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор index - вектор нулевого размера;
//3. При селекции корректных значений индексов строк получился подвектор вектора
//   индексов строк нулевого размера, т.е. исходный вектор индексов строк index не
//   содержал ни одного допустимого значения индекса строки для данной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const ivector& index - ссылка на вектор с индексами складываемых строк
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rvector result - результирующий вектор сложения строк, индексы которых
// передаются через целочисленный вектор index.
//***********************************************************************************
rvector TRealMatrix::SumRows(const ivector& index) const
{rvector result;
 //Проверка выполнения условий сложения строк исходной матрицы
 if ((IsZeroSize()) || (index.IsZeroSize())) return result;
 //Выбор подвектора Index корректных индексов строк из вектора index
 ivector row(index);//Копирование вектора index
 ivector interval(2,0L);
 interval[0] = 0; interval[1] = Rows()-1;
 TBelongClosedInterval<long, ivector> Predicate =
 TBelongClosedInterval<long,ivector>(interval);
 row = row.SubVector(Predicate);
 if (row.IsZeroSize()) return result;
 //Сложение строк с индексами, значения которых расположены в целочисленном векторе
 //Index, исходной матрицы друг с другом
 result.Set(Cols(),ROW,0.0);//Создание результирующего вектора
 for (ulong j = 0; j < Cols(); j++)
  for (ulong i = 0L; i < row.Size(); i++)
   result.Put(j,result.Get(j) + data[row.Get(i)][j]);
 return result;
}
//-----------------------------------------------------------------------------------
//Расчет миноров исходной матрицы
//-----------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double U_Minor(ulong k, ulong g) const
//НАЗНАЧЕНИЕ: РАСЧЕТ МИНОРА МАТРИЦЫ
//Функция вычисляет минор исходной матрицы следующего вида:
//M(0 1 ... k-1 k, 0 1 ... k-1 g), где g > k
// 0 1 ... k-1 k - строки исходной матрицы рассчитываемого минора;
// 0 1 ... k-1 g - столбцы исходной матрицы рассчитываемого минора.
//Верхние границы строк k и столбцов g исходной матрицы, которые участвуют в фор-
//мировании элементов минора входят в данное допустимое множество. Нумерация
//строк и столбцов начинается с 0.
//Функция использует вызов функции U_SubMatrix(k,g), которая формирует заданный
//минор и функцию DET_UnSymmetric(...), которая вычисляет данный минор.
//Если индексы столбцов и строк из которых будет формироваться минор будут некор-
//ректны, то функция возвращает Det = 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong k - верхняя граница строк матрицы, участвующих в формировании минора
//2. ulong g - верхняя граница столбцов матрицы, участвующих в формировании минора
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double Det  - значение заданного минора
//******************************************************************************
double TRealMatrix::U_Minor(ulong k, ulong g) const
{double Det = 0.0;
 if (IsZeroSize()) return Det;//Матрица нулевого размера
 //Проверка на допустимость индексов k & g, 0 < g < Cols(), 0 <= k < g, k < Rows()
 if ((k >= Rows()) || (g <= k) || (g >= Cols())) return Det;
 //-----------------------------------------------------------------------------
 //Формирование подматрицы M(0 1 ... k-1 k, 0 1 ... k-1 g), где g > k
 //-----------------------------------------------------------------------------
 rmatrix M = U_SubMatrix(k,g);
 //Вычисление определителя подматрицы - минора
 Det = M.DET_UnSymmetric();
 return Det; //Значение минора
}
//******************************************************************************
//СТАТУС: I.2; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double L_Minor(ulong g, ulong k) const
//НАЗНАЧЕНИЕ: РАСЧЕТ МИНОРА МАТРИЦЫ
//Функция вычисляет минор исходной матрицы следующего вида:
//M(0 1 ... k-1 g, 0 1 ... k-1 k), где g > k
// 0 1 ... k-1 g - строки исходной матрицы рассчитываемого минора;
// 0 1 ... k-1 k - столбцы исходной матрицы рассчитываемого минора.
//Верхние границы строк g и столбцов k исходной матрицы, которые участвуют в фор-
//мировании элементов минора входят в данное допустимое множество. Нумерация
//строк и столбцов начинается с 0.
//Функция использует вызов функции L_SubMatrix(g,k), которая формирует заданный
//минор и функцию DET_UnSymmetric(...), которая вычисляет данный минор.
//Если индексы столбцов и строк из которых будет формироваться минор будут некор-
//ректны, то функция возвращает Det = 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong g - верхняя граница строк матрицы, участвующих в формировании минора
//2. ulong k - верхняя граница столбцов матрицы, участвующих в формировании минора
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double Det  - значение заданного минора
//******************************************************************************
double TRealMatrix::L_Minor(ulong g, ulong k) const
{double Det = 0.0;
 if (IsZeroSize()) return Det;//Матрица нулевого размера
 //Проверка на допустимые индексы k & g, 0 < g < Rows(), 0 <= k < g, k < Cols()
 if ((k >= Cols()) || (g <= k) || (g >= Rows())) return Det;
 //-----------------------------------------------------------------------------
 //Формирование подматрицы M(0 1 ... k-1 g, 0 1 ... k-1 k), где g > k
 //-----------------------------------------------------------------------------
 rmatrix M = L_SubMatrix(g,k);
 Det = M.DET_UnSymmetric();//Вычисление определителя подматрицы - минора
 return Det; //Значение минора
}
//******************************************************************************
//СТАТУС: I.3; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double P_Minor(ulong k) const
//НАЗНАЧЕНИЕ: РАСЧЕТ ГЛАВНОГО k-го МИНОРА МАТРИЦЫ
//Функция вычисляет минор исходной матрицы следующего вида:
//M(0 1 ... k-1 k, 0 1 ... k-1 k),
// 0 1 ... k-1 k - строки исходной матрицы рассчитываемого главного минора;
// 0 1 ... k-1 k - столбцы исходной матрицы рассчитываемого главного минора.
//Верхние границы первых k строк и столбцов исходной матрицы, которые участвуют
//в формировании элементов главного минора входят в данное допустимое множество.
//Нумерация строк и столбцов начинается с 0.
//Функция использует вызов функции P_SubMatrix(k), которая формирует заданный
//главный минор и функцию DET_UnSymmetric(...), которая вычисляет данный минор.
//Если индексы столбцов и строк из которых будет формироваться главный минор бу-
//дут некорректны, то функция возвращает Det = 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//ulong k - верхняя граница строк и столбцов матрицы, участвующих в формировании
//главного минора k-го порядка
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double Det  - значение главного минора k-го порядка
//******************************************************************************
double TRealMatrix::P_Minor(ulong k) const
{double Det = 0.0;
 if (IsZeroSize()) return Det;//Матрица нулевого размера
 //Проверка на допустимость индекса k, k < Rows(), k < Cols()
 if ((k >= Cols()) || (k >= Rows())) return Det;
 //-----------------------------------------------------------------------------
 //Формирование подматрицы M(0 1 ... k-1 k, 0 1 ... k-1 k)
 //-----------------------------------------------------------------------------
 rmatrix M = P_SubMatrix(k);
 //Вычисление определителя подматрицы - главного минора k-го порядка
 Det = M.DET_UnSymmetric();
 return Det; //Значение минора
}
//******************************************************************************
//СТАТУС: I.4; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix U_AllMinors() const
//НАЗНАЧЕНИЕ: РАСЧЕТ ВСЕХ НАДДИАГОНАЛЬНЫХ МИНОРОВ МАТРИЦЫ
//Функция вычисляет все миноры исходной матрицы следующего вида:
//M(0 1 ... k-1 k, 0 1 ... k-1 g), где g > k
// 0 1 ... k-1 k - строки исходной матрицы рассчитываемого минора;
// 0 1 ... k-1 g - столбцы исходной матрицы рассчитываемого минора.
//Диапазон изменения g: 0 < g < min(Cols(),Rows());
//Диапазон изменения k: 0 <= k < g.
//Функция использует вызов функции U_Minor(k,g). Все вычисленные миноры заносят-
//ся в матрицу, которая будет являться верхней треугольной матрицей с нулевыми
//диагональными элементами.
//В случае неудачи функция возвращает действительную матрицу нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix U_Minors  - матрица миноров
//******************************************************************************
rmatrix TRealMatrix::U_AllMinors() const
{rmatrix U_Minors;
 if (IsZeroSize()) return U_Minors;//Матрица нулевого размера
 //-----------------------------------------------------------------------------
 //Определение всех миноров вида M(0 1 ... k-1 k, 0 1 ... k-1 g), где g > k
 //-----------------------------------------------------------------------------
 ulong bound = (Rows() < Cols()) ? Rows() : Cols();
 //Создание матрицы для размещения наддиагональных миноров
 U_Minors.Set(bound,bound,0.0);
 //Цикл вычисления всех наддиагональных миноров
 for(ulong i = 0L; i < bound; i++)
  for (ulong j = i+1; j < bound; j++)
   U_Minors.Put(i,j,U_Minor(i,j));
 return U_Minors; //Матрица всех наддиагональных миноров
}
//******************************************************************************
//СТАТУС: I.5; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix L_AllMinors() const
//НАЗНАЧЕНИЕ: РАСЧЕТ ВСЕХ ПОДДИАГОНАЛЬНЫХ МИНОРОВ МАТРИЦЫ
//Функция вычисляет все миноры исходной матрицы следующего вида:
//M(0 1 ... k-1 g, 0 1 ... k-1 k), где g > k
// 0 1 ... k-1 g - строки исходной матрицы рассчитываемого минора;
// 0 1 ... k-1 k - столбцы исходной матрицы рассчитываемого минора.
//Диапазон изменения g: 0 < g < min(Cols(),Rows());
//Диапазон изменения k: 0 <= k < g.
//Функция использует вызов функции L_Minor(g,k). Все вычисленные миноры заносят-
//ся в матрицу, которая будет являться нижней треугольной матрицей с нулевыми
//диагональными элементами.
//В случае неудачи функция возвращает действительную матрицу нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix L_Minors  - матрица миноров
//******************************************************************************
rmatrix TRealMatrix::L_AllMinors() const
{rmatrix L_Minors;
 if (IsZeroSize()) return L_Minors;//Матрица нулевого размера
 //-----------------------------------------------------------------------------
 //Определение всех миноров вида M(0 1 ... k-1 g, 0 1 ... k-1 k), где g > k
 //-----------------------------------------------------------------------------
 ulong bound = (Rows() < Cols()) ? Rows() : Cols();
 //Создание матрицы для размещения поддиагональных миноров
 L_Minors.Set(bound,bound,0.0);
 //Цикл вычисления всех поддиагональных миноров
 for(ulong i = 1L; i < bound; i++)
  for (ulong j = 0; j < i; j++)
   L_Minors.Put(i,j,L_Minor(i,j));
 return L_Minors; //Матрица всех поддиагональных миноров
}
//******************************************************************************
//СТАТУС: I.6; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix P_AllMinors() const
//НАЗНАЧЕНИЕ: РАСЧЕТ ВСЕХ ГЛАВНЫХ МИНОРОВ МАТРИЦЫ
//Функция вычисляет все главные миноры исходной матрицы следующего вида:
//M(0 1 ... k-1 k, 0 1 ... k-1 k)
// 0 1 ... k-1 k - строки исходной матрицы рассчитываемого минора;
// 0 1 ... k-1 k - столбцы исходной матрицы рассчитываемого минора.
//Диапазон изменения k: 0 <= k < min(Cols(),Rows());
//Функция использует вызов функции P_Minor(k). Все вычисленные миноры заносятся
//в матрицу, которая будет являться диагональной матрицей.
//В случае неудачи функция возвращает действительную матрицу нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix P_Minors  - матрица главных миноров
//******************************************************************************
rmatrix TRealMatrix::P_AllMinors() const
{rmatrix P_Minors;
 if (IsZeroSize()) return P_Minors;//Mатрица нулевого размера
 //-----------------------------------------------------------------------------
 //Определение всех миноров вида M(0 1 ... k-1 k, 0 1 ... k-1 k)
 //-----------------------------------------------------------------------------
 ulong bound = (Rows() < Cols()) ? Rows() : Cols();
 //Создание матрицы для размещения диагональных миноров
 P_Minors.Set(bound,bound,0.0);
 //Цикл вычисления всех диагональных миноров
 for(ulong i = 0L; i < bound; i++) P_Minors.Put(i,i,P_Minor(i));
 return P_Minors; //Матрица всех главных миноров
}
//******************************************************************************
//СТАТУС: I.7; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rvector& P_AllMinors(rvector& P) const
//НАЗНАЧЕНИЕ: РАСЧЕТ ВСЕХ ГЛАВНЫХ МИНОРОВ МАТРИЦЫ
//Функция вычисляет все главные миноры исходной матрицы следующего вида:
//M(0 1 ... k-1 k, 0 1 ... k-1 k)
// 0 1 ... k-1 k - строки исходной матрицы рассчитываемого минора;
// 0 1 ... k-1 k - столбцы исходной матрицы рассчитываемого минора.
//Диапазон изменения k: 0 <= k < min(Cols(),Rows());
//Функция использует вызов функции P_Minor(k). Все вычисленные миноры заносятся
//в вектор P, передаваемый по ссылке.
//В случае неудачи функция возвращает вектор нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: rvector& P - ссылка на вектор значений главных миноров
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rvector& P - результирующий вектор с вычисленными значениями главных миноров
//******************************************************************************
rvector& TRealMatrix::P_AllMinors(rvector& P) const
{if (IsZeroSize()) //Mатрица нулевого размера
 {P.Set(0,ROW,false); return P;}
 //-----------------------------------------------------------------------------
 //Определение всех миноров вида M(0 1 ... k-1 k, 0 1 ... k-1 k)
 //-----------------------------------------------------------------------------
 ulong bound = (Rows() < Cols()) ? Rows() : Cols();
 //Создание вектора для размещения диагональных (главных) миноров
 P.Set(bound,ROW,false);
 //Цикл вычисления всех диагональных миноров
 for(ulong i = 0L; i < bound; i++) P.Put(i,P_Minor(i));
 return P;//Вектор со всеми главными минорами
}
//******************************************************************************
//СТАТУС: I.8; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rmatrix AllMinors(bool L = true, bool P = true, bool U = true) const
//НАЗНАЧЕНИЕ: РАСЧЕТ ВСЕХ МИНОРОВ МАТРИЦЫ
//Функция вычисляет все миноры исходной матрицы следующего вида. Функция исполь-
//зует вызовы функций U_AllMinors(), L_AllMinors() и P_AllMinors(), в зависимос-
//ти от выбранных опций U, L, P соответственно. Все вычисленные миноры заносятся
//в матрицу, которая будет являться квадратной матрицей.
//В случае неудачи функция возвращает действительную матрицу нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. bool L - признак вычисления всех поддиагональных миноров
//2. bool P - признак вычисления всех главных миноров
//3. bool U - признак вычисления всех наддиагональных миноров
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix Minors  - матрица миноров
//******************************************************************************
rmatrix TRealMatrix::AllMinors(bool L, bool P, bool U) const
{rmatrix Minors;
 if (IsZeroSize()) return Minors; //Матрица нулевого размера
 if ((L == OFF) && (P == OFF) && (U == OFF)) return Minors;
 //-----------------------------------------------------------------------------
 //Определение всех миноров исходной матрицы
 //-----------------------------------------------------------------------------
 ulong bound = (Rows() < Cols()) ? Rows() : Cols();
 Minors.Set(bound,bound,0.0);//Создание матрицы для размещения всех миноров
 //Формирование поддиагональных миноров
 if (L == ON) Minors = L_AllMinors();
 //Формирование главных миноров
 if (P == ON)
 {if (L == OFF) Minors = P_AllMinors();
  else Minors = Minors + P_AllMinors();
 }
 //Формирование наддиагональных миноров
 if (U == ON)
 {if ((L == OFF) && (P == OFF)) Minors = U_AllMinors();
  else Minors = Minors + U_AllMinors();
 }
 return Minors; //Матрица всех миноров
}

//------------------------------------------------------------------------------
// Разложение действительных квадратных матриц на нижнюю, верхнюю и диагональную
// матрицы: A = LDU
// В алгоритме используется вычисление всех миноров исходной матрицы для расчета
// коэффициентов нижней L, верхней U и диагональной D матриц. С вычислительной
// точки зрения этот алгоритм нельзя считать эффективным для разложения матрицы.
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LDU_Gauss(rmatrix& LDU) const
//НАЗНАЧЕНИЕ: РАЗЛОЖЕНИЕ КВАДРАТНОЙ МАТРИЦЫ НА ПРОИЗВЕДЕНИЕ ДВУХ ТРЕУГОЛЬНЫХ и
//            ДИАГОНАЛЬНОЙ МАТРИЦ ВЫЧИСЛЕНИЕМ ВСЕХ МИНОРОВ
// LDU-expansion of real square matrix by calculating all minors
//Функция предназначена для разложения квадратной действительной матрицы на
//произведение двух треугольных матриц и диагональной матрицы вычислением всех
//миноров исходной матрицы.
//ТЕОРЕТИЧЕСКИЕ ПРЕДПОСЫЛКИ.
// Всякая квадратная матрица A = ||a(i,k)|| (1..n) ранга r, у которой
//       | 1  2 ... k |
// Dk = A|            | != 0 (k = 1, 2, ..., r),
//       | 1  2 ... k |
// представима в виде произведения нижней треугольной матрицы L, диагональной
// матрицы D и верхней треугольной матрицы U:
//
//                             |D1       |
//                             | D2/D1   |
//           |1    0  ...... 0||  .      ||1 U12 ......... U1n|
//           |L21  1  ...... 0||   .     ||0  1 U23 ...... U2n|
// A = LDU = |L31  L32  1 .. 0||    .    ||0  0  1  U34 .. U3n| ,где
//           | ............. 0||  Dr/Dr-1||0 ..............   |
//           |Ln1  Ln2 ....  1||     0   ||0  0  0 ........ 1 |
//                             |      .  |
//                             |       0 |
//
//       A(1 2 ... k-1 g, 1 2 ... k-1 k)        A(1 2 ... k-1 k, 1 2 ... k-1 g)
// Lgk = -------------------------------, Ukg = -------------------------------
//           A(1 2 ... k, 1 2 ... k)                A(1 2 ... k, 1 2 ... k)
//
// (g = k+1, ...., n; k = 1, 2, ..., r), а Lgk, Ukg произвольные при
//  g = k+1, ...., n; k = r+1, ...., n.
//РЕАЛИЗАЦИЯ. Осуществляется проверка матрицы на квадратную, если матрица тако-
//вой не является, то функция возвращает false и матрицу LDU нулевого размера.
//Для квадратной матрицы вычисляются все ее миноры - матрица миноров Minor. Далее
//вычисляются коэффициенты матриц L, U и D по формулам из теоремы и заносятся в
//матрицу LDU. Нижняя треугольная подматрица матрицы LDU будет содержать коэффи-
//циенты матрицы L (без элементов главной диагонали, равных 1); верхняя треуголь-
//ная подматрица матрицы LDU - коэффициенты матрицы U (без элементов главной
//диагонали, равных 1); на диагонали матрицы LDU - располагаются коэффициенты
//диагональной матрицы D.
//Если матрица - квадртная, то функция возвращает true и элементы матриц L,D,U
//в матрице LDU, передаваемой в функцию по ссылке.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//rmatrix& LDU - ссылка на матрицу с элементами верхней U, нижней L треугольных
//матриц и диагональной D матрицы, представляющие исходную матрицу: A = LDU
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат LDU-разложения матрицы
//******************************************************************************
bool TRealMatrix::LDU_Gauss(rmatrix& LDU) const
{//Матрица нулевого размера или неквадратная
 if (IsZeroSize() || IsRectang()) {LDU.Set(0L,0L,false); return false;}
 //Формируем результирующую матрицу
 LDU.Set(Rows(),Rows(),0.0);
 //Расчет всех миноров исходной матрицы
 rmatrix M = AllMinors();
 //-----------------------------------------------------------------------------
 //Расчет коэффициентов матрицы L(g,k)
 for (ulong i = 1L; i < Rows(); i++)
  for (ulong j = 0L; j < i; j++)
  {if (M.Get(j,j) != 0) LDU.Put(i,j,M.Get(i,j)/M(j,j));}
 //----------------------------------------------------------------------------
 //Расчет коэффициентов матрицы U(g,k)
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = i+1; j < Cols(); j++)
  {if (M.Get(i,i) != 0) LDU.Put(i,j,M.Get(i,j)/M(i,i));}
 //----------------------------------------------------------------------------
 //Расчет коэффициентов матрицы D(k,k)
 LDU.Put(0L,0L,M.Get(0L,0L));
 for (ulong i = 1L; i < Rows(); i++)
 {if (M.Get(i-1,i-1) != 0) LDU.Put(i,i,M.Get(i,i)/M(i-1,i-1));}
 return true;
}
//******************************************************************************
//СТАТУС: I.2, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LDU_Gauss(rmatrix& L, rmatrix& D, rmatrix& U) const
//НАЗНАЧЕНИЕ: РАЗЛОЖЕНИЕ КВАДРАТНОЙ МАТРИЦЫ НА ПРОИЗВЕДЕНИЕ ДВУХ ТРЕУГОЛЬНЫХ и
//            ДИАГОНАЛЬНОЙ МАТРИЦ ВЫЧИСЛЕНИЕМ ВСЕХ МИНОРОВ
// LDU-expansion of real square matrix by calculating all minors
//Функция предназначена для разложения квадратной действительной матрицы на
//произведение двух треугольных матриц и диагональной матрицы вычислением всех
//миноров исходной матрицы. Функция использует вызов функции LDU_Gauss(A) и
//далее при успешном завершении ее работы размещает элементы нижней треугольной
//матрицы в матрице L, верхней треугольной матрицы - в матрице U и диагональной
//матрицы в матрице D, передаваемых по ссылке.
//В случае неудачи, функция возвращает false и матрицы L, D и U нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//rmatrix& L - ссылка на матрицу с элементами нижней треугольной матрицы разложе-
//ния исходной матрицы: A = LDU;
//rmatrix& D - ссылка на матрицу с элементами диагональной D матрицы разложения
//исходной матрицы: A = LDU;
//rmatrix& U - ссылка на матрицу с элементами верхней треугольной матриц разложе-
//ния исходной матрицы: A = LDU
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат LDU-разложения матрицы
//******************************************************************************
bool TRealMatrix::LDU_Gauss(rmatrix& L, rmatrix& D, rmatrix& U) const
{rmatrix B;
 if (LDU_Gauss(B) == false)
 {L.Set(0L,0L,false); D.Set(0L,0L,false); U.Set(0L,0L,false); return false;}
 L.Set(B.Rows(),0.0); D.Set(B.Rows(),0.0); U.Set(B.Rows(),0.0);
 //Формирование матриц L,D и U с коэффициентами матриц разложения исходной
 for (ulong i = 0L; i < B.Rows(); i++)
  for (ulong j = 0L; j < B.Cols(); j++)
  {if (i == j) {L.Put(i,i,1); D.Put(i,i,B.Get(i,i)); U.Put(i,i,1);}
   if (i > j) L.Put(i,j,B.Get(i,j));
   if (i < j) U.Put(i,j,B.Get(i,j));
  }
 return true;
}
//-----------------------------------------------------------------------------------
//Расчет определителей вещественных квадратных матриц и разложение матриц на верхнюю
//и нижнюю треугольные матрицы: A = LU
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: I.1; TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend double InnerProduct(ulong l, ulong s, ulong u, double init,
//                            const rmatrix& A, bool Avar, ulong Aconst,
//                            const rmatrix& B, bool Bvar, ulong Bconst)
//НАЗНАЧЕНИЕ: НАКОПЛЕНИЕ ВНУТРЕННЕГО СКАЛЯРНОГО ПРОИЗВЕДЕНИЯ ЭЛЕМЕНТОВ МАТРИЦЫ
//           (МАТРИЦ) ВИДА Ak * Bk И СУММИРОВАНИЕ ИХ С НАЧАЛЬНЫМ ЗНАЧЕНИЕМ.
//Функция накапливает скалярного произведения элементов матрицы (матриц). Вычиления
//производятся с числами типа long double, что увеличивает точность вычислений, затем
//результирующая сумма округляется до типа double. При вычислениях один из индексов
//матриц A & B изменяется в диапазоне от l до u с шагом s, другой индекс матриц является
//ЗАФИКСИРОВАННЫМ. Переменные Avar и Bvar типа bool указывают на изменяемый тип индекса
//матриц - СТРОКУ или СТОЛБЕЦ. Если изменяется строка, то эти переменные принимают
//значение ROW (true), иначе COL (false). Аргументы Aconst и Bconst указывают на зна-
//чение зафиксированного индекса, который будет являтся противоположным значениям пе-
//ременных Avar и Bvar.
//Переменная init содержит начальное значение скалярного произведения. Пользователь
//должен контролировать корректность задания параметров функции InnerProduct, чтобы
//избежать попытки доступа к несуществующим элементам матриц. Общая формула накопления
//скалярного произведения имеет вид:
// sum = init + SUM[A(k,c1)*B(c2,k), l <= k < u, с шагом s], где
//1. sum - результат накопления скалярного произведения элементов матриц(ы);
//2. init - начальное значение sum;
//3. A(k,c1), B(c2,k) - значения элементов матриц A & B, порядок индексов элементов
//   k, c1, c2 может быть произвольным, т.е. допустимы следующие варианты:
//   a) A(k,c1), B(c2,k) b) A(c1,k), B(c2,k) c) A(k,c1), B(k,c2);
//4. k - значение переменного индекса для доступа к элементам матриц A & B.
//   Индекс k изменяется от l до u с шагом s;
//5. c1, c2 - значения фиксированных индексов для доступа к элементам матриц A и B
//   соответственно.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong l - нижняя граница переменного индекса элемента матрицы
//2. ulong s - шаг переменного индекса элемента матрицы
//3. ulong u - верхняя граница переменного индекса элемента матрицы
//4. double init - начальное значение скалярного произведения элементов матриц
//5. const rmatrix& A - ссылка на матрицу A
//6. bool Avar - признак типа изменяемого индекса элементов матрицы A: строка или столбец
//7. ulong Aconst - значение фиксированного индекса элементов матрицы A
//8. const rmatrix& B - ссылка на матрицу B
//9. bool Bvar - признак типа изменяемого индекса элементов матрицы B: строка или столбец
//10. ulong Bconst - значение фиксированного индекса элементов матрицы B
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// double result  - накопленное произведение элементов матриц(ы) по переменному индексу
// строки (столбца) с начальным значением init
//***********************************************************************************
double InnerProduct(ulong l, ulong s, ulong u, double init, const rmatrix& A,
       bool Avar, ulong Aconst, const rmatrix& B, bool Bvar, ulong Bconst)
{long double sum = init;
 long double Ak, Bk;
 //double result;
 ulong c1 = Aconst;
 ulong c2 = Bconst;
 //Вычисление скалярного произведения с повышенной точностью
 for (ulong k = l; k < u; k += s)
 {Ak = (Avar == ROW) ? A.Get(k,c1) : A.Get(c1,k);
  Bk = (Bvar == ROW) ? B.Get(k,c2) : B.Get(c2,k);
  sum += Ak*Bk;
 }
return sum;//result = sum;
}
//***********************************************************************************
//СТАТУС: I.2, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool LU_UnSymmetric(double& Det, rmatrix& LU, ivector& ExChange,
//                     double* Base = NULL, uint* Power = NULL) const
//НАЗНАЧЕНИЕ: РАЗЛОЖЕНИЕ КВАДРАТНОЙ МАТРИЦЫ НА ПРОИЗВЕДЕНИЕ ДВУХ ТРЕУГОЛЬНЫХ МАТРИЦ
//            ПО АЛГОРИТМУ КРАУТА
//     LU-expansion of unsymmetric real square matrix by Krauth algoritnm
//Функция предназначена для разложения квадратной несимметрической действительной мат-
//рицы на произведение двух треугольных матриц и вычисление определителя матрицы A в
//форме, исключающей возможность переполнения разрядной сетки ЭВМ.
//ТЕОРЕТИЧЕСКИЕ ПРЕДПОСЫЛКИ.
//Если матрица A неособая, то ее можно представить в виде произведения двух матриц:
//A = LU, где L и U - соответственно нижняя и верхняя треугольные матрицы. Это представ-
//ление, если оно существует, единственно с точностью до выбора диагональных элементов
//этих матриц. Если полученное разложение записать в виде: LU = (LD)(D'U), D' - обрат-
//ная матрица, то особый интерес представляет такой выбор диагональной матрицы D, при
//котором либо произведение LD есть нижняя треугольная матрица с единичной диагональю,
//либо D'U - верхняя треугольная матрица с единичной диагональю. Эти разложения опре-
//деляют соответственно алгоритм Дулиттла и алгоритм Краута. Разложение Дулиттла, по
//существу, аналогично методу исключения Гаусса и м.б. использовано для решения систем
//линейных уравнений (СЛУ), однако алгоритм Краута имеет ряд небольших преимуществ,
//которые используются ниже. Связь между элементами матриц L, U и A выражается в виде
//следующих уравнений:
//SUM{l(i,k)*u(k,r) by 1 <= k <= r-1} + l(i,r) = a(i,r) (i = r,...,n);       (1)
//SUM{l(r,k)*u(k,i) by 1 <= k <= r-1} + l(r,r)*u(r,i) = a(r,i) (i = r+1,...,n).(2)
//Процесс прерывается на r-ом шаге, если l(r,r) = 0. Несостоятельность алгоритма на
//r-ом шаге возникает в том случае, когда l(i,i) != 0 (i = 1,2,...,r-1), а
//l(r,r) = 0. Если же все главные миноры матрицы A не равны нулю, то разложение Краута
//может быть завершено и по построению будет единственным. Однко процесс разложения
//может оказаться несостоятельным, даже если матрица A очень хорошо обусловлена, напри-
//мер, для матрицы вида
// | 0 1 |
// | 1 0 |.
//Часто, однако, процесс разложения может стать численно неустойчивым, хотя исходная
//матрица хорошо обусловлена. Например,
// | eps  a |
// | b    c |, если eps мало по сравнению с a, b и c. В действительности процесс может
//быть устойчивым, даже если главные подматрицы матрицы A значительно хуже обусловлены,
//чем сама матрица A.
//ПРИМЕНЕНИЕ АЛГОРИТМА.
//В начале работы функция проверяет исходную матрицу на матрицу ненулевого размера и
//на квадратную матрицу. В случае, если матрица является матрицей нулевого размера или
//не является квадратной, то функция возвращает false. В этом случае определитель мат-
//рицы считается равным нулю, матрица разложения A исходной матрицы вида LU и вектор
//перестановок строк становятся нулевого размера. Кроме того, исключительная ситуация
//может быть сгенерирована в ходе работы функции, если текущий ведущий элемент матрицы
//на r-ом шаге работы алгоритма Краута станет равным или близким к нулю (lrr < 8*eps,
//eps = 1e-15), что может быть вызвано особенностью исходной матрицы или ошибками
//округления, приводящие матрицу к вырожденному виду. Это означает, что определитель
//матрицы равен 0 и треугольное разложение такой матрицы провести невозможно.
//Исходная матрица при работе функции сохраняется, все операции проводятся с копией
//исходной матрицы - матрицей LU, передаваемой по ссылке. При успешном завершении ра-
//боты алгоритма Краута матрица LU будет содержать элементы нижней L и верхней U тре-
//угольных матриц, за исключением диагональных элементов матрицы U, которые считаются
//равными единице. Информация о перестановке строк матрицы A будет содержатся в век-
//торе ExChange, ExChange.Size() = A.Rows(), причем на i-ом шаге происходит переста-
//новка строк с номерами i и ExChange[i]. Определитель матрицы A после вычислений
//представлен в двух видах: в виде значения передаваемой по ссылке переменной Det типа
//double и в виде Base*2^(Power). Второй способ представления определителя дает возмож-
//ность сохранить очень большие значения определителя, приводящие в первом случае к
//переполнению разрядной сетки компьютера. Вектор перестановок ExChange используется
//при решении систем уравнений вида AX = B, где B - матрица правых частей, X - матрица
//решений (векторы x), соответствующие своим правым частям матрицы B. С помощью вектора
//перестановок осуществляется перестановка строк матрицы B, так как в ходе выполнения
//алгоритма Краута порядок следования строк в матрице A может быть изменен.
//При работе функции используется функция InnerProduct для вычисления скалярного
//произведения элементов матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double& Det - ссылка на переменную со значением определителя матрицы;
//2. rmatrix& LU - ссылка на матрицу с элементами верхней U и нижней L треугольных
//   матриц, за исключением диагональных элементов U равных 1, которые представляют
//   исходную матрицу: A = LU;
//3. ivector& ExChange - вектор перестановок строк исходной матрицы при выполнении
//   алгоритма Краута;
//4. double* Base (NULL) - указатель на мантиссу определителя матрицы;
//5. long* Power (NULL) - указатель на показатель степени числа 2 определителя
//   матрицы. Параметры Base & Power дают возможность представить определитель в виде:
//   Det = Base * 2^(Power), что позволяет избежать переполнения разрядной сетки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат разложения матрицы на две
//треугольные и вычисления определителя исходной матрицы
//***********************************************************************************
bool TRealMatrix::LU_UnSymmetric(double& Det, rmatrix& LU, ivector& ExChange,
     double* Base, long* Power) const
{try
 {if (IsZeroSize()) throw M_ZERO_ERROR;//Проверка на матрицу нулевого размера
  if (IsRectang()) throw M_TYPE_ERROR; //Матрица не квадратная
  LU = *this; //Копируем исходную матрицу
  //Формируем вектор перестановок
  ExChange.Resize(LU.Rows()); ExChange.SetType(ROW);
  for (ulong i = 0L; i < ExChange.Size(); i++) ExChange.Put(i,i);
  //Объявление рабочих переменных
  double d1 = 1.0; //мантисса определителя
  long d2 = 0; //показатель степени определителя
  double x, y;
  ulong l;
  //---------------------------------------------------------------------------------
  //                             АЛГОРИТМ КРАУТА
  //---------------------------------------------------------------------------------
  //1. Вычисление норм всех строк матрицы
  rvector Norms;
  LU.NormAllRows(Norms,EUCLIDEAN_NORM);
  //2. Начало цикла разложения матрицы A на две треугольные: L & U
  for (ulong k = 0L; k < LU.Rows(); k++) //k-ый шаг алгоритма Краута
  {l = k; x = 0.0;
   //Цикл вычисления коэффициентов L(i,k) - нижней треугольной матрицы
   for (ulong i = k; i < LU.Rows(); i++)
   {y = InnerProduct(0,1,k,-LU(i,k),LU,COL,i,LU,ROW,k);
    LU(i,k) = -y;
    //Проверка евклидовой нормы i-строки матрицы на нуль. Если евклидова норма строки
    //равна нулю, то матрица A вырождена (квадратная матрица неполного ранга)
    if (Norms.Get(i) < EPS) throw M_DEGENERACY;
    y = fabs(y/Norms.Get(i));
    if (y > x) {x = y; l = i;}
   }//Конец цикла по i

   //Проверка на перестановку строк l и k
   if (l != k) //Выполнить перестановку
   {d1 = -d1; //Изменение знака определителя при перестановке строк матрицы
    LU.ExchangeRows(l, k); //Перестановка строк с индексами l & k
    Norms.Put(l,Norms.Get(k));
   }
   ExChange.Put(k,l);
   //Пошаговое вычисление определителя матрицы
   d1 = d1*LU.Get(k,k);
   //Проверка на вырожденность матрицы A
   if (x < 8*EPS) throw M_DEGENERACY;

   //Представление определителя матрицы в виде d1*2^(d2), где d1=0 или  1/16<=|d1|<1
   if ((Base != NULL) && (Power != NULL))
   {while (fabs(d1) >= 1.0) {d1 = d1 * 0.0625; d2 = d2 + 4;}
    while (fabs(d1) < 0.0625) {d1 = d1 * 16; d2 = d2 - 4;}
   }

   //Цикл вычисления коэффициентов U(k,j) - верхней треугольной матрицы
   x = -1/LU.Get(k,k);
   for (ulong j = k+1; j < LU.Cols(); j++)
   {y = InnerProduct(0,1,k,-LU(k,j),LU,COL,k,LU,ROW,j);
    LU.Put(k,j,x * y);
   }//Конец цикла по j

  }//Конец цикла по k
  //------------------------- Конец алгоритма Краута --------------------------------
  if ((Base != NULL) && (Power != NULL)) {*Base = d1; *Power = d2;}
  //Получение значения определителя в явном виде
  Det = d1 * pow(2.0,d2); //Det A = d1 * 2^d2
 }
 catch (int error_type) //Блок обработки исключительной ситуации
 {//Установка выходных данных в случае генерации исключительной ситуации
  LU.Set(0L,0L,false); ExChange.Set(0L,ROW); Det = 0.0;
  if (Base != NULL) *Base = 0.0;
  if (Power != NULL) *Power = 0;
  if (error_type == M_TYPE_ERROR) return false;
  else if (error_type == M_ZERO_ERROR) return false;
  else if (error_type == M_DEGENERACY) return false; //Вырожденная матрица
 }
return true;
}
//***********************************************************************************
//СТАТУС: I.3, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool LU_UnSymmetric(rmatrix& LU, ivector& ExChange, double Eps = 1e-16) const
//НАЗНАЧЕНИЕ: РАЗЛОЖЕНИЕ КВАДРАТНОЙ МАТРИЦЫ НА ПРОИЗВЕДЕНИЕ ДВУХ ТРЕУГОЛЬНЫХ МАТРИЦ
//            ПО АЛГОРИТМУ КРАУТА
//     LU-expansion of unsymmetric real square matrix by Krauth algoritnm
//Функция раскладывает квадратную несимметрическую действительную матрицу на произве-
//дение двух треугольных матриц.
//ТЕОРЕТИЧЕСКИЕ ПРЕДПОСЫЛКИ.
//Если матрица A неособая, то ее можно представить в виде произведения двух матриц:
//A = LU, где L и U - соответственно нижняя и верхняя треугольные матрицы. Это представ-
//ление, если оно существует, единственно с точностью до выбора диагональных элементов
//этих матриц. Если полученное разложение записать в виде: LU = (LD)(D'U), D' - обрат-
//ная матрица, то особый интерес представляет такой выбор диагональной матрицы D, при
//котором либо произведение LD есть нижняя треугольная матрица с единичной диагональю,
//либо D'U - верхняя треугольная матрица с единичной диагональю. Эти разложения опре-
//деляют соответственно алгоритм Дулиттла и алгоритм Краута. Разложение Дулиттла, по
//существу, аналогично методу исключения Гаусса и м.б. использовано для решения систем
//линейных уравнений (СЛУ), однако алгоритм Краута имеет ряд небольших преимуществ,
//которые используются ниже. Связь между элементами матриц L, U и A выражается в виде
//следующих уравнений:
//SUM{l(i,k)*u(k,r) by 1 <= k <= r-1} + l(i,r) = a(i,r) (i = r,...,n);       (1)
//SUM{l(r,k)*u(k,i) by 1 <= k <= r-1} + l(r,r)*u(r,i) = a(r,i) (i = r+1,...,n).(2)
//Процесс прерывается на r-ом шаге, если l(r,r) = 0. Несостоятельность алгоритма на
//r-ом шаге возникает в том случае, когда l(i,i) != 0 (i = 1,2,...,r-1), а
//l(r,r) = 0. Если же все главные миноры матрицы A не равны нулю, то разложение Краута
//может быть завершено и по построению будет единственным. Однко процесс разложения
//может оказаться несостоятельным, даже если матрица A очень хорошо обусловлена, напри-
//мер, для матрицы вида
// | 0 1 |
// | 1 0 |.
//Часто, однако, процесс разложения может стать численно неустойчивым, хотя исходная
//матрица хорошо обусловлена. Например,
// | eps  a |
// | b    c |, если eps мало по сравнению с a, b и c. В действительности процесс может
//быть устойчивым, даже если главные подматрицы матрицы A значительно хуже обусловлены,
//чем сама матрица A.
//ПРИМЕНЕНИЕ АЛГОРИТМА.
//В начале работы функция проверяет исходную матрицу на матрицу ненулевого размера и
//на квадратную матрицу. В случае, если матрица является матрицей нулевого размера или
//не является квадратной, то функция возвращает false. В этом случае определитель мат-
//рицы считается равным нулю, матрица разложения A исходной матрицы вида LU и вектор
//перестановок строк становятся нулевого размера. Кроме того, исключительная ситуация
//может быть сгенерирована в ходе работы функции, если текущий ведущий элемент матрицы
//на r-ом шаге работы алгоритма Краута станет равным или близким к нулю (lrr < 8*eps,
//eps = 1e-15), что может быть вызвано особенностью исходной матрицы или ошибками
//округления, приводящие матрицу к вырожденному виду. Это означает, что определитель
//матрицы равен 0 и треугольное разложение такой матрицы провести невозможно.
//Исходная матрица при работе функции сохраняется, все операции проводятся с копией
//исходной матрицы - матрицей LU, передаваемой по ссылке. При успешном завершении ра-
//боты алгоритма Краута матрица LU будет содержать элементы нижней L и верхней U тре-
//угольных матриц, за исключением диагональных элементов матрицы U, которые считаются
//равными единице. Информация о перестановке строк матрицы A будет содержатся в век-
//торе ExChange, ExChange.Size() = A.Rows(), причем на i-ом шаге происходит переста-
//новка строк с номерами i и ExChange[i]. Вектор перестановок ExChange используется
//при решении систем уравнений вида AX = B, где B - матрица правых частей, X - матрица
//решений (векторы x), соответствующие своим правым частям матрицы B. С помощью вектора
//перестановок осуществляется перестановка строк матрицы B, так как в ходе выполнения
//алгоритма Краута порядок следования строк в матрице A может быть изменен. Функции
//использует InnerProduct(...) для вычисления скалярного произведения элементов матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& LU - ссылка на матрицу с элементами верхней U и нижней L треугольных
//   матриц, за исключением диагональных элементов U равных 1, которые представляют
//   исходную матрицу: A = LU;
//2. ivector& ExChange - вектор перестановок строк исходной матрицы при выполнении
//   алгоритма Краута;
//3. double Eps [1e-16] - точность вычислений
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат треугольного разложения матрицы
//***********************************************************************************
bool TRealMatrix::LU_UnSymmetric(rmatrix& LU, ivector& ExChange, double Eps) const
{try
 {if (IsZeroSize()) throw M_ZERO_ERROR;//Проверка на матрицу нулевого размера
  if (IsRectang()) throw M_TYPE_ERROR; //Матрица не квадратная
  LU = *this; //Копируем исходную матрицу
  //Формируем вектор перестановок
  ExChange.Resize(LU.Rows()); ExChange.SetType(ROW);
  for (ulong i = 0L; i < ExChange.Size(); i++) ExChange.Put(i,i);
  //Объявление рабочих переменных
  double x, y;
  ulong l;
  //---------------------------------------------------------------------------------
  //                             АЛГОРИТМ КРАУТА
  //---------------------------------------------------------------------------------
  //1. Вычисление норм всех строк матрицы
  rvector Norms;
  LU.NormAllRows(Norms,EUCLIDEAN_NORM);
  //2. Начало цикла разложения матрицы A на две треугольные: L & U
  for (ulong k = 0L; k < LU.Rows(); k++) //k-ый шаг алгоритма Краута
  {l = k; x = 0.0;
   //Цикл вычисления коэффициентов L(i,k) - нижней треугольной матрицы
   for (ulong i = k; i < LU.Rows(); i++)
   {y = InnerProduct(0,1,k,-LU(i,k),LU,COL,i,LU,ROW,k);
    LU(i,k) = -y;
    //Проверка евклидовой нормы i-строки матрицы на нуль. Если евклидова норма строки
    //равна нулю, то матрица A вырождена (квадратная матрица неполного ранга)
    if (Norms.Get(i) < Eps) throw M_DEGENERACY;
    y = fabs(y/Norms.Get(i));
    if (y > x) {x = y; l = i;}
   }//Конец цикла по i

   //Проверка на перестановку строк l и k
   if (l != k) //Выполнить перестановку
   {LU.ExchangeRows(l, k); //Перестановка строк с индексами l & k
    Norms.Put(l,Norms.Get(k));
   }
   ExChange.Put(k,l);
   //Проверка на вырожденность матрицы A
   if (x < 8*Eps) throw M_DEGENERACY;

   //Цикл вычисления коэффициентов U(k,j) - верхней треугольной матрицы
   x = -1/LU.Get(k,k);
   for (ulong j = k+1; j < LU.Cols(); j++)
   {y = InnerProduct(0,1,k,-LU(k,j),LU,COL,k,LU,ROW,j);
    LU.Put(k,j,x * y);
   }//Конец цикла по j

  }//Конец цикла по k
  //------------------------- Конец алгоритма Краута --------------------------------
 }
 catch (int error_type) //Блок обработки исключительной ситуации
 {//Установка выходных данных в случае генерации исключительной ситуации
  LU.Set(0L,0L,false); ExChange.Set(0L,ROW);
  if (error_type == M_TYPE_ERROR) return false;
  else if (error_type == M_ZERO_ERROR) return false;
  else if (error_type == M_DEGENERACY) return false; //Вырожденная матрица
 }
return true;
}
//***********************************************************************************
//СТАТУС: I.4, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double DET_UnSymmetric(double* Base, long* Power) const
//НАЗНАЧЕНИЕ: РАСЧЕТ ОПРЕДЕЛИТЕЛЯ КВАДРАТНОЙ НЕСИММЕТРИЧЕСКОЙ МАТРИЦЫ
//Для расчета определителя функция использует алгоритм Краута (компактная схема Гаусса)
//LU-разложения несимметрической квадратной матрицы с одновременным вычислением опре-
//делителя. Вычисленное значение определителя матрицы является результатом работы
//функции. При det A = 0 - матрица является ВЫРОЖДЕННОЙ.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double* Base (NULL) - указатель на мантиссу определителя матрицы;
//2. long* Power (NULL) - указатель на показатель степени числа 2 определителя мат-
//   рицы. Параметры Base & Power дают возможность представить определитель в виде:
//   Det = Base * 2^(Power), что позволяет избежать переполнения разрядной сетки.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double Det - значение определителя исходной матрицы
//***********************************************************************************
double TRealMatrix::DET_UnSymmetric(double* Base, long* Power) const
{double Det; //значение определителя исходной матрицы
 try
 {//Проверка на матрицу нулевого размера
  if (IsZeroSize()) throw M_ZERO_ERROR;
  //Проверка на квадратную матрицу
  if (IsRectang()) throw M_TYPE_ERROR; //Матрица не квадратная

  rmatrix LU(*this);//Копируем исходную матрицу

  //Формируем вектор перестановок
  ivector ExChange(LU.Rows(),ROW);
  for (ulong i = 0L; i < ExChange.Size(); i++) ExChange.Put(i,i);

  //Объявление рабочих переменных
  double d1 = 1.0; //мантисса определителя
  uint d2 = 0; //показатель степени определителя
  double x, y;
  ulong l;
  //---------------------------------------------------------------------------------
  //                             АЛГОРИТМ КРАУТА
  //---------------------------------------------------------------------------------
  //1. Вычисление норм всех строк матрицы
  rvector Norms;
  LU.NormAllRows(Norms,EUCLIDEAN_NORM);
  //2. Начало цикла разложения матрицы A на две треугольные: L & U
  for (ulong k = 0L; k < LU.Rows(); k++) //k-ый шаг алгоритма Краута
  {l = k; x = 0.0;
   //Цикл вычисления коэффициентов L(i,k) - нижней треугольной матрицы
   for (ulong i = k; i < LU.Rows(); i++)
   {y = InnerProduct(0,1,k,-LU(i,k),LU,COL,i,LU,ROW,k);
    //Проверка евклидовой нормы i-строки матрицы на нуль
    if (Norms.Get(i) < EPS) //Норма строки равна нулю - матрица A вырождена
    {Det = 0.0;
     if (Base != NULL) *Base = 0.0;
     if (Power != NULL) *Power = 0;
     return Det;
    }
    LU(i,k) = -y; y = fabs(y/Norms[i]);
    if (y > x) {x = y; l = i;}
   }//Конец цикла по i

   //Проверка на перестановку строк l и k
   if (l != k) //Выполнить перестановку
   {d1 = -d1; //Изменение знака определителя при перестановке строк матрицы
    LU.ExchangeRows(l, k); //Перестановка строк с индексами l & k
    Norms.Put(l,Norms.Get(k));
   }
   ExChange.Put(k,l);
   //Пошаговое вычисление определителя матрицы
   d1 = d1*LU.Get(k,k);
   //Проверка на вырожденность матрицы A
   if (x < 8*EPS)
   {Det = 0.0;
    if (Base != NULL) *Base = 0.0;
    if (Power != NULL) *Power = 0;
    return Det;
   }
   //Представление определителя матрицы в виде d1*2^(d2), где d1 = 0 или
   // 1/16 <= |d1| < 1
   if ((Base != NULL) && (Power != NULL))
   {while (fabs(d1) >= 1.0) {d1 = d1 * 0.0625; d2 = d2 + 4;}
    while (fabs(d1) < 0.0625) {d1 = d1 * 16; d2 = d2 - 4;}
   }

   //Цикл вычисления коэффициентов U(k,j) - верхней треугольной матрицы
   x = -1/LU.Get(k,k);
   for (ulong j = k+1; j < LU.Cols(); j++)
   {y = InnerProduct(0,1,k,-LU(k,j),LU,COL,k,LU,ROW,j);
    LU.Put(k,j,x * y);
   }//Конец цикла по j

  }//Конец цикла по k
  //---------------------- Конец алгоритма Краута -----------------------------
  if ((Base != NULL) && (Power != NULL)) {*Base = d1; *Power = d2;}
  //Получение значения определителя в явном виде
  Det = d1 * pow(2.0,d2); //Det A = d1 * 2^d2
 }
 catch (int error_type) //Блок обработки исключительной ситуации
 {//Установка выходных данных в случае генерации исключительной ситуации
  Det = 0.0;
  if (Base != NULL) *Base = 0.0;
  if (Power != NULL) *Power = 0;
  if (error_type == M_TYPE_ERROR) return Det;
  else if (error_type == M_ZERO_ERROR) return Det;
 }
return Det;
}
//-----------------------------------------------------------------------------------
//    Решение действительных систем линейных алгебраических уравнений
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: I.5, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rmatrix LE_UnSymSolution(const rmatrix& B, const ivector& ExChange) const
//НАЗНАЧЕНИЕ: РЕШЕНИЕ СИСТЕМЫ ЛИНЕЙНЫХ УРАВНЕНИЙ (СЛУ) ВИДА AX = B
//Функция решает СЛУ AX = B, где A - несимметрическая матрица размера n * n, B - мат-
//рица r правых частей размера n * r. Функции должнен предшествовать вызов функции
//LU_UnSymmetric(...), которая раскладывает матрицу A на произведение верхней U и ниж-
//ней L треугольных матриц. Исходной матрицей служит разложенная на L & U матрица, а
//не матрица коэффициентов при неизвестных в левой части СЛУ. Информация о перестановке
//строк при разложении LU-разложении матрицы коэффициентов передаются через вектор
//ExChange. Решение системы уравнений AX = B состоит из трех этапов: перестановки эле-
//ментов правых частей, которые хранятся в матрице B и последовательного решения сна-
//чала системы уравнений LY = B, а затем системы UX = Y. Матрицы решений Y, а затем и
//X записываются в матрицу X, которая возвращается по окончании работы функцией. Сле-
//дует заметить, что данная система всегда будет иметь решение, так как матрица коэф-
//фициентов разложена на матрицы L и U. Функция вызывает InnerProduct(...) для вычис-
//ления скалярного произведения элементов матриц.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& B - ссылка на матрицу правых частей размера n x r
//2. const ivector& ExChange - вектор перестановок строк исходной матрицы при
//   выполнении алгоритма Краута;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// rmatrix X - матрица решений системы линейных уравнений с r правыми частями
//***********************************************************************************
rmatrix TRealMatrix::LE_UnSymSolution(const rmatrix& B, const ivector& ExChange) const
{rmatrix X;
 if (B.IsZeroSize()) return X;//Матрица B - матрица нулевого размера
 //Проверка на соответствие числа строк матрицы коэффициентов при неизвестных A
 //количества строк матрицы правых частей B
 if (Rows() != B.Rows()) return X;
 X = B;
 ulong r = B.Cols();
 ulong n = Rows();
 double x;
 //Шаг 1. Перестановка строк матрицы правых частей B
 if (!ExChange.IsZeroSize()) X.ExchangeRows(ExChange);
 //----------------------------------------------------------------------------------
 //Решение системы уравнений по k-му столбцу матрицы правых частей B
 //----------------------------------------------------------------------------------
 for (ulong k = 0; k < r; k++)
 {//Шаг 2. Решение системы LY = B
  for (ulong i = 0; i < n; i++)
  {x = InnerProduct(0,1,i,X(i,k),*this,COL,i,X,ROW,k);
   X.Put(i,k,-x/data[i][i]);
  }
  //Шаг 3. Решение системы UX = B
  for (ulong i = n-1;; i--)
  {x = InnerProduct(i+1,1,n,X(i,k),*this,COL,i,X,ROW,k);
   X.Put(i,k,-x);
   if (i == 0) break;
  }
 }//Конец решения СЛУ с r правыми частями
 return X;//Матрица решений для r правых частей СЛУ вида AX = B.
}
//***********************************************************************************
//СТАТУС: I.6, TRealMatrix class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend rmatrix LE_UnSymSolution(const rmatrix& A, const rmatrix& B)
//НАЗНАЧЕНИЕ: РЕШЕНИЕ СИСТЕМЫ ЛИНЕЙНЫХ УРАВНЕНИЙ ВИДА AX = B
//Данная функция позволяет решить систему линейных уравнений AX = B, где A - несиммет-
//рическая матрица размера n * n коэффициентов СЛУ при неизвестных, B - матрица r пра-
//вых частей размера n * r. Функция для решения системы линейных уравнений использует
//разновидность компактной схемы Гаусса - алгоритм Краута и состоит из двух основных
//частей: 1) Разложения матрицы A на верхнюю U треугольную матрицу с единицами на глав-
//ной диагонали и нижнюю L треугольную матрицу по алгоритму Краута 2) Собственно нахож-
//дения неизвестных (вектора решения) для r правых частей матрицы B. Работа функции
//строится на вызове двух функций LU_UnSymmetric(...) и LE_UnSymSolution(...).
//В ходе решения системы линейных уравнений могут возникать исключительные ситуации.
//Основные причины генерации таких ситуаций следующие: вырожденность матрицы A (detA = 0),
//несоответствие числа строк матрицы B матрице A, нулевыми размерами матриц A или B.
//При возникновении исключительной ситуации возвращается матрица решений X нулевого
//размера без принудительного завершения работы всей программы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& A - ссылка на матрицу коэффициентов при неизвестных размера n x n
//2. const rmatrix& B - ссылка на матрицу правых частей размера n x r
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//rmatrix X - матрица решений системы линейных уравнений с r правыми частями
//***********************************************************************************
rmatrix LE_UnSymSolution(const rmatrix& A, const rmatrix& B)
{rmatrix X;
 try
 {//Проверка матриц A & B на матрицы нулевого размера
  if (B.IsZeroSize() || A.IsZeroSize()) throw M_ZERO_ERROR;
  //Проверка матрицы А на квадратную
  if (!A.IsSquare()) throw M_SIZE_ERROR;
  //Проверка на соответствие числа строк матрицы коэффициентов при неизвестных
  //A количества строк матрицы правых частей B
  if (A.Rows() != B.Rows()) throw M_SIZE_MISMATCH;
  //---------------------------------------------------------------------------------
  //1. Разложение матрицы A по алгоритму Краута вида A = LU
  //---------------------------------------------------------------------------------
  double Det;
  rmatrix LU;
  ivector ExChange;
  bool lSuccess = A.LU_UnSymmetric(Det, LU, ExChange);
  //Анализ матрицы A на вырожденность - det A = 0
  if (lSuccess == false) throw M_DEGENERACY;
  //---------------------------------------------------------------------------------
  //2. Решение системы линейных уравнений с r-правыми частями
  //---------------------------------------------------------------------------------
  X = LU.LE_UnSymSolution(B, ExChange);
 }
 //Блок обработки исключительных ситуаций
 catch (int error_type)
 {X.Set(0L,0L,false);
  if (error_type == M_SIZE_ERROR) return X;
  else if (error_type == M_SIZE_MISMATCH) return X;
  else if (error_type == M_ZERO_ERROR) return X;
  else if (error_type == M_DEGENERACY) return X; //Вырожденная матрица
 }//Конец блока обработки исключительных ситуаций
return X;//Матрица решений СЛУ с r правыми частями
}
//-----------------------------------------------------------------------------------
// Обращение матриц
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: I.7, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix INV_Krauth(double Eps = 1e-16) const
//НАЗНАЧЕНИЕ: ОБРАЩЕНИЕ НЕСИММЕТРИЧЕСКОЙ КВАДРАТНОЙ МАТРИЦЫ С ИСПОЛЬЗОВАНИЕМ
//            КОМПАКТНОЙ СХЕМЫ ГАУССА (АЛГОРИТМ КРАУТА) ДЛЯ РЕШЕНИЯ СЛУ
//Данная функция позволяет обратить несимметрическую квадратную матрицу размера n * n.
//Работа функции сходна с функцией для решения системы линейных уравнений с использо-
//ванием компактной схемы Гаусса и состоит из двух основных частей:
//1) LU разложения матрицы A по алгоритму Краута;
//2) Собственно нахождения обратной матрицы, когда матрица правых частей B является
//   единичной матрицей размера n x n.
//Работа функции строится на вызове двух функций LU_UnSymmetric(...) и LE_UnSymSolution(...).
//После выполнения последней функции элементы преобразованной матрицы B являются эле-
//ментами ОБРАТНОЙ МАТРИЦЫ.
//При обращении матрицы могут возникать исключительные ситуации. Основные причины ге-
//нерации таких ситуаций следующие: вырожденность исходной матрицы A (detA = 0), нуле-
//вым размером матрицы A, матрица А не является квадратной. При возникновении исключи-
//тельной ситуации возвращается матрица Inverse нулевого размера без принудительного
//завершения работы всей программы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double Eps [1e-16] - точность вычислений
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix Inverse - обратная матрица
//***********************************************************************************
rmatrix TRealMatrix::INV_Krauth(double Eps) const
{rmatrix Inverse;
 try
 {//Проверка матрицы A на матрицу нулевого размера
  if (IsZeroSize()) throw M_ZERO_ERROR;
  //Проверка матрицы А на квадратную
  if (!IsSquare()) throw M_SIZE_ERROR;
  //---------------------------------------------------------------------------------
  //1. LU разложение матрицы A по алгоритму Краута
  //---------------------------------------------------------------------------------
  rmatrix LU;
  ivector ExChange;
  bool lSuccess = LU_UnSymmetric(LU,ExChange,Eps);
  //Анализ матрицы A на вырожденность - det A = 0
  if (lSuccess == false) throw M_DEGENERACY;
  //---------------------------------------------------------------------------------
  //2. Обращение матрицы А n x n решением системы линейных уравнений AX = B, где
  //   матрица B - единичная матрица размера n x n.
  //---------------------------------------------------------------------------------
  rmatrix E(Rows(),RM_UNIT);
  Inverse = LU.LE_UnSymSolution(E, ExChange);
 }
 //Блок обработки исключительных ситуаций
 catch (int error_type)
 {Inverse.Set(0L,0L,false);
  if (error_type == M_SIZE_ERROR) return Inverse;
  else if (error_type == M_ZERO_ERROR) return Inverse;
  else if (error_type == M_DEGENERACY) return Inverse; //Вырожденная матрица
 }//Конец блока обработки исключительных ситуаций
return Inverse;//Обратная матрица
}
//***********************************************************************************
//СТАТУС: I.8, TRealMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool INV_Krauth(rmatrix& invA, double Eps = 1e-16) const
//НАЗНАЧЕНИЕ: ОБРАЩЕНИЕ НЕСИММЕТРИЧЕСКОЙ КВАДРАТНОЙ МАТРИЦЫ С ИСПОЛЬЗОВАНИЕМ
//            КОМПАКТНОЙ СХЕМЫ ГАУССА (АЛГОРИТМ КРАУТА) ДЛЯ РЕШЕНИЯ СЛУ
//Функция позволяет обратить несимметрическую квадратную матрицу размера n * n.
//Работа функции сходна с функцией для решения системы линейных уравнений с использо-
//ванием компактной схемы Гаусса и состоит из двух основных частей:
//1) LU разложения матрицы A по алгоритму Краута;
//2) Собственно нахождения обратной матрицы, когда матрица правых частей B является
//   единичной матрицей размера n x n.
//Элементы обратной матрицы А формируются в матрице invA, передаваемой по ссылке.
//При обращении матрицы могут возникать исключительные ситуации. Основные причины ге-
//нерации таких ситуаций следующие: вырожденность исходной матрицы A (detA = 0), нуле-
//вым размером матрицы A, матрица А не является квадратной. При возникновении исключи-
//тельной ситуации возвращается false и матрица invA нулевого размера без принудитель-
//ного завершения работы всей программы.
//Функция возвращает false и прекращает свою работу, если адреса исходной и результи-
//рующей A матриц совпадают (одна и та же матрица).
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& invA - ссылка на матрицу, в которой формируется обратная матрица
//2. double Eps [1e-16] - точность вычислений
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат обращения исходной матрицы
//***********************************************************************************
bool TRealMatrix::INV_Krauth(rmatrix& invA, double Eps) const
{//Адреса исходной и результирующей матриц совпадают
 if (this == &invA) return false;
 try
 {//Проверка матрицы A на матрицу нулевого размера
  if (IsZeroSize()) throw M_ZERO_ERROR;
  //Проверка матрицы А на квадратную
  if (!IsSquare()) throw M_SIZE_ERROR;
  //---------------------------------------------------------------------------------
  //1. LU разложение матрицы A по алгоритму Краута
  //---------------------------------------------------------------------------------
  rmatrix LU;
  ivector ExChange;
  bool lSuccess = LU_UnSymmetric(LU,ExChange,Eps);
  //Анализ матрицы A на вырожденность - det A = 0
  if (lSuccess == false) throw M_DEGENERACY;
  //---------------------------------------------------------------------------------
  //2. Обращение матрицы А n x n решением системы линейных уравнений AX = B, где
  //   матрица B - единичная матрица размера n x n.
  //---------------------------------------------------------------------------------
  invA.Set(Rows(),RM_UNIT);
  //invA = LU.LE_UnSymSolution(invA, ExChange);
  //Inverse = LU.LE_UnSymSolution(E, ExChange);

  //Шаг 1. Перестановка строк матрицы правых частей invA
  if (!ExChange.IsZeroSize()) invA.ExchangeRows(ExChange);
  //---------------------------------------------------------------------------------
  //Решение системы уравнений по k-му столбцу матрицы правых частей invA
  //---------------------------------------------------------------------------------
  ulong n = Rows();
  double x;
  for (ulong k = 0; k < n; k++)
  {//Шаг 2. Решение системы LY = X
   for (ulong i = 0; i < n; i++)
   {x = InnerProduct(0,1,i,invA(i,k),LU,COL,i,invA,ROW,k);
    invA.Put(i,k,-x/LU.Get(i,i));
   }
   //Шаг 3. Решение системы UX = B
   for (ulong i = n-1;; i--)
   {x = InnerProduct(i+1,1,n,invA(i,k),LU,COL,i,invA,ROW,k);
    invA.Put(i,k,-x);
    if (i == 0) break;
   }
  }//Конец решения СЛУ с n правыми частями

 }
 //Блок обработки исключительных ситуаций
 catch (int error_type)
 {invA.Set(0L,false);
  if (error_type == M_SIZE_ERROR) return false;
  else if (error_type == M_ZERO_ERROR) return false;
  else if (error_type == M_DEGENERACY) return false; //Вырожденная матрица
 }//Конец блока обработки исключительных ситуаций
return true;//Обратная матрица вычислена
}

//----------------------------------------------------------------------------------------
//Расчет собственных значений и собственных векторов действительных матриц
//----------------------------------------------------------------------------------------
//****************************************************************************************
//СТАТУС: I.7, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: uint EVV_Jacobi(TRealVector& D, TRealMatrix& V, double EPS=1e-19)
//НАЗНАЧЕНИЕ: РАСЧЕТ СОБСТВЕННЫХ ЗНАЧЕНИЙ И СОБСТВЕННЫХ ВЕКТОРОВ МАТРИЦЫ
//Функция предназначена для определения собственных значений и собственных векторов СИММЕТ-
//РИЧЕСКОЙ действительной матрицы по алгоритму ЯКОБИ.
//ТЕОРИТИЧЕСКИЕ ПРЕДПОСЫЛКИ. Алгоритм Якоби приводит исходную симметрическую матрицу к ДИА-
//ГОНАЛЬНОМУ ВИДУ с помощью последовательности элементарных ортогональных преобразований
//(плоских вращений или вращений Якоби). Процедура построена таким образом, что на k+1-ом
//шаге осуществляется преобразование вида:
//               Ak -> Ak+1 = tr(Uk)AkUk,                                  (1)
//где Uk = Uk(p,q,phi) - ортогональная матрица, отличающаяся от единичной только элементами:
//               upp = uqq = cos(phi) & upq = -upq = sin(phi).             (2)
//Исходную матрицу A в соответствии с соотношением (1) обозначают через A0. В целом, метод
//Якоби позволяет выполнить с определенной точностью преобразование исходной матрицы к виду:
//               A -> D = tr(V)AV,                                         (3)
//где D - диагональная, а V - ортогональная матрица. Матрица D является пределом, к которому
//стремиться последовательность матриц Ak при k -> бесконечности, а V - произведение всех
//промежуточных матриц плоских вращений, используемых для диагонализации исходой матрицы,
//т.е. V = U0*U1*U2...
//Основное достоинство метода Якоби заключается в том, что при выполнении каждого плоского
//вращения уменьшается сумма квадратов внедиагональных элементов; сходимость этой суммы к
//нулю по мере увеличения числа шагов гарантирует сходимость процесса диагонализации. Ско-
//рость сходимости - КВАДРАТИЧНАЯ.
//ПРИМЕНЕНИЕ АЛГОРИТМА. Алгоритм реализует построчный поиск максимального по модулю элемента
//в правом верхнем углу исходной симметрической матрицы. Алгоритм пригоден для любых дейст-
//вительных симметрических матриц. Он обеспечивает точность, сравнимую с точностью компьютера,
//на котором реализован алгоритм. Обычно для этого требуется примерно 6-10 циклов (максималь-
//ное кол-во 50), или приблизительно 3n^2-5n^2 вращений Якоби. Несмотря на то, что метод
//Якоби достаточно компактен и изящен и вычисление собственных векторов не предсавляет за-
//труднений, он требует большего времени для вычислений, чем сочетание процедуры преобразо-
//вания к трехдиагональной форме с последующим вычислением собственных значений трехдиаго-
//нальной матрицы. Поэтому при больших порядках исходных матриц предпочтительнее использо-
//вать эти процедуры вместо процедуры Якоби. Кроме того, метод Якоби не использует преиму-
//ществ симметрических ленточных матриц, ширина которых мала по сравнению с их порядком n.
//Для матриц такого типа лучше применять LR-алгоритм.
//В начале работы функции осуществляется проверка матрицы на симметричность. Функция изме-
//няет только наддиагональные элементы исходной симметрической матрицы, поэтому после за-
//вершения процесса диагонализации матрица восстанавливается. Вычисленные собственные зна-
//чения матрицы записываются в объект TRealVector D, передаваемый по ссылке. D - это век-
//тор-строка, размерности n (n - размерность исходной симметрической матрицы). Если ссылка
//на объект TRealMatrix V не равна NULL, то в ходе работы алгоритма Якоби осуществляется
//вычисление собственных векторов исходной матрицы, в противном случае - собственные вектора
//не вычисляются. Система найденных векторов всегда ортогональна, и это свойство сохраняется
//даже в случае весьма близких или кратных собственных значений. Хотя точность ортогональных
//соотношений значительна, отсюда не следует, что стольже точны и сами собственные векторы.
//TRealMatrix V - это квадратная матрицу порядка n. Следует заметить, что если объекты D & V,
//передаваемые по ссылке, содержали какую-либо информацию, то после работы функции она будет
//утеряна и объекты D и V будут иметь новый тип, размерность и содержать другие данные:
//собственные значения и собственные векторы исходной симметрической матрицы соответственно.
//Величина double EPS характеризует точность производимых расчетов.
//При успешном завершении функции, она возвращает количество произведенных плоских враще-
//ний - rot. Если матрица не является симметрической, то выполнение алгоритма Якоби не
//производится. После выполнения алгоритма Якоби расположение собственных значений не упо-
//рядочено.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint rot - количество проведенных плоских вращений при приведении
//исходной действительной симметрической матрицы к диагональному виду.
//****************************************************************************************
uint TRealMatrix::EVV_Jacobi(TRealVector& D, TRealMatrix& V, double EPS) const
{uint rot = 0;//Счетчик числа проведенных плоских вращений
 //---------------------------------------------------------------------------------------
 //Проверка матрицы на симметричность
 if ((!IsSymmetric()) && (!IsDiagonal()))
 {D.Resize(0,false); V.Set(0,false); return rot;}
 if (this == &V) {D.Resize(0,false); return rot;}
 //---------------------------------------------------------------------------------------
 //Объявление вспомогательных переменных
 double sm, c, s, t, h, g, tau, theta, tresh;

 bool eivec = true;//Определение собственных векторов
 ulong n = Rows();//Определение порядка исходной матрицы
 //Создание вектора-строки D с собственными значениями матрицы
 D.Set(n,ROW,0.0);
 //Создание вспомогательных векторов-строк
 rvector b(n,ROW,false), z(n,ROW,false);
 if (&V == NULL) eivec = false;
 //Создание квадратной матрицы V с собственными векторами матрицы
 else V.Set(n,n,false);
 //-----------------------------------------------------------------------------
 //                               Алгоритм Якоби
 //-----------------------------------------------------------------------------
 if (eivec) //Вычисление собственных векторов необходимо
 {//Преобразование матрицы V в диагональную матрицу
  for (ulong p = 0; p < n; p++)
   for (ulong q = 0; q < n; q++)
    if (p == q) V.Put(p,q,1.0);
    else V.Put(p,q,0);
 }
 //Копирование диагональных элементов матрицы в D & b, обнуление z
 for (ulong p = 0; p < n; p++)
 {b.Put(p,data[p][p]); D.Put(p,data[p][p]); z.Put(p,0);}
 //-----------------------------------------------------------------------------
 //Начало цикла диагонализации исходной матрицы
 //-----------------------------------------------------------------------------
 for (ulong i = 1; i <= 50; i++)
 {sm = 0.0;
  //Цикл подсчета суммы наддиагональных элементов матрицы
  for (ulong p = 0; p < (n-1); p++)
   for (ulong q = p+1; q < n; q++)
    sm += fabs(data[p][q]);
  //Сумма наддиагональных элементов равна (близка) 0 - процесс диагонализации
  //завершен
  if (sm < EPS) break; //return rot;
  //Проверка условия выполнения первых трех вращений
  if (i < 4) tresh = (0.2*sm)/(n*n);
  else tresh = 0.0;
  //----------------------------------------------------------------------------
  //Цикл выполнения вращения в плоскости (p,q)
  //----------------------------------------------------------------------------
  for (ulong p = 0; p < (n-1); p++)
   for (ulong q = p+1; q < n; q++)
   {g = 100*fabs(data[p][q]);
    if ((i > 4) && (g < EPS) && (fabs(fabs(D.Get(p))-fabs(D.Get(q))) < EPS))
     data[p][q] = 0.0;
    //Вращение
    else if (fabs(data[p][q]) > tresh)
    {//Вычисление тангенса угла вращения
     h = D.Get(q) - D.Get(p);
     if ((g < EPS) && (fabs(h) > EPS)) t = data[p][q]/h;
     else
     {theta = (0.5*h)/data[p][q];
      t = 1/(fabs(theta)+sqrt(1+theta*theta));
      if (theta < 0) t = -t;
     }
     c = 1/sqrt(1+t*t);
     s = t*c;
     tau = s/(1+c);
     h = t*data[p][q];
     z.Put(p,z.Get(p)-h); z.Put(q,z.Get(q)+h);
     D.Put(p,D.Get(p)-h); D.Put(q,D.Get(q)+h);
     data[p][q] = 0.0;
     //варианта 0 <= j < p
     for (ulong j = 0; j < p; j++)
     {g = data[j][p]; h = data[j][q];
      data[j][p] = g-s*(h+g*tau);
      data[j][q] = h+s*(g-h*tau);
     }
     //варианта p < j < q
     for (ulong j = p+1; j < q; j++)
     {g = data[p][j]; h = data[j][q];
      data[p][j] = g-s*(h+g*tau);
      data[j][q] = h+s*(g-h*tau);
     }
     //варианта g < j <= n
     for (ulong j = q+1; j < n; j++)
     {g = data[p][j]; h = data[q][j];
      data[p][j] = g-s*(h+g*tau);
      data[q][j] = h+s*(g-h*tau);
     }
     //Вычисление собственных векторов
     if (eivec)
      for (ulong j = 0; j < n; j++)
      {g = V.Get(j,p); h = V.Get(j,q);
       V.Put(j,p, g-s*(h+g*tau));
       V.Put(j,q, h+s*(g-h*tau));
      }
     rot += 1;
    }
   }//Конец цикла вращения в плоскости (p,q)
   for (ulong p = 0; p < n; p++)
   {b.Put(p, b.Get(p) + z.Get(p));
    D.Put(p, b.Get(p));
    z.Put(p,0);
   }
 }//Конец цикла диагонализации

//Восстановление исходной матрицы
for (ulong p = 1; p < n; p++)
 for (ulong q = 0; q < p; q++)
  data[q][p] = data[p][q];

return rot;
}
//****************************************************************************************
//СТАТУС: I.7.1, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// int EV_Jacobi(TRealVector& D, double EPS=1e-19, bool lSort=true) const
//НАЗНАЧЕНИЕ: РАСЧЕТ СОБСТВЕННЫХ ЗНАЧЕНИЙ СИММЕТРИЧЕСКОЙ МАТРИЦЫ
//Функция предназначена для определения собственных значений СИММЕТРИЧЕСКОЙ действительной
//матрицы по алгоритму ЯКОБИ с возможностью их сортировки по возрастанию. Алгоритм работы
//функции по определению собственных значений аналогичен функции EVV_Jacobi(...). Функция
//осуществляет проверку матрицы только на ее квадратность с целью ускорения процесса вычис-
//лений без проверки на симметричность. Функция изменяет только наддиагональные элементы
//исходной симметрической матрицы, поэтому после завершения процесса диагонализации матрица
//восстанавливается. Вычисленные собственные значения матрицы записываются в вектор D, пе-
//редаваемый по ссылке. Размерность вектора D равна размерности исходной матрицы (по числу
//собственных чисел исходной матрицы). Величина double EPS характеризует точность произво-
//димых расчетов.
//При успешном завершении функции, она возвращает количество произведенных плоских вращений
//rot, в случае неудачи -1. Опция lSort отвечает за сортировку по возрастанию собственных
//значений, расмещаемых в векторе D.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TRealVector& D - ссылка на вектор-приемник собственных значений матрицы;
//2. double EPS - точность производимых расчетов;
//3. bool lSort (true) - опция сортировки по возрастанию вычисленных собственных чисел.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint rot - количество проведенных плоских вращений при приведении
//исходной действительной симметрической матрицы к диагональному виду.
//****************************************************************************************
int TRealMatrix::EV_Jacobi(TRealVector& D, double EPS, bool lSort) const
{int rot = 0;//Счетчик числа проведенных плоских вращений
 //---------------------------------------------------------------------------------------
 //Проверка матрицы на квадратную
 if (!this->IsSquare() || this->IsZeroSize()) {D.Resize(0,false); return -1;}
 //---------------------------------------------------------------------------------------
 //Объявление вспомогательных переменных
 double sm, c, s, t, h, g, tau, theta, tresh;

 ulong n = Rows();//Определение порядка исходной матрицы
 //Создание вектора-строки D с собственными значениями матрицы
 D.Set(n,ROW,0.0);
 //Создание вспомогательных векторов-строк
 rvector b(n,ROW,false), z(n,ROW,false);
 //-----------------------------------------------------------------------------
 //                               Алгоритм Якоби
 //-----------------------------------------------------------------------------
 //Копирование диагональных элементов матрицы в D & b, обнуление z
 for (ulong p = 0; p < n; p++)
 {b.Put(p,data[p][p]); D.Put(p,data[p][p]); z.Put(p,0);}
 //-----------------------------------------------------------------------------
 //Начало цикла диагонализации исходной матрицы
 //-----------------------------------------------------------------------------
 for (ulong i = 1; i <= 50; i++)
 {sm = 0.0;
  //Цикл подсчета суммы наддиагональных элементов матрицы
  for (ulong p = 0; p < (n-1); p++)
   for (ulong q = p+1; q < n; q++)
    sm += fabs(data[p][q]);
  //Сумма наддиагональных элементов равна (близка) 0 - процесс диагонализации
  //завершен
  if (sm < EPS) break; //return rot;
  //Проверка условия выполнения первых трех вращений
  if (i < 4) tresh = (0.2*sm)/(n*n);
  else tresh = 0.0;
  //----------------------------------------------------------------------------
  //Цикл выполнения вращения в плоскости (p,q)
  //----------------------------------------------------------------------------
  for (ulong p = 0; p < (n-1); p++)
   for (ulong q = p+1; q < n; q++)
   {g = 100*fabs(data[p][q]);
    if ((i > 4) && (g < EPS) && (fabs(fabs(D.Get(p))-fabs(D.Get(q))) < EPS))
     data[p][q] = 0.0;
    //Вращение
    else if (fabs(data[p][q]) > tresh)
    {//Вычисление тангенса угла вращения
     h = D.Get(q) - D.Get(p);
     if ((g < EPS) && (fabs(h) > EPS)) t = data[p][q]/h;
     else
     {theta = (0.5*h)/data[p][q];
      t = 1/(fabs(theta)+sqrt(1+theta*theta));
      if (theta < 0) t = -t;
     }
     c = 1/sqrt(1+t*t);
     s = t*c;
     tau = s/(1+c);
     h = t*data[p][q];
     z.Put(p,z.Get(p)-h); z.Put(q,z.Get(q)+h);
     D.Put(p,D.Get(p)-h); D.Put(q,D.Get(q)+h);
     data[p][q] = 0.0;
     //варианта 0 <= j < p
     for (ulong j = 0; j < p; j++)
     {g = data[j][p]; h = data[j][q];
      data[j][p] = g-s*(h+g*tau);
      data[j][q] = h+s*(g-h*tau);
     }
     //варианта p < j < q
     for (ulong j = p+1; j < q; j++)
     {g = data[p][j]; h = data[j][q];
      data[p][j] = g-s*(h+g*tau);
      data[j][q] = h+s*(g-h*tau);
     }
     //варианта g < j <= n
     for (ulong j = q+1; j < n; j++)
     {g = data[p][j]; h = data[q][j];
      data[p][j] = g-s*(h+g*tau);
      data[q][j] = h+s*(g-h*tau);
     }
     rot += 1;
    }
   }//Конец цикла вращения в плоскости (p,q)
   for (ulong p = 0; p < n; p++)
   {b.Put(p, b.Get(p) + z.Get(p));
    D.Put(p, b.Get(p));
    z.Put(p,0);
   }
 }//Конец цикла диагонализации

//Восстановление исходной матрицы
for (ulong p = 1; p < n; p++)
 for (ulong q = 0; q < p; q++)
  data[q][p] = data[p][q];

//Сортировка по возрастанию собственных чисел матрицы
if (lSort) D.BubbleSort(DESCENDING);

return rot;
}
//-----------------------------------------------------------------------------------
//    Треугольное разложение положительно определенных симметрических матриц
//                     (разложение по схеме Холецкого)
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: I.8, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:  bool DET_Cholesky(rmatrix& LU, double& Det) const
//НАЗНАЧЕНИЕ: LU-РАЗЛОЖЕНИЕ СИММЕТРИЧЕСКОЙ ПОЛОЖИТЕЛЬНО ОПРЕДЕЛЕННОЙ МАТРИЦЫ ПО СХЕМЕ
//ХОЛЕЦКОГО С ВЫЧИСЛЕНИЕМ ОПРЕДЕЛИТЕЛЯ.
//С целью ускорения работы не производится проверка матрицы на симметричность и поло-
//жительную определенность. Матрица проверяется только на квадратную и ненулевого раз-
//мера. Верхняя U и нижняя L треугольные матрицы размещаются в матрице LU, передавае-
//мой по ссылке, размерность матрицы LU будет соответствовать размерности исходной
//матрицы. При LU-разложении будут задействованы только диагональные и наддиагональные
//элементы исходной матрицы. При вычислении определителя исходной матрицы использовано
//представление d1*2^d2.
//При успешном завершении функции возвращается true, матрица LU будет содержать элементы
//верхней и нижней треугольных матриц LU-разложения по схеме Холецкого и соответство-
//вать размерности исходной матрицы, в переменной Det будет храниться определитель ис-
//ходной матрицы.
//Если исходная матрица не является квадратной или из-за ошибок округления вычисленные
//значения диагональных элементов матрицы L оказываются неположительными, то функция
//возвращает значение false, матрица LU становится матрицей нулевого размера, а в пе-
//ременную Det записывается 0.
//Функция не изменяет значений элементов исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& LU - ссылка на матрицу с элементами верхней и нижней треугольной матри-
//   цами LU-разложения по схеме Холецкого исходной матрицы;
//2. double& Det - ссылка на переменную с величиной определителя матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат выполнения LU-разложения исходной матрицы
//***********************************************************************************
bool TRealMatrix::DET_Cholesky(rmatrix& LU, double& Det) const
{//Проверка исходной матрицы на квадратную и не нулевого размера
 if (IsRectang() || IsZeroSize()) {LU.Set(0L,false); Det = 0.0; return false;}
 double d1 = 1.0, d2 = 0.0, x;
 ulong N = Rows();
 //Построение матрицы LU одинаковой  с исходной матрицей размерности
 LU.Set(N,false);
 //----------------------------------------------------------------------------------
 //LU-разложение по схеме Холецкого
 //----------------------------------------------------------------------------------
 for (ulong i = 0L; i < N; i++)
  for (ulong j = i; j < N; j++)
  {x = data[i][j];
   for (ulong k = i-1; k < i; k--) x = x - LU.Get(j,k)*LU.Get(i,k);//k < i
   //Вычисление диагонального элемента матрицы L
   if (j == i)
   {d1 = d1*x;
    if (x == 0.0) {LU.Set(0L,false); Det = 0.0; return false;}
    //Вычисление определителя исходной матрицы
    while (fabs(d1) >= 1.0) {d1 = d1*0.0625; d2 = d2+4;}
    while (fabs(d1) < 0.0625) {d1 = d1*16; d2 = d2-4;}

    if (x < 0.0) {LU.Set(0L,false); Det = 0.0; return false;}
    LU.Put(i,i,1.0/sqrt(x));
   }
   //Вычисление внедиагональных элементов матриц L и U
   else {LU.Put(j,i,x*LU.Get(i,i)); LU.Put(i,j,LU.Get(j,i));}
  }//Завершение формирования матриц L и U

  //Вычисление диагональных элементов матриц L и U
  for (ulong i = 0L; i < N; i++) LU.Put(i,i,1.0/LU.Get(i,i));
  //Вычисление определителя исходной матрицы
  Det = d1*pow(2.0,d2);

 return true;
}
//***********************************************************************************
//СТАТУС: I.9, friend function to TRealMatrix class
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool LE_Cholesky(const rmatrix& A, const rmatrix& B, rmatrix& X)
//НАЗНАЧЕНИЕ: РЕШЕНИЕ СИСТЕМЫ ЛИНЕЙНЫХ УРАВНЕНИЙ ПО СХЕМЕ ХОЛЕЦКОГО AX = B.
//A - положительно определенная симметрическая матрица размерности N, B - матрица R
//правых частей размера NxR, матрица X - матрица решений размера NxR.
//С целью ускорения работы не производится проверка матрицы A на симметричность и поло-
//жительную определенность. Матрица A проверяется только на квадратную и ненулевого раз-
//мера. Осуществляется проверка на равное число строк матриц A и B.
//Матрица решений X формируется в ходе выполнения функции, матрицы A и B функцией не
//изменяются.
//В случае невозможности LU-разложения матрицы A по схеме Холецкого или несовпадения
//числа строк матриц A и В функция возвращает false и преобразует матрицу X в матрицу
//нулевого размера.
//                А Л Г О Р И Т М   Р А Б О Т Ы   Ф У Н К Ц И И
//1. LU-разложение матрицы A по схеме Холецкого с размещением элементов в матрице L.
//2. Отыскание решения системы AX = B как результат последовательного решения систем
//   LY = B и UX = Y.
//При успешном завершении функции возвращается true, матрица X будет содержать решение
//системы уравнений AX = B. Каждое решение представляет собой вектор-столбец, количество
//которых определятся числом столбцов матрицы правых частей B.
//Функцию можно использовать для обращения матрицы A. Для этого матрица B должна быть
//ЕДИНИЧНОЙ матрицей с размерностью равной размерности A. В этом случае, матрица реше-
//ний X будет является ОБРАТНОЙ к матрице A.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix&  A - ссылка на симметрическую положительно определенную матрицу
//   коэффициентов линейного уравнения, размерности n;
//2. const rmatrix&  B - ссылка на матрицу r правых частей размера nxr;
//3. rmatrix&  X - ссылка на матрицу решений системы линейных алгебраических уравнений.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат решения системы линейных уравнений
//***********************************************************************************
bool LE_Cholesky(const rmatrix& A, const rmatrix& B, rmatrix& X)
{X.Set(0L,false);
 //Проверка исходной матрицы на квадратную и не нулевого размера
 if (A.IsRectang() || A.IsZeroSize() || B.IsZeroSize() || A.Rows() != B.Rows())
  return false;
 double x,z;
 ulong n = A.Rows(), r = B.Cols();
 //Построение матрицы L одинаковой  с матрицей A размерности
 rmatrix L(n,false);
 //----------------------------------------------------------------------------------
 //LU-разложение по схеме Холецкого
 //----------------------------------------------------------------------------------
 for (ulong i = 0L; i < n; i++)
  for (ulong j = i; j < n; j++)
  {x = A.Get(i,j);
   for (ulong k = i-1; k < i; k--) x = x - L.Get(j,k)*L.Get(i,k);
   if (j == i) //Вычисление диагонального элемента матрицы L
   {if (x <= 0.0) return false;
    L.Put(i,i,1.0/sqrt(x));
   }
   else L.Put(j,i,x*L.Get(i,i)); //Вычисление внедиагональных элементов матрицы L
  }
  //---------------------------------------------------------------------------------
  //Решение системы уравнений AX = B
  //---------------------------------------------------------------------------------
  X.Set(n,r,false);
  for (ulong j = 0L; j < r; j++)
  {//Решение системы Ly = b
   for (ulong i = 0L; i < n; i++)
   {z = B.Get(i,j);
    for (ulong k = i-1; k < i; k--) z = z - L.Get(i,k)*X.Get(k,j);
    X.Put(i,j,z*L.Get(i,i));
   }
   //Решение системы Ux = y
   for (ulong i = n-1; i < n; i--)
   {z = X.Get(i,j);
    for (ulong k = i+1; k < n; k++) z = z - L.Get(k,i)*X.Get(k,j);
    X.Put(i,j,z*L.Get(i,i));
   }
  }
 return true;
}
//***********************************************************************************
//СТАТУС: I.10, TRealMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:  bool INV_Cholesky(rmatrix& invA) const
//НАЗНАЧЕНИЕ: ОБРАЩЕНИЕ СИММЕТРИЧЕСКОЙ ПОЛОЖИТЕЛЬНО ОПРЕДЕЛЕННОЙ МАТРИЦЫ ПО СХЕМЕ
//ХОЛЕЦКОГО
//С целью ускорения работы не производится проверка матрицы на симметричность и поло-
//жительную определенность. Матрица проверяется только на квадратную и ненулевого раз-
//мера. Матрица обратная исходной размещается в матрице invA, передаваемой в функцию
//по ссылке.
//При успешном завершении функции возвращается true, матрица invA будет содержать эле-
//менты обратной матрицы к исходной матрице.
//Если исходная матрица не является квадратной или из-за ошибок округления вычисленные
//значения диагональных элементов матрицы L оказываются неположительными, то функция
//возвращает значение false и матрица invA становится матрицей нулевого размера.
//Функция не изменяет значений элементов исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//rmatrix& invA - ссылка на матрицу, в которой формируется матрица обратная исходной.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения обращения исходной матрицы
//***********************************************************************************
bool TRealMatrix::INV_Cholesky(rmatrix& invA) const
{//Проверка исходной матрицы на квадратную и не нулевого размера
 if (IsRectang() || IsZeroSize()) {invA.Set(0L,false); return false;}
 double x,y,z;
 ulong n = Rows();
 //Построение матрицы invA одинаковой с исходной матрицей размерности
 invA.Set(n,false);
 //----------------------------------------------------------------------------------
 //LU-разложение по схеме Холецкого - формирование матрицы L
 //----------------------------------------------------------------------------------
 for (ulong i = 0L; i < n; i++)
  for (ulong j = i; j < n; j++)
  {x = data[i][j];
   for (ulong k = i-1; k < i; k--) x = x - invA.Get(j,k)*invA.Get(i,k);
   if (j == i) //Вычисление диагонального элемента матрицы L
   {if (x <= 0.0) {invA.Set(0L,false); return false;}
    y = 1.0/sqrt(x);
    invA.Put(i,i,y);
   }
   else invA.Put(j,i,x*y); //Вычисление внедиагональных элементов матрицы L
  }

 //----------------------------------------------------------------------------------
 // Обращение матрицы L
 //----------------------------------------------------------------------------------
 for (ulong i = 0L; i < n; i++)
  for (ulong j = i+1; j < n; j++)
  {z = 0.0;
   for (ulong k = j-1; (k >= i && k < j); k--) z = z - invA.Get(j,k)*invA.Get(k,i);
   invA.Put(j,i,z*invA.Get(j,j));
  }

 //----------------------------------------------------------------------------------
 // Вычисление матрицы, обратной A
 //----------------------------------------------------------------------------------
 for (ulong i = 0L; i < n; i++)
  for (ulong j = i; j < n; j++)
  {z = 0.0;
   for (ulong k = j; k < n; k++) z = z + invA.Get(k,j)*invA.Get(k,i);
   invA.Put(j,i,z);
   if (i != j) invA.Put(i,j,z);
  }

 return true;
}

//===================================================================================
// II. РЕАЛИЗАЦИЯ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TRealMatrix
//     PRIVATE MEMBER-FUNCTION OF TRealMatrix CLASS REALIZATION
//===================================================================================
//***********************************************************************************
//СТАТУС: II.1., private, TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Initial()
//НАЗНАЧЕНИЕ: Начальная инициализация свойств вещественной матрицы при ее создании.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRealMatrix::Initial()
{//Начальная инициализация защищенных членов-данных класса
 type = SQUARE; //Вещественная матрица нулевого размера
 m = 0L; n = 0L; //Установка размерности матрицы
 data = NULL;    //Установка указателя на элементы матрицы в NULL
}
//***********************************************************************************
//СТАТУС: II.2., private, TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Create()
//НАЗНАЧЕНИЕ: Распределение оперативной памяти под элементы вещественной матрицы без
//их инициализации. Количество элементов матрицы определяется по формуле:
//Q = Rows()*Cols(). Если Rows() или Cols() равны 0, то создается матрица нулевого
//размера. В случае нехватки памяти генерируется ошибка и функция возвращает false.
//Элементы матрицы хранятся в двумерном массиве data. При создании вектора-столбца,
//получается матрица вида: data[m][1], при создании вектора-строки - data[1][n].
//В общем случае создается матрица следующего вида: data[m][n].
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
bool TRealMatrix::Create()
{//Проверка на матрицу нулевого размера
 if ((Rows() == 0) || (Cols() == 0)) {Initial(); return true;}
 //Распределение памяти под элементы матрицы и первоначальная их инициализация
 try
  {//Распределение памяти под строки матрицы - m
   data = new double*[Rows()];
   //Распределение памяти под столбцы матрицы - n
   for (ulong i = 0L; i < Rows(); i++) data[i] = new double[Cols()];
  }
  // ENTER THIS BLOCK ONLY IF xalloc IS THROWN.
  // YOU COULD REQUEST OTHER ACTIONS BEFORE TERMINATING
  catch (std::bad_alloc) {Initial(); return false;} //xalloc x
 return true;
}
//***********************************************************************************
//СТАТУС: II.3., private, TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Delete()
//НАЗНАЧЕНИЕ: Удаление из оперативной памяти элементов вещественной матрицы. После
//завершения работы функции получается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRealMatrix::Delete()
{if (data == NULL) {Initial(); return;}//Проверка на матрицу нулевого размера
 //Удаление элементов матрицы
 for (ulong i = 0L; i < Rows(); i++) delete[] data[i];//Удаление строк
 delete[] data ;
 Initial();
}
//===================================================================================
// III. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TRealMatrix
//      PROTECTED MEMBER-FUNCTION OF TRealMatrix CLASS REALIZATION
//===================================================================================
//-----------------------------------------------------------------------------------
// РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ФУНКЦИЙ КЛАССА TRealMatrix ИНИЦИАЛИЗАЦИИ ЭЛЕМЕНТОВ
// МАТРИЦЫ В ЗАВИСИМОСТИ ОТ ЕЕ ПОДТИПА
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: III.1, TRealMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitZeroMatrix()
//НАЗНАЧЕНИЕ: Инициализация элементы матрицы с нулевыми элементами
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRealMatrix::InitZeroMatrix()
{for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++) data[i][j] = 0.0;
}
//***********************************************************************************
//СТАТУС: III.2, TRealMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitMatrix()
//НАЗНАЧЕНИЕ: Инициализация элементов матрицы любого типа случайными значениями.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRealMatrix::InitMatrix()
{randomize();//Инициализация генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++) data[i][j] = rand();
}
//***********************************************************************************
//СТАТУС: III.3, TRealMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitDiagonal()
//НАЗНАЧЕНИЕ: Инициализация элементов диагональной матрицы случайными значениями
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRealMatrix::InitDiagonal()
{if (IsSquare() == false) {InitMatrix(); return;}
 randomize();//Инициализация генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i == j) ? rand() : 0.0;
}
//***********************************************************************************
//СТАТУС: III.4, TRealMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitScalar()
//НАЗНАЧЕНИЕ: Инициализация элементов скалярной матрицы случайным значением.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRealMatrix::InitScalar()
{if (IsSquare() == false) {InitMatrix(); return;}
 randomize();//Инициализация генератора случайных чисел
 int value = rand();
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i == j) ? value : 0.0;
}
//***********************************************************************************
//СТАТУС: III.5, TRealMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitUnit()
//НАЗНАЧЕНИЕ: Инициализация элементов единичной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRealMatrix::InitUnit()
{if (IsSquare() == false) {InitMatrix(); return;}
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i == j) ? 1.0 : 0.0;
}
//***********************************************************************************
//СТАТУС: III.6, TRealMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitBand(ulong diags)
//НАЗНАЧЕНИЕ: Инициализация элементов ленточной матрицы случайными значениями.
//Количество диагоналей diags должно быть нечетным и быть в пределах:
// 1 < diags < 2*Rows()-1. Матрица должна быть квадратной и Rows() > 2.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong diags - число диагоналей матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRealMatrix::InitBand(ulong diags)
{if (IsSquare() == false) {InitMatrix(); return;}
 if (Rows() < 3) {InitMatrix(); return;}
 if ((diags < 3) || (diags%2 == 0L) || (diags >= 2*Rows()-1)) diags = 3;
 randomize();//Инициализация генератора случайных чисел
 ulong delta;
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
  {delta = (i > j) ? (i-j) : (j-i);
   if (2*delta <= diags-1) data[i][j] = rand();
   else data[i][j] = 0.0;
  }
}
//***********************************************************************************
//СТАТУС: III.7, TRealMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitUTriang()
//НАЗНАЧЕНИЕ: Инициализация элементов верхней треугольной матрицы случайными числами.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRealMatrix::InitUTriang()
{if (IsSquare() == false) {InitMatrix(); return;}
 randomize();//Инициализация генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i <= j) ? rand() : 0.0;
}
//***********************************************************************************
//СТАТУС: III.8, TRealMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitLTriang()
//НАЗНАЧЕНИЕ: Инициализация элементов нижней треугольной матрицы случайными числами.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRealMatrix::InitLTriang()
{if (IsSquare() == false) {InitMatrix(); return;}
 randomize();//Инициализация генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i >= j) ? rand() : 0.0;
}
//***********************************************************************************
//СТАТУС: III.9, TRealMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitSymmetric()
//НАЗНАЧЕНИЕ: Инициализация элементов симметрической матрицы случайными значениями.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRealMatrix::InitSymmetric()
{if (IsSquare() == false) {InitMatrix(); return;}
 randomize();//Инициализация генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {if (i != j) data[i][j] = data[j][i] = rand();
   else data[i][j] = rand();
  }
}
//***********************************************************************************
//СТАТУС: III.10, TRealMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitSkewSymmetric()
//НАЗНАЧЕНИЕ: Инициализация элементов кососимметрической матрицы случайными значениями
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRealMatrix::InitSkewSymmetric()
{if (IsSquare() == false) {InitMatrix(); return;}
 randomize();//Инициализация генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {if (i != j) {data[i][j] = rand(); data[j][i] = -data[i][j];}
   else data[i][j] = rand();
  }
}
//***********************************************************************************
//СТАТУС: III.11, TRealMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitAltSign()
//НАЗНАЧЕНИЕ: Инициализация элементов знакопеременной матрицы случайными значениями
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TRealMatrix::InitAltSign()
{if (IsSquare() == false) {InitMatrix(); return;}
 randomize();//Инициализация генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {if (i != j) {data[i][j] = rand(); data[j][i] = -data[i][j];}
   else data[i][j] = 0.0;
  }
}
//----------------------------------------------------------------------------------------
// ЗАЩИЩЕННЫЕ ФУНКЦИЙ КЛАССА TRealMatrix КОНСОЛЬНОГО ВВОДА ЭЛЕМЕНТОВ МАТРИЦЫ
//----------------------------------------------------------------------------------------
//****************************************************************************************
//СТАТУС: III.1, protected TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutRealMatrix(string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>][<j>]: <real value>.
//Функция позволяет вводить действительные матрицы класса TRealMatrix произвольных
//типов. При вводе элементов матрицы проверяется корректность чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование действительной матрицы (вектора).
//2. bool confirm - опция подтверждения ввода каждого элемента матрицы;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TRealMatrix::InPutRealMatrix(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << "     " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода всех элементов действительной матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
   data[i][j] = EditDouble(confirm); //Ввод элемента матрицы
   ClrScr(x,y);//Очистка экрана
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.2, protected TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutDiagonal(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ ДИАГОНАЛЬНОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>][<j>]: <real value>.
//При вводе элементов матрицы проверяется корректность чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование действительной матрицы.
//2. bool confirm - опция подтверждения ввода каждого элемента матрицы;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TRealMatrix::InPutDiagonal(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //---------------------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << "     " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода диагональных элементов действительной матрицы
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {if (i == j)
   {cout << name << "[" << (i+1) << "][" << (i+1) << "]: ";
    data[i][i] = EditDouble(confirm); //Ввод элемента матрицы
    ClrScr(x,y);//Очистка экрана
   }
   else data[i][j] = 0.0;
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.3, protected TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutScalar(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ СКАЛЯРНОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//Diagonal elements value: <real value>.
//При вводе элементов матрицы проверяется корректность чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование действительной матрицы;
//2. bool confirm - опция подтверждения ввода каждого элемента матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TRealMatrix::InPutScalar(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 double value;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << "     " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Ввод диагонального элемента скалярной матрицы
 cout << "Diagonal elements value: ";
 value = EditDouble(confirm); //Ввод элемента матрицы
 //Цикл присваивания диагональным элементам скалярной матрицы значения value
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i == j) ? value : 0.0;
 ClrScr(x,y);//Очистка экрана
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.4, protected TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutBand(ulong diags, const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ ЛЕНТОЧНОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>][<j>]: <real value>.
//Функция позволяет вводить элементы ленточной матрицы, которые принадлежат ее
//диагоналям, остальным элементам автоматически присваиваются нулевые значения.
//При ввода элементов матрицы проверяется корректность чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong diags - число диагоналей ленточной матрицы;
//2. const string& name - наименование ленточной матрицы.
//3. bool confirm - опция подтверждения ввода каждого элемента матрицы;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TRealMatrix::InPutBand(ulong diags, const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << "     " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода элементов ленточной матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {ulong delta = (i > j) ? (i-j) : (j-i);
   if (2*delta <= diags-1) //Диагональный элемент ленточной матрицы
   {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
    data[i][j] = EditDouble(confirm); //Ввод элемента матрицы
    ClrScr(x,y);//Очистка экрана
   }
   else data[i][j] = 0.0;
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.5, protected TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutUTriang(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ ВЕРХНЕЙ ТРЕУГОЛЬНОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>][<j>]: <real value>.
//Функция позволяет вводить элементы верхней треугольной матрицы, которые размещаются на и
//выше ее главной диагонали, остальным элементам автоматически присваиваются нулевые значения.
//При ввода элементов матрицы проверяется корректность чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование действительной матрицы.
//2. bool confirm (true) - опция подтверждения ввода каждого элемента матрицы;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TRealMatrix::InPutUTriang(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //---------------------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << "     " << Properties(s);
 cout << line << endl;
 //---------------------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода элементов верхней треугольной матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {if (i <= j )
   {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
    data[i][j] = EditDouble(confirm); //Ввод элемента матрицы
    ClrScr(x,y);//Очистка экрана
   }
   else data[i][j] = 0.0;
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.6, protected TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutLTriang(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ НИЖНЕЙ ТРЕУГОЛЬНОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>][<j>]: <real value>.
//Функция позволяет вводить элементы нижней треугольной матрицы, которые размещаются на ее
//главной диагонали и под ней, остальным элементам автоматически присваиваются нулевые
//значения. При вводе элементов матрицы проверяется корректность чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование действительной матрицы;
//2. bool confirm (true) - опция подтверждения ввода данных каждого элемента матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TRealMatrix::InPutLTriang(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //--------------------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << "     " << Properties(s);
 cout << line << endl;
 //-------------------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода элементов нижней треугольной матрицы
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
  {if (i >= j )
   {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
    data[i][j] = EditDouble(confirm); //Ввод элемента матрицы
    ClrScr(x,y);//Очистка экрана
   }
   else data[i][j] = 0.0;
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.7, protected TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutSymmetric(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ СИММЕТРИЧЕСКОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>][<j>]: <real value>.
//Функция вводит элементы симметрической матрицы, которые размещаются на ее главной диагонали
//и над ней, поддиагональным элементам присваиваются значения симметрических им наддиагоналных
//элементов. При вводе элементов матрицы проверяется корректность чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование действительной матрицы;
//2. bool confirm - опция подтверждения ввода каждого элемента матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TRealMatrix::InPutSymmetric(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << "     " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода элементов симметрической матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
   data[i][j] = EditDouble(confirm); //Ввод элемента матрицы
   if (i != j) data[j][i] = data[i][j];
   ClrScr(x,y);//Очистка экрана
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.8, protected TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutSkewSymmetric(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ КОСОСИММЕТРИЧЕСКОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>][<j>]: <real value>.
//Функция вводит элементы кососимметрической матрицы, размещаемые на ее главной диагонали
//и над ней, поддиагональным элементам присваиваются значения симметрических им наддиагональных
//элементов с противоположным знаком. При вводе элементов матрицы проверяется корректность
//чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование действительной матрицы;
//2. bool confirm - опция подтверждения ввода каждого элемента матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TRealMatrix::InPutSkewSymmetric(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << "     " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода элементов кососимметрической матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
   data[i][j] = EditDouble(confirm); //Ввод элемента матрицы
   if (i != j) data[j][i] = -data[i][j];
   ClrScr(x,y);//Очистка экрана
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.9, protected TRealMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutAltSign(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ ЗНАКОПЕРЕМЕННОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>][<j>]: <real value>.
//Функция вводит элементы знакопеременной матрицы, размещаемые над ее главной диагональю,
//поддиагональным элементам присваиваются значения симметрических им наддиагоналных элементов
//с противоположным знаком. Значения диагональных элементов матрицы равны нулю. При вводе
//элементов матрицы проверяется корректность чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование действительной матрицы;
//2. bool confirm - опция подтверждения ввода каждого элемента матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TRealMatrix::InPutAltSign(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //------------------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << "     " << Properties(s);
 cout << line << endl;
 //------------------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода элементов знакопеременной матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {if (i != j )
   {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
    data[i][j] = EditDouble(confirm); //Ввод элемента матрицы
    if (i != j) data[j][i] = -data[i][j];
    ClrScr(x,y);//Очистка экрана
   }
   else data[i][j] = 0.0;
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}

//===================================================================================
//    РЕАЛИЗАЦИЯ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССУ TRealMatrix
//    REALIZATION of THE FRIEND FUNCTION TO TRealMatrix CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: FRIEND FUNCTION to TRealMatrix class # 1
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend uint* MaxStrLen(const TRealMatrix& R, uint precision)
//НАЗНАЧЕНИЕ: Определение максимального символьного размера элементов вещественной
//матрицы R и максимальную ширину каждого столбца матрицы. Функция применяется для
//рационального отображения элементов вещественной матрицы.
//При вычислении максимальной символьной длины приняты следующие соглашения:
//1. Точность представления действительного числа равна precision.
//В ходе работы функции создается массив для хранения данных по максимальной ширине
//каждого столбца матрицы и максимального символьного размера элемента матрицы -
//MaxLen[R.Cols()+1]. Максимальный размер элемента матрицы хранится в последней ячейке
//массива MaxLen.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TRealMatrix& R - ссылка на вещественную матрицу;
//2. uint precision - количество выводимых цифр чисел с плавающей точкой.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//uint* MaxLen - массив с шириной каждого столбца матрицы и максимальной символь-
//ной длиной элемента матрицы R.
//***********************************************************************************
uint* MaxStrLen(const TRealMatrix& R, uint precision)
{uint* MaxLen = NULL;
 //Проверка матрицы на нулевой размер
 if (R.IsZeroSize()) return MaxLen;
 //Динамическое распределение памяти под элементы массива MaxLen и их начальная
 //инициализация
 uint szMaxLen = R.Cols()+1;
 MaxLen = new uint[szMaxLen];
 for (uint i = 0; i < szMaxLen; i++) MaxLen[i] = 0;

 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 uint count;
 //Цикл считывания элементов вещественной матрицы
 for (ulong i = 0L; i < R.Rows(); i++)
  for (ulong j = 0L; j < R.Cols(); j++)
  {//Формирование символьного представления вещественного числа
   text << setprecision(precision) << R.Get(i,j) << ends;
   //Получение максимальной символьной длины элемента вещественной матрицы и
   //каждого столбца матрицы
   count = text.pcount()-1;
   if (count > MaxLen[j])
   {MaxLen[j] = count;
    if (MaxLen[j] > MaxLen[szMaxLen-1]) MaxLen[szMaxLen-1] = MaxLen[j];
   }
   text.seekp(0);
  }
return MaxLen;
}
//----------------------------------------------------------------------------------------
//Построение корреляционной матрицы
//----------------------------------------------------------------------------------------
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 2
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool CorrelationMatrix(const rvector& V, rmatrix& R);
//НАЗНАЧЕНИЕ: ПОСТРОЕНИЕ КОРРЕЛЯЦИОННОЙ (КОВАРИАЦИОННОЙ) МАТРИЦЫ
//Расчет корреляционной матрицы по данным из вектора V и размещение ее элементов в матрице
//R. Размерность матрицы R будет равна размерности вектора V. Функция изменяет размерность
//и элементы матрицы R и не изменяет вектор V. Каждый элемент матрицы R рассчитывается по
//формуле: R[i,j] = V[i] * V[j].
//Функция возвращает false, если вектор V - нулевого размера или невозможно выделить память
//под размещение элементов матрицы R.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - константная ссылка на вещественный исходный вектор по элементам
//   которого строится корреляционная матрица R.
//2. rmatrix& R - ссылка на вещественную матрицу, в которой будут размещаться элементы
//   корреляционной матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции.
//****************************************************************************************
bool CorrelationMatrix(const rvector& V, rmatrix& R)
{//Проверка на вектор нулевого размера
 if (V.IsZeroSize()) return false;
 //Распределение памяти под корреляционную матрицу R без начальной инициализации
 if (R.Set(V.Size(),false) == false) return false;
 //Формирование корреляционной матрицы
 for (ulong i = 0L; i < R.Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {if (i == j) R.Put(i,j,V.Get(i)*V.Get(i));
   else
   {R.Put(i,j,V.Get(i)*V.Get(j));
    R.Put(j,i,R.Get(i,j));
   }
  }
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 3
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool MatrixToVectorByCols(const rmatrix& A, rvector& V)
//НАЗНАЧЕНИЕ: Преобразование матрицы в вектор. Элементы матрицы A, передаваемой по ссылке,
//размещаются в векторе V. Копирование происходит по столбцам от первого до последнего.
//Функция изменяет размеры вектора V таким образом, чтобы в нем могли разместится все эле-
//менты матрицы A: V.Size() = A.Rows()*A.Cols(). Вектор V становится вектором-столбцом. При
//невозможности выделить память под новый размер вектора V функция возвращает false. Матрица
//A функцией не изменяется.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& A - константная ссылка на вещественную матрицу, преобразуемую в
//   вектор-столбец копированием по столбцам.
//2. rvector& V - ссылка на вещественный вектор, в котором будут размещаться элементы
//   матрицы A.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции.
//****************************************************************************************
bool MatrixToVectorByCols(const rmatrix& A, rvector& V)
{//Проверка на матрицу нулевого размера
 if (A.IsZeroSize()) {V.Set(0L,COL,false); return true;}
 //Распределение памяти под элементы вектора V без начальной инициализации
 if (!V.Set(A.Rows()*A.Cols(),COL,false)) {V.Set(0L,COL,false); return false;}
 //Постолбцовое копирование элементов матрицы A в вектор V
 ulong p = 0L;
 for (ulong j = 0L; j < A.Cols(); j++)
  for (ulong i = 0L; i < A.Rows(); i++)
   V.Put(p++,A.Get(i,j));
 return true;
}
//***********************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 4
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool MatrixToVectorByRows(const rmatrix& A, rvector& V);
//НАЗНАЧЕНИЕ: Преобразование матрицы в вектор. Элементы матрицы A, передаваемой по
//ссылке, размещаются в векторе V. Копирование происходит по строкам от первой до пос-
//ледней. Функция изменяет размеры вектора V таким образом, чтобы в нем могли размес-
//тится все элементы матрицы A: V.Size() = A.Rows()*A.Cols(). Вектор V становится век-
//тором-строкой. При невозможности выделить память под новый размер вектора V функция
//возвращает false. Матрица A функцией не изменяется.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& A - константная ссылка на вещественную матрицу, преобразуемую в
//   вектор-строку копированием по строкам.
//2. rvector& V - ссылка на вещественный вектор, в котором будут размещаться элементы
//   матрицы A.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции.
//***********************************************************************************
bool MatrixToVectorByRows(const rmatrix& A, rvector& V)
{//Проверка на матрицу нулевого размера
 if (A.IsZeroSize()) {V.Set(0L,ROW,false); return true;}
 //Распределение памяти под элементы вектора V без начальной инициализации
 if (!V.Set(A.Rows()*A.Cols(),ROW,false)) {V.Set(0L,ROW,false); return false;}
 //Построчное копирование элементов матрицы A в вектор V
 ulong p = 0L;
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   V.Put(p++,A.Get(i,j));
 return true;
}
//***********************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 5
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool VectorToMatrixByCols(const rvector& V, rmatrix& A, ulong rows, ulong cols);
//НАЗНАЧЕНИЕ: Преобразование вектора в матрицу. Элементы вектора V, передаваемый по
//ссылке, размещаются в матрице. Копирование происходит по столбцам от первого до
//последнего. Функция изменяет размеры матрицы А таким образом, чтобы в ней могли раз-
//местится все элементы вектора V: A.Rows()*A.Cols() = V.Size(). Произведение rows*cols
//должно быть в точности равно V.Size(), в противном случае, функция возвращает false.
//При невозможности выделить память под новый размер матрицы A функция возвращает false.
//Вектор V функцией не изменяется.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - константная ссылка на вещественный вектор, преобразуемый в
//   матрицу копированием элементов по столбцам.
//2. rmatrix& A - ссылка на вещественную матрицу, в которой будут размещаться элементы
//   вектора V.
//3. ulong rows - количество строк, формируемой матрицы A;
//4. ulong cols - количество столбцов, формируемой матрицы A.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции.
//***********************************************************************************
bool VectorToMatrixByCols(const rvector& V, rmatrix& A, ulong rows, ulong cols)
{//Проверка на вектор нулевого размера
 if (V.IsZeroSize()) {A.Set(0L,false); return true;}
 //Проверка на возможность создания матрицы A c размерами rows x cols
 if (rows*cols != V.Size()) {A.Set(0L,false); return false;}
 //Распределение памяти под элементы матрицы A без начальной инициализации
 if (!A.Set(rows,cols,false)) {A.Set(0L,false); return false;}
 //Копирование по столбцам элементов вектора V в матрицу A
 ulong p = 0L;
 for (ulong j = 0L; j < A.Cols(); j++)
  for (ulong i = 0L; i < A.Rows(); i++)
   A.Put(i,j,V.Get(p++));
 return true;
}
//***********************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 6
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool VectorToMatrixByRows(const rvector& V, rmatrix& A, ulong rows, ulong cols);
//НАЗНАЧЕНИЕ: Преобразование вектора в матрицу. Элементы вектора V, передаваемый по
//ссылке, размещаются в матрице. Копирование происходит по строкам от первой до послед-
//ней. Функция изменяет размеры матрицы А таким образом, чтобы в ней могли разместится
//все элементы вектора V: A.Rows()*A.Cols() = V.Size(). Произведение rows*cols должно
//быть в точности равно V.Size(), в противном случае, функция возвращает false. При
//невозможности выделить память под новый размер матрицы A функция возвращает false.
//Вектор V функцией не изменяется.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rvector& V - константная ссылка на вещественный вектор, преобразуемый в
//   матрицу копированием элементов по строкам.
//2. rmatrix& A - ссылка на вещественную матрицу, в которой будут размещаться элементы
//   вектора V.
//3. ulong rows - количество строк, формируемой матрицы A;
//4. ulong cols - количество столбцов, формируемой матрицы A.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции.
//***********************************************************************************
bool VectorToMatrixByRows(const rvector& V, rmatrix& A, ulong rows, ulong cols)
{//Проверка на вектор нулевого размера
 if (V.IsZeroSize()) {A.Set(0L,false); return true;}
 //Проверка на возможность создания матрицы A c размерами rows x cols
 if (rows*cols != V.Size()) {A.Set(0L,false); return false;}
 //Распределение памяти под элементы матрицы A без начальной инициализации
 if (!A.Set(rows,cols,false)) {A.Set(0L,false); return false;}
 //Копирование по столбцам элементов вектора V в матрицу A
 ulong p = 0L;
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   A.Put(i,j,V.Get(p++));
 return true;
}
//***********************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 7
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool Multiply(rmatrix& C, const rmatrix& A, const rmatrix& B);
//НАЗНАЧЕНИЕ: ПЕРЕМНОЖЕНИЕ ДВУХ ВЕЩЕСТВЕННЫХ МАТРИЦ.
//Реализация общего алгоритма умножения двух вещественных матриц A(m x n) и B(n x p):
//C(m x p) = A(m x n) * B(n x p), где каждый элемент матрицы С вычисляется по формуле:
//C(i,j) = SUM{A(i,k)*B(k,j) by k, 0 <= k < n}
//Результат перемножения матриц A на B, размещается в матрице C. Матрицы A и В функцией
//не изменяются. Если адреса матриц C и A или C и B совпадают, то функция завершает
//работу и возвращает false. Правила умножения матрицы на матрицу следующие:
//1. Количество СТОЛБЦОВ матрицы слева A(m x n) должно быть РАВНО количеству СТРОК
//   матрицы справа B(n x p).
//2. Размерности матриц A & B не должны быть нулевыми.
//3. При умножении матриц согласно правил 1 и 2 всегда получается МАТРИЦА размерности
//   равной числу СТРОК матрицы слева и числу СТОЛБЦОВ матрицы справа:
//   C(m x p) = A(m x n) * B(n x p).
//Если условия 1, 2 не выполняются, то возвращается false и матрица C становится матри-
//цей нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TRealMatrix& C - ссылка на результирующую матрицу;
//2. const TRealMatrix& A - ссылка на левую матрицу;
//3. const TRealMatrix& B - ссылка на правую матрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения умножения двух матриц
//***********************************************************************************
bool Multiply(rmatrix& C, const rmatrix& A, const rmatrix& B)
{//Проверка на совпадение адреса матрицы C с A или B
 if ((&C == &A) || (&C == &B)) return false;
 //Матрица (матрицы) нулевого размера
 if ((A.IsZeroSize()) || (B.IsZeroSize())) {C.Set(0L,false); return false;}
 //Умножение производится с матрицами неподходящих для умножения размерностей
 if (A.Cols() != B.Rows()) {C.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Перемножение двух матриц
 //----------------------------------------------------------------------------------
 C.Set(A.Rows(),B.Cols(),false);
 //Операция перемножения двух матриц
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < B.Cols(); j++)
  {double sum = 0.0;
   for (ulong k = 0L; k < A.Cols(); k++) sum += A.Get(i,k)*B.Get(k,j);
   C.Put(i,j,sum);
  }
 return true; //Перемножение двух матриц выполнено успешно
}
//***********************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 8
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool Multiply(rmatrix& A, const rmatrix& B);
//НАЗНАЧЕНИЕ: ПЕРЕМНОЖЕНИЕ ДВУХ ВЕЩЕСТВЕННЫХ МАТРИЦ с записью результата в матрицу A.
//Реализация общего алгоритма умножения двух вещественных матриц A(m x n) и B(n x p):
//C(m x p) = A(m x n) * B(n x p), где каждый элемент матрицы С вычисляется по формуле:
//C(i,j) = SUM{A(i,k)*B(k,j) by k, 0 <= k < n}
//При реализации операции A = A*B возможны следующие ситуации с распределением памяти:
//1) Матрица B(n x p) - прямоугольная. В этом случае необходимо сделать копию матрицы
//   A (A'), умножить A'*B, результат умножения записать в матрицу A с новыми размерами
//  (m x p).
//2) Матрица B(n x n) - квадратная. В этом случае размер матрицы A*B совпадет с размером
//   матрицы A, для хранения промежуточных результатов достаточно иметь вектор размером
//   в n и результаты умножения размещать непосредственно в матрице A, без задания
//   новых размеров.
//Результат перемножения матриц A на B, размещается в матрице A. Матрица В функцией
//не изменяется. Если A и B совпадают, то функция завершает работу и возвращает false.
//Правила умножения матрицы на матрицу следующие:
//1. Количество СТОЛБЦОВ матрицы слева A(m x n) должно быть РАВНО количеству СТРОК
//   матрицы справа B(n x p).
//2. Размерности матриц A & B не должны быть нулевыми.
//3. При умножении матриц согласно правил 1 и 2 всегда получается МАТРИЦА размерности
//   равной числу СТРОК матрицы слева и числу СТОЛБЦОВ матрицы справа:
//   C(m x p) = A(m x n) * B(n x p).
//Если условия 1, 2 не выполняются, то возвращается false и матрица C становится матри-
//цей нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TRealMatrix& A - ссылка на левую матрицу;
//2. const TRealMatrix& B - ссылка на правую матрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения умножения двух матриц
//***********************************************************************************
bool Multiply(rmatrix& A, const rmatrix& B)
{//Проверка на совпадение адресов матрицы A и B
 if (&A == &B) return false;
 //Матрица (матрицы) нулевого размера
 if ((A.IsZeroSize()) || (B.IsZeroSize())) {A.Set(0L,false); return false;}
 //Умножение производится с матрицами неподходящих для умножения размерностей
 if (A.Cols() != B.Rows()) {A.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Перемножение двух матриц
 //----------------------------------------------------------------------------------
 if (B.IsSquare()) //Правая матрица B квадратная
 {rvector V(B.Cols(),ROW,false);
  if (V.IsZeroSize()) {A.Set(0L,false); return false;}
  //Операция перемножения двух матриц
  for (ulong i = 0L; i < A.Rows(); i++)
  {for (ulong j = 0L; j < B.Cols(); j++)
   {double sum = 0.0;
    for (ulong k = 0L; k < A.Cols(); k++) sum += A.Get(i,k)*B.Get(k,j);
    V.Put(j,sum);
   }
   for (ulong k = 0L; k < V.Size(); k++) A.Put(i,k,V.Get(k));
  }
 }
 else //Правая матрица B прямоугольная - общий случай умножения
 {rmatrix C(A);//Копирование матрицы A в C
  //Изменяем размер матрицы A - матрица A должна стать результирующей
  A.Set(A.Rows(),B.Cols(),false);
  if (C.IsZeroSize() || A.IsZeroSize()) {A.Set(0L,false); return false;}
  //Операция перемножения двух матриц A = C*B
  for (ulong i = 0L; i < C.Rows(); i++)
   for (ulong j = 0L; j < B.Cols(); j++)
   {double sum = 0.0;
    for (ulong k = 0L; k < C.Cols(); k++) sum += C.Get(i,k)*B.Get(k,j);
    A.Put(i,j,sum);
   }
 }
 return true; //Перемножение двух матриц выполнено успешно
}
//***********************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 9
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool Multiply(rmatrix& D, const rmatrix& A, const rmatrix& B, const rmatrix& C)
//НАЗНАЧЕНИЕ: ПЕРЕМНОЖЕНИЕ ТРЕХ ВЕЩЕСТВЕННЫХ МАТРИЦ.
//Реализация общего алгоритма умножения трех вещественных матриц:
//D(m x k) = A(m x n) * B(n x p) * C(p x k)
//Результат перемножения матриц A*B*C, размещается в матрице D. Матрицы A,В,C функцией
//не изменяются. Если адрес D совпадает с адресом A или B или C, то функция завершает
//работу и возвращает false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TRealMatrix& D - ссылка на результирующую матрицу;
//2. const TRealMatrix& A - ссылка на левую матрицу;
//3. const TRealMatrix& B - ссылка на среднюю матрицу.
//3. const TRealMatrix& C - ссылка на правую матрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения умножения трех матриц
//***********************************************************************************
bool Multiply(rmatrix& D, const rmatrix& A, const rmatrix& B, const rmatrix& C)
{//Проверка на совпадение адреса матрицы D с A или B или C
 if ((&D == &A) || (&D == &B) || (&D == &C)) return false;
 //Матрица (матрицы) нулевого размера
 if ((A.IsZeroSize()) || (B.IsZeroSize()) || (C.IsZeroSize()))
 {D.Set(0L,false); return false;}
 //Умножение производится с матрицами неподходящих для умножения размерностей
 if ((A.Cols() != B.Rows()) || (B.Cols() != C.Rows()))
 {D.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Перемножение трех матриц
 //----------------------------------------------------------------------------------
 if (Multiply(D,A,B)) return Multiply(D,C);
 else return false;
}
//***********************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 10
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool Multiply(rmatrix& B, const rmatrix& A, double c)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕЩЕСТВЕННОЙ МАТРИЦЫ НА КОНСТАНТУ
//Алгоритм состоит в умножении каждого элемента матрицы на величину c:
//B(m x n) = A(m x n) * c, где B(i,j) = A(i,j)*c,  0 <=i <m, 0 <=j <n. Результат умно-
//жения матриц A*c, размещается в матрице B. Матрица A функцией не изменяется. Если
//адреса матриц A и B совпадают, то функция завершает работу и возвращает false.
//Функция возвращает false и устанавливает матрицу B нулевого размера, в случае если
//матрица A нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TRealMatrix& B - ссылка на результирующую матрицу;
//2. const TRealMatrix& A - исходную матрицу;
//3. double c - значение умножаемое на элементы матрицы A.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат выполнения умножения матрицы на число
//***********************************************************************************
bool Multiply(rmatrix& B, const rmatrix& A, double c)
{//Проверка на совпадение адресов матриц A и B
 if (&B == &A) return false;
 //Матрица A нулевого размера
 if (A.IsZeroSize()) {B.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Умножение матрицы на число B = c * A = A * c
 //----------------------------------------------------------------------------------
 if (c == 0.0) {if (!B.Set(A.Rows(),A.Cols(),0.0)) return false;}
 else if (c == 1.0) {B = A; if (B.IsZeroSize()) return false;}
 else
 {if (!B.Set(A.Rows(),A.Cols(),false)) return false;
  for (ulong i = 0L; i < A.Rows(); i++)
   for (ulong j = 0L; j < A.Cols(); j++)
    B.Put(i,j,A.Get(i,j)*c);
 }
 return true; //Перемножение матрицы на число выполнено успешно
}
//***********************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 11
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool Multiply(rmatrix& A, double c);
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕЩЕСТВЕННОЙ МАТРИЦЫ НА КОНСТАНТУ
//Алгоритм состоит в умножении каждого элемента матрицы на величину c:
//A(m x n) = A(m x n) * c, где A(i,j) = A(i,j)*c,  0 <=i <m, 0 <=j <n. Результат умно-
//жения матриц A*c, размещается в матрице A. Матрица A изменяется функцией. Функция
//возвращает false, в случае если матрица A нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TRealMatrix& A - ссылка на результирующую и исходную матрицу;
//2. double c - значение умножаемое на элементы матрицы A.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат выполнения умножения матрицы на число
//***********************************************************************************
bool Multiply(rmatrix& A, double c)
{//Матрица A нулевого размера
 if (A.IsZeroSize()) return false;
 //----------------------------------------------------------------------------------
 //Умножение матрицы на число B = c * A = A * c
 //----------------------------------------------------------------------------------
 if (c == 0.0)
  for (ulong i = 0L; i < A.Rows(); i++)
   for (ulong j = 0L; j < A.Cols(); j++)
    A.Put(i,j,0.0);
 else if (c != 1.0)
 {for (ulong i = 0L; i < A.Rows(); i++)
   for (ulong j = 0L; j < A.Cols(); j++)
    A.Put(i,j,A.Get(i,j)*c);
 }
 return true; //Перемножение матрицы на число выполнено успешно
}
//***********************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 12
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool Add(rmatrix& C, const rmatrix& A, const rmatrix& B)
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ ДВУХ ВЕЩЕСТВЕННЫХ МАТРИЦ
//Алгоритм сложения двух вещественных матриц A и B: C = A + B, C(i,j)=A(i,j)+B(i,j).
//Результат сложения двух матриц размещается в матрице C. Матрицы A и B функцией не
//изменяются. Если адрес матрицы C совпадает с адресами матриц A или B, то функция
//завершает работу и возвращает false.
//При сложении двух матриц должны выполняться следующие правила:
//1. Матрицы не должны быть матрицами НУЛЕВОГО РАЗМЕРА;
//2. Матрицы должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ:
//   A.Rows() == B.Rows() || A.Cols() == B.Cols()
//В противном случае функция возвращает false и устанавливает матрицу C нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TRealMatrix& C - ссылка на результирующую матрицу;
//2. const TRealMatrix& A - ссылка на левую матрицу;
//3. const TRealMatrix& B - ссылка на правую матрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат выполнения сложения двух матриц
//***********************************************************************************
bool Add(rmatrix& C, const rmatrix& A, const rmatrix& B)
{//Проверка на совпадение адреса матрицы C с адресами A или B
 if ((&C == &A) || (&C == &B)) return false;
 //Матрица (матрицы) нулевого размера
 if ((A.IsZeroSize()) || (B.IsZeroSize())) {C.Set(0L,false); return false;}
 //Матрицы разных размерностей
 if ((A.Rows() != B.Rows()) || (A.Cols() != B.Cols()))
 {C.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Сложение двух матриц C = A + B
 //----------------------------------------------------------------------------------
 if (!C.Set(A.Rows(),A.Cols(),false)) return false;
 {for (ulong i = 0L; i < A.Rows(); i++)
   for (ulong j = 0L; j < A.Cols(); j++)
    C.Put(i,j,A.Get(i,j)+B.Get(i,j));
 }
 return true; //Сложение двух матриц выполнено успешно
}
//***********************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 13
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool Add(rmatrix& A, const rmatrix& B)
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ ДВУХ ВЕЩЕСТВЕННЫХ МАТРИЦ
//Алгоритм сложения двух вещественных матриц A и B: A = A + B, A(i,j)=A(i,j)+B(i,j).
//Результат сложения двух матриц размещается в матрице A. Матрица B функцией не изме-
//няется. Если адреса матриц A и B совпадают, то функция завершает работу и возвращает
//false. При сложении двух матриц должны выполняться следующие правила:
//1. Матрицы не должны быть матрицами НУЛЕВОГО РАЗМЕРА;
//2. Матрицы должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ:
//   A.Rows() == B.Rows() || A.Cols() == B.Cols()
//В противном случае функция возвращает false и устанавливает матрицу A нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TRealMatrix& A - ссылка на результирующую и исходную матрицу;
//2. const TRealMatrix& B - ссылка на складываемую матрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат выполнения сложения двух матриц
//***********************************************************************************
bool Add(rmatrix& A, const rmatrix& B)
{//Проверка на совпадение адресов матриц A и B
 if (&A == &B) return false;
 //Матрица (матрицы) нулевого размера
 if ((A.IsZeroSize()) || (B.IsZeroSize())) {A.Set(0L,false); return false;}
 //Матрицы разных размерностей
 if ((A.Rows() != B.Rows()) || (A.Cols() != B.Cols()))
 {A.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Сложение двух матриц A = A + B
 //----------------------------------------------------------------------------------
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
    A.Put(i,j,A.Get(i,j)+B.Get(i,j));
 return true; //Сложение двух матриц выполнено успешно
}
//***********************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 14
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool Multiply(rvector& Y, const rmatrix& A, const rvector& X);
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ ВЕКТОРА НА МАТРИЦУ СПРАВА.
//Реализация общего алгоритма умножения матрицы A(m x n) на вектор X(n x 1):
//Y(m x 1) = A(m x n) * X(n x 1), где каждый элемент вектора Y вычисляется по формуле:
//Y(k) = SUM{A(i,k)*X(k) by k, 0 <= k < m, 0 <= i < n}
//Результирующий вектор Y является вектором-столбцом с размером равным числу строк
//матрицы A. По типу вектор X может быть вектором-строкой или вектором-столбцом.
//Результат перемножения A на X, размещается в векторе Y. Матрица A и вектор X функцией
//не изменяются. Если адреса векторов Y и X совпадают, то функция завершает работу и
//возвращает false. Правила умножения матрицы на вектор следующие:
//1. Количество СТОЛБЦОВ матрицы A(m x n) должно быть РАВНО размеру вектора X(n).
//2. Размерности матрицы A & вектора X не должны быть нулевыми.
//3. При умножении A на X согласно правил 1 и 2 всегда получается ВЕКТОР размерности
//   равной числу СТРОК матрицы A: Y(m x 1) = A(m x n) * X(n x 1).
//4. Функция не учитывает тип вектора X (столбец или строка).
//При нарушении условий 1, 2 возвращается false и вектор Y становится вектором нулевого
//размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TRealVector& Y - ссылка на результирующий вектор;
//2. const TRealMatrix& A - ссылка на матрицу;
//3. const TRealVector& X - ссылка на вектор.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат выполнения умножения матрицы на вектор
//***********************************************************************************
bool Multiply(rvector& Y, const rmatrix& A, const rvector& X)
{//Проверка на совпадение адресов векторов Y и X
 if (&Y == &X) return false;
 //Матрица A или вектор X нулевого размера
 if ((A.IsZeroSize()) || (X.IsZeroSize())) {Y.Set(0L,COL,false); return false;}
 //Умножение производится с матрицей и вектором неподходящих для умножения размерностей
 if (A.Cols() != X.Size()) {Y.Set(0L,COL,false); return false;}
 //----------------------------------------------------------------------------------
 //Перемножение матрицы на вектор Y = A*X
 //----------------------------------------------------------------------------------
 if (!Y.Set(A.Rows(),COL,false)) return false;
 for (ulong i = 0L; i < A.Rows(); i++)
 {double sum = 0.0;
  for (ulong j = 0L; j < A.Cols(); j++) sum += A.Get(i,j)*X.Get(j);
  Y.Put(i,sum);
 }
 return true; //Перемножение матрицы на вектор выполнено успешно
}
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 15
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//  friend bool QuadraticForm(rmatrix& B, const rmatrix& H, const rmatrix& A);
//НАЗНАЧЕНИЕ: КВАДРАТИЧЕСКАЯ МАТРИЧНАЯ ФОРМА: B = H * A * trH
//Алгоритм вычисления квадратической матричной формы вида:
// B(m x m) = H(m x n) * A(n x n) * trH(n x m), trH - транспонированная матрица H.
//Функция не вычисляет в явном виде матрицу trH, используя для этого элементы матрицы H,
//что оптимизирует вычисление произведения трех матриц как по времени, так и по объему ис-
//пользуемой памяти. Результат вычисления квадратической матричной формы размещается в мат-
//рице B, передаваемой в функцию по ссылке. Функция не изменяет матрицы H & A в ходе вычис-
//лений.
//C(m x p) = A(m x n) * B(n x p), где каждый элемент матрицы С вычисляется по формуле:
//C(i,j) = SUM{A(i,k)*B(k,j) by k, 0 <= k < n}
//Если адреса матриц B и H или B и A совпадают, то функция завершает работу и возвращает
//false. Правила вычисления КВАДРАТИЧЕСКОЙ МАТРИЧНОЙ ФОРМЫ:
//1. Количество СТОЛБЦОВ матрицы H(m x n) должно быть РАВНО количеству СТРОК матрицы
//   A(n x n), матрица A должна быть КВАДРАТНОЙ.
//2. Размерности матриц H & A не должны быть нулевыми.
//3. При умножении матриц согласно правил 1 и 2 всегда получается КВАДРАТНАЯ МАТРИЦА
//   с размерностью равной числу СТРОК матрицы H.
//Если условия 1, 2 не выполняются, то возвращается false и матрица B становится матрицей
//нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TRealMatrix& B - ссылка на результирующую матрицу;
//2. const TRealMatrix& H - ссылка на левую матрицу (правая матрица - trH);
//3. const TRealMatrix& A - ссылка на квадратную матрицу.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат вычисления квадратической формы
//****************************************************************************************
bool QuadraticForm(rmatrix& B, const rmatrix& H, const rmatrix& A)
{//Проверка на совпадение адресов матриц B и H или B и A
 if ((&B == &H) || (&B == &A)) return false;
 //Матрица (матрицы) нулевого размера
 if ((H.IsZeroSize()) || (A.IsZeroSize())) {B.Set(0L,false); return false;}
 //Умножение производится с матрицами неподходящих для умножения размерностей
 if ((A.IsRectang()) || (H.Cols() != A.Rows())) {B.Set(0L,false); return false;}
 //--------------------------------------------------------------------------------------
 //Вычисление КВАДРАТИЧЕСКОЙ МАТРИЧНОЙ ФОРМЫ
 //--------------------------------------------------------------------------------------
 if (!B.Set(H.Rows(),false)) return false;
 rvector V(A.Cols(),ROW,false);
 //Матричное произведение вида: B = H * A * trH
 for (ulong i = 0L; i < H.Rows(); i++)
 {for (ulong j = 0L; j < A.Cols(); j++)
  {double sum = 0.0;
   for (ulong k = 0L; k < H.Cols(); k++) sum += H.Get(i,k)*A.Get(k,j);
   V.Put(j,sum);
  }
  //Умножение вектора V на i-строку матрицы H (i-ый столбец матрицы trH)
  for (ulong j = 0L; j < H.Rows(); j++)
  {double sum = 0.0;
   for (ulong k = 0L; k < V.Size(); k++) sum += V.Get(k)*H.Get(j,k);
   B.Put(i,j,sum);
  }
 }
return true; //Квадратическая матричная форма вычислена
}
//***********************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 16
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool QuadraticForm(rmatrix& Q, const rmatrix& H, const rvector& X);
//НАЗНАЧЕНИЕ: КВАДРАТИЧЕСКАЯ ФОРМА: Q = H * X * trX * trH = H * Rxx * trH
//Алгоритм вычисления квадратической матричной формы вида H * X * trX * trH проходит
//в два шага:
//1) Вычисляется вектор Y = H * X;
//2) Вычисляется корреляционная матрица Q = Ryy = Y * trY.
//Функция не вычисляет в явном виде матрицы Rxx & trH, что оптимизирует вычисление
//квадратической формы как по времени, так и по объему используемой памяти. Результат
//вычисления квадратической матричной формы размещается в матрице Q, передаваемой в
//функцию по ссылке. Функция не изменяет матрицу H и вектор X в ходе вычислений.
//Если адреса матриц Q и H совпадают, то функция завершает работу и возвращает false.
//Правила вычисления КВАДРАТИЧЕСКОЙ МАТРИЧНОЙ ФОРМЫ:
//1. Количество СТОЛБЦОВ матрицы H(m x n) должно быть РАВНО РАЗМЕРУ вектора X(n x 1).
//2. Матрица H & вектор V не должны быть нулевыми.
//3. При вычислении всегда получается КВАДРАТНАЯ МАТРИЦА Q с размерностью равной числу
//   СТРОК матрицы H.
//4. Вектор V может быть вектором-строкой или вектором-столбцом.
//Если условия 1, 2 не выполняются, то возвращается false и матрица Q становится мат-
//рицей нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. TRealMatrix& Q - ссылка на результирующую матрицу;
//2. const TRealMatrix& H - ссылка на матрицу (правая матрица - trH);
//3. const TRealVector& V - ссылка на вектор.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат вычисления квадратической формы
//***********************************************************************************
bool QuadraticForm(rmatrix& Q, const rmatrix& H, const rvector& X)
{//Проверка на совпадение адресов матриц Q и H
 if (&Q == &H) return false;
 //Матрица || вектор нулевого размера
 if ((H.IsZeroSize()) || (X.IsZeroSize())) {Q.Set(0L,false); return false;}
 //Размеры матрицы H & вектора X не согласованы для выполнения операции умножения
 if (H.Cols() != X.Size()) {Q.Set(0L,false); return false;}
 //----------------------------------------------------------------------------------
 //Вычисление КВАДРАТИЧЕСКОЙ МАТРИЧНОЙ ФОРМЫ
 //----------------------------------------------------------------------------------
 rvector Y(H.Rows(),COL,false);
 if (Y.IsZeroSize()) {Q.Set(0L,false); return false;}
 //[1] Вычисление матрично-векторного произведения вида: Y = H * X
 for (ulong i = 0L; i < H.Rows(); i++)
 {double sum = 0.0;
  for (ulong j = 0L; j < H.Cols(); j++) sum += H.Get(i,j)*X.Get(j);
  Y.Put(i,sum);
 }
 //[2] Вычисление корреляционной матрицы Q = Ryy = Y*trY
 return CorrelationMatrix(Y,Q);//Результат вычсления квадратической матричной формы
}
//***********************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 17
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool DirectFourierTransform(rmatrix& FT_Y, const rmatrix& X, long hX0 = 0L,
//            long wX0 = 0L, ulong VCount = 0L, ulong HCount = 0L);
//НАЗНАЧЕНИЕ: ПРЯМОЕ ДВУМЕРНОЕ ПРЕОБРАЗОВАНИЕ ФУРЬЕ (Fourier Transform - FT)
//Функция вычисляет двумерное преобразование Фурье функции, которая задана элементами
//матрицы X (X - модель двумерного дискретного сигнала (изображения)). Результат FT
//размещается в матрице FT_Y, передаваемой в функцию по ссылке. Размерность матрицы
//FT_Y определяется количеством отсчетов в пространственных частот по вертикали VCount
//и горизонтали HCount (FT_Y.Rows() = VCount, FT_Y.Cols() = HCount). По умолчанию кол-во
//отсчетов по вертикали совпадает с X.Rows(), кол-во отсчетов по горизонтали - X.Cols.
//Функция не изменяет матрицу X в ходе вычислений и возвращает true при вычислении
//двумерного преобразования Фурье или false в противоположном случае. Причины неудач-
//ного завершения функции:
//1. Матрица X - матрица нулевого размера;
//2. Не удалось выделить память под элементы матрицы FT_Y.
//Параметры hX0 и wX0 задают точку начала координат отсчетов в матрице X и могут при-
//нимать произвольное значение (по умолчанию hX0 = wX0 = 0). С учетом периодичности
//функции X(w1,w2) с периодом 2*PI, которая получается в результате двумерного преоб-
//разования Фурье из функции X(n1,n2), все вычисления проводятся на интервале [-PI..PI]
//с шагами дискретизации по w1 и w2, которые определяются величинами VCount и HCount.
//Для пары значений вертикальной w1 и горизонтальной w2 пространственных частот значе-
//ние X(w1,w2) = SUM[0<=n1<N1]SUM[0<=n2<N2] X(n1,n2)*EXP(-j*w1*(n1-hX0)-j*w2*(n2-wX0)),
//N1 = X.Rows(), N2 = X.Cols(); -PI <= w1,w2 <= PI.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& FT_Y - ссылка на матрицу - результат прямого преобразования дискретного
//   пространственно-ограниченного сигнала X;
//2. const rmatrix& X - ссылка на матрицу - дискретный двумерный сигнал (изображение);
//3. long hX0 (0L) - значение точки начала координат отсчетов по вертикали для X;
//4. long wX0 (0L) - значение точки начала координат отсчетов по горизонтали для X;
//5. ulong VCount (0L) - кол-во отсчетов вертикальной пространственной частоты;
//6. ulong HCount (0L) - кол-во отсчетов горизонтальной пространственной частоты;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат вычисления преобразования Фурье
//***********************************************************************************
bool DirectFourierTransform(rmatrix& FT_Y, const rmatrix& X, long hX0, long wX0,
     ulong VCount, ulong HCount)
{//----------------------------------------------------------------------------------
 //Проверка на возможность построения двумерного преобразования Фурье
 //----------------------------------------------------------------------------------
 if ((X.IsZeroSize())) {FT_Y.Set(0L,false); return false;}
 //Определение количества отсчетов горизонтальной и вертикальной частот
 if (HCount == 0L) HCount = X.Cols();
 if (VCount == 0L) VCount = X.Rows();
 //Формирование матрицы FT_Y необходимой размерности
 if (!FT_Y.Set(VCount,HCount,false)) return false;
 //----------------------------------------------------------------------------------
 //Двумерное преобразование Фурье дискретного двумерного сигнала X
 //----------------------------------------------------------------------------------
 double dw1 = 6.2831853/(VCount-1);
 double dw2 = 6.2831853/(HCount-1);
 double W1 = -3.14159265, W2;

 for (ulong w1 = 0; w1 < VCount; w1++)
 {W2 = -3.14159265;
  for (ulong w2 = 0; w2 < HCount; w2++)
  {complex sum(0.0,0.0);
   long n1, n2;
   for (ulong i = 0L; i < X.Rows(); i++)
   {n1 = i-hX0;
    for (ulong j = 0L; j < X.Cols(); j++)
    {n2 = j-wX0;
     sum += polar(X.Get(i,j),-W1*n1-W2*n2);
    }
   }
   FT_Y.Put(w1,w2,norm(sum));
   W2 += dw2;
  }
  W1 += dw1;
 }
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 18
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool Log10(rmatrix& A)
//НАЗНАЧЕНИЕ: ЛОГАРИФМИРОВАНИЕ ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ ПО ОСНОВАНИЮ 10
//Все элементы матрицы должны быть ПОЛОЖИТЕЛЬНЫМИ, (R(i,j) > 0), иначе функция возвращает
//false и логарифмирование не осуществляется. При попытке логарифмирования матрицы нулевого
//размера функция возвращает false. Функция изменяет исходную матрицу.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// rmatrix& A - ссылка на матрицу, элементы которой логарифмируются
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//****************************************************************************************
bool Log10(rmatrix& A)
{if (A.IsZeroSize()) return false;//Матрица нулевого размера
 //Поиск отрицательных или нулевых значений
 bool lNegative = false;
 for (ulong i = 0L; i < A.Rows(); i++)
 {for (ulong j = 0L; j < A.Cols(); j++)
  {if (A.Get(i,j) <= 0.0) {lNegative = true; break;}}
 }
 if (lNegative) return false;
 //Логарифмирование элементов матрицы по основанию 10
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   A.Put(i,j,log10(A.Get(i,j)));
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 19
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool Log10(rmatrix& A, double Min)
//НАЗНАЧЕНИЕ: ЛОГАРИФМИРОВАНИЕ ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ ПО ОСНОВАНИЮ 10. Всем не-
//положительным значениям присваивается значение Min (д.б. отрицательным). Всем значениям
//матрицы, чьи десятичные логарифмы меньше Min, также присваивается значение Min. В случае
//матрицы нулевого размера функция возвращает false. Функция изменяет исходную матрицу.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& A - ссылка на матрицу, элементы которой логарифмируются;
//2. double Min - минимальное значение прологарифмированного элемента матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//****************************************************************************************
bool Log10(rmatrix& A, double Min)
{double value;
 if (A.IsZeroSize()) return false;//Матрица нулевого размера
 if (Min >= 0) Min = -100.0;
 //Логарифмирование элементов матрицы по основанию 10
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
  {value = A.Get(i,j);
   if (value <= 0) value = Min;
   else
   {value = log10(value);
    if (value < Min) value = Min;
   }
   A.Put(i,j,value);
  }
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 20
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend long Log10(rmatrix& B, const rmatrix& A, double factor, double Min = -60)
//НАЗНАЧЕНИЕ: ЛОГАРИФМИРОВАНИЕ ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОЙ МАТРИЦЫ ПО ОСНАВАНИЮ 10 с последую-
//щим умножением на множитель factor и ограничением минимальных значений на уровне Min.
//Для НЕПОЛОЖИТЕЛЬНЫХ элементов матрицы A (A[i,j] <= 0) устанавливается значение Min.
//Функция возвращает кол-во неположительных элементов матрицы A, к которым была применена
//данная операция. Функция не изменяет элементы исходной матрицы A. Результирующая матрица
//формируется в матрице B. Если Min >= 0, то сравнение на минимальную пороговую величину не
//проводится. Аналогично, если factor = 0, то умножение прологарифмированной величины не
//проводится.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& B - ссылка на результирующую матрицу;
//2. const rmatrix& A - ссылка на исходную матрицу, элементы которой логарифмируются;
//3. double factor - множитель на который домножаются прологарифмированные элементы;
//4. double Min - минимально допустимое значение прологарфмированного и домноженного эл-та.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//****************************************************************************************
long Log10(rmatrix& B, const rmatrix& A, double factor, double Min)
{B = A;
 if (B.IsZeroSize()) return -1L;//Матрица нулевого размера
 long Count = 0L;
 bool lFlag = false;
 double x, MinLg;
 //Логарифмирование элементов матрицы по основанию 10 с домножением на множитель factor
 for (ulong i = 0L; i < B.Rows(); i++)
  for (ulong j = 0L; j < B.Cols(); j++)
  {x = B.Get(i,j);
   if (x > 0.0)
   {x = log10(x);
    if (factor != 0.0) x = x*factor;
    if ((Min < 0.0) && (x < Min)) x = Min;
    if (lFlag == false)
    {lFlag = true;
     MinLg = x;
    }
    else if (lFlag && (MinLg > x)) MinLg = x;
   }
   else Count++;//Неположительное значение элемента матрицы
   B.Put(i,j,x);
  }
  //Анализ на наличие неположительных значений в матрице A
  if (Count > 0L)
  {Min = (Min > MinLg) ? MinLg-1 : Min;
   if (Min >= 0.0) Min = -60;//Минимальный порог д.б. отрицательным для неположит-х чисел
   for (ulong i = 0L; i < B.Rows(); i++)
    for (ulong j = 0L; j < B.Cols(); j++)
    {if (B.Get(i,j) == A.Get(i,j)) B.Put(i,j,Min);
    }
  }
 return Count;
}
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 21
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// ulong Round(rmatrix& A, const double r_val, const double eps = 1e-10)
//НАЗНАЧЕНИЕ: ОКРУГЛЕНИЕ всех значений матрицы A, передаваемой по ссылке, до величины r_val,
//если они находятся в пределах |r_val - A[i][j]| < eps. Функция изменяет исходную матрицу.
//Функция возвращает количество успешных округлений.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& A - ссылка на матрицу, значения которой округляются;
//2. const double r_val - значение присваимое элементу матрицы при его округлении;
//3. const double eps (1e-10) - допуск в пределах которого разрешено округление.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong count - количество произведенных округлений
//****************************************************************************************
ulong Round(rmatrix& A, const double r_val, const double eps)
{ulong Count = 0L;
 if (A.IsZeroSize()) return Count;//Матрица нулевого размера
 //Округление значений матрицы до величины r_val с точностью eps
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
  {if (fabs(r_val - A.Get(i,j)) < eps)
   {A.Put(i,j,r_val);
    Count++;
   }
  }
 return Count;
}
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 22
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Square(rmatrix& A)
//НАЗНАЧЕНИЕ: Возведение всех элементов матрицы A, передаваемой по ссылке, в квадрат.
//Функция изменяет исходную матрицу.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//rmatrix& A - ссылка на матрицу, значения которой возводятся в квадрат;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//****************************************************************************************
bool Square(rmatrix& A)
{if (A.IsZeroSize()) return false;//Матрица нулевого размера
 //Возведение значений матрицы в квадрат
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   A.Put(i,j,A.Get(i,j)*A.Get(i,j));
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 23
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool Square(rmatrix& B, const rmatrix& A)
//НАЗНАЧЕНИЕ: Возведение всех элементов матрицы A, передаваемой по ссылке, в квадрат и
//присвоение результата матрице B. Функция не изменяет исходную матрицу A.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& B - результирующая матрица, в которую заносится результат возведения в
//   квадрат элементов матрицы A;
//2. const rmatrix& A - ссылка на матрицу, значения которой возводятся в квадрат;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//****************************************************************************************
bool Square(rmatrix& B, const rmatrix& A)
{B = A;
 return Square(B);
}
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 24
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool Add(rmatrix& A, double value)
//НАЗНАЧЕНИЕ: Увеличение всех элементов матрицы A, передаваемой по ссылке, на значение
//value. Функция изменяет исходную матрицу.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& A - ссылка на матрицу, значения которой будут изменятся;
//2. double value - значение, на которое увеличиваются значения матрицы A.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//****************************************************************************************
bool Add(rmatrix& A, double value)
{if (A.IsZeroSize()) return false;//Матрица нулевого размера
 //Возведение значений матрицы в квадрат
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   A.Put(i,j,A.Get(i,j) + value);
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 25
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Sqrt(rmatrix& A)
//НАЗНАЧЕНИЕ: Извлечение квадратного корня из всех элементов матрицы A, передаваемой по
//ссылке. Функция изменяет исходную матрицу.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//rmatrix& A - ссылка на матрицу, из значений которых извлекается квадратный корень;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//****************************************************************************************
bool Sqrt(rmatrix& A)
{if (A.IsZeroSize()) return false;//Матрица нулевого размера
 //Поиск отрицательных или нулевых значений
 bool lNegative = false;
 for (ulong i = 0L; i < A.Rows(); i++)
 {for (ulong j = 0L; j < A.Cols(); j++)
  {if (A.Get(i,j) <= 0.0) {lNegative = true; break;}}
 }
 if (lNegative) return false;
 //Извлечение квадратного корня из всех значений матрицы
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   A.Put(i,j,sqrt(A.Get(i,j)));
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 26
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Abs(rmatrix& A)
//НАЗНАЧЕНИЕ: Вычисление абсолютных величин всех элементов матрицы A , передаваемой по
//ссылке. Функция изменяет исходную матрицу.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//rmatrix& A - ссылка на матрицу, значения которой возводятся в квадрат;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//****************************************************************************************
bool Abs(rmatrix& A)
{if (A.IsZeroSize()) return false;//Матрица нулевого размера
 //Вычисление абсолютных величин всех элементов матрицы
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   A.Put(i,j,fabs(A.Get(i,j)));
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 27
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool CalcDiagElems(rvector& D, const rmatrix& H, const rmatrix& R, bool sq_root)
//НАЗНАЧЕНИЕ: Вычисление диагональных элементов произведения трех матриц вида:
// D(n) = diag(Q(n,n) = trH(n,m) * R(m,m) * H(m,n).
//Функция не вычисляет в явном виде матрицу trH, которая является транспонированной к мат-
//рице H, передаваемой по ссылке, используя ее элементы. Результат вычисления диагональных
//элементов произведения трех матриц помещается в вектор D, передаваемый по ссылке. Функция
//не изменяет элементов матриц H & R в ходе вычислений. Опция sq_root = true позволяет
//сразу вычислять квадратный корень из вычисленных значений диагональных элементов. Вычис-
//ления разбиваются на два этапа:
//1) Вычисляется вектор-столбец V(j) произведения столбцов R(j,k)*H(k,i),
//   0 <= j < n, 0 <= k < m и i = const для данного j-го столбца (0 <= i < n);
//2) Вычисляется скалярное произведение j-го столбца матрицы H(m,n), что соответствует
//   j-ой строке trH(n,m), и вектора V(j). Результат вычисления заносится в D(i) элемент
//   результирующего вектора диагональных элементов. Цикл по i повторяется до n.
//По сравнению с классической схемой вычисления данный алгоритм не требует формирования
//матрицы trH, вычисления двух матричных произведений A = trH*R и B = A*H и затем выборки
//из матрицы B диагональных элементов и занесения их в вектор D. Таким образом, выполняется
//оптимизация как по объему вычислений, так и по кол-ву используемой памяти. Дополнительная
//память выделяется только под вектор промежуточных вычислений V размером m. Правила вычис-
//ления ДИАГОНАЛЬНЫХ ЭЛЕМЕНТОВ ПРОИЗВЕДЕНИЯ trH(n,m) * R(m,m) * H(m,n):
//1. Размерности матриц R & H не должны быть нулевыми;
//2. Матрица R должна быть квадратной;
//3. Размерности матрицы R & H должны быть согласованы для выполнения операции умножения
//   матриц, в которой H - правая матрица.
//Результатом успешного выполнения функции считается формирование вектора диагональных
//элементов D размером n. В случае не выполнения правил вычисления функция возвращает false
//и вектор D нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& D - ссылка на результирующий вектор диагональных элементов;
//2. const TRealMatrix& R - ссылка на на квадратную матрицу;
//3. const TRealMatrix& H - ссылка на правую матрицу (левая матрица - trH);
//4. bool sq_root - опция вычисления квадратного корня из вычисленных диагональных элементов.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат вычисления диагональных элементов
//****************************************************************************************
bool CalcDiagElems(rvector& D, const rmatrix& H, const rmatrix& R, bool sq_root)
{//Матрица (матрицы) нулевого размера
 if ((H.IsZeroSize()) || (R.IsZeroSize())) {D.Set(0L,COL,false); return false;}
 //Умножение производится с матрицами неподходящих для умножения размерностей
 if ((R.IsRectang()) || (R.Cols() != H.Rows())) {D.Set(0L,COL,false); return false;}
 //--------------------------------------------------------------------------------------
 //Вычисление ДИАГОНАЛЬНЫХ ЭЛЕМЕНТОВ ПРОИЗВЕДЕНИЯ trH(n,m)R(m,m)H(m,n)
 //--------------------------------------------------------------------------------------
 if (D.Set(H.Cols(),false) == false) return false;
 rvector V(R.Rows(),ROW,false);
 double sum;

 for (ulong i = 0L; i < H.Cols(); i ++)
 {for (ulong j = 0L; j < R.Cols(); j++)
  {sum = 0.0;
   for (ulong k = 0L; k < H.Rows(); k++) sum += R.Get(j,k)*H.Get(k,i);
   V.Put(j,sum);
  }
  //Умножение вектора-столбца V на i-й столбец матрицы H (скалярное произведение)
  sum = 0.0;
  for (ulong j = 0L; j < H.Rows(); j++) sum += H.Get(j,i)*V.Get(j);
  if (sq_root) sum = sqrt(sum);
  D.Put(i,sum);
 }
 return true; //Дигональные элементы вычислены
}
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 28
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool Average(rmatrix& A, const rmatrix& B, ulong n)
//НАЗНАЧЕНИЕ: Выполнение усреднения элементов матрицы B делением их на число опытов n c
//последующим суммированием с элементами матрицы A, которая будет изменяться функцией:
//A = A + B/n. Матрицы A и B должны быть ненулевого размера и одинаковой размерности. Если
//матрица A не совпадает по размеру с матрицей B, то выполняется операция: A = B/n.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& A - ссылка на результирующую матрицу;
//2. const rmatrix& B - ссылка на матрицу с усредняемыми элементами;
//3. ulong n - число усреднений в эксперименте (n > 0).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения операции
//****************************************************************************************
bool Average(rmatrix& A, const rmatrix& B, ulong n)
{if (B.IsZeroSize()) {A.Set(0L,false); return false;}
 if (!IsEqualSize(A,B))
 {A = B;
  if (n > 0)
  {for (ulong i = 0L; i < A.Rows(); i++)
    for (ulong j = 0L; j < A.Cols(); j++)
     A.Put(i,j,A.Get(i,j)/n);
  }
 }
 else
 {if (n == 0) n = 1;
  for (ulong i = 0L; i < A.Rows(); i++)
    for (ulong j = 0L; j < A.Cols(); j++)
     A.Put(i,j,A.Get(i,j)+B.Get(i,j)/n);
 }
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 29
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool InfiniteAverage(rmatrix& AvX, const rmatrix& Xk, ulong k)
//НАЗНАЧЕНИЕ: Выполнение операции непрерывного усреднения элементов матрицы без задания
//общего числа усреднений. Функция формирует в матрице AvX матрицу усредненных значений
//на k-ом шаге (опыте) по формуле: AvX = (k*AvX + Xk)/(k+1), k > 0. Для k == 0: AvX = Xk.
//Правила использования функции следующие:
//1. Пользователь должен следить, чтобы при каждом очередном вызове функции значения k
//   отличались на ЕДИНИЦУ в сторону увеличения k, иначе результаты усреднения будут
//   неверными. Для первого вызова функции следует задать k == 0.
//2. Матрица Xk не должна быть матрицей нулевого размера, иначе функция возвращает false и
//   матрицу AvX - нулевого размера.
//3. За исключением k == 0 размерности матриц AvX и Xk должны совпадать, иначе возвращается
//   false и матрица AvX - нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& AvX - ссылка на результирующую матрицу с усредненными значениями для k опытов;
//2. const rmatrix& Xk - ссылка на матрицу с элементами k-ой выборки;
//3. ulong k - номер выборки (k >= 0).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения операции
//****************************************************************************************
bool InfiniteAverage(rmatrix& AvX, const rmatrix& Xk, ulong k)
{if (Xk.IsZeroSize()) {AvX.Set(0L,false); return false;}
 if (k == 0) {AvX = Xk; return true;}
 if (IsEqualSize(AvX,Xk) == false) {AvX.Set(0L,false); return false;}
 //Получение матрицы усредненных значений AvX на k-ом шаге: AvX = (k*AvX + Xk)/(k+1)
 for (ulong i = 0L; i < AvX.Rows(); i++)
  for (ulong j = 0L; j < AvX.Cols(); j++)
   AvX.Put(i,j,(k*AvX.Get(i,j)+Xk.Get(i,j))/(k+1));
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TRealMatrix class # 30
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend string& MakeTable(string& sTbl, const UStringMap& HeadColl, const rmatrix& A,
// uint precision = 6, string& delim = string(1,' '));
//НАЗНАЧЕНИЕ: Табличное форматирование данных матрицы A с формированием заголовка таблицы
//по столбцам из контейнера заголовков HeadColl в строке sTbl типа string. Функция возвра-
//щает ссылку на строку sTbl.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& sTbl - ссылка на результирующую строку с табличным представлением матрицы A;
//2. const UStringMap& HeadColl - контейнер с заголовками столбцов матрицы A;
//3. const rmatrix& A - ссылка на матрицу с форматируемыми данными;
//4. uint precision (6) - точность символьного представления чисел с плавающей запятой;
//5. string& delim - строка-разделитель столбцов матрицы A в строке sTbl.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения операции
//****************************************************************************************
string& MakeTable(string& sTbl, const UStringMap& HeadColl, const rmatrix& A,
        uint precision, string& delim)
{//Объявление переменных
 ivector WCols;
 string sHead;
 std::map<ulong,string>::const_iterator pos;
 string sCurHead;//Строка с текущим заголовком
 long LenHead;//Длина строки с текущим заголовком
 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 text.setf(ios::right);//Выравнивание по правому краю.
 //Определение максимальной символьной длины элемента матрицы
 if (A.WidthCols(WCols,precision) == 0)
 {sTbl.assign("Zero-size Real Matrix"); return sTbl;}
 //Построение заголовка таблицы
 for (ulong i = 0; i < A.Cols(); i++)
 {pos = HeadColl.find(i);//Поиск заголовка столбца с номером i
  if (pos != HeadColl.end())
  {LenHead = pos->second.length(); sCurHead.assign(pos->second);}
  else //Формируем заголовок автоматически
  {text << "Col_" << i << ends;
   sCurHead.assign(text.str()); text.seekp(0); LenHead = sCurHead.length();
  }
  if (WCols.Get(i) < LenHead) WCols.Put(i,LenHead);

  text << setw(WCols.Get(i)) << sCurHead;
  if ((A.Cols()-i) > 1) text << delim << ends;
  else text << endl << ends;
  sHead.append(text.str()); text.seekp(0);
 }
 sTbl.assign(sHead);
 //Табличное представление данных, хранящихся в матрице A
 //Вывод значений элементов вещественной матрицы в строку
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
  {//Формирование символьного представления вещественного числа
   text << setw(WCols.Get(j)) << setprecision(precision) << A.Get(i,j);
   if ((A.Cols()-j) > 1) text << delim << ends;
   else text << endl << ends;//Каждая строка матрицы выводится с новой строки
   sTbl.append(text.str()); text.seekp(0);
  }
 return sTbl;
}

//*******************  ЗАВЕРШЕНИЕ РЕАЛИЗАЦИИ КЛАССА TRealMatrix  *************************

//****************************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TComplexMatrix
//****************************************************************************************

//========================================================================================
//  РЕАЛИЗАЦИЯ КОНСТРУКТОРОВ и ДЕСТРУКТОРА КЛАССА TComplexMatrix
//  TComplexMatrix CLASS CONSTRUCTORs & DESTRUCTOR REALIZATION
//========================================================================================
//****************************************************************************************
//СТАТУС: 1; public; TComplexMatrix constructor by default
//НАИМЕНОВАНИЕ ФУНКЦИИ: TComplexMatrix()
//НАЗНАЧЕНИЕ: Конструктор по умолчанию класса TComplexMatrix.
//Функция предназначена для создания класса TComplexMatrix по умолчанию. По
//умолчанию конструируется комплексная матрица нулевого размера - CM_ZEROSIZE.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TComplexMatrix::TComplexMatrix() {Initial();}
//******************************************************************************
//СТАТУС: 2; public TComplexMatrix constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TComplexMatrix(ulong row, ulong col, complex value)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TComplexMatrix создает квадратную
//или прямоугольную комплексную матрицу с инициализацией элементов значением value.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong row - количество строк матрицы
//2. ulong col - количество столбцов матрицы
//3. complex value - инициализирующее значение
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TComplexMatrix::TComplexMatrix(ulong row, ulong col, complex value)
{Initial();//Начальная инициализация членов-данных класса
 Set(row,col,value);
}
//******************************************************************************
//СТАТУС: 3; public TComplexMatrix constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TComplexMatrix(ulong row, ulong col, bool init)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TComplexMatrix создает комплексную
//матрицу и инициализирует ее случайными значениями при init = true и не инициа-
//лизирует в противном случае.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong row - количество строк матрицы
//2. ulong col - количество столбцов матрицы
//3. bool init - опция инициализации матрицы случайными значениями
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TComplexMatrix::TComplexMatrix(ulong row, ulong col, bool init)
{Initial();//Начальная инициализация членов-данных класса
 Set(row,col,init);
}
//******************************************************************************
//СТАТУС: 4; public TComplexMatrix constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TComplexMatrix(ulong size, complex value)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TComplexMatrix создает квадратную
//матрицу и инициализирует ее элементы значением value.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong size - размерность квадратной матрицы
//2. complex value - инициализирующее значение
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TComplexMatrix::TComplexMatrix(ulong size, complex value)
{Initial();//Начальная инициализация членов-данных класса
 Set(size,value);
}
//******************************************************************************
//СТАТУС: 5; public TComplexMatrix constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TComplexMatrix(ulong size, bool init)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TComplexMatrix создает квадратную
//матрицу и инициализирует ее случайными значениями при init=true и не инициали-
//зирует в противном случае.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong size - размерность квадратной матрицы
//2. bool init - опция инициализации матрицы случайными значениями
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TComplexMatrix::TComplexMatrix(ulong size, bool init)
{Initial();//Начальная инициализация членов-данных класса
 Set(size,init);
}
//******************************************************************************
//СТАТУС: 6; public TComplexMatrix constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TComplexMatrix(ulong size, uint sq_type, ulong diag = 3L)
//НАЗНАЧЕНИЕ: Конструктор с аргументами класса TComplexMatrix создает квадратную
//матрицу типа sq_type и инициализирует ее случайными значениями. Параметр diag
//используется при конструировании ленточной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong size - размерность квадратной матрицы
//2. uint sq_type - тип квадратной матрицы
//3. ulong diag - кол-во диагоналей ленточной матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TComplexMatrix::TComplexMatrix(ulong size, uint sq_type, ulong diag)
{Initial();//Начальная инициализация членов-данных класса
 Set(size, sq_type, diag);
}
//******************************************************************************
//СТАТУС: 7; public TComplexMatrix constructor with arguments
//НАИМЕНОВАНИЕ ФУНКЦИИ: TComplexMatrix(const PF_MATRIX& Info)
//НАЗНАЧЕНИЕ: Конструктор класса TComplexMatrix создает комплексную матрицу согласно
//данным структуры типа PF_MATRIX, передаваемой по ссылке.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const PF_MATRIX& Info - ссылка на структуру свойств, создаваемой матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TComplexMatrix::TComplexMatrix(const PF_MATRIX& Info)
{Initial();//Начальная инициализация членов-данных класса
 Set(Info);
}
//******************************************************************************
//СТАТУС: 8; public TComplexMatrix class copy constructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: TComplexMatrix(const TComplexMatrix& A)
//НАЗНАЧЕНИЕ: Конструктор копирования класса TComplexMatrix создает объект класса
//TComplexMatrix по  характеристикам класса A. Осуществляется корректное копиро-
//вание членов-указателей на данные копируемого класса в создаваемый класс с целью
//недопущения ссылок указателей разных объектов класса на одно и то же место па-
//мяти. Для процедуры копирования используется ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// const TComplexMatrix& A - ссылка на объект типа TComplexMatrix
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TComplexMatrix::TComplexMatrix(const TComplexMatrix& A)
{Initial();//Начальная инициализация членов-данных класса
 *this = A;//Установка характеристик матрицы, вызовом перегруженного оператора =
}
//******************************************************************************
//СТАТУС: 9; public TComplexMatrix class destructor
//НАИМЕНОВАНИЕ ФУНКЦИИ: ~TComplexMatrix()
//НАЗНАЧЕНИЕ: ДЕСТРУКТОР класса TComplexMatrix удаляет объекта данного класса
//после завершения работы с ним. В ходе работы деструктор освобождает оперативную
//память занятую элементами и характеристиками комплексной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
TComplexMatrix::~TComplexMatrix() {Delete();}

//==============================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TComplexMatrix
//    PUBLIC MEMBER-FUNCTION OF TComplexMatrix CLASS REALIZATION
//==============================================================================
//------------------------------------------------------------------------------
// РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ФУНКЦИЙ КЛАССА cmatrix, ОПРЕДЕЛЯЮЩИХ ТИП МАТРИЦ
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1., public, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsZeroSize() const
//НАЗНАЧЕНИЕ: Проверка комплексной матрицы на матрицу нулевого размера. В случае
//удачи функция возвращает - true и false - в противном случае.
//Свойства матрицы нулевого размера следующие:
//1. (Rows() || Cols()) == 0 - кол-во строк или столбцов равно нулю;
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::IsZeroSize() const
{//Проверка на m = n = 0
 if ((Rows() == 0L) || (Cols() == 0L)) return true;
 return false;
}
//******************************************************************************
//СТАТУС: I.2., public, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsZero() const
//НАЗНАЧЕНИЕ: Проверка комплексной матрицы на матрицу  со всеми нулевыми элемен-
//тами. В случае удачи функция возвращает - true и false - в противном случае.
//Свойства комплексной матрицы со всеми нулевыми элементами:
//1. A[i][j] = C_ZERO - ВСЕ элементы квадратной матрицы должны быть равны НУЛЮ.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::IsZero() const
{//Цикл проверки свойства 1
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
  {if (abs(data[i][j]) > EPS) return false;}
 return true;
}
//******************************************************************************
//СТАТУС: I.3., public, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsSymmetric() const
//НАЗНАЧЕНИЕ: Проверка комплексной матрицы на симметричность. В случае ее симмет-
//ричности функция возвращает - true и false - в противном случае.
//Свойства симметрической комплексной матрицы:
//1. Rows() == Cols() - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = A[j][i] - элементы матрицы, расположенные симметрично друг
//   друга относительно главной диагонали матрицы должны быть равными;
//3. Должен существовать внедиагональный элемент матрицы отличный от нуля.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::IsSymmetric() const
{//Матрица прямоугольная или размерность квадратной матрицы меньше 2
 if ((IsRectang()) || (Rows() < 2)) return false;
 bool lNonZero = false;
 //Цикл проверки свойства 2
 for (ulong i = 1L; i < Rows(); i++)
  for (ulong j = 0L; j < i; j++)
  {if (lNonZero == false) lNonZero = (abs(data[i][j]) > EPS) ? true : false;
   if (abs(data[i][j]-data[j][i]) > EPS) return false;
  }
return lNonZero;
}
//******************************************************************************
//СТАТУС: I.4., public, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsSkewSymmetric() const
//НАЗНАЧЕНИЕ: Проверка комплексной матрицы на кососимметричность. В случае ее
//кососимметричности функция возвращает - true и false - в противном случае.
//Свойства кососимметрической комплексной матрицы:
//1. Rows() == Cols() - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = -A[j][i] - элементы матрицы, расположенные симметрично друг
//   друга относительно главной диагонали матрицы должны быть равными по модулю
//   и противоположными по знаку.
//3. Должен существовать внедиагональный элемент матрицы отличный от нуля.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::IsSkewSymmetric() const
{//Матрица прямоугольная или размерность квадратной матрицы меньше 2
 if ((IsRectang()) || (Rows() < 2)) return false;
 bool lNonZero = false;
 //Цикл проверки свойства 2
 for (ulong i = 1L; i < Rows(); i++)
  for (ulong j = 0L; j < i; j++)
  {if (lNonZero == false) lNonZero = (abs(data[i][j]) > EPS) ? true : false;
   if (abs(data[i][j] + data[j][i]) > EPS) return false;
  }
 return lNonZero;
}
//******************************************************************************
//СТАТУС: I.5., public, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsAltSign() const
//НАЗНАЧЕНИЕ: Проверка комплексной матрицы на знакопеременность. В случае ее
//знакопеременности функция возвращает - true и false - в противном случае.
//Свойства знакопеременной комплексной матрицы:
//1. Rows() == Cols() - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = -A[j][i] - элементы матрицы, расположенные симметрично друг
//   друга относительно главной диагонали матрицы должны быть равными по модулю
//   и противоположными по знаку.
//3. A[i][i] = C_ZERO - элементы матрицы, расположенные на главной диагонали
//   должны быть равными нулю.
//4. Должен существовать внедиагональный элемент матрицы отличный от нуля.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::IsAltSign() const
{//Матрица прямоугольная или размерность квадратной матрицы меньше 2
 if ((IsRectang()) || (Rows() < 2)) return false;
 bool lNonZero = false;
 //Цикл проверки свойства 2 и 3
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i ; j++)
  {if (i != j) //Элемент матрицы размещен не на главной диагонали
   {if (lNonZero == false) lNonZero = (abs(data[i][j]) > EPS) ? true : false;
    if (abs(data[i][j] + data[j][i]) > EPS) return false;
   }
   else //Элемент матрицы размещен на главной диагонали
    if (abs(data[i][j]) > EPS) return false;
  }
 return lNonZero;
}
//******************************************************************************
//СТАТУС: I.6, public, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsUpperTriang() const
//НАЗНАЧЕНИЕ: Проверка комплексной матрицы на верхнюю треугольную. Если матрица -
//верхняя треугольная, то функция возвращает - true и false - в противном случае.
//Свойства верхней треугольной комплексной матрицы:
//1. Rows() == Cols() - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = 0, для всех i > j - элементы матрицы, расположенные ниже главной
//  диагонали матрицы должны быть равны нулю.
//3. Должны существовать элементы матрицы отличные от нуля, расположенные выше
//   главной диагонали.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::IsUpperTriang() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 bool lNonZero = false;
 //Цикл проверки свойства 2
 for (ulong i = 1L; i < Rows(); i++)
  for (ulong j = 0L; j < i; j++)
  {if (lNonZero == false) lNonZero = (abs(data[j][i]) > EPS) ? true : false;
   //Элемент матрицы, размещенные ниже главной диагонали
   if (abs(data[i][j]) > EPS) return false;
  }
 return lNonZero;
}
//******************************************************************************
//СТАТУС: I.7., public, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsLowerTriang() const
//НАЗНАЧЕНИЕ: Проверка комплексной матрицы на нижнюю треугольную. Если матрица -
//нижняя треугольная, то функция возвращает - true и false - в противном случае.
//Свойства нижней треугольной комплексной матрицы:
//1. Rows() == Cols() - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = 0, для всех i < j - элементы матрицы, расположенные выше главной
//  диагонали матрицы должны быть равны нулю.
//3. Должны существовать элементы матрицы отличные от нуля, расположенные ниже
//   главной диагонали.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::IsLowerTriang() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 bool lNonZero = false;
 //Цикл проверки свойства 2
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = i+1; j < Cols(); j++)
  {if (lNonZero == false) lNonZero = (abs(data[j][i]) > EPS) ? true : false;
   //Элементы матрицы, размещенные выше главной диагонали
   if (abs(data[i][j]) > EPS) return false;
  }
 return lNonZero;
}
//******************************************************************************
//СТАТУС: I.8, public, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsDiagonal() const
//НАЗНАЧЕНИЕ: Проверка  комплексной матрицы на диагональную. Если матрица - диа-
//гональная, то функция возвращает - true и false - в противном случае.
//Свойства диагональной комплексной матрицы следующие:
//1. Rows() == Cols() - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = 0, для всех i != j - элементы матрицы, расположенные не на глав-
//   ной диагонали матрицы должны быть равны нулю.
//3. Должен существовать элемент матрицы отличный от нуля, расположенный на
//   главной диагонали.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::IsDiagonal() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 bool lNonZero = false;
 //Цикл проверки свойства 2
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {//Элемент матрицы размещенный не на главной диагонали
   if ((i != j) && (abs(data[i][j]) > EPS)) return false;
   else //Диагональный элемент
    if (lNonZero == false) lNonZero = (abs(data[i][j]) > EPS) ? true : false;
  }
return lNonZero;
}
//******************************************************************************
//СТАТУС: I.9., public, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsScalar() const
//НАЗНАЧЕНИЕ: Проверка комплексной матрицы на скалярную. Если матрица - скалярная,
//то функция возвращает - true и false - в противном случае.
//Свойства скалярной комплексной матрицы следующие:
//1. Rows() == Cols() - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = 0, для всех i != j - элементы матрицы, расположенные не на главной
//   диагонали матрицы должны быть равны нулю.
//3. A[i][i] = c, для всех i = j - элементы матрицы, расположенные на главной
//   диагонали равны между собой (c != 1 && c != 0).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::IsScalar() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 complex c = data[0][0];
 if (abs(c) < EPS) return false;//Проверка на c == 0.0
 if (abs(c - C_ONE) < EPS) return false;//Проверка на c == 1.0
 //Цикл проверки свойства 2 & 3
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {//Внедиагональный элемент матрицы
   if ((i != j) && (abs(data[i][j]) > EPS)) return false;
   else //Диагональный элемент матрицы
    if (abs(data[i][j] - c) > EPS) return false;
  }
 return true;
}
//******************************************************************************
//СТАТУС: I.10, public, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsUnit() const
//НАЗНАЧЕНИЕ: Проверка комплексной матрицы на единичную. Если матрица - единичная,
//то функция возвращает - true и false - в противном случае.
//Свойства единичной комплексной матрицы:
//1. Rows() == Cols() - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = 0, для всех i != j - элементы матрицы, расположенные не на главной
//   диагонали матрицы должны быть равны нулю.
//3. A[i][i] = 1, для всех i = j - элементы матрицы, расположенные на главной
//   диагонали равны между собой.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::IsUnit() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 //Цикл проверки свойства 2 & 3
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
  {//Внедиагональный элемент матрицы
   if ((i != j) && (abs(data[i][j]) > EPS)) return false;
   else //Внедиагональный элемент матрицы
    if (abs(data[i][j] - 1.0) > EPS) return false;
  }
 return true;
}
//******************************************************************************
//СТАТУС: I.11, public, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsBand(ulong& diags) const
//НАЗНАЧЕНИЕ: Проверка комплексной матрицы на ленточную с  автоматическим опре-
//делением числа дигоналей. На ленточную проверяется квадратная  матрица размер-
//ностью не меньше трех, максимальное число диагоналей матрицы определяется фор-
//мулой: maxdiag = 2*Rows()-1. Проверка начинается с максимально возможного чис-
//ла диагоналей. Это позволяет определить сразу является матрица ленточной или
//нет. Число диагоналей у ленточной матрицы может быть только НЕЧЕТНЫМ.
//Если матрица является ленточной, то функция возвращает - true и false - в про-
//тивном случае. В переменную diags, передаваемую по ссылке, заносится число
//диагоналей квадратной матрицы (1 <= diags <= maxdiag). Матрица считается лен-
//точной при diags != 1 (диагональная матрица) и diags != maxdiag (обыкновенная
//квадратная матрица). При diags == 0 - матрица прямоугольная.
//Свойства ленточной вещественной матрицы следующие:
//1. Rows() == Cols() - матрица должна быть КВАДРАТНОЙ, m > 2;
//2. A[i][j] = 0, для элементов матрицы, индексы которых должны удовлетворять
//   следующему неравенству: 2*|i-j| > diag-1.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong& diags - число диагоналей матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::IsBand(ulong& diags) const
{//Проверка на квадратную матрицу
 if (!IsSquare() || (Rows() < 3)) {diags = 0L; return false;}
 diags = 2*Rows()-1;//Максимальное число диагоналей данной матрицы
 for (ulong n = Rows()-1; n > 0; n--)
 {ulong j = 0L;
  bool lZeroDiag = true;
  for (ulong i = n; i < Rows(); i++)
  {if ((abs(data[i][j]) > EPS) || (abs(data[j][i]) > EPS))
   {lZeroDiag = false; break;}
   j++;
  }
  if (lZeroDiag == false) break;
  diags -= 2;//Уменьшаем число диагоналей ленточной матрицы от значения maxdiag
 }
 //Анализ результатов
 return ((diags == 1L) || (diags == 2*Rows()-1)) ? false : true;
}
//******************************************************************************
//СТАТУС: I.12., public, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsHermitian() const
//НАЗНАЧЕНИЕ: Проверка комплексной матрицы на эрмитовую матрицу. В случае эрмито-
//вости матрицы функция возвращает - true и false - в противном случае.
//Свойства эрмитовой матрицы:
//1. Rows() = Cols() - комплексная матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = conj(A[j][i]) - элементы матрицы, расположенные симметрично друг
//   друга относительно главной диагонали матрицы должны быть КОМПЛЕКСНО-СОПРЯ-
//   ЖЕННЫМИ.
//3. imag(A[i][i]) = 0 - элементы эрмитовой матрицы, расположенные на ее глав-
//   ной диагонали должны быть ВЕЩЕСТВЕННЫМИ числами.
//4. Должны существовать элементы матрицы отличные от нуля, расположенные вне
//   главной диагонали.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::IsHermitian() const
{//Проверка на квадратную матрицу
 if (!IsSquare() || (Rows() < 2)) return false;
 //Цикл проверки свойств 2 и 3
 bool lNonZero = false;
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {if (i == j) //Элемент матрицы размещен на главной диагонали
    if (fabs(imag(data[i][j])) > EPS) return false;
   else //Внедиагональный элемент
   {if (lNonZero == false) lNonZero = (abs(data[i][j]) > EPS) ? true : false;
    if (abs(data[i][j] - conj(data[j][i])) > EPS) return false;
   }
  }
 return lNonZero;
}
//******************************************************************************
//СТАТУС: I.13, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: uint SubType() const
//НАЗНАЧЕНИЕ: Определение подтипа комплексной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint type - подтип матрицы
//******************************************************************************
uint TComplexMatrix::SubType() const
{if (IsZeroSize()) return CM_ZEROSIZE;//Матрица нулевого размера
 //Действительное число - матрица размером 1 x 1
 if ((Rows() == 1) && (Cols() == 1)) return CM_NUMBER;
 if (IsZero()) return CM_ZERO;//Матрица со всеми нулевыми элементами

 if (IsRectang()) //Прямоугольная матрица
 {if ((Rows() == 1) && (Cols() > 1)) return CV_ROW;//Вектор-строка
  if ((Cols() == 1) && (Rows() > 1)) return CV_COLUMN;//Вектор-столбец
  return CM_RECTANG;
 }
 else //Квадратная матрица
 {//Проверка подклассов класса <КВАДРАТНАЯ МАТРИЦА> ...
  //----------------------------------------------------------------------------
  //Проверка на диагональную матрицу
  if (IsDiagonal())
  {if (IsScalar()) return CM_SCALAR;//Проверка на скалярную матрицу
   if (IsUnit()) return CM_UNIT;//Проверка на единичную матрицу
   return CM_DIAGONAL;
  }
  //----------------------------------------------------------------------------
  if (IsSymmetric()) return CM_SYMMETRICAL;//Проверка на симметричность
  if (IsSkewSymmetric()) //Проверка на кососимметричность
  {//Проверка на знакопеременность
   if (IsAltSign()) return CM_ALTERNATINGSIGN;
   return CM_SKEWSYMMETRIC;
  }
  //----------------------------------------------------------------------------
  //Проверка на эрмитовость
  if (IsHermitian()) return CM_HERMITIAN;
  //----------------------------------------------------------------------------
  //Проверка на верхнюю треугольную матрицу
  if (IsUpperTriang()) return CM_UTRIANG;
  //Проверка на нижнюю треугольную матрицу
  if (IsLowerTriang()) return CM_LTRIANG;
  //----------------------------------------------------------------------------
  //Проверка на ленточную матрицу с определением числа ее диагоналей
  ulong diags = 0L;
  if (IsBand(diags)) return CM_BAND;
 }
return CM_SQUARE;
}
//******************************************************************************
//СТАТУС: I.14, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: uint SubType(ulong& n) const
//НАЗНАЧЕНИЕ: Определение подтипа комплексной матрицы. В переменную n, передаваемую
//по ссылке, в зависимости от подтипа матрицы заноситься дополнительная информа-
//ция о матрице. Для квадратной матрицы и векторов - n будет содержать размерности,
//для ленточной матрицы - количество диагоналей.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong& n - ссылка на переменную, в которую заносится
//дополнительная информация о матрице
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint type - подтип матрицы
//******************************************************************************
uint TComplexMatrix::SubType(ulong& n) const
{n = 0L;
 if (IsZeroSize()) return CM_ZEROSIZE;//Матрица нулевого размера
 //Действительное число - матрица размером 1 x 1
 if ((Rows() == 1) && (Cols() == 1)) {n = 1L; return CM_NUMBER;}
 //Матрица со всеми нулевыми элементами
 if (IsZero()) return CM_ZERO;

 if (IsRectang()) //Прямоугольная матрица
 {if ((Rows() == 1) && (Cols() > 1)) {n = Cols(); return CV_ROW;}//Вектор-строка
  if ((Cols() == 1) && (Rows() > 1)) {n = Rows(); return CV_COLUMN;}//Вектор-столбец
  return CM_RECTANG;
 }
 else //Квадратная матрица
 {//Проверка подклассов класса <КВАДРАТНАЯ МАТРИЦА> ...
  //----------------------------------------------------------------------------
  n = Rows();//Размерность квадратной матрицы
  //Проверка на диагональную матрицу
  if (IsDiagonal())
  {if (IsScalar()) return CM_SCALAR;//Проверка на скалярную матрицу
   if (IsUnit()) return CM_UNIT;//Проверка на единичную матрицу
   return CM_DIAGONAL;
  }
  //----------------------------------------------------------------------------
  //Проверка на эрмитовость
  if (IsHermitian()) return CM_HERMITIAN;
  //----------------------------------------------------------------------------
  if (IsSymmetric()) return CM_SYMMETRICAL;//Проверка на симметричность
  if (IsSkewSymmetric()) //Проверка на кососимметричность
  {//Проверка на знакопеременность
   if (IsAltSign()) return CM_ALTSIGN;
   return CM_SKEWSYMMETRIC;
  }
  //----------------------------------------------------------------------------
  //Проверка на верхнюю треугольную матрицу
  if (IsUpperTriang()) return CM_UTRIANG;
  //Проверка на нижнюю треугольную матрицу
  if (IsLowerTriang()) return CM_LTRIANG;
  //----------------------------------------------------------------------------
  //Проверка на ленточную матрицу с определением числа ее диагоналей
  ulong diags;
  if (IsBand(diags)) {n = diags; return CM_BAND;}
 }
return CM_SQUARE;
}

//------------------------------------------------------------------------------
// РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ФУНКЦИЙ ОПРЕДЕЛЯЮЩИХ СВОЙСТВА КЛАССА TComplexMatrix
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Properties(PF_MATRIX& Info) const
//НАЗНАЧЕНИЕ: Определение  свойств комплексной матрицы. Функция размещает харак-
//теристики матрицы в структуре Info, передаваемой по ссылке. Для ленточной мат-
//рицы поле Info.cols будет содержать количество ее диагоналей.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// PF_MATRIX& Info - ссылка на структуру со свойствами данной матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::Properties(PF_MATRIX& Info) const
{Info.type = Type(); Info.rows = Rows(); Info.cols = Cols();
 //----------------------------------------------------------------------------
 //Определение подтипа матрицы
 //----------------------------------------------------------------------------
 ulong n; Info.subtype = SubType(n);
 //Число диагоналей для ленточной матрицы
 if (Info.subtype == CM_BAND) Info.cols = n;
}
//******************************************************************************
//СТАТУС: I.2, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// void Properties(ulong& rows, ulong& cols, bool& type, uint& subtype) const
//НАЗНАЧЕНИЕ: Определение свойств комплексной  матрицы. Функция размещает харак-
//теристики матрицы в переменных rows, cols, type, subtype, передаваемых по ссылке.
//Для ленточной матрицы cols будет содержать количество ее диагоналей.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong& rows - ссылка на число строк матрицы
//2. ulong& cols - ссылка на число столбцов (диагоналей) матрицы
//3. bool& type  - ссылка на тип матрицы (SQUARE || RECTANG)
//4. uint& subtype - ссылка на подтип матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::Properties(ulong& rows, ulong& cols, bool& type, uint& subtype) const
{type = Type(); rows = Rows(); cols = Cols();
 ulong n; subtype = SubType(n);//Определение подтипа матрицы
 if (subtype == CM_BAND) cols = n;//Число диагоналей для ленточной матрицы
}
//******************************************************************************
//СТАТУС: I.3, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetType(string& s, uint language = ENG) const
//НАЗНАЧЕНИЕ: Формирование наименования типа матрицы на русском или английском
//языке. Допускается многоязычный интерфейс корректировкой кода функции. Язык по
//умолчанию - английский. Формирование типа матрицы (SQUARE || RECTANG) осуществ-
//ляется в строке s, передаваемой по ссылке. Функция возвращает ссылку на строку
//с наименованием типа вектора.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку для формирования имени типа вектора
//2. uint language [ENG] - язык наименования типа вектора
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// string& s - ссылка на строку с сформированным именем типа вектора
//******************************************************************************
string& TComplexMatrix::GetType(string& s, uint language) const
{if (language == RUS) //Формирование наименования типа матрицы на русском языке
  s = (IsSquare()) ? "Квадратная комплексная матрица" :
                     "Прямоугольная комплексная матрица";
 else //Формирование наименования типа матрицы на английском языке
  s = (IsSquare()) ? "Square complex matrix" : "Rectangular complex matrix";
 return s;
}
//******************************************************************************
//СТАТУС: I.4, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetSubType(string& s, uint language = ENG) const
//НАЗНАЧЕНИЕ: Получение наименования подтипа матрицы. Таблица соответствия подтипа
//матрицы с ее наименованиями представлена массивом CMatrName. В массиве хранятся
//наименования матриц на русском и английском языке. Индексом для получения имени
//матрицы служит ее подтип (subtype). Осуществляется обработка некорректного за-
//дания  языка, на  котором  должно  быть получено имя. Допускается многоязычный
//интерфейс путем корректировки структуры MATRIX_NAME и внесения изменений в мас-
//сив CMatrName. Язык по умолчанию - английский.  При формировании наименования
//матрицы в строке s, прежнее содержимое строки уничтожается.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку;
//2. uint language (ENG) - язык, на котором формируется наименование матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с именем подтипа матрицы
//******************************************************************************
string& TComplexMatrix::GetSubType(string& s, uint language) const
{uint index = SubType();//Определяем подтип матрицы
 switch (language)
 { case RUS: //указать наименование типа матрицы на русском языке
    s = CMatrName[index].rus_name; break;
   case ENG: //указать наименование типа матрицы на английском языке
    s = CMatrName[index].eng_name; break;
   //Наименование типа матрицы на заданном языке отсутствует
   default: //указать наименование типа матрицы на английском языке
    s = CMatrName[index].eng_name; break;
 }
 return s;
}
//******************************************************************************
//СТАТУС: I.5; public member-function of class TComplexMatrix
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Properties(string& s) const
//НАЗНАЧЕНИЕ: Формирование свойств TComplexMatrix в виде строки.
//ПРИМЕР: TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строковый объект
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами матрицы
//******************************************************************************
string& TComplexMatrix::Properties(string& s) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 s.resize(0);
 PF_MATRIX Info;
 Properties(Info);//Определение свойств матрицы
 //-----------------------------------------------------------------------------
 //1. Формирование наименования типа матрицы
 s.append("TYPE: ");
 text << CMatrName[Info.subtype].eng_name << "; " << ends;
 s.append(text.str()); text.seekp(0);
 //2. Формирование размерности матрицы
 s.append("DIMENSION: ");
 text << Rows() << " x " << Cols() << ends;
 s.append(text.str()); text.seekp(0);
 //Для ленточной матрицы формируем количество ее диагоналей
 if (Info.subtype == CM_BAND)
 {text << "; " << Info.cols << "-diags" << ends;
  s.append(text.str()); text.seekp(0);
 }
 s.append("\n");//'\n'
return s;
}

//------------------------------------------------------------------------------
// РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ФУНКЦИЙ УСТАНОВКА СВОЙСТВ МАТРИЦЫ TComplexMatrix
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(ulong rows, ulong cols, complex value)
//НАЗНАЧЕНИЕ: Установка новых размеров комплексной матрицы и их инициализация
//величиной value. При невозможности создания матрицы новых размеров функция
//возвращает false, матрица становится нулевой размерности.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong rows - количество строк матрицы
//2. ulong cols - количество столбцов матрицы
//3. complex value - инициализирующая величина
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак создания матрицы новых размеров
//******************************************************************************
bool TComplexMatrix::Set(ulong rows, ulong cols, complex value)
{//Анализ на соответствие размеров старой и новой матрицы
 if ((rows != Rows()) || (cols != Cols()))
 {Delete();//1. Удаление элементов матрицы со старыми размерами
  //2. Установка новых размеров и типа матрицы
  m = rows; n = cols; type = (m == n) ? SQUARE : RECTANG;
  //3. Распределение памяти под хранение элементов матрицы с новыми размерами
  if (Create() == false) return false;
 }
 //Инициализация элементов матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = value;
 return true;
}
//******************************************************************************
//СТАТУС: I.2, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(ulong rows, ulong cols, bool init)
//НАЗНАЧЕНИЕ: Установка  новых  размеров комплексной матрицы и их инициализация
//cлучайными значениями при init = true. По умолчанию матрица не инициализируется.
//При  невозможности создания матрицы новых размеров возвращается false, матрица
//становится нулевой размерности.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong rows - количество строк матрицы
//2. ulong cols - количество столбцов матрицы
//3. bool init - опция инициализации случайными значениями элементов матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак создания матрицы новых размеров
//******************************************************************************
bool TComplexMatrix::Set(ulong rows, ulong cols, bool init)
{//Анализ на соответствие размеров старой и новой матрицы
 if ((rows != Rows()) || (cols != Cols()))
 {Delete();//1. Удаление элементов матрицы со старыми размерами
  //2. Установка новых размеров и типа матрицы
  m = rows; n = cols; type = (m == n) ? SQUARE : RECTANG;
  //3. Распределение памяти под хранение элементов матрицы с новыми размерами
  if (Create() == false) return false;
 }
 if (init) InitMatrix();//Инициализация элементов матрицы случайными значениями
 return true;
}
//******************************************************************************
//СТАТУС: I.3, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(ulong size, uint sq_type, ulong diags = 3L)
//НАЗНАЧЕНИЕ: Установка  новых свойств квадратной комплексной матрицы и ее ини-
//циализация. При невозможности создания квадратной матрицы новых размеров функция
//возвращает false, матрица становится нулевой размерности.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong size - размерность квадратной матрицы
//2. uint sq_type - подтип квадратной матрицы
//3. ulong diags (3) - количество диагоналей для ленточной матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак создания матрицы новых размеров
//******************************************************************************
bool TComplexMatrix::Set(ulong size, uint sq_type, ulong diags)
{//Анализ на соответствие размеров старой и новой матрицы
 if ((size != Rows()) || (size != Cols()))
 {Delete();//1. Удаление элементов матрицы со старыми размерами
  //2. Установка новых размеров и типа матрицы
  m = n = size; type = SQUARE;
  //3. Распределение памяти под хранение элементов матрицы с новыми размерами
  if (Create() == false) return false;
 }
 switch (sq_type) //Инициализация элементов квадратной комплексной матрицы
 { case CM_HERMITIAN:
    InitHermitian(); break;
   case CM_DIAGONAL:
    InitDiagonal(); break;
   case CM_SCALAR:
    InitScalar(); break;
   case CM_UNIT:
    InitUnit(); break;
   case CM_BAND:
    InitBand(diags); break;
   case CM_UPPERTRIANG:
    InitUTriang(); break;
   case CM_LOWERTRIANG:
    InitLTriang(); break;
   case CM_SYMMETRICAL:
    InitSymmetric(); break;
   case CM_SKEWSYMMETRIC:
    InitSkewSymmetric(); break;
   case CM_ALTSIGN:
    InitAltSign(); break;
   case CM_ZERO:
    InitZeroMatrix(); break;
   default: //По умолчанию - квадратная матрица
    InitMatrix(); break;
 }
 return true;
}
//******************************************************************************
//СТАТУС: I.4, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(const PF_MATRIX& Info)
//НАЗНАЧЕНИЕ: Установка новых свойств комплексной матрицы по данным из структуры
//Info типа PF_MATRIX, передаваемой по ссылке. При невозможности создания матрицы
//с новыми свойствами функция возвращает false и матрица становится нулевой раз-
//мерности.
//При создании квадратной матрицы (Info.type == SQUARE), размерность матрицы
//определяется полем Info.rows.
//При создании ленточной матрицы (Info.type == SQUARE && Info.subtype == CM_BAND)
//размерность матрицы определяется полем Info.rows, количество диагоналей - полем
//Info.cols.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const PF_MATRIX& Info - ссылка на структуру со свойствами создаваемой матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак создания матрицы с новыми свойствами
//******************************************************************************
bool TComplexMatrix::Set(const PF_MATRIX& Info)
{if (Info.type == RECTANG) //Создание прямоугольной матрицы
  return Set(Info.rows,Info.cols,true);
 else //Создание квадратной матрицы
  return Set(Info.rows, Info.subtype, Info.cols);
}

//------------------------------------------------------------------------------
// ИНИЦИАЛИЗАЦИЯ ЭЛЕМЕНТОВ МАТРИЦЫ СЛУЧАЙНЫМИ ЗНАЧЕНИЯМИ
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Random(double a = 0.0, double b = 1.0)
//НАЗНАЧЕНИЕ: Инициализация элементов матрицы случайными величинами, распределен-
//ными по равновероятному закону в интервале [a..b]. Функция возвращает false для
//матрицы нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double a (0) - нижняя граница интервала изменения равномерной СВ
//2. double b (1) - верхняя граница интервала изменения равномерной СВ
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//******************************************************************************
bool TComplexMatrix::Random(double a, double b)
{//Матрица нулевого размера не инициализируется
 if (IsZeroSize()) return false;
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 //Инициализация элементов вектора СВ
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = complex(RNG.Random(a, b),RNG.Random(a, b));
 return true;
}
//******************************************************************************
//СТАТУС: I.2, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Rand2PI()
//НАЗНАЧЕНИЕ: Инициализация элементов матрицы случайными величинами, распределен-
//ными по равновероятному закону в интервале [0..2PI]. Функция возвращает false
//для матрицы нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//******************************************************************************
bool TComplexMatrix::Rand2PI()
{//Матрица нулевого размера не инициализируется
 if (IsZeroSize() == 0L) return false;
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 //Инициализация элементов матрицы СВ
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = complex(RNG.Rand2PI(),RNG.Rand2PI());
 return true;
}
//******************************************************************************
//СТАТУС: I.3, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Gauss(double E = 0.0, double D = 1.0)
//НАЗНАЧЕНИЕ: Инициализация  элементов  матрицы случайными величинами, распреде-
//ленными по нормальному закону с математическим ожиданием E и дисперсией D.
//Функция возвращает false для матрицы нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double E (0) - математическое ожидание гауссовой СВ
//2. double D (1) - дисперсия гауссовой СВ
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//******************************************************************************
bool TComplexMatrix::Gauss(double E, double D)
{//Матрица нулевого размера не инициализируется
 if (IsZeroSize() == 0L) return false;
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 //Инициализация элементов матрицы СВ
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = complex(RNG.Gauss(E,D),RNG.Gauss(E,D));
 return true;
}
//******************************************************************************
//СТАТУС: I.4, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Relay()
//НАЗНАЧЕНИЕ: Инициализация элементов матрицы случайными величинами, распределен-
//ными по закону Рэлея. Функция возвращает false для матрицы нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//******************************************************************************
bool TComplexMatrix::Relay()
{//Матрица нулевого размера не инициализируется
 if (IsZeroSize() == 0L) return false;
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 //Инициализация элементов матрицы СВ
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = complex(RNG.Relay(),RNG.Relay());
 return true;
}
//******************************************************************************
//СТАТУС: I.5, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Exp(double t = 1.0)
//НАЗНАЧЕНИЕ: Инициализация элементов матрицы случайными величинами, распределен-
//ными по экспоненциальному закону с параметром t. Функция возвращает false для
//матрицы нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: double t (1.0) - параметр экспоненциальной СВ
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//******************************************************************************
bool TComplexMatrix::Exp(double t)
{//Матрица нулевого размера не инициализируется
 if (IsZeroSize() == 0L) return false;
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 //Инициализация элементов матрицы СВ
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = complex(RNG.Exp(t),RNG.Exp(t));
 return true;
}

//----------------------------------------------------------------------------------------
// ОБЩЕДОСТУПНЫЕ ФУНКЦИИ РАБОТЫ С КОМПЛЕКСНОЙ МАТРИЦЕЙ TComplexMatrix
//----------------------------------------------------------------------------------------
//****************************************************************************************
//СТАТУС: I.1, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Edit(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: Редактирование всех элементов матрицы. В зависимости от подтипа комплексной
//матрицы подключается функция ввода элементов для данной матрицы. Предусмотрен режим ввода
//элементов матрицы с подтверждением ввода каждого элемента матрицы. Строка name задает
//наименование матрицы. Формат ввода следующий:
//MODE: INPUT ELEMENTS of <type> MATRIX
//<name>[<i>][<j>]: <complex value>.
//При вводе каждого элемента матрицы предусматривается контроль корректности вводимых данных,
//зависящих от подтипа матрицы и от представления комплексных чисел. При работе функции
//значения элементов матрицы изменяются безвозвратно.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. bool confirm - подтверждение ввода каждого элемента комплексной матрицы;
//2. const string& name - наименование матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TComplexMatrix::Edit(const string& name, bool confirm)
{const string line(78,'-');
 STR_UINT Option[3] = {
  {1, "Edit matrix properties" },
  {2, "Edit matrix elements" },
  {3, "Exit" } };
 TB_STR_UINT TbOption = {3, Option};
 string head;
 uint nChoice;
 do //Начало цикла редактирования
 {//----------------------------------------------------------------------------
  //Вывод заголовка и свойств редактируемой матрицы
  clrscr(); //Очистка экрана
  cout << line << endl;
  cout << "MODE: EDIT COMPLEX MATRIX - <" << name << ">" << endl;
  cout << "  " << Properties(head);
  cout << line << endl;
  //----------------------------------------------------------------------------
  head.assign(" Select option: ");
  nChoice = ConsoleChoice(TbOption, 3, head.c_str(), 2);
  //Анализируем выбор пользователя
  if (nChoice == 1) //Изменение характеристик редактируемой матрицы
  {PF_MATRIX Info;
   InPutPF_CMATRIX(Info, name.c_str());
   Set(Info);
   cout << "New complex matrix's properties have just installed!" << endl;
   cout << "Matrix is initialized according to its extended type." << endl;
   cout << "Press any key..."; getch();
  }
  else if (nChoice == 2) //Редактирование элементов матрицы
  {ulong diags;
   uint CM_Type = SubType(diags);
   clrscr(); //Очистка экрана
   switch (CM_Type)
   {case CM_ZEROSIZE: //Матрица нулевого размера
     cout << "\nMODE: INPUT ELEMENTS of ZeroSize Complex Matrix" << endl;
     cout << "WARNING! Input elements of this matrix are impossible." << endl;
     cout << "Press any key...\a"; getch();
     break;
    case CM_DIAGONAL: //Ввод элементов диагональной матрицы
     InPutDiagonal(name,confirm);
     break;
    case CM_SCALAR: //Ввод элементов скалярной матрицы
     InPutScalar(name,confirm);
     break;
    case CM_BAND: //Ввод элементов ленточной матрицы
     InPutBand(diags,name,confirm);
     break;
    case CM_UTRIANG: //Ввод элементов верхней треугольной матрицы
     InPutUTriang(name,confirm);
     break;
    case CM_LTRIANG: //Ввод элементов нижней треугольной матрицы
     InPutLTriang(name,confirm);
     break;
    case CM_SYMMETRICAL: //Ввод элементов симметрической матрицы
     InPutSymmetric(name,confirm);
     break;
    case CM_SKEWSYMMETR: //Ввод элементов кососимметрической матрицы
     InPutSkewSymmetric(name,confirm);
     break;
    case CM_ALTSIGN: //Ввод элементов знакопеременной матрицы
     InPutAltSign(name,confirm);
     break;
    case CM_HERMITIAN: //Ввод элементов эрмитовой матрицы
     InPutHermitianMatrix(name,confirm);
     break;
    default: //Стандартный ввод элементов комплексной матрицы
     InPutComplexMatrix(name,confirm);
   }
  }
  else if (nChoice == 3) //Выход из режима редактирования
  {//Запрос на выход из режима редактирования
   char c;
   cout << "Would you like to finish editing the complex matrix? [y/n]: "; cin >> c;
   if ((c == 'y') || (c == 'Y')) {clrscr(); break;}
  }
 } while (true); //Завершение цикла редактирования
}
//******************************************************************************
//СТАТУС: I.2; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector Row(ulong index) const
//НАЗНАЧЕНИЕ: Получение строки матрицы с заданным индексом от 0 до Rows()-1.
//Если индекс строки матрицы некорректен, то возвращается вектор-строка нулевого
//размера. Функция возвращает комплексный вектор со следующими параметрами:
//size = Cols(), type = ROW.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong index - индекс копируемой строки матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector Row - строка матрицы с номером index
//******************************************************************************
cvector TComplexMatrix::Row(ulong index) const
{cvector Row;
 if (IsZeroSize()) return Row;//Матрица нулевого размера
 if (index >= Rows()) return Row;//Индекс строки матрицы некорректен
 //Формируем вектор Row с элементами строки матрицы с номером index
 Row.Set(Cols(),ROW,false);
 //Копирование значений элементов строки матрицы в вектор Row
 for (ulong j = 0L; j < Cols(); j++) Row.Put(j,data[index][j]);
 return Row;
}
//******************************************************************************
//СТАТУС: I.3; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Row(cvector& V, ulong index) const
//НАЗНАЧЕНИЕ: Получение строки матрицы с заданным индексом от 0 до Rows()-1.
//Строка матрицы с индексом index формируется в векторе V, передаваемом по ссылке.
//Если индекс строки матрицы некорректен или матрица нулевого размера, то функция
//возвращает false и вектор V становится вектором нулевого размера.
//Вектор V будет иметь следующие свойства: size = Cols(); type = ROW.
//Корректные значения индекса строки: 0 <= index < Rows().
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong index - индекс копируемой строки матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::Row(cvector& V, ulong index) const
{V.Set(Cols(),ROW,false);
 if ((IsZeroSize()) || (index >= Rows())) return false;
 //Копирование значений элементов строки матрицы в вектор V
 for (ulong j = 0L; j < Cols(); j++) V.Put(j,data[index][j]);
 return true;
}
//******************************************************************************
//СТАТУС: I.4; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector Col(ulong index) const
//НАЗНАЧЕНИЕ: Получение столбца матрицы с заданным индексом от 0 до Cols()-1.
//Если индекс столбца матрицы некорректен, то возвращается вектор-столбец нуле-
//вого размера. Функция возвращает комплексный вектор со следующими параметрами:
//size = Rows(), type = COL.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong index - индекс копируемого столбца матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector Col - столбец матрицы с номером index
//******************************************************************************
cvector TComplexMatrix::Col(ulong index) const
{cvector Col(0L,COL,false);
 if (IsZeroSize()) return Col;//Матрица нулевого размера
 if (index >= Cols()) return Col;//Индекс столбца матрицы некорректен
 //Формируем вектор Col с элементами столбца матрицы с номером index
 Col.Set(Rows(),COL,false);
 //Копирование значений элементов столбца матрицы в вектор Col
 for (ulong i = 0L; i < Rows(); i++) Col.Put(i,data[i][index]);
 return Col;
}
//******************************************************************************
//СТАТУС: I.5; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Col(rvector& V, ulong index) const
//НАЗНАЧЕНИЕ: Получение столбца матрицы с заданным индексом от 0 до Cols()-1.
//Столбец матрицы с индексом index формируется в векторе V, передаваемом по ссылке.
//Если индекс столбца матрицы некорректен или матрица нулевого размера, то функция
//возвращает false и вектор V становится вектором нулевого размера.
//Вектор V будет иметь следующие свойства: size = Rows(); type = COL.
//Корректные значения индекса строки: 0 <= index < Cols().
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong index - индекс копируемого столбца матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::Col(cvector& V, ulong index) const
{V.Set(Rows(),COL,false);
 if ((IsZeroSize()) || (index >= Cols())) return false;
 //Копирование значений элементов столбца матрицы в вектор V
 for (ulong i = 0L; i < Rows(); i++) V.Put(i,data[i][index]);
 return true;
}
//******************************************************************************
//СТАТУС: I.6; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ExchangeRows(ulong i, ulong j)
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ДВУХ СТРОК МАТРИЦЫ с индексами от 0 до Rows()-1.
//Функция возвращает признак успешно или нет произошла перестановка двух строк и
//изменяет элементы исходной матрицы.
//Если индексы переставляемых строк матрицы некорректны, то возвращается false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong i - индекс первой переставляемой строки матрицы;
//2. ulong j - индекс второй переставляемой строки матрицы с первой строкой.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool Success - результат выполнения перестановки двух строк
//******************************************************************************
bool TComplexMatrix::ExchangeRows(ulong i, ulong j)
{if (IsZeroSize()) return false;//Матрица нулевого размера
 //Индексы переставляемых строк матрицы некорректны
 if ((i >= Rows()) || (j >= Rows())) return false;
 if (i == j) return true; //Перестановка не требуется
 //Операция перестановки двух строк матрицы
 complex x;
 for (ulong k = 0L; k < Cols(); k++)
 { x = data[i][k]; data[i][k] = data[j][k]; data[j][k] = x;}
 return true; //Перестановка двух строк выполнена успешно
}
//******************************************************************************
//СТАТУС: I.7; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ExchangeRows(const ivector& permutation)
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА СТРОК МАТРИЦЫ по вектору перестановок permutation.
//Функция возвращает признак успешно или нет произошла перестановка строк и изме-
//няет элементы исходной матрицы. Вектор перестановок может быть больше или мень-
//ше числа строк матрицы. i-ый элемент вектора хранит индекс строки матрицы с
//которой необходимо совершить перестановку. Перестановка двух строк выполняется
//функцией ExchangeRows(i, permutation[i]), где i - индекс первой переставляемой
//строки, permutation[i] - индекс строки матрицы переставляемой с первой строкой.
//Если индексы переставляемых строк матрицы некорректны, то возвращается false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const ivector& permutation - ссылка на вектор перестановок строк матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool Success - признак выполнения операции перестановки строк
//******************************************************************************
bool TComplexMatrix::ExchangeRows(const ivector& permutation)
{//Вектор перестановок нулевого размера
 if (permutation.IsZeroSize()) return false;
 if (IsZeroSize()) return false;//Матрица нулевого размера
 //Операция перестановки строк матрицы по вектору перестановок
 ulong Count = (Rows() < permutation.Size()) ? Rows() : permutation.Size();
 bool lSuccess = false;
 for (ulong k = 0L; k < Count; k++)
 {if (ExchangeRows(k, permutation[k])) lSuccess = true;}
 return lSuccess; //Признак выполнения операции перестановки строк
}
//******************************************************************************
//СТАТУС: I.8; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ExchangeCols(ulong i, ulong j)
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ДВУХ СТОЛБЦОВ МАТРИЦЫ с индексами от 0 до Cols()-1.
//Функция возвращает признак выполнения перестановка двух столбцов и изменяет
//элементы исходной матрицы.
//В случае невозможности перестановки двух строк возвращается false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong i - индекс первого переставляемого столбца матрицы;
//2. ulong j - индекс второго столбца матрицы, переставляемого с первым столбцом.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool Success - результат операции перестановки двух столбцов
//******************************************************************************
bool TComplexMatrix::ExchangeCols(ulong i, ulong j)
{if (IsZeroSize()) return false;//Матрица нулевого размера
 //Индексы переставляемых столбцов матрицы некорректны
 if ((i >= Cols()) || (j >= Cols())) return false;
 if (i == j) return true; //Перестановка не требуется
 //Операция перестановки двух столбцов матрицы
 complex x;
 for (ulong k = 0L; k < Rows(); k++)
 { x = data[k][i]; data[k][i] = data[k][j]; data[k][j] = x; }
 return true; //Перестановка двух столбцов выполнена
}
//******************************************************************************
//СТАТУС: I.9; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ExchangeCols(const ivector& permutation)
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА СТОЛБЦОВ МАТРИЦЫ по вектору перестановок permutation.
//Функция возвращает признак выполнения перестановки столбцов и изменяет элементы
//исходной матрицы. Вектор перестановок может быть больше или меньше числа столб-
//цов матрицы. i-ый  элемент вектора хранит индекс столбца матрицы с которым со-
//вершается перестановка.
//Перестановка выполняется функцией ExchangeCols(i, permutation[i]), где i - ин-
//декс  первой переставляемого  столбца, permutation[i] - индекс второго столбца
//матрицы переставляемой с первым столбцом.
//При невозможности перестановки столбцов матрицы возвращается false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const ivector& permutation - ссылка на вектор перестановок столбцов матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool Success - результат операции перестановки столбцов
//******************************************************************************
bool TComplexMatrix::ExchangeCols(const ivector& permutation)
{//Проверка вектора перестановок на вектор нулевого размера
 if (permutation.IsZeroSize()) return false;
 if (IsZeroSize()) return false;//Матрица нулевого размера
 //Операция перестановки столбцов матрицы по вектору перестановок
 ulong Count = (Cols() < permutation.Size()) ? Cols() : permutation.Size();
 bool lSuccess = false;
 for (ulong k = 0L; k < Count; k++)
 {if (ExchangeCols(k, permutation[k])) lSuccess = true;}
 return lSuccess; //Признак выполнения операции перестановки столбцов
}
//******************************************************************************
//СТАТУС: I.10, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix ReverseByCol(ulong left = 0L, ulong right = MAX_SIZE) const
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ЭЛЕМЕНТОВ МАТРИЦЫ В ЗАДАННОМ ИНТЕРВАЛЕ СТОЛБЦОВ
//            В ОБРАТНОМ ПОРЯДКЕ ПО СТОЛБЦАМ
//Функция изменяет порядок следования элементов матрицы по столбцам в интервале
//от индекса столбца со значением left до индекса столбца со значением right
//(включая его) на обратный.
//Значения верхней и нижней границ интервала столбцов, в которой должна осущест-
//вляться обратная перестановка должны удовлетворять следующим условиям:
// left <= right && right < Cols(), в противном случае функция не выполняется.
//По умолчанию, функция осуществляет перестановку всех элементов матрицы по всем
//столбцам.
//Работа функции не приводит к изменению внутренней структуры исходной матрицы,
//так как функция работает с ее копией. Результатом работы функции является мат-
//рица, совпадающая по размерам с исходной, но с переставленными в обратном по-
//рядке элементами по столбцам. 
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left (0) - нижний индекс столбца, с которого будет происходить
//   перестановка элементов матрицы в обратном порядке;
//2. ulong right (MAX_SIZE ~ Size()-1) - верхний индекс столбца матрицы, до ко-
//   торого будет происходить перестановка элементов вектора в обратном порядке,
//   включая значение индекса right.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// cmatrix result - матрица с переставленными в обратном порядке по столбцам
// относительно исходной матрицы элементами.
//******************************************************************************
cmatrix TComplexMatrix::ReverseByCol(ulong left, ulong right) const
{cmatrix result;//Создание результирующей матрицы
 right = (right == MAX_SIZE) ? Cols()-1 : right;
 //Проверка на возможность или необходимость осуществления перестановки
 if ((Cols() < 2) || (left >= right) || (right >= Cols())) return result;
 //Выполнение перестановки элементов матрицы по столбцам в обратном порядке
 result = *this;//Копирование исходной матрицы
 ulong r = right;
 ulong l = left;
 complex temp;
 for (ulong i = 0; i < result.Rows(); i++)
 {while (l < r)
  {temp = result.Get(i,l); result.Put(i,l,result.Get(i,r)); result.Put(i,r,temp);
   l++; r--; //Переход к другим индексам переставляемых элементов
  }
  r = right; l = left;
 }
 return result;//Матрица с переставленными в обратном порядке элементами
}
//******************************************************************************
//СТАТУС: I.11, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix ReverseByRow(ulong left = 0L, ulong right = MAX_SIZE) const
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ЭЛЕМЕНТОВ МАТРИЦЫ В ЗАДАННОМ ИНТЕРВАЛЕ СТРОК
//            В ОБРАТНОМ ПОРЯДКЕ ПО СТРОКАМ
//Функция изменяет порядок следования элементов матрицы по строкам в интервале
//от индекса строки со значением left до индекса строки со значением right
//(включая его) на обратный.
//Значения верхней и нижней границ интервала строк, в которой должна выполняться
//обратная перестановка должны удовлетворять следующим условиям:
// left <= right && right < Cols(), в противном случае функция не выполняется.
//По умолчанию, функция осуществляет перестановку всех элементов матрицы по всем
//строкам.
//Работа функции не приводит к изменению внутренней структуры исходной матрицы,
//так как функция работает с ее копией. Результатом работы функции является мат-
//рица, совпадающая по размерам с исходной, но с переставленными в обратном по-
//рядке элементами по строкам.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left (0) - нижний индекс строки, с которого будет происходить
//   перестановка элементов матрицы в обратном порядке;
//2. ulong right (MAX_SIZE ~ Size()-1) - верхний индекс строки матрицы, до кото-
//   рого будет происходить перестановка элементов вектора в обратном порядке,
//   включая значение индекса right.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// cmatrix result - матрица с переставленными в обратном порядке по строкам
// относительно исходной матрицы элементами.
//******************************************************************************
cmatrix TComplexMatrix::ReverseByRow(ulong left, ulong right) const
{cmatrix result;//Создание результирующей матрицы
 right = (right == MAX_SIZE) ? Rows()-1 : right;
 //Проверка на возможность или необходимость осуществления перестановки
 if ((Rows() < 2) || (left >= right) || (right >= Rows())) return result;
 //Выполнение перестановки элементов матрицы по строкам в обратном порядке
 result = *this;//Копирование исходной матрицы
 ulong r = right;
 ulong l = left;
 complex temp;
 for (ulong i = 0; i < result.Cols(); i++)
 {while (l < r)
  {temp = result.Get(l,i); result.Put(l,i,result.Get(r,i)); result.Put(r,i,temp);
   l++; r--; //Переход к другим индексам переставляемых элементов
  }
  r = right; l = left;
 }
 return result;//Матрица с переставленными в обратном порядке элементами
}
//******************************************************************************
//СТАТУС: I.12, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ReverseCols()
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ВСЕХ СТОЛБЦОВ МАТРИЦЫ В ОБРАТНОМ ПОРЯДКЕ
//Функция изменяет внутренную структуры исходной матрицы. Если матрица является
//матрицей нулевого размера, то функция возвращает false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения функции
//******************************************************************************
bool TComplexMatrix::ReverseCols()
{if (IsZeroSize()) return false;
 ulong r = Cols()-1;
 ulong l = 0L;
 complex temp;
 for (ulong i = 0; i < Rows(); i++)
 {while (l < r)
  {temp = data[i][l]; data[i][l] = data[i][r]; data[i][r] = temp;
   l++; r--; //Переход к другим индексам переставляемых элементов
  }
  r = Cols()-1; l = 0L;
 }
 return true;//Обратная перестановка элементов матрицы по столбцам завершена
}
//******************************************************************************
//СТАТУС: I.13, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ReverseRows()
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ВСЕХ СТРОК МАТРИЦЫ В ОБРАТНОМ ПОРЯДКЕ
//Функция изменяет внутренную структуры исходной матрицы. Если матрица является
//матрицей нулевого размера, то функция возвращает false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения функции
//******************************************************************************
bool TComplexMatrix::ReverseRows()
{if (IsZeroSize()) return false;
 ulong up = 0L;
 ulong down = Rows()-1;
 complex temp;
 for (ulong j = 0L; j < Cols(); j++)
 {while (up < down)
  {temp = data[up][j]; data[up][j] = data[down][j]; data[down][j] = temp;
   up++; down--; //Переход к другим индексам переставляемых элементов
  }
  up = 0L; down = Rows()-1;
 }
 return true;//Обратная перестановка элементов матрицы по строкам завершена
}

//------------------------------------------------------------------------------
//Реализация общедоступных функций формирования подматриц исходной матрицы
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix U_SubMatrix(ulong k, ulong g) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ КВАДРАТНОЙ ПОДМАТРИЦЫ
//Функция формирует квадратную подматрицу из исходной матрицы следующего вида:
//SubMatrix(0 1 ... k-1 k, 0 1 ... k-1 g), где
// 0 1 ... k-1 k - строки исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы;
// 0 1 ... k-1 g - столбцы исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы, g > k.
//Подматрица формируется из элементов, стоящих на пересечении строк и столбцов,
//которые принадлежат вышеуказанному множеству столбцов и строк, исходной матри-
//цы. Функция возвращает сформированную подматрицу.
//Верхние границы строк k и столбцов g исходной матрицы, которые участвуют в фор-
//мировании элементов подматрицы входят в данное допустимое множество. Нумерация
//строк и столбцов начинается с 0.
//Если индексы столбцов и строк из которых будет формироваться подматрица будут
//некорректны, то функция возвращает комплексную матрицу нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong k - верхняя граница строк матрицы, формирующих подматрицу;
//2. ulong g - верхняя граница столбцов матрицы, формирующих подматрицу.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix SubMatrix - квадратная подматрица
//******************************************************************************
cmatrix TComplexMatrix::U_SubMatrix(ulong k, ulong g) const
{cmatrix SubMatrix;
 if (IsZeroSize()) return SubMatrix;//Матрица нулевого размера
 //Проверка на допустимые индексы k & g, 0 <= k < Rows(), k < g < Cols()
 if ((k >= Rows()) || (g <= k) || (g >= Cols())) return SubMatrix;
 //-----------------------------------------------------------------------------
 //Формирование квадратной подматрицы
 //-----------------------------------------------------------------------------
 SubMatrix.Set(k+1,false);
 //Цикл формирования элементов подматрицы: Rows: 0 1 ... k-1 k; Cols: 0 1 ... k-1 g
 for (ulong i = 0L; i < Rows(); i++)
 {if (i > k) break; //Выход из цикла - подматрица сформирована
  for (ulong j = 0L; j < Cols(); j++)
  {if (j < k) SubMatrix.Put(i,j,data[i][j]);
   //Формирование последнего столбца подматрицы
   else {SubMatrix.Put(i,k,data[i][g]); break; }
  }
 }
 return SubMatrix; //Квадратная подматрица
}
//******************************************************************************
//СТАТУС: I.2; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix L_SubMatrix(ulong g, ulong k) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ КВАДРАТНОЙ ПОДМАТРИЦЫ
//Функция формирует квадратную подматрицу из исходной матрицы следующего вида:
//SubMatrix(0 1 ... k-1 g, 0 1 ... k-1 k), где
// 0 1 ... k-1 g - строки исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы;
// 0 1 ... k-1 k - столбцы исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы, g > k.
//Подматрица формируется из элементов, стоящих на пересечении строк и столбцов,
//которые принадлежат вышеуказанному множеству столбцов и строк, исходной матри-
//цы. Функция возвращает сформированную подматрицу.
//Верхние границы строк g и столбцов k исходной матрицы, которые участвуют в фор-
//мировании элементов подматрицы входят в данное допустимое множество. Нумерация
//строк и столбцов начинается с 0.
//Если индексы столбцов и строк из которых будет формироваться подматрица будут
//некорректны, то функция возвращает комплексную матрицу нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong g - верхняя граница строк матрицы, формирующих подматрицу
//2. ulong k - верхняя граница столбцов матрицы, формирующих подматрицу
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: сmatrix SubMatrix - квадратная подматрица
//******************************************************************************
cmatrix TComplexMatrix::L_SubMatrix(ulong g, ulong k) const
{cmatrix SubMatrix;
 if (IsZeroSize()) return SubMatrix;//Матрица нулевого размера
 //Проверка на допустимые индексы k & g, 0 < g < Rows(), 0 <= k < g, k < Cols()
 if ((k >= Cols()) || (g <= k) || (g >= Rows())) return SubMatrix;
 //-----------------------------------------------------------------------------
 //Формирование подматрицы
 //-----------------------------------------------------------------------------
 SubMatrix.Set(k+1,false);
 //Цикл формирования элементов подматрицы: Rows: 0 1 ... k-1 g; Cols: 0 1 ... k-1 k
 for (ulong i = 0L; i < Rows(); i++)
 {if (i == k) i = g; //Формирование последней строки матрицы
  for (ulong j = 0L; j <= k ; j++)
  {if (i != g) SubMatrix.Put(i,j,data[i][j]);
   else SubMatrix.Put(k,j,data[i][j]);
  }
  if (i == g) break; //Выход из цикла - подматрица сформирована
 }
 return SubMatrix; //Квадратная подматрица
}
//******************************************************************************
//СТАТУС: I.3; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix P_SubMatrix(ulong k) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ КВАДРАТНОЙ ПОДМАТРИЦЫ
//Функция формирует квадратную подматрицу из исходной матрицы следующего вида:
//SubMatrix(0 1 ... k-1 k, 0 1 ... k-1 k), где
// 0 1 ... k-1 k - строки исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы;
// 0 1 ... k-1 k - столбцы исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы.
//Подматрица формируется из элементов, стоящих на пересечении первых k строк и
//первых k столбцов - ГЛАВНЫЕ ПОДМАТРИЦЫ. Функция возвращает сформированную
//подматрицу.
//Верхние границы строк k и столбцов k исходной матрицы, которые участвуют в фор-
//мировании элементов подматрицы входят в данное допустимое множество. Нумерация
//строк и столбцов начинается с 0.
//Если индексы столбцов и строк из которых будет формироваться подматрица будут
//некорректны, то функция возвращает комплексную матрицу нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//ulong k - верхняя граница строк и столбцов матрицы, формирующая подматрицу
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix SubMatrix - главная подматрица k-го порядка
//******************************************************************************
cmatrix TComplexMatrix::P_SubMatrix(ulong k) const
{cmatrix SubMatrix;
 if (IsZeroSize()) return SubMatrix;//Матрица нулевого размера
 //Проверка на допустимость индекса k, 0 <= k < Rows(), 0 <= k < Cols()
 if ((k >= Cols()) || (k >= Rows())) return SubMatrix;
 //-----------------------------------------------------------------------------
 //Формирование главной подматрицы
 //-----------------------------------------------------------------------------
 SubMatrix.Set(k+1,false);
 //Цикл формирования элементов подматрицы: Rows: 0 1 ... k-1 k; Cols: 0 1 ... k-1 k
 for (ulong i = 0L; i <= k; i++)
  for (ulong j = 0L; j <= k ; j++)
    SubMatrix.Put(i,j,data[i][j]);
 return SubMatrix; //Квадратная подматрица
}
//******************************************************************************
//СТАТУС: I.4; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix SubMatrixByCols(const ivector& IndexCols, bool Check = false) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДМАТРИЦЫ ПО ИНДЕКСАМ СТОЛБЦОВ ИСХОДНОЙ МАТРИЦЫ, пе-
//редавемым через вектор IndexCols. Количество строк подматрицы определяется ко-
//личеством строк исходной матрицы. При Check == true проверяется принадлежность
//индексов в IndexCols допустимым значениям индексов столбцов исходной матрицы.
//При проверке формируется объект-предикат типа TBelongClosedInterval<long,ivector>,
//который проверяет каждое значение индекса столбца на допустимость и на основе
//его работы формируется подвектор IndexCols с корректными значениями индексов
//столбцов. При Check == false проверка не проводится, что ускоряет работу функ-
//ции, ответственность за корректные значения индексов столбцов возлагается на
//пользователя.
//Функция возвращает подматрицу нулевого размера в следующих случаях:
//1. Исходная матрица является матрицей нулевого размера;
//2. Вектор индексов столбцов является вектором нулевого размера;
//3. При Check == true, подвектор вектора IndexCols оказался вектором нулевого
//   размера - все индексы столбцов находятся вне границ размерности матрицы по
//   столбцам.
//Возможно аварийное завершение работы программы при Check == false, если индекс
//столбца в векторе IndexCols является некорректным.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& IndexCols - ссылка на вектор с индексами столбцов матрицы;
//2. bool Check (false) - опция проверки значений индексов столбцов на корректность
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//cmatrix SubMatrix - подматрица, формируемая из столбцов исходной матрицы по
//                    индексам из вектора IndexCols.
//******************************************************************************
cmatrix TComplexMatrix::SubMatrixByCols(const ivector& IndexCols, bool Check) const
{cmatrix SubMatrix;
 //Матрица или вектора IndexCols нулевого размера
 if ((IsZeroSize()) || (IndexCols.IsZeroSize())) return SubMatrix;
 //Формирование вектора корректных индексов столбцов для исходной матрицы
 ivector Index = IndexCols;
 if (Check)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Cols()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  if (Index.IsZeroSize()) return SubMatrix;
 }
 //Формирование подматрицы с индексами столбцов исходной матрицы, размещенных
 //в векторе Index, и количеством строк равным их числу исходной матрицы
 SubMatrix.Set(Rows(),Index.Size(),false);
 //Цикл формирования значений элементов подматрицы SubMatrix
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Index.Size(); j++)
   SubMatrix.Put(i,j,data[i][Index.Get(j)]);
 return SubMatrix; //Подматрица, составленная из столбцов исходной матрицы
}
//******************************************************************************
//СТАТУС: I.5; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix SubMatrixByRows(const ivector& IndexRows, bool Check = false) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ  ПОДМАТРИЦЫ ПО ИНДЕКСАМ СТРОК ИСХОДНОЙ МАТРИЦЫ, пере-
//давемым  через  вектор  IndexRows. Количество столбцов подматрицы определяется
//количеством столбцов исходной матрицы. При Check == true проверяется принадлеж-
//ность индексов в IndexCols допустимым значениям индексов строк исходной матрицы.
//При проверке формируется объект-предикат TBelongClosedInterval<long,ivector>,
//который проверяет каждое значение индекса строки на допустимость и на основе его
//работы формируется подвектор вектора IndexRows с корректными значениями индексов
//строк. При Check == false проверка не проводится, что ускоряет работу функции,
//но  ответственность за корректные значения индексов строк возлагается на поль-
//зователя.
//Функция возвращает подматрицу нулевого размера в следующих случаях:
//1. Исходная матрица является матрицей нулевого размера;
//2. Вектор индексов строк является вектором нулевого размера;
//3. При Check == true, подвектор вектора IndexRows оказался вектором нулевого
//   размера - все индексы строк находятся вне границ размерности матрицы по
//   строкам.
//Возможно аварийное завершение работы программы при Check == false, если индекс
//строки в векторе IndexRows является некорректным.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& IndexRows - ссылка на вектор с индексами строк матрицы;
//2. bool Check (false) - опция проверки значений индексов строк в IndexRows.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// cmatrix SubMatrix - подматрица, формируемая из строк исходной матрицы по
//                     индексам, размещенным в векторе IndexRows.
//******************************************************************************
cmatrix TComplexMatrix::SubMatrixByRows(const ivector& IndexRows, bool Check) const
{cmatrix SubMatrix;
 //Матрица или вектор с индексами строк нулевого размера
 if (IsZeroSize() || IndexRows.IsZeroSize()) return SubMatrix;
 //Формирование вектора корректных индексов строк для исходной матрицы
 ivector Index = IndexRows;
 if (Check)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Rows()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  if (Index.IsZeroSize()) return SubMatrix;
 }
 //Формирование подматрицы с индексами строк исходной матрицы, размещенных
 //в векторе Index, и количеством столбцов равным числу столбцов исходной матрицы
 SubMatrix.Set(Index.Size(),Cols(),false);
 //Цикл формирования значений элементов подматрицы SubMatrix
 for (ulong i = 0L; i < Index.Size(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   SubMatrix.Put(i,j,data[Index.Get(i)][j]);
 return SubMatrix; //Подматрица, составленная из строк исходной матрицы
}
//******************************************************************************
//СТАТУС: I.6; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix SubMatrix(const ivector& IndexRows, const ivector& IndexRows,
//                   bool Check = false) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДМАТРИЦЫ ПО ИНДЕКСАМ СТРОК И СТОЛБЦОВ ИСХОДНОЙ
//МАТРИЦЫ по индексам строк и столбцов, передавемым через векторы IndexRows и
//IndexCols. Размерность подматрицы определяется по строкам - размерностью вектора
//IndexRows, по столбцам - размерностью вектора IndexCols. При Check == true идет
//проверка на принадлежность индексов в IndexRows и IndexCols допустимым значениям
//индексов строк и столбцов матрицы. При проверке формируются объекты-предикаты
//TBelongClosedInterval, проверяющие значения индексов строк и столбцов на допус-
//тимость. По их работе формируются подвекторы векторов IndexRows и IndexCols с
//корректными значениями индексов строк и столбцов. При Check == false проверка
//не проводится, что ускоряет работу функции, но ответственность за корректные
//значения индексов строк и столбцов возлагается на пользователя. Фильтрация не-
//корректных значений индексов столбцов и строк может привести к уменьшению раз-
//меров исходных векторов IndexRows и IndexCols либо привести их к вектору нуле-
//вого размера, при отсутствии в них корректных значений индексов.
//Функция возвращает подматрицу нулевого размера в следующих случаях:
//1. Исходная матрица является матрицей нулевого размера;
//2. Вектор индексов строк или столбцов является вектором нулевого размера;
//3. При Check == true, подвектор вектора IndexRows или IndexCols оказались век-
//   торами нулевого размера - все индексы строк или столбцов находятся вне гра-
//   ниц размерности матрицы по строкам или по столбцам.
//Возможно аварийное завершение работы программы при Check == false, если индекс
//строки или столбца в векторе IndexRows или IndexCols является некорректным.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const ivector& IndexRows - ссылка на вектор с индексами строк матрицы;
//2. const ivector& IndexCols - ссылка на вектор с индексами столбцов матрицы;
//3. bool Check (false) - опция проверки значений индексов строк и столбцов
//   в векторах IndexRows и IndexCols на корректность
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// cmatrix SubMatrix - подматрица, формируемая из строк и столбцов исходной мат-
// рицы, индексы которых размещены в векторах IndexRows и IndexCols.
//******************************************************************************
cmatrix TComplexMatrix::SubMatrix(const ivector& IndexRows, const ivector& IndexCols,
        bool Check) const
{cmatrix SubMatrix;
 //Матрица или векторы с индексами строк и столбцов нулевого размера
 if (IsZeroSize() || IndexRows.IsZeroSize() || IndexCols.IsZeroSize())
  return SubMatrix;
 //Формирование вектора корректных индексов строк для исходной матрицы
 ivector Row = IndexRows;
 if (Check)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Rows()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Row = Row.SubVector(Predicate);
  if (Row.IsZeroSize()) return SubMatrix;
 }
 //Формирование вектора корректных индексов столбцов для исходной матрицы
 ivector Col = IndexCols;
 if (Check)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Cols()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Col = Col.SubVector(Predicate);
  if (Col.IsZeroSize()) return SubMatrix;
 }
 //Формирование подматрицы с индексами строк и столбцов исходной матрицы, разме-
 //щенных в векторах Row и Col
 SubMatrix.Set(Row.Size(),Col.Size(),false);
 //Цикл формирования значений элементов подматрицы SubMatrix
 for (ulong i = 0L; i < Row.Size(); i++)
  for (ulong j = 0L; j < Col.Size(); j++)
   SubMatrix.Put(i,j,data[Row.Get(i)][Col.Get(j)]);
 return SubMatrix; //Подматрица, составленная из строк и столбцов исходной матрицы
}

//------------------------------------------------------------------------------
// РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ФУНКЦИЙ ПРИСВАИВАНИЯ ЭЛЕМЕНТАМ МАТРИЦЫ ЗНАЧЕНИЙ
// ДРУГОЙ МАТРИЦЫ или ВЕКТОРОВ
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix AssignRow(const cvector& V, ulong row, ulong pos) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТРОКЕ МАТРИЦЫ КОМПЛЕКСНОГО ВЕКТОРА
//Присваивание строке матрицы с индексом row, начиная со столбца с индексом pos,
//элементов вектора V, передавемого по ссылке. Вектор V может иметь любую размер-
//ность. Функция присваивает значения элементов вектора V копии исходной матрицы,
//начиная с первого элемента вектора V, вплоть до последнего элемента вектора V
//или последнего столбца матрицы, в зависимости от соотношения начального индекса
//столбца pos матрицы, с которого начинается присваивание, размеров матрицы и
//вектора V.
//Значения элементов исходной матрицы и его структура не изменяются в результате
//работы функции, так как все операции осуществляются с копией исходной матрицы,
//которая и является результатом работы функции.
//Возвращается матрица нулевого размера в следующих ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Номер строки row превышает количество строк для данной матрицы;
//4. Начальный  индекс столбца pos в исходной матрице, начиная с которого выпол-
//   няется присваивание, превышает количество столбцов исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка  на вектор-источник, значения  элементов которого
//   будут присваиваться строке исходной матрицы;
//2. ulong row - номер строки матрицы, которой будут присваиваться элементы
//   вектора V;
//3. ulong pos - начальный индекс столбца матрицы, с которого начнется  присваи-
//   вание значений элементов вектора V строке c номером row матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::AssignRow(const cvector& V, ulong row, ulong pos) const
{cmatrix result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (row >= Rows()) || (pos >= Cols()))
  return result;
 result = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора строке матрицы
 ulong col;
 for (ulong i = 0L; i < V.Size(); i++)
 {col = i+pos;
  if (col < result.Cols()) result.Put(row,col,V.Get(i));
  else break; //Выход из цикла
 }
 return result;
}
//******************************************************************************
//СТАТУС: I.2, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix AssignRow(const cvector& V, ulong left, ulong right, ulong pos) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТРОКАМ МАТРИЦЫ ЭЛЕМЕНТОВ КОМПЛЕКСНОГО ВЕКТОРА,
//            ИНДЕКСЫ КОТОРЫХ ПРИНАДЛЕЖАТ ИНТЕРВАЛУ [left..right]
//Присваивание строкам матрицы, принадлежащими интервалу [left..right], начиная
//со столбца с индексом pos, элементов вектора V, передавемого по ссылке. Вектор
//V может иметь любую размерность. Функция присваивает значения элементов вектора
//V  копии  исходной матрицы, начиная с первого элемента вектора V до последнего
//элемента вектора V или последнего  столбца  матрицы, в зависимости от соотношения
//начального индекса столбца pos матрицы, с которого начинается присваивание,
//размеров матрицы и вектора V.
//Исходная матрицы не изменяется функцией, так как все операции присваивания осу-
//ществляются с копией исходной матрицы, являющейся результатом работы функции.
//Возвращается матрицу нулевого размера в следующих ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Граничные индексы left или right строк превышают количество строк исходной
//   матрицы или left > right;
//4. Начальный  индекс столбца pos в исходной матрице, начиная с которого выпол-
//   няется присваивание, превышает количество столбцов исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка  на вектор, присваиваемый строкам матрицы;
//2. ulong left - нижняя граница интервала индексов строк матрицы;
//3. ulong right - верхняя граница интервала индексов строк матрицы;
//4. ulong pos - начальный индекс столбца матрицы, с которого начинается присваи-
//   вание значений элементов вектора V строкам матрицы.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::AssignRow(const cvector& V, ulong left, ulong right, ulong pos) const
{cmatrix result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (pos >= Cols())) return result;
 right = (right == MAX_SIZE) ? Rows()-1 : right;
 if ((right >= Rows()) || (left > right)) return result;
 result = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора строкам матрицы
 ulong col;
 for (ulong row = left; row <= right; row++)
 {for (ulong i = 0L; i < V.Size(); i++)
  {col = i+pos;
   if (col < result.Cols()) result.Put(row,col,V.Get(i));
   else break; //Выход из цикла по столбцам матрицы
  }
 }
 return result;
}
//******************************************************************************
//СТАТУС: I.3, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//cmatrix AssignRow(const cvector& V, const ivector& rows, ulong pos = 0L) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТРОКАМ МАТРИЦЫ ЭЛЕМЕНТОВ КОМПЛЕКСНОГО ВЕКТОРА,
//            ИНДЕКСЫ КОТОРЫХ ПЕРЕДАЮТСЯ ВЕКТОРОМ rows
//Присваивание строкам матрицы с индексами, расположенными в векторе rows, начиная
//со столбца с индексом pos, элементов вектора V, передавемого по ссылке. По умол-
//чанию индекс столбца pos, с которого начинается присваивание,  равен 0. Вектор
//V может иметь любую размерность. Значения вектора V присваиваются копии матрицы,
//начиная с первого элемента вектора V до последнего элемента вектора V или пос-
//леднего столбца матрицы, в зависимости от соотношения начального индекса столбца
//pos матрицы, с которого начинается присваивание, размеров матрицы и вектора V.
//Вектор rows, передаваемый по ссылке, содержит индексы строк, которым будут прис-
//ваиваться значения элементов вектора V. Перед выполнением присваивания индексы
//строк, хранимых в векторе rows, проходят фильтрацию. Из элементов вектора rows
//формируется его подвектор Index, который не содержит повторяющихся индексов строк
//и индексов, значения которых превышают количество строк исходной матрицы.
//Исходная матрица не изменяется функцией, так  как  вся  работа происходит с ко-
//пией исходной матрицы, являющейся результатом работы функции.
//Возвращается матрица нулевого размера в следующих ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Вектор-индексов строк rows - вектор нулевого размера;
//4. Подвектор Index - нулевого размера - корректные значения индексов строк для
//   данной исходной матрицы в векторе-индексов строк rows не найдены;
//5. Начальный  индекс столбца pos в исходной матрице, начиная с которого выпол-
//   няется присваивание, превышает количество столбцов исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на вектор, присваиваемый строкам матрицы;
//2. const ivector& rows - ссылка на вектор с индексами строк;
//3. ulong pos - начальный индекс столбца матрицы, с которого начнется  присваи-
//   вание значений элементов вектора V строкам матрицы.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::AssignRow(const cvector& V, const ivector& rows, ulong pos) const
{cmatrix result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (rows.IsZeroSize()) || (pos >= Cols()))
  return result;
 //Формирование вектора корректных индексов строк для исходной матрицы
 ivector Index = rows;
 ivector interval(2,0L);
 interval[0] = 0; interval[1] = Rows()-1;
 TBelongClosedInterval<long, ivector> Predicate =
 TBelongClosedInterval<long,ivector>(interval);
 Index = Index.SubVector(Predicate);
 Index = Index.Unique();//Фильтрация повторяющихся индексов строк
 if (Index.IsZeroSize()) return result;//Корректные индексы строк не найдены

 result = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора строкам матрицы
 ulong col;
 for (ulong i = 0L; i < Index.Size(); i++)
 {for (ulong j = 0L; j < V.Size(); j++)
  {col = j+pos;
   if (col < result.Cols()) result.Put(Index.Get(i),col,V.Get(j));
   else break; //Выход из цикла по столбцам матрицы
  }
 }
 return result;
}
//******************************************************************************
//СТАТУС: I.4, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix AssignCol(const cvector& V, ulong col, ulong pos = 0L) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТОЛБЦУ МАТРИЦЫ КОМПЛЕКСНОГО ВЕКТОРА
//Присваивание столбцу матрицы с индексом col, начиная со строки с индексом pos,
//элементов вектора V, передавемого по ссылке. По умолчанию индекс первой строки,
//с которой начинается присваивание, равен 0. Вектор V может иметь любую размер-
//ность. Элементы вектора V присваиваются копии исходной матрицы, начиная с пер-
//вого элемента вектора V до последнего элемента или последней строки матрицы,
//в зависимости от соотношения начального индекса строки pos матрицы, с которой
//начинается присваивание, размеров матрицы и вектора V.
//Исходная матрица не изменяется функцией, так как функция работает с ее копией,
//являющейся результатом ее работы.
//Возвращается матрица нулевого размера в следующих ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Номер столбца col превышает количество столбцов для данной матрицы;
//4. Начальный  индекс строки pos в исходной матрице, начиная с  которого выпол-
//   няется присваивание, превышает количество строк исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на вектор, присваиваемый столбцу матрицы;
//2. ulong col - столбец матрицы, которому присваиваються элементы вектора;
//3. ulong pos - начальный индекс строки, с которого начинается присваивание.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::AssignCol(const cvector& V, ulong col, ulong pos) const
{cmatrix result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (col >= Cols()) || (pos >= Rows()))
  return result;
 result = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора столбцу матрицы
 ulong row;
 for (ulong i = 0L; i < V.Size(); i++)
 {row = i+pos;
  if (row < result.Rows()) result.Put(row,col,V.Get(i));
  else break; //Выход из цикла
 }
 return result;
}
//******************************************************************************
//СТАТУС: I.5, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix AssignCol(const cvector& V, ulong left = 0L, ulong right = MAX_SIZE,
//                   ulong pos = 0L) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТОЛБЦАМ МАТРИЦЫ ЭЛЕМЕНТОВ КОМПЛЕКСНОГО ВЕКТОРА,
//            ИНДЕКСЫ КОТОРЫХ ПРИНАДЛЕЖАТ ИНТЕРВАЛУ [left..right]
//Присваивание столбцам матрицы с индексами в интервале [left..right], начиная со
//строки с индексом pos, элементов вектора V, передавемого по ссылке. По умолчанию
//индекс строки pos = 0. По умолчанию, вектор V присваивается всем столбцам матрицы.
//Вектор V может иметь любую размерность. Значения элементов V присваиваются ко-
//пии исходной матрицы, начиная с первого элемента вектора V и до последнего или
//последней строки матрицы, в зависимости от соотношения начального индекса строки
//pos матрицы, с которой начинается присваивание, размеров матрицы и вектора V.
//Исходная матрица не изменяется функцией, так как функция работает с копией ис-
//ходной матрицы, являющейся результатом ее работы.
//Возвращается матрица нулевого размера в следующих ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Граничные индексы left или right столбцов превышают количество столбцов ис-
//   ходной матрицы или left > right;
//4. Начальный  индекс  строки  pos в исходной матрице, начиная с которой выпол-
//   няется присваивание, превышает количество строк исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на вектор, присваиваемый строкам матрицы;
//2. ulong left -  нижняя  граница  интервала индексов столбцов матрицы;
//3. ulong right - верхняя граница интервала индексов столбцов матрицы;
//4. ulong pos - начальный индекс строки, с которого начинается присваивание.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующий матрица
//******************************************************************************
cmatrix TComplexMatrix::AssignCol(const cvector& V, ulong left, ulong right,
                                  ulong pos) const
{cmatrix result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (pos >= Rows())) return result;
 right = (right == MAX_SIZE) ? Cols()-1 : right;
 if ((right >= Cols()) || (left > right)) return result;
 result = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора столбцам матрицы
 ulong row;
 for (ulong col = left; col <= right; col++)
 {for (ulong i = 0L; i < V.Size(); i++)
  {row = i+pos;
   if (row < result.Rows()) result.Put(row,col,V.Get(i));
   else break; //Выход из цикла по строкам матрицы
  }
 }
 return result;
}
//******************************************************************************
//СТАТУС: I.6, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//cmatrix AssignCol(const cvector& V, const ivector& cols, ulong pos = 0L) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТОЛБЦАМ МАТРИЦЫ ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА,
//            ИНДЕКСЫ КОТОРЫХ ПЕРЕДАЮТСЯ ВЕКТОРОМ cols
//Присваивание столбцам матрицы с индексами из вектора cols, начиная со строки с
//индексом pos, элементов вектора V, передавемого по ссылке. По умолчанию индекс
//строки pos = 0. Вектор V может иметь любую размерность. Функция присваивает
//значения элементов вектора V копии исходной матрицы, начиная с первого элемен-
//та вектора V и до последнего или последней строки матрицы, в зависимости от
//соотношения начального индекса строки pos матрицы, с которого начинается прис-
//ваивание, размеров матрицы и вектора V.
//Вектор cols содержит индексы столбцов, которым присваиваются значения элементов
//вектора V. Перед присваиванием индексы столбцов проходят фильтрацию. Из вектора
//cols формируется подвектор Index, который не содержит повторяющихся индексов
//столбцов и некорректных индексов столбцов матрицы.
//Исходная матрица не изменяется функцией, так как вся работа идет с копией мат-
//рицы, являющейся результатом работы функции.
//Возвращается матрицу нулевого размера в следующих ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Вектор-индексов столбцов cols - вектор нулевого размера;
//4. Подвектор Index - нулевого размера - корректные значения  индексов столбцов
//   для данной исходной матрицы в векторе-индексов столбцов cols не найдены;
//5. Начальный  индекс строки pos в исходной матрице, начиная с которого выпол-
//   няется присваивание, превышает количество строк исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на вектор, присваиваемый столбцам матрицы;
//2. const ivector& cols - ссылка на вектор с индексами столбцов матрицы;
//3. ulong pos - начальный индекс строки, с которого начинается присваивание.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая  матрица
//******************************************************************************
cmatrix TComplexMatrix::AssignCol(const cvector& V, const ivector& cols, ulong pos) const
{cmatrix result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (cols.IsZeroSize()) || (pos >= Rows()))
  return result;
 //Формирование вектора корректных индексов столбцов для исходной матрицы
 ivector Index = cols;
 ivector interval(2,0L);
 interval[0] = 0; interval[1] = Cols()-1;
 TBelongClosedInterval<long, ivector> Predicate =
 TBelongClosedInterval<long,ivector>(interval);
 Index = Index.SubVector(Predicate);
 Index = Index.Unique();//Фильтрация повторяющихся индексов столбцов
 if (Index.IsZeroSize()) return result;//Корректные индексы столбцов не найдены

 result = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора столбцам матрицы
 ulong row;
 for (ulong j = 0L; j < Index.Size(); j++)
 {for (ulong i = 0L; i < V.Size(); i++)
  {row = i+pos;
   if (row < result.Rows()) result.Put(row,Index.Get(j),V.Get(i));
   else break; //Выход из цикла по строкам матрицы
  }
 }
 return result;
}
//******************************************************************************
//СТАТУС: I.7, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//cmatrix Assign(const cmatrix& M, ulong row = 0L, ulong col = 0L) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ ИСХОДНОЙ МАТРИЦЕ ЭЛЕМЕНТОВ КОМПЛЕКСНОЙ МАТРИЦЫ
//Присваивание начинается с элемента исходной  матрицы, который размещается на
//пересечении строки с индексом row и столбца с индексом col. По умолчанию прис-
//ваивание начинается с первого элементы исходной матрицы с координатами (0,0).
//Далее присваивание осуществляется элементам исходной матрицы, индексы которых
//располагаются правее (по столбцам) и ниже (по строкам) индексов начального эле-
//мента исходной матрицы. Матрица M может иметь любую размерность. Присваивание
//значений матрицы M начинается с первого элемента данной матрицы - M(0,0) и идет
//либо до последнего значения данной матрицы по координатам строки или столбца,
//либо до последних значений исходной матрицы по ее координатам строк и столбцов
//в зависимости от соотношения размерностей исходной матрицы, матрицы-источника M
//по строкам и столбцам и координаты начального элемента исходной матрицы, с ко-
//торого начинается присваивание. В ходе операции присваивания размеры исходной
//матрицы не изменяются, так как присваивание осуществляется в крайнем случае до
//граничных значений индексов исходной матрицы по строкам и столбцам.
//Исходная матрицы не изменяются функцией, так как функция работает с ее копией,
//являющейся результатом работы функции.
//Возвращается матрицу нулевого размера в следующих ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Матрица-источник M - матрица нулевого размера;
//3. Координаты  начального  элемента  исходного  матрицы, с которого начинается
//   присваивание  выходят за пределы граничных значений по строкам или столбцам
//   для исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& M - ссылка на матрицу, присваемую элементам исходной матрицы;
//2. ulong row - индекс строки начального элемента исходной матрицы;
//3. ulong col - индекс столбца начального элемента исходной матрицы.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::Assign(const cmatrix& M, ulong row, ulong col) const
{cmatrix result;
 //Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (M.IsZeroSize()) || (row >= Rows()) || (col >= Cols()))
  return result;
 result = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора столбцам матрицы
 ulong Row, Col;
 for (ulong i = 0L; i < M.Rows(); i++)
 {Row = i+row;
  if (Row >= result.Rows()) break;//Выход из цикла по строкам
  for (ulong j = 0L; j < M.Cols(); j++)
  {Col = j+col;
   if (Col < result.Cols()) result.Put(Row,Col,M.Get(i,j));
   else break; //Выход из цикла по столбцам матрицы
  }
 }
 return result;
}

//------------------------------------------------------------------------------
//Умножение матрицы на элементарную матрицу и элементарные матрицы специального
//                              вида (elementary matrix)
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool DiagonalEM(const cmatrix& Q, bool Disp, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ДИАГОНАЛЬНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Dk.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицу Dk. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Dk;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong k - k-й диагональный элемент матрицы отличный от нуля и единицы,
//   0 <= k < Q.Rows().
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::DiagonalEM(const cmatrix& Q, bool Disp, ulong k)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong j = 0L; j < Cols(); j++) data[k][j] *= Q.Get(k,k);//По столбцам
 else //Умножение СПРАВА: R' = R * Q
  for (ulong i = 0L; i < Rows(); i++) data[i][k] *= Q.Get(k,k);//По строкам
 return true;
}
//******************************************************************************
//СТАТУС: I.2, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool DiagonalEM(const cmatrix& Q, bool Disp, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ГРУППУ ДИАГОНАЛЬНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Dk.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Dk. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Dk;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong first - индекс первой диагональной элементарной матрицы;
//4. ulong last -  индекс последней диагональной элементарной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::DiagonalEM(const cmatrix& Q, bool Disp, ulong first, ulong last)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = first; k <= last; k++)
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    data[k][j] *= Q.Get(k,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = first; k <= last; k++)
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][k] *= Q.Get(k,k);
return true;
}
//******************************************************************************
//СТАТУС: I.3, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool DiagonalEM(const cmatrix& Q, bool Disp)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВСЕ ДИАГОНАЛЬНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Dk.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Dk. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Dk;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::DiagonalEM(const cmatrix& Q, bool Disp)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L)) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = 0L; k < Rows(); k++)
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    data[k][j] *= Q.Get(k,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = 0L; k < Cols(); k++)
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][k] *= Q.Get(k,k);
return true;
}
//******************************************************************************
//СТАТУС: I.4, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LowerColumnEM(const cmatrix& Q, bool Disp, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА НИЖНЮЮ СТОЛБЦОВУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Lkc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицу Lkc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, с элементами матрицы Lkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong k - k-й столбец матрицы с отличными от нуля поддиагональными  элемен-
//   тами 0 <= k < Q.Rows().
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::LowerColumnEM(const cmatrix& Q, bool Disp, ulong k)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong i = k+1; i < Rows(); i++) //По строкам
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    data[i][j] += data[k][j]*Q.Get(i,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong i = 0L; i < Rows(); i++) //По строкам
   for (ulong j = k+1; j < Cols(); j++) //По столбцам
    data[i][k] += data[i][j]*Q.Get(j,k);
return true;
}
//******************************************************************************
//СТАТУС: I.5, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool LowerColumnEM(const cmatrix& Q, bool Disp, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ГРУППУ НИЖНИХ СТОЛБЦОВЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Lkc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Lkc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Lkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong first - индекс первой нижней столбцовой элементарной матрицы;
//4. ulong last -  индекс последней нижней столбцовой элементарной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::LowerColumnEM(const cmatrix& Q, bool Disp, ulong first, ulong last)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = first; k <= last; k++)
   for (ulong i = k+1; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = first; k <= last; k++)
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = k+1; j < Cols(); j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
return true;
}
//******************************************************************************
//СТАТУС: I.6, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LowerColumnEM(const cmatrix& Q, bool Disp)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВСЕ НИЖНИЕ СТОЛБЦОВЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Lkc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Lkc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Lkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::LowerColumnEM(const cmatrix& Q, bool Disp)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L)) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = 0L; k < Rows(); k++)
   for (ulong i = k+1; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = 0L; k < Cols(); k++)
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = k+1; j < Cols(); j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
return true;
}
//******************************************************************************
//СТАТУС: I.7, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool UpperColumnEM(const cmatrix& Q, bool Disp, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВЕРХНЮЮ СТОЛБЦОВУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Ukc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицу Ukc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Ukc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong k - k-й столбец матрицы с отличными от нуля наддиагональными  элемен-
//   тами 0 <= k < Q.Rows().
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::UpperColumnEM(const cmatrix& Q, bool Disp, ulong k)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong i = 0L; i < k; i++) //По строкам
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    data[i][j] += data[k][j]*Q.Get(i,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong i = 0L; i < Rows(); i++) //По строкам
   for (ulong j = 0L; j < k; j++) //По столбцам
    data[i][k] += data[i][j]*Q.Get(j,k);
return true;
}
//******************************************************************************
//СТАТУС: I.8, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool UpperColumnEM(const cmatrix& Q, bool Disp, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ГРУППУ ВЕРХНИХ СТОЛБЦОВЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Ukc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Ukc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Lkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong first - индекс первой верхней столбцовой элементарной матрицы;
//4. ulong last -  индекс последней верхней столбцовой элементарной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::UpperColumnEM(const cmatrix& Q, bool Disp, ulong first, ulong last)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = first; k <= last; k++)
   for (ulong i = 0L; i < k; i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = first; k <= last; k++)
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < k; j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
return true;
}
//******************************************************************************
//СТАТУС: I.9, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool UpperColumnEM(const cmatrix& Q, bool Disp)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВСЕ НИЖНИЕ СТОЛБЦОВЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Ukc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Ukc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Lkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::UpperColumnEM(const cmatrix& Q, bool Disp)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L)) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = 0L; k < Rows(); k++)
   for (ulong i = 0L; i < k; i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = 0L; k < Cols(); k++)
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < k; j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
return true;
}
//******************************************************************************
//СТАТУС: I.10, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CompleteColumnEM(const cmatrix& Q, bool Disp, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА СТОЛБЦОВУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Tkc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицу Tkc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Tkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong k - k-й столбец матрицы с отличными от нуля элементами 0 <= k < Q.Rows().
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::CompleteColumnEM(const cmatrix& Q, bool Disp, ulong k)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
 {for (ulong i = 0L; i < k; i++) //По строкам
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    data[i][j] += data[k][j]*Q.Get(i,k);

  for (ulong i = k+1; i < Rows(); i++) //По строкам
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    data[i][j] += data[k][j]*Q.Get(i,k);
 }
 else //Умножение СПРАВА: R' = R * Q
 {for (ulong i = 0L; i < Rows(); i++) //По строкам
   for (ulong j = 0L; j < k; j++) //По столбцам
    data[i][k] += data[i][j]*Q.Get(j,k);

  for (ulong i = 0L; i < Rows(); i++) //По строкам
   for (ulong j = k+1; j < Cols(); j++) //По столбцам
    data[i][k] += data[i][j]*Q.Get(j,k);
 }
return true;
}
//******************************************************************************
//СТАТУС: I.11, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CompleteColumnEM(const cmatrix& Q, bool Disp, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ГРУППУ СТОЛБЦОВЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Tkc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Tkc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Lkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong first - индекс первой столбцовой элементарной матрицы;
//4. ulong last -  индекс последней столбцовой элементарной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::CompleteColumnEM(const cmatrix& Q, bool Disp, ulong first, ulong last)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
 {for (ulong k = first; k <= last; k++)
  {for (ulong i = 0L; i < k; i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
   for (ulong i = k+1; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
  }
 }
 else //Умножение СПРАВА: R' = R * Q
 {for (ulong k = first; k <= last; k++)
  {for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < k; j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = k+1; j < Cols(); j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
  }
 }
return true;
}
//******************************************************************************
//СТАТУС: I.12, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CompleteColumnEM(const cmatrix& Q, bool Disp)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВСЕ СТОЛБЦОВЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Tkc.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Tkc. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Tkc;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::CompleteColumnEM(const cmatrix& Q, bool Disp)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L)) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
 {for (ulong k = 0L; k < Rows(); k++)
  {for (ulong i = 0L; i < k; i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
   for (ulong i = k+1; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[i][j] += data[k][j]*Q.Get(i,k);
  }
 }
 else //Умножение СПРАВА: R' = R * Q
 {for (ulong k = 0L; k < Cols(); k++)
  {for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = 0L; j < k; j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    for (ulong j = k+1; j < Cols(); j++) //По столбцам
     data[i][k] += data[i][j]*Q.Get(j,k);
  }
 }
return true;
}
//******************************************************************************
//СТАТУС: I.13, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LeftRowEM(const cmatrix& Q, bool Disp, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ЛЕВУЮ СТРОЧНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Lkr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицу Lkr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Lkr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong k - k-я строка матрицы с ненулевыми элементами, расположенными  слева
//   от диагонали 0 <= k < Q.Rows().
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::LeftRowEM(const cmatrix& Q, bool Disp, ulong k)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong j = 0L; j < Cols(); j++) //По столбцам
   for (ulong i = 0L; i < k; i++) //По строкам
    data[k][j] += data[i][j]*Q.Get(k,i);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong j = 0L; j < k; j++) //По столбцам
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][j] += data[i][k]*Q.Get(k,j);
return true;
}
//******************************************************************************
//СТАТУС: I.14, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool LeftRowEM(const cmatrix& Q, bool Disp, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ГРУППУ ЛЕВЫХ СТРОЧНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Lkr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Lkr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Lkr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong first - индекс первой левой строчной элементарной матрицы;
//4. ulong last -  индекс последней левой строчной элементарной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::LeftRowEM(const cmatrix& Q, bool Disp, ulong first, ulong last)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = first; k <= last; k++)
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < k; i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = first; k <= last; k++)
   for (ulong j = 0L; j < k; j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
return true;
}
//******************************************************************************
//СТАТУС: I.15, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LeftRowEM(const cmatrix& Q, bool Disp);
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВСЕ ЛЕВЫЕ СТРОЧНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Lkr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Lkr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Lkr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::LeftRowEM(const cmatrix& Q, bool Disp)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L)) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = 0L; k < Rows(); k++)
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < k; i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);

 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = 0L; k < Cols(); k++)
   for (ulong j = 0L; j < k; j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
return true;
}
//******************************************************************************
//СТАТУС: I.16, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool RightRowEM(const cmatrix& Q, bool Disp, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ПРАВУЮ СТРОЧНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Ukr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицу Ukr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Ukr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong k - k-я строка матрицы с ненулевыми элементами, расположенными  справа
//   от диагонали 0 <= k < Q.Rows().
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::RightRowEM(const cmatrix& Q, bool Disp, ulong k)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong j = 0L; j < Cols(); j++) //По столбцам
   for (ulong i = k+1; i < Rows(); i++) //По строкам
    data[k][j] += data[i][j]*Q.Get(k,i);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong j = k+1; j < Cols(); j++) //По столбцам
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][j] += data[i][k]*Q.Get(k,j);
return true;
}
//******************************************************************************
//СТАТУС: I.17, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool RightRowEM(const cmatrix& Q, bool Disp, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ГРУППУ ПРАВЫХ СТРОЧНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Ukr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Ukr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу, которая хранит элементы
//   матрицы Ukr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong first - индекс первой правой строчной элементарной матрицы;
//4. ulong last -  индекс последней правой строчной элементарной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::RightRowEM(const cmatrix& Q, bool Disp, ulong first, ulong last)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = first; k <= last; k++)
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = k+1; i < Rows(); i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);
 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = first; k <= last; k++)
   for (ulong j = k+1; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
return true;
}
//******************************************************************************
//СТАТУС: I.18, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool RightRowEM(const cmatrix& Q, bool Disp)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВСЕ ПРАВЫЕ СТРОЧНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Ukr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Ukr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Ukr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::RightRowEM(const cmatrix& Q, bool Disp)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L)) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
  for (ulong k = 0L; k < Rows(); k++)
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = k+1; i < Rows(); i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);

 else //Умножение СПРАВА: R' = R * Q
  for (ulong k = 0L; k < Cols(); k++)
   for (ulong j = k+1; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
return true;
}
//******************************************************************************
//СТАТУС: I.19, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CompleteRowEM(const cmatrix& Q, bool Disp, ulong k)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ПОЛНУЮ СТРОЧНУЮ ЭЛЕМЕНТАРНУЮ МАТРИЦУ Tkr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицу Tkr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Tkr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong k - k-я строка матрицы с ненулевыми элементами, 0 <= k < Q.Rows().
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::CompleteRowEM(const cmatrix& Q, bool Disp, ulong k)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (k >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
 {for (ulong j = 0L; j < Cols(); j++) //По столбцам
   for (ulong i = 0L; i < k; i++) //По строкам
    data[k][j] += data[i][j]*Q.Get(k,i);

  for (ulong j = 0L; j < Cols(); j++) //По столбцам
   for (ulong i = k+1; i < Rows(); i++) //По строкам
    data[k][j] += data[i][j]*Q.Get(k,i);
 }
 else //Умножение СПРАВА: R' = R * Q
 {for (ulong j = 0L; j < k; j++) //По столбцам
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][j] += data[i][k]*Q.Get(k,j);

  for (ulong j = k+1; j < Cols(); j++) //По столбцам
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][j] += data[i][k]*Q.Get(k,j);
 }
return true;
}
//******************************************************************************
//СТАТУС: I.20, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool CompleteRowEM(const cmatrix& Q, bool Disp, ulong first, ulong last)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ГРУППУ СТРОЧНЫХ ЭЛЕМЕНТАРНЫХ МАТРИЦ Tkr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Tkr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Tkr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong first - индекс первой строчной элементарной матрицы;
//4. ulong last -  индекс последней строчной элементарной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::CompleteRowEM(const cmatrix& Q, bool Disp, ulong first, ulong last)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (first > last) || (last >= Q.Rows())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
 {for (ulong k = first; k <= last; k++)
  {for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < k; i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = k+1; i < Rows(); i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);
  }
 }
 else //Умножение СПРАВА: R' = R * Q
 {for (ulong k = first; k <= last; k++)
  {for (ulong j = 0L; j < k; j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
   for (ulong j = k+1; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
  }
 }
return true;
}
//******************************************************************************
//СТАТУС: I.21, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool CompleteRowEM(const cmatrix& Q, bool Disp)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ВСЕ СТРОЧНЫЕ ЭЛЕМЕНТАРНЫЕ МАТРИЦЫ Tkr.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую матрицы Tkr. Функция при возможности умножения изменяет элементы
//исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Ukr;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::CompleteRowEM(const cmatrix& Q, bool Disp)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L)) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
 {for (ulong k = 0L; k < Rows(); k++)
  {for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < k; i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
    for (ulong i = k+1; i < Rows(); i++) //По строкам
     data[k][j] += data[i][j]*Q.Get(k,i);
  }
 }
 else //Умножение СПРАВА: R' = R * Q
 {for (ulong k = 0L; k < Cols(); k++)
  {for (ulong j = 0L; j < k; j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
   for (ulong j = k+1; j < Cols(); j++) //По столбцам
    for (ulong i = 0L; i < Rows(); i++) //По строкам
     data[i][j] += data[i][k]*Q.Get(k,j);
  }
 }
return true;
}
//******************************************************************************
//СТАТУС: I.22, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool OrdinaryEM(const cmatrix& Q, bool Disp, ulong row, ulong col)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ МАТРИЦЫ НА ЭЛЕМЕНТАРНУЮ МАТРИЦУ Bij.
//Функция осуществляет проверку на возможность умножения матрицы на матрицу Q,
//содержащую элементарную матрицу Bij. При умножении исходной матрицы на элемен-
//тарную матрицу значения элементов исходной матрицы изменяются.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& Q - ссылка на квадратную матрицу с элементами матрицы Bij;
//2. bool Disp - расположение элементарной матрицы относительно исходной матрицы;
//3. ulong row - строка матрицы с ненулевым элементом, 0 <= row < Q.Rows();
//4. ulong col - столбец матрицы с ненулевым элементом, 0 <= col < Q.Cols();
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - признак выполнения операции умножения на элементарную матрицу
//******************************************************************************
bool TComplexMatrix::OrdinaryEM(const cmatrix& Q, bool Disp, ulong row, ulong col)
{//Проверка на возможность умножения матрицы на элементарную матрицу
 if ((!IsSquare()) || (!Q.IsSquare()) || (Rows() != Q.Rows()) ||
     (Rows() == 0L) || (row >= Rows()) || (col >= Cols())) return false;
 //Реализация операции умножения
 if (Disp == LEFT) //Умножение СЛЕВА: R' = Q * R
 {if (row != col)
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[row][j] += data[col][j]*Q.Get(row,col);
  else //row == col
   for (ulong j = 0L; j < Cols(); j++) //По столбцам
     data[row][j] *= Q.Get(row,col);
 }
 else //Умножение СПРАВА: R' = R * Q
 {if (row != col)
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][col] += data[i][row]*Q.Get(row,col);
  else //row == col
   for (ulong i = 0L; i < Rows(); i++) //По строкам
    data[i][col] *= Q.Get(row,col);
 }
return true;
}

//------------------------------------------------------------------------------
//              РЕАЛИЗАЦИЯ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1; public; TComplexMatrix class overloading operator()
//OVERLOADING OPERATOR OF FUNCTION CALL
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex& operator() (ulong i, ulong j)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЗОВА ФУНКЦИИ класса TComplexMatrix
//Функция предназначена для доступа к одному элементу матрицы или вектора.
//Осуществляется проверка корректности индексов строки и столбца, по которым
//располагается требуемый элемент матрицы. Функция вызывается во всех пользова-
//тельских функциях, кроме вызова в операторе присваивания и конструкторе копи-
//рования, т.к. в качестве аргументов последних передается константный объект.
//Доступ к членам-данным константных объектов можно осуществлять только с исполь-
//зованием константных функций.
//ПРИМЕР ВЫЗОВА: A(3,2), где i=3 - индекс строки, j=2 - индекс столбца комплекс-
//ной матрицы. Нумерация строк и столбцов начинается с 0.
//Если индекс элемента матрицы некорректен, то возвращается data[0][0].
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint i - индекс строки матрицы
//2. uint j - индекс столбца матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex& value - ссылка на a[i][j] компонент матрицы
//******************************************************************************
complex& TComplexMatrix::operator() (ulong i, ulong j)
{if (IsZeroSize()) return data[0][0];//Матрица нулевого размера
 //Проверка корректности индексов доступа к элементу матрицы
 if ((i >= Rows()) || (j >= Cols())) return data[0][0];
 return data[i][j];
}
//******************************************************************************
//СТАТУС: I.2; public; TComplexMatrix class overloading operator()
//OVERLOADING OPERATOR OF FUNCTION CALL
//НАИМЕНОВАНИЕ ФУНКЦИИ: const complex& operator() (ulong i, ulong j) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЗОВА ФУНКЦИИ класса TComplexMatrix
//Функция предназначена для доступа к одному элементу матрицы или вектора.
//Осуществляется проверка корректности индексов строки и столбца, по которым
//располагается требуемый элемент матрицы. Функция вызывается в операторе прис-
//ваивания и конструкторе копирования, т.к. в качестве их аргументов передается
//константный объект. Доступ к членам-данным константных объектов можно осуществ-
//лять только с использованием константных функций.
//ПРИМЕР ВЫЗОВА: A(3,2), где i=3 - индекс строки, j=2 - индекс столбца комплекс-
//ной матрицы. Нумерация строк и столбцов начинается с 0.
//Если индекс элемента матрицы некорректен, то возвращается data[0][0].
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint i - индекс строки матрицы
//2. uint j - индекс столбца матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: const complex& value - ссылка на a[i][j]
//******************************************************************************
const complex& TComplexMatrix::operator() (ulong i, ulong j) const
{if (IsZeroSize()) return data[0][0];//Матрица нулевого размера
 //Проверка корректности индексов доступа к элементу матрицы
 if ((i >= Rows()) || (j >= Cols())) return data[0][0];
 return data[i][j];
}
//******************************************************************************
//СТАТУС: I.3; public; TComplexMatrix class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator =(const TComplexMatrix& C)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ класса TComplexMatrix.
//Функция осуществляет копирование характеристик и значений элементов из одной
//комплексной матрицы в другую. Осуществляется корректное копирование членов-
//указателей на данные копируемого класса в создаваемый класс с целью недопуще-
//ния ссылок указателей разных объектов класса на одно и то же место памяти.
//При попытке присваивания матрицы самой себе или невозможности присваивания
//возвращается false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TComplexMatrix& C - ссылка на копируемую матрицу
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
bool TComplexMatrix::operator =(const TComplexMatrix& C)
{//Предотвращение попытки присваивания объекта самому себе
 if (this == &C) return false;
 //Установка свойств копирующей матрицы
 if (Set(C.Rows(),C.Cols(),false) == false) return false;
 //Копирование значений элементов матрицы C
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = C.Get(i,j);
 return true;
}
//******************************************************************************
//СТАТУС: I.4; public; TComplexMatrix class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator =(const double value)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ КОМПОНЕНТАМ МАТРИЦЫ
//            ДЕЙСТВИТЕЛЬНОГО ЧИСЛА.
//Функция осуществляет присваивание ВСЕМ компонентам матрицы значения value.
//При попытке присваивания матрице нулевого размера действительного числа
//возвращается false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const double value - присваеваемое матрице значение.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::operator =(const double value)
{if (IsZeroSize()) return false;//Матрица нулевого размера
 //Цикл присваивания компонентам вектора значения value
 complex z = complex(value,0);
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
   data[i][j] = z;
 return true;
}
//******************************************************************************
//СТАТУС: I.5; public; TComplexMatrix class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator =(const complex value)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ ВСЕМ КОМПОНЕНТАМ МАТРИЦЫ
//            КОМПЛЕКСНОГО ЧИСЛА.
//Функция осуществляет присваивание ВСЕМ компонентам матрицы значения value.
//При попытке присваивания матрице нулевой размерности комплексного числа
//возвращается false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const complex value - присваиваемое матрице значение
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::operator =(const complex value)
{if (IsZeroSize()) return false;//Матрица нулевого размера
 //Цикл присваивания компонентам матрицы значения value
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
   data[i][j] = value;
 return true;
}
//******************************************************************************
//СТАТУС: I.6; public TComplexMatrix class overloading operator ==
//OVERLOADING COMPARISON OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ==(const TComplexMatrix& A) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СРАВНЕНИЯ ДВУХ МАТРИЦ.
//Две матрицы считаются РАВНЫМИ, если:
//1) Размерности матриц равны Rows()==A.Rows() && Cols()==A.Cols()
//2) data[i][j] == A.data[i][j], для всех i,j (0<=i<Rows(), 0<=j<Cols()).
//В случае равентства матриц функция возвращает true, в противном случае - false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TComplexMatrix& A - ссылка на сравниваемую матрицу
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool compare
//******************************************************************************
bool TComplexMatrix::operator ==(const TComplexMatrix& A) const
{//Матрица сравнивается сама с собой
 if (this == &A) return true;
 //Размерности матриц не совпадают
 if ((Rows() != A.Rows()) || (Cols() != A.Cols())) return false;
 //Поэлементное сравнение матриц
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {if (abs(data[i][j] - A.Get(i,j)) > EPS) return false;}
 return true;//Результат сравнения двух матриц
}
//******************************************************************************
//СТАТУС: I.7; public TComplexMatrix class overloading operator <<
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend ostream& operator <<(ostream& out, const TComplexMatrix& C)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВЫВОДА класса TComplexMatrix.
//Вывод в поток характеристик матрицы и ее элементов. Функция возвращает ссылку
//на поток, что позволяет записывать в программе операторы вывода в поток каскадно.
//Формат вывода значений элементов матрицы:
// <x+y*i;>, где x - реальная, y - мнимая значения элемента матрицы.
//При выводе элементов комплексной матрицы приняты следующие соглашения:
//1. Все элементы матрицы имеют ширину вывода равную наибольшей символьной длине
//   элемента в данном столбце матрицы, который определяется функцией
//   MaxStrLen(...)
//2. Если мнимая часть числа равна 0, то она не отображается.
//3. Выводятся только отрицательные знаки чисел.
//4. Точность вывода чисел с плавающей точкой равна 9.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на объект потока вывода
//2. сonst TComplexMatrix& C - ссылка на матрицу, выводимую в поток.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ostream& out - ссылка на объект потока вывода.
//******************************************************************************
ostream& operator <<(ostream& out, const TComplexMatrix& C)
{string s;
 uint prec = out.precision();
 long flags = out.flags();
 complex value;
 C.Properties(s);//Получение свойств матрицы C в виде строки
 out << s;//Вывод характеристик матрицы
 if (C.IsZeroSize()) return out;
 //Определение максимальной символьной длины элемента матрицы
 uint* MaxLen = MaxStrLen(C,prec);
 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 out.setf(ios::right);//Выравнивание по правому краю.
 //Вывод значений элементов комплексной матрицы C в поток
 for (ulong i = 0L; i < C.Rows(); i++)
 {for (ulong j = 0L; j < C.Cols(); j++)
  {value = C.Get(i,j);
   //Формирование символьного представления комплексного числа
   //Вывод реальной части комплексного числа
   if (fabs(real(value)) < EPS) text << "0";
   else text << setprecision(prec) << real(value);
   if (fabs(imag(value)) > EPS)
   {if (imag(value) > 0) text << "+" << setprecision(prec) << imag(value);
    else text << setprecision(prec) << imag(value);
    text << "i;";
   }
   else text << ";";
   text << ends;
   s.assign(text.str()); text.seekp(0);
   out << setw(MaxLen[j]) << s;
   if ((C.Cols()-j) > 1) out << " ";
  }
  out << endl; //Элементы каждой строки матрицы выводятся с новой строки
 }
 delete[] MaxLen; //Удаление массива с размерами каждого столбца матрицы
 out.flags(flags);
return out;
}

//------------------------------------------------------------------------------
//    РЕАЛИЗАЦИЯ ОПЕРАЦИЙ ЛИНЕЙНОЙ АЛГЕБРЫ над КОМПЛЕКСНЫМИ МАТРИЦАМИ
// Все операции линейной алгебры не изменяют значений компонент исходных матриц,
// над которыми выполняются операции линейной алгебры.
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Reverse()
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ЭЛЕМЕНТОВ КВАДРАТНОЙ МАТРИЦЫ ОТНОСИТЕЛЬНО
//            ДОПОЛНИТЕЛЬНОЙ ДИАГОНАЛИ
//Операция проводится с исходной квадратной матрицей. Алгоритм перестановки эле-
//ментов квадратной матрицы относительно дополнительной диагонали:
// A[i,j] -> A'[ |j-n|, |i-n| ], где n = Rows()-1.
//Если матрица - не квадратная или нулевого размера, то возвращается false и ис-
//ходная матрица не изменяется.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат перестановки
//******************************************************************************
bool TComplexMatrix::Reverse()
{if (IsZeroSize() || IsRectang()) return false;
 //-----------------------------------------------------------------------------
 //Перестановка элементов матрицы относительно дополнительной диагонали
 //-----------------------------------------------------------------------------
 ulong new_i, new_j, n = Rows()-1;
 complex temp;
 for (ulong i = 0L; i < n; i++)
  for (ulong j = 0L; j < (n-i); j++)
  {temp = data[i][j]; new_i = n-j; new_j = n-i;
   data[i][j] = data[new_i][new_j];
   data[new_i][new_j] = temp;
  }
 return true;
}
//******************************************************************************
//СТАТУС: I.1, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix Transpose(bool conjugate = true) const
//НАЗНАЧЕНИЕ: ТРАНСПОНИРОВАНИЕ КОМПЛЕКСНОЙ МАТРИЦЫ
//Операция транспонирования производится с копией исходной матрицы, возвращаемая
//данной функцией. Результат транспонирования матрицы A(m x n) - это матрица
//B(n x m). Столбцы матрицы B совпадают со строками матрицы A.
//Аргумент  conjugate, по умолчанию равный true, позволяет получать транспониро-
//ванную и сопряженную матрицу к данной, что является частой операцией при тран-
//спонировании комплексных матриц.
//При попытке транспонирования матрицы нулевого размера возвращается матрица
//нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//bool conjugate (true) - опция комплексного сопряжения матрицы при ее транспонировании
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - транспонированная матрица
//******************************************************************************
cmatrix TComplexMatrix::Transpose(bool conjugate) const
{cmatrix result;
 if (IsZeroSize()) return result;//Матрица нулевого размера
 //Создание транспонированной матрицы
 result.Set(Cols(),Rows(),false);
 //Транспонирование элементов матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.data[j][i] = (conjugate) ? conj(data[i][j]) : data[i][j];
 return result;
}
//******************************************************************************
//СТАТУС: I.2, TComplexMatrix class overloading operator !
//OVERLOADING UNARY OPERATOR < ! >
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix operator !() const
//Операция транспонирования производится с копией исходной матрицы, возвращаемая
//данной функцией. Результат транспонирования матрицы A(m x n) - это матрица
//B(n x m). Столбцы матрицы B совпадают со строками матрицы A.
//При попытке транспонирования матрицы нулевого размера возвращается матрица
//нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - транспонированная матрица
//******************************************************************************
cmatrix TComplexMatrix::operator !() const
{cmatrix result;
 if (IsZeroSize()) return result;//Матрица нулевого размера
 //Создание транспонированной матрицы
 result.Set(Cols(),Rows(),false);
 //Транспонирование элементов матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(j,i,data[i][j]);
 return result;
}
//******************************************************************************
//СТАТУС: I.3, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix Conj() const
//НАЗНАЧЕНИЕ: СОПРЯЖЕНИЕ КОМПЛЕКСНОЙ МАТРИЦЫ
//Данная операция производится с копией исходной матрицы, возвращаемой данной
//функцией. При сопряжении матрицы нулевого размера возвращается матрица нулевого
//размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - сопряженная матрица данной.
//******************************************************************************
cmatrix TComplexMatrix::Conj() const
{cmatrix result;
 if (IsZeroSize()) return result;//Матрица нулевого размера
 //Создание копии исходной матрицы
 result.Set(Rows(),Cols(),false);
 //Получение комплексно-сопряженной матрицы данной
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
    result.Put(i,j,conj(data[i][j]));
 return result;
}
//******************************************************************************
//СТАТУС: I.4, TComplexMatrix class overloading operator ~
//OVERLOADING UNARY OPERATOR < ~ >
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix operator ~() const
//НАЗНАЧЕНИЕ: СОПРЯЖЕНИЕ КОМПЛЕКСНОЙ МАТРИЦЫ
//Данная операция производится с копией исходной матрицы, возвращаемой данной
//функцией. При попытке сопряжения матрицы нулевого размера возвращается матрица
//нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - сопряженная матрица данной
//******************************************************************************
cmatrix TComplexMatrix::operator ~() const
{cmatrix result;
 if (IsZeroSize()) return result;//Матрица нулевого размера
 result.Set(Rows(),Cols(),false);
 //Получение комплексно-сопряженной матрицы данной
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
   result.Put(i,j,conj(data[i][j]));
 return result;
}

//------------------------------------------------------------------------------
// Определение норм и нормирование комплексной матрицы
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double FirstNorm() const
//НАЗНАЧЕНИЕ: ПЕРВАЯ (КУБИЧЕСКАЯ) НОРМА КОМПЛЕКСНОЙ КВАДРАТНОЙ МАТРИЦЫ
//Функция осуществляет определение первой (кубической) нормы комплексной матри-
//цы. Для квадратной матрицы A(n x n) первая норма вычисляется по формуле:
// ||A|| = max|Aij| by i & j, максимальное абсолютное значение элемента матри-
//цы A размера n.
//|Aij| = sqrt(Re(Aij)^2 + Im(Aij)^2) - абсолютное значение (модуль) комплексно-
//го элемента матрицы.
//При определении нормы матрицы нулевого размера или неквадратной матрицы
//возвращается 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - первая норма матрицы
//******************************************************************************
double TComplexMatrix::FirstNorm() const
{double norm = 0.0;
 //Матрица нулевого размера или прямоугольная матрица
 if ((IsZeroSize()) || (IsRectang())) return norm;
 //Поиск максимального по абсолютной величине элемента матрицы
 double value;
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {value = abs(data[i][j]);
   if (norm < value) norm = value;
  }
 return norm;
}
//******************************************************************************
//СТАТУС: I.2, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double NFirstNorm() const
//НАЗНАЧЕНИЕ: МАТРИЧНАЯ НОРМА ДЕЙСТВИТЕЛЬНОЙ КВАДРАТНОЙ МАТРИЦЫ вида N*max|Aij|
//Норма определена для квадратной матрицы A(n x n) и вычисляется по формуле:
// ||A|| = n*max|Aij| by i & j, максимальное абсолютное значение элемента матри-
//цы A размера n.
//При попытке определения нормы матрицы нулевого размера или неквадратной матри-
//цы возвращается 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - норма матрицы
//******************************************************************************
double TComplexMatrix::NFirstNorm() const {return Rows()*FirstNorm();}
//******************************************************************************
//СТАТУС: I.3, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double SecondNorm() const
//НАЗНАЧЕНИЕ: ВТОРАЯ (ОКТАЭДРИЧЕСКАЯ) НОРМА КОМПЛЕКСНОЙ КВАДРАТНОЙ МАТРИЦЫ
//Функция осуществляет определение второй (октаэдрической) нормы комплексной
//квадратной матрицы. Для матрицы A(n x n) вторая норма вычисляется по следующей
//формуле:
// ||A|| = SUM|Aij| by i & j, сумма абсолютных значений элементов матрицы A.
//При определении нормы матрицы нулевого размера или неквадратной матрицы возвра-
//щается 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - вторая норма матрицы
//******************************************************************************
double TComplexMatrix::SecondNorm() const
{double norm = 0.0;
 //Матрица нулевого размера или матрица неквадратная
 if ((IsZeroSize()) || (IsRectang())) return norm;
 //Суммирование абсолютных величин компонент комплексной квадратной матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++) norm += abs(data[i][j]);
 return norm;
}
//******************************************************************************
//СТАТУС: I.4, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double ThirdNorm() const
//НАЗНАЧЕНИЕ: ТРЕТЬЯ (СФЕРИЧЕСКАЯ, ЕВКЛИДОВА) НОРМА КВАДРАТНОЙ КОМПЛЕКСНОЙ
//            МАТРИЦЫ
//Функция осуществляет определение третьей нормы комплексной квадратной матрицы.
//Для матрицы A(n x n) евклидова норма вычисляется по следующей формуле:
// ||A|| = sqrt(SUM|Aij|^2 by i & j).
//При определении нормы матрицы нулевого размера или неквадратной матрицы возвра-
//щается 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double value - евклидова норма матрицы
//******************************************************************************
double TComplexMatrix::ThirdNorm() const
{double value = 0.0;
 //Матрица нулевого размера или матрица неквадратная
 if ((IsZeroSize()) || (IsRectang())) return value;
 //Суммирование квадратов абсолютных величин элементов матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++) value += norm(data[i][j]);
 //Вычисление нормы комплексной квадратной матрицы
 return sqrt(value);
}
//******************************************************************************
//СТАТУС: I.5, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double PNorm(uint p = 2) const
//НАЗНАЧЕНИЕ: P-НОРМА (НОРМЫ ГЕЛЬДЕРА) КОМПЛЕКСНОЙ КВАДРАТНОЙ МАТРИЦЫ
//Функция осуществляет определение p-нормы комплексной квадратной матрицы. Для
//матрицы A(n x n) p-норма вычисляется по следующей формуле:
// ||A|| = {SUM|Aij|^p by i,j}^(1/p).
//При попытке определения нормы матрицы нулевого размера или неквадратной матри-
//цы возвращается 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint p - p-норма матрицы (by default p=2-Евклидова норма)
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - p-норма квадратной матрицы
//******************************************************************************
double TComplexMatrix::PNorm(uint p) const
{double norm = 0.0;
 //Матрица нулевого размера или матрица неквадратная
 if ((IsZeroSize()) || (IsRectang())) return norm;
 //Вычисление p-нормы комплексной квадратной матрицы
 if (p == 0) norm = FirstNorm();//Первая норма
 else if (p == 1) norm = SecondNorm();//Вторая норма
 else if (p == 2) norm = ThirdNorm();//Третья норма
 else
 {for (ulong i = 0L; i < Rows(); i++)
   for (ulong j = 0L; j < Cols(); j++)
    norm += pow(abs(data[i][j]),p);
  norm = pow(norm,1/p);
 }
 return norm;
}
//******************************************************************************
//СТАТУС: I.6, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double Norm(uint type = EUCLIDEAN_NORM, uint p = 2) const
//НАЗНАЧЕНИЕ: НОРМА КОМПЛЕКСНОЙ КВАДРАТНОЙ МАТРИЦЫ
//Функция осуществляет определение нормы комплексной квадратной матрицы в зави-
//симости от значения переменной type. Аргумент p необходим для определения
//p-нормы матрицы. По умолчанию функция определяет ЕВКЛИДОВУ НОРМУ матрицы.
//При определении нормы матрицы нулевого размера или неквадратной матрицы возвра-
//щается 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//uint type (EUCLIDEAN_NORM) - тип нормы комплексной квадратной матрицы;
//uint p (p = 2) - параметр для p-нормы матрицы.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - норма матрицы заданного типа
//******************************************************************************
double TComplexMatrix::Norm(uint type, uint p) const
{double norm;
 switch (type)
 {//Определение первой (кубической) нормы
  case FIRST_NORM:
   norm = FirstNorm(); break;
  //Определение второй (октаэдрической) нормы
  case SECOND_NORM:
   norm = SecondNorm(); break;
  //Определение третьей (сферической, евклидовой) нормы
  case THIRD_NORM:
   norm = ThirdNorm(); break;
  //Определение p-нормы или нормы Гельдера
  case P_NORM:
   norm = PNorm(p); break;
  //Несуществующий тип нормы
  default:
   norm = 0.0;
 }
 return norm;
}
//******************************************************************************
//СТАТУС: I.7; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// double NormRow(ulong index, uint type = EUCLIDEAN_NORM, uint p = 2) const
//НАЗНАЧЕНИЕ: Определение нормы строки матрицы с индексом index от 0 до Rows()-1.
//Если индекс строки матрицы некорректен, то возвращается 0. По умолчанию вычис-
//ляется эвклидова норма строки матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong index - индекс строки матрицы для которой вычисляется норма
//2. uint type - тип вычисляемой нормы
//3. uint p - показатель степени для p-норм Гельдера
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double Norm - норма строки матрицы с номером index
//******************************************************************************
double TComplexMatrix::NormRow(ulong index, uint type, uint p) const
{//Получение строки матрицы с номером index в виде вектора
 cvector V = Row(index);
 //Вычисление нормы вектора заданного типа
 return V.Norm(type,p);
}
//******************************************************************************
//СТАТУС: I.8; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// double NormСol(ulong index, uint type = EUCLIDEAN_NORM, uint p = 2) const
//НАЗНАЧЕНИЕ: Определение нормы столбца матрицы с индексом index от 0 до Cols()-1.
//Если индекс столбца матрицы некорректен, то возвращается 0. По умолчанию вычис-
//ляется эвклидова норма столбца матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong index - индекс столбца матрицы для которой вычисляется норма
//2. uint type - тип вычисляемой нормы
//3. uint p - показатель степени для p-норм Гельдера
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double Norm - норма столбца матрицы с номером index
//******************************************************************************
double TComplexMatrix::NormCol(ulong index, uint type, uint p) const
{//Получение стобца матрицы с номером index в виде вектора
 cvector V = Col(index);
 //Вычисление нормы вектора заданного типа
 return V.Norm(type,p);
}
//******************************************************************************
//СТАТУС: I.9; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rvector NormAllRows(uint type = EUCLIDEAN_NORM, uint p = 2) const
//НАЗНАЧЕНИЕ: Вычисление норм всех строк матрицы от 0 до Rows()-1. По умолчанию
//вычисляется эвклидова норма строк матрицы. Значения всех норм строк заносятся
//в вектор Norms со следующими параметрами: size = Rows(); type = ROW.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint type - тип вычисляемой нормы
//2. uint p - показатель степени для p-норм Гельдера
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector Norms - нормы всех строк матрицы
//******************************************************************************
rvector TComplexMatrix::NormAllRows(uint type, uint p) const
{rvector Norms;
 if (IsZeroSize()) return Norms;//Матрица нулевого размера
 //Формируем вектор Norms с нормами всех строк матрицы
 Norms.Set(Rows(),ROW,false);
 //Формируем вектор Row с элементами текущей строки матрицы для которой будет
 //вычисляться норма
 cvector Row(Cols(),ROW,false);
 //Цикл вычисления норм всех строк матрицы
 for (ulong i = 0L; i < Rows(); i++)
 {//Копирование значений элементов i-ой строки матрицы в вектор Row
  for (ulong j = 0L; j < Cols(); j++) Row.Put(j,data[i][j]);
  //Определение нормы заданного типа для i-ой строки
  Norms.Put(i,Row.Norm(type,p));
 }
 return Norms;
}
//******************************************************************************
//СТАТУС: I.10; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// rvector NormAllCols(uint type = EUCLIDEAN_NORM, uint p = 2) const
//НАЗНАЧЕНИЕ: Вычисление норм всех столбцов матрицы от 0 до Cols()-1. По умолча-
//нию вычисляется эвклидова норма столбцов матрицы. Значения всех норм столбцов
//заносятся в вектор Norms со следующими параметрами: size = Cols(), type = COL.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint type - тип вычисляемой нормы
//2. uint p - показатель степени для p-норм Гельдера
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rvector Norms - нормы всех столбцов матрицы
//******************************************************************************
rvector TComplexMatrix::NormAllCols(uint type, uint p) const
{rvector Norms;
 if (IsZeroSize()) return Norms;//Матрица нулевого размера
 //Формируем вектор Norms с нормами всех столбцов матрицы
 Norms.Set(Cols(),COL,0.0);
 //Формируем вектор Col с элементами текущего столбца матрицы для которой будет
 //вычисляться норма
 cvector Col(Rows(),COL);
 //Цикл вычисления норм всех столбцов матрицы
 for (ulong j = 0L; j < Cols(); j++)
 {//Копирование значений элементов i-го столбца матрицы в вектор Col
  for (ulong i = 0L; i < Rows(); i++) Col.Put(i,data[i][j]);
  //Определение нормы заданного типа для j-го столбца
  Norms.Put(j,Col.Norm(type,p));
 }
 return Norms;
}
//******************************************************************************
//СТАТУС: I.11, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool NormAllRows(rvector& V, uint type = EUCLIDEAN_NORM, uint p = 2) const
//НАЗНАЧЕНИЕ: ВЫЧИСЛЕНИЕ НОРМ ВСЕХ СТРОК МАТРИЦЫ.
//Тип вычисляемых норм строк матрицы определяется переменной type. Аргумент p
//необходим для определения p-нормы матрицы. По умолчанию функция определяет
//ЕВКЛИДОВУ НОРМУ для всех строк матрицы. Нормы всех строк формируются в векторе
//V, передаваемом по ссылке. Вектор V будет иметь следующие свойства:
//V.Size() == Rows(), V.Type() == ROW.
//При определении норм строк матрицы нулевого размера возвращается false, вектор
//V становиться вектором нулевой длины.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& V - результирующий вектор с нормами всех строк матрицы;
//2. uint type - тип определяемой нормы строк матрицы;
//3. uint p - параметр для p-нормы строки (by default: p=2 - Евклидова норма).
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::NormAllRows(rvector& V, uint type, uint p) const
{V.Resize(Rows()); V.SetType(ROW);
 if (IsZeroSize()) return false;//Матрица нулевого размера
 cvector Temp;
 for (ulong i = 0L; i < Rows(); i++)
 {Row(Temp,i);//Получение строки матрицы с индексом i
  V.Put(i,Temp.Norm(type,p));//Расчет нормы i-ой строки матрицы
 }
 return true;
}
//******************************************************************************
//СТАТУС: I.12, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool NormAllCols(rvector& V, uint type = EUCLIDEAN_NORM, uint p = 2) const
//НАЗНАЧЕНИЕ: ВЫЧИСЛЕНИЕ НОРМ ВСЕХ СТОЛБЦОВ МАТРИЦЫ.
//Тип вычисляемых норм столбцов матрицы определяется переменной type. Аргумент p
//необходим для определения p-нормы матрицы. По умолчанию функция определяет
//ЕВКЛИДОВУ НОРМУ для всех столбцов матрицы. Нормы всех столбцов формируются в
//векторе V, передаваемом по ссылке. Вектор V будет иметь следующие свойства:
//V.Size() == Cols(), V.Type() == COL.
//При определении норм столбцов матрицы нулевого размера возвращается false,
//вектор V становиться вектором нулевой длины.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& V - результирующий вектор с нормами всех столбцов матрицы;
//2. uint type - тип определяемой нормы столбцов матрицы;
//3. uint p - параметр для p-нормы столбца (by default: p=2 - Евклидова норма).
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::NormAllCols(rvector& V, uint type, uint p) const
{V.Resize(Cols()); V.SetType(COL);
 if (IsZeroSize()) return false;//Матрица нулевого размера
 cvector Temp;
 for (ulong j = 0L; j < Cols(); j++)
 {Col(Temp,j);//Получение столбца матрицы с индексом j
  V.Put(j,Temp.Norm(type,p));//Расчет нормы j-го столбца матрицы
 }
 return true;
}
//******************************************************************************
//СТАТУС: I.13, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Normalize(cmatrix& A, uint NormType, uint p=0) const
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ КОМПЛЕКСНОЙ КВАДРАТНОЙ МАТРИЦЫ
//С целью нормирования функция определяет норму квадратной матрицы, затем каждый
//элемент  матрицы делится на норму матрицы. Определяемая норма определяется пе-
//ременной type. Аргумент p необходим для определения p-нормы матрицы. Исходная
//матрица при нормировании не изменяется, так как все операции производятся с
//матрицей A, в которую копируется исходная матрица.
//При нормировании матрицы с нормой равной 0 возвращается false, а матрица A
//становится матрицей нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& A - ссылка на результирующую матрицу;
//2. uint NormType - тип нормы квадратной матрицы;
//3. uint p - параметр для p-нормы матрицы (by default p=0)
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::Normalize(cmatrix& A, uint NormType, uint p) const
{double norm = Norm(NormType,p);
 if (norm < EPS) {A.Set(0L,0L,false); return false;}
 A = *this;
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   A.Put(i,j,A.Get(i,j)/norm);
 return true;
}
//******************************************************************************
//СТАТУС: I.14, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Normalize(uint NormType, uint p=0)
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ КОМПЛЕКСНОЙ КВАДРАТНОЙ МАТРИЦЫ
//С целью нормирования функция определяет норму квадратной матрицы, затем каждый
//элемент  матрицы делится на норму матрицы. Определяемая норма определяется пе-
//ременной type. Аргумент p необходим для определения p-нормы матрицы. Исходная
//матрица изменяется при нормировании.
//При нормировании матрицы с нормой равной 0 возвращается false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint NormType - тип нормы квадратной матрицы;
//2. uint p - параметр для p-нормы матрицы (by default p=0).
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::Normalize(uint NormType, uint p)
{double norm = Norm(NormType,p);
 if (norm < EPS) return false;
 //Нормирование элементов матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = data[i][j]/norm;
 return true;
}
//******************************************************************************
//СТАТУС: I.15, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool NormalizeToDB(rmatrix& A, double MindB = -60) const
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ КОМПЛЕКСНОЙ МАТРИЦЫ в ДЕЦИБЕЛАХ
//Функция осуществляет операцию нормирования вещественной матрицы в децибелах.
//С этой целью, во-первых, вычисляется первая норма матрицы. Во-вторых, каждый
//элемент матрицы R делится на первую норму матрицы.
//В-третьих, элементы матрицы логарифмируются: Power = true: 10*log10(norm{R(i,j)});
//При попытке нормировки матрицы нулевого размера функция возвращает false.
//Функция не изменяет исходную матрицу, результаты нормировки заносятся в матрицу
//A, передаваемую по ссылке.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& A - ссылка на результирующую матрицу
//2. double MindB (-60 dB) - минимальный пороговый уровень
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::NormalizeToDB(rmatrix& A, double MindB) const
{if (IsZeroSize()) {A.Set(0L,0L,false); return false;}//Матрица нулевого размера
 //Поиск максимального значения
 double Max = 0.0;
 A.Set(Rows(),Cols(),false);
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {A.Put(i,j,norm(data[i][j]));
   if (Max < A.Get(i,j)) Max = A.Get(i,j);
  }
 if (Max < EPS) {A.Set(0L,0L,false); return false;}
 //Нормирование компонент матрицы A в пределах (0..1]
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   A.Put(i,j,A.Get(i,j)/Max);
 //Нормирование в dB с установкой нижнего порогового уровня [0..MindB]
 double value;
 MindB = (MindB >= 0.0) ? -60.0 : MindB;
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
  {value = A.Get(i,j);
   if (fabs(value) < EPS) A.Put(i,j,MindB);//Нулевое значение
   else
   {value = 10*log10(value);
    if (value < MindB) value = MindB;
    A.Put(i,j,value);
   }
  }
 return true;
}
//******************************************************************************
//СТАТУС: I.16, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool NormalizeRows(cmatrix& A, uint NormType, uint p=0) const
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ КОМПЛЕКСНОЙ МАТРИЦЫ ПО КАЖДОЙ СТРОКЕ
//Во-первых, функция определяет нормы всех строк матрицы, затем каждая строка
//матрицы делится на норму данной строки. Тип нормы определяется переменной type.
//Аргумент p необходим для определения p-нормы матрицы. Исходная матрица при
//нормировании не изменяется, так как все операции производятся с матрицей A, в
//которую копируется исходная матрица.
//Если какая-либо норма строки матрицы равна 0, то возвращается false, а матрица
//A становится матрицей нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& A - ссылка на результирующую матрицу;
//2. uint NormType - тип норм строк матрицы;
//3. uint p - параметр для p-норм строк матрицы (by default p=0)
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::NormalizeRows(cmatrix& A, uint NormType, uint p) const
{rvector Norms;
 //Определение норм всех строк матрицы
 if (NormAllRows(Norms,NormType,p) == false) {A.Set(0L,0L,false); return false;}
 //Поиск нормы равной 0
 for (ulong i = 0L; i < Norms.Size(); i++)
 {if (Norms.Get(i) < EPS) {A.Set(0L,0L,false); return false;}}
 //Построчное нормирование матрицы
 A.Set(Rows(),Cols(),false);
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   A.Put(i,j,data[i][j]/Norms.Get(i));
 return true;
}
//******************************************************************************
//СТАТУС: I.17, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool NormalizeRows(uint NormType, uint p=0)
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ КОМПЛЕКСНОЙ МАТРИЦЫ ПО КАЖДОЙ СТРОКЕ
//Во-первых, функция определяет нормы всех строк матрицы, затем каждая строка
//матрицы делится на норму данной строки. Тип нормы определяется переменной type.
//Аргумент p необходим для определения p-нормы матрицы. Исходная матрица при
//нормировании изменяется.
//Если какая-либо норма строки матрицы равна 0, то возвращается false и нормиро-
//вание не осуществляется.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint NormType - тип норм строк матрицы;
//2. uint p - параметр для p-норм строк матрицы (by default p=0)
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - норма матрицы заданного типа
//******************************************************************************
bool TComplexMatrix::NormalizeRows(uint NormType, uint p)
{rvector Norms;
 //Определение норм всех строк матрицы
 if (NormAllRows(Norms,NormType,p) == false) return false;
 //Поиск нормы равной 0
 for (ulong i = 0L; i < Norms.Size(); i++) {if (Norms.Get(i) < EPS) return false;}
 //Построчное нормирование матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = data[i][j]/Norms.Get(i);
 return true;
}
//******************************************************************************
//СТАТУС: I.18, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//bool NormalizeRowsToDB(rmatrix& A, double MindB=-60) const
//НАЗНАЧЕНИЕ: ПОСТРОЧНОЕ НОРМИРОВАНИЕ КОМПЛЕКСНОЙ МАТРИЦЫ в ДЕЦИБЕЛАХ
//С этой целью, во-первых, вычисляются первые нормы каждой строки матрицы.
//Во-вторых, каждая строка матрицы делится на норму для этой строки.
//В-третьих, элементы матрицы логарифмируются:
//Power = true: 10*log10(norm{R(i,j)});
//При попытке нормировки матрицы нулевого размера функция возвращает false.
//Функция не изменяет исходную матрицу, результаты нормировки заносятся в матрицу
//A, передаваемую по ссылке.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& A - ссылка на результирующую матрицу
//2. double MindB (-60 dB) - минимальный пороговый уровень
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::NormalizeRowsToDB(rmatrix& A, double MindB) const
{if (IsZeroSize()) {A.Set(0L,0L,false); return false;}//Матрица нулевого размера
 //Определение первых норм строк с поиском нулевых значений
 rvector Norm(Rows(),ROW);
 double value;
 for (ulong i = 0L; i < Rows(); i++)
 {double Max = 0.0;
  for (ulong j = 0L; j < Cols(); j++)
  {value = norm(data[i][j]);
   if (Max < value) Max = value;
  }
  if (Max < EPS) {A.Set(0L,0L,false); return false;}
  Norm.Put(i,Max);
 }
 A.Set(Rows(),Cols(),false);
 //Нормирование компонент матрицы A в пределах (0..1]
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   A.Put(i,j,A.Get(i,j)/Norm.Get(i));
 //Нормирование в dB с установкой нижнего порогового уровня [0..MindB]
 MindB = (MindB >= 0.0) ? -60.0 : MindB;
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
  {value = A.Get(i,j);
   if (fabs(value) < EPS) A.Put(i,j,MindB);//Нулевое значение
   else
   {value = 10*log10(value);
    if (value < MindB) value = MindB;
    A.Put(i,j,value);
   }
  }
 return true;
}
//******************************************************************************
//СТАТУС: I.19, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool NormalizeCols(cmatrix& A, uint NormType, uint p=0) const
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ КОМПЛЕКСНОЙ МАТРИЦЫ ПО КАЖДОМУ СТОЛБЦУ
//Во-первых, функция определяет нормы всех столбцов матрицы, затем каждая столбец
//матрицы делится на норму данного столбца. Тип нормы определяется переменной type.
//Аргумент p необходим для определения p-нормы матрицы. Исходная матрица при
//нормировании не изменяется, так как все операции производятся с матрицей A, в
//которую копируется исходная матрица.
//Если какая-либо норма столбца матрицы равна 0, то возвращается false, а матрица
//A становится матрицей нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. сmatrix& A - ссылка на результирующую матрицу;
//2. uint NormType - тип норм столбцов матрицы;
//3. uint p - параметр для p-норм столбцов матрицы (by default p=0)
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::NormalizeCols(cmatrix& A, uint NormType, uint p) const
{rvector Norms;
 //Определение норм всех столбцов матрицы
 if (NormAllCols(Norms,NormType,p) == false) {A.Set(0L,0L,false); return false;}
 //Поиск нормы равной 0
 for (ulong i = 0L; i < Norms.Size(); i++)
 {if (Norms.Get(i) < EPS) {A.Set(0L,0L,false); return false;}}
 //Постолбцовое нормирование матрицы
 A.Set(Rows(),Cols(),false);
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   A.Put(i,j,data[i][j]/Norms.Get(j));
 return true;
}
//******************************************************************************
//СТАТУС: I.20, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool NormalizeCols(uint NormType, uint p=0)
//НАЗНАЧЕНИЕ: НОРМИРОВАНИЕ КОМПЛЕКСНОЙ МАТРИЦЫ ПО КАЖДОМУ СТОЛБЦУ
//Во-первых, функция определяет нормы всех столбцов матрицы, затем каждая столбец
//матрицы делится на норму данного столбца. Тип нормы определяется переменной type.
//Аргумент p необходим для определения p-нормы матрицы. Исходная матрица при
//постолбцовом нормировании изменяется.
//Если какая-либо норма столбца матрицы равна 0, то возвращается false.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint NormType - тип норм столбцов матрицы;
//2. uint p - параметр для p-норм столбцов матрицы (by default p=0)
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::NormalizeCols(uint NormType, uint p)
{rvector Norms;
 //Определение норм всех столбцов матрицы
 if (NormAllCols(Norms,NormType,p) == false) return false;
 //Поиск нормы равной 0
 for (ulong i = 0L; i < Norms.Size(); i++)
 {if (Norms.Get(i) < EPS) return false;}
 //Постолбцовое нормирование матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = data[i][j]/Norms.Get(j);
 return true;
}
//******************************************************************************
//СТАТУС: I.21, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool NormalizeColsToDB(rmatrix& A, double MindB=-60) const
//НАЗНАЧЕНИЕ: ПОСТОЛБЦОВОЕ НОРМИРОВАНИЕ КОМПЛЕКСНОЙ МАТРИЦЫ в ДЕЦИБЕЛАХ
//С этой целью, во-первых, вычисляются первые нормы каждого столбца матрицы.
//Во-вторых, каждый столбец матрицы делится на норму для этой столбца.
//В-третьих, элементы матрицы логарифмируются:
//Power = true: 10*log10(norm{R(i,j)});
//При попытке нормировки матрицы нулевого размера функция возвращает false.
//Функция не изменяет исходную матрицу, результаты нормировки заносятся в матрицу
//A, передаваемую по ссылке.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& A - ссылка на результирующую матрицу
//2. double MindB (-60 dB) - минимальный пороговый уровень
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::NormalizeColsToDB(rmatrix& A, double MindB) const
{if (IsZeroSize()) {A.Set(0L,0L,false); return false;}//Матрица нулевого размера
 //Определение первых норм столбцов с поиском отрицательных или нулевых значений
 rvector Norm(Cols(),COL);
 double value;
 for (ulong j = 0L; j < Cols(); j++)
 {double Max = 0.0;
  for (ulong i = 0L; i < Rows(); i++)
  {value = norm(data[i][j]);
   if (Max < value) Max = value;
  }
  if (Max < EPS) {A.Set(0L,0L,false); return false;};
  Norm.Put(j,Max);
 }
 A.Set(Rows(),Cols(),false);
 //Нормирование компонент матрицы A в пределах (0..1]
 for (ulong j = 0L; j < A.Cols(); j++)
  for (ulong i = 0L; i < A.Rows(); i++)
   A.Put(i,j,A.Get(i,j)/Norm.Get(j));
 //Нормирование в dB с установкой нижнего порогового уровня [0..MindB]
 MindB = (MindB >= 0.0) ? -60.0 : MindB;
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
  {value = A.Get(i,j);
   if (fabs(value) < EPS) A.Put(i,j,MindB);//Нулевое значение
   else
   {value = 10*log10(value);
    if (value < MindB) value = MindB;
    A.Put(i,j,value);
   }
  }
 return true;
}
//****************************************************************************************
//СТАТУС: I.22, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double Trace() const
//НАЗНАЧЕНИЕ: ВЫЧИСЛЕНИЕ СЛЕДА КОМПЛЕКСНОЙ КВАДРАТНОЙ МАТРИЦЫ
//След комплексной квадратной матрицы вычисляется СУММИРОВАНИЕМ ДИАГОНАЛЬНЫХ ЭЛЕМЕНТОВ.
//При попытке определения следа матрицы нулевого размера или прямоугольной матрицы
//возвращается 0.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex Spur - след квадратной матрицы
//****************************************************************************************
complex TComplexMatrix::Trace() const
{complex Spur = C_ZERO;
 //Матрица нулевого размера или прямоугольная матрица
 if ((IsZeroSize()) || (IsRectang())) return Spur;
 //Вычисление следа квадратной комплексной матрицы
 for (ulong i = 0L; i < Rows(); i++) Spur += data[i][i];
 return Spur;
}

//------------------------------------------------------------------------------
//    РЕАЛИЗАЦИЯ ОПЕРАЦИЙ ЛИНЕЙНОЙ АЛГЕБРЫ над КОМПЛЕКСНЫМИ МАТРИЦАМИ
// Все операции линейной алгебры не изменяют значений компонент исходных матриц,
// над которыми выполняются операции линейной алгебры.
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1, friend function of the TComplexMatrix class
//OVERLOADING ADDITION OPERATION (+) by Increasing Matrix on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cmatrix operator +(const double value, const cmatrix& A)
//НАЗНАЧЕНИЕ: УВЕЛИЧЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Число value прибавляется слева: B = const + A, B(i,j) = A(i,j) + const
//Для осуществления операции сложения матрицы с числом необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается матрица нулевого размера.
//Результатом сложения матрицы с числом всегда является МАТРИЦА.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const double value - вещественное число, складываемое с матрицей.
//2. const cmatrix& A - ссылка на комплексную матрицу, к компонентам которой
//   добавляется вещественное число value.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица A, увеличенная на значение value
//******************************************************************************
cmatrix operator +(const double value, const cmatrix& A)
{cmatrix result;
 if (A.IsZeroSize()) return result;//Матрица нулевого размера
 result.Set(A.Rows(),A.Cols(),false);
 //Цикл увеличения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)+value);
 return result;
}
//******************************************************************************
//СТАТУС: I.2, friend function of the TComplexMatrix class
//OVERLOADING ADDITION OPERATION (+) by Increasing Matrix on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cmatrix operator +(const cmatrix& A, const double value)
//НАЗНАЧЕНИЕ: УВЕЛИЧЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Число value прибавляется справа: B = A + const, B(i,j) = A(i,j) + const
//Для осуществления операции сложения матрицы с числом необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается матрица нулевого размера.
//Результатом сложения матрицы с числом всегда является МАТРИЦА.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& A - ссылка на комплексную матрицу, к компонентам которой
//   добавляется вещественное число value.
//2. const double value - вещественное число, складываемое с матрицей.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица A, увеличенная на значение value
//******************************************************************************
cmatrix operator +(const cmatrix& A, const double value)
{cmatrix result;
 if (A.IsZeroSize()) return result;//Матрица нулевого размера
 result.Set(A.Rows(),A.Cols(),false);
 //Цикл увеличения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)+value);
 return result;
}
//******************************************************************************
//СТАТУС: I.3, friend function of the TComplexMatrix class
//OVERLOADING ADDITION OPERATION (+) by Increasing Matrix on the Complex Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cmatrix operator +(const complex value, const cmatrix& A)
//НАЗНАЧЕНИЕ: УВЕЛИЧЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА КОМПЛЕКСНУЮ ВЕЛИЧИНУ value.
//Число value прибавляется слева: B = const + A, B(i,j) = A(i,j) + const
//Для осуществления операции сложения матрицы с числом необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается матрица нулевого размера.
//Результатом сложения матрицы с числом всегда является МАТРИЦА.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const complex value - комплексное число, складываемое с матрицей.
//2. const cmatrix& A - ссылка на комплексную матрицу, к компонентам которой
//   добавляется комплексное число value.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица A, увеличенная на значение value
//******************************************************************************
cmatrix operator +(const complex value, const cmatrix& A)
{cmatrix result;
 if (A.IsZeroSize()) return result;//Матрица нулевого размера
 result.Set(A.Rows(),A.Cols(),false);
 //Цикл увеличения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)+value);
 return result;
}
//******************************************************************************
//СТАТУС: I.4, friend function of the TComplexMatrix class
//OVERLOADING ADDITION OPERATION (+) by Increasing Matrix on the Complex Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cmatrix operator +(const cmatrix& A, const complex value)
//НАЗНАЧЕНИЕ: УВЕЛИЧЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА КОМПЛЕКСНУЮ ВЕЛИЧИНУ value.
//Число value прибавляется справа: B = A + const, B(i,j) = A(i,j) + const
//Для осуществления операции сложения матрицы с числом необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается матрица нулевого размера.
//Результатом сложения матрицы с числом всегда является МАТРИЦА.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& A - ссылка на комплексную матрицу, к компонентам которой
//   добавляется комплексное число value.
//2. const double value - комплексное число, складываемое с матрицей.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица A, увеличенная на значение value
//******************************************************************************
cmatrix operator +(const cmatrix& A, const complex value)
{cmatrix result;
 if (A.IsZeroSize()) return result;//Матрица нулевого размера
 result.Set(A.Rows(),A.Cols(),false);
 //Цикл увеличения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)+value);
 return result;
}
//******************************************************************************
//СТАТУС: I.5, friend function of the TComplexMatrix class
//OVERLOADING DECREASE OPERATION (-) by Decreasing Matrix on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cmatrix operator -(const cmatrix& A, const double value)
//НАЗНАЧЕНИЕ: УМЕНЬШЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Действительное число value должно располагаться ТОЛЬКО СПРАВА от матрицы A:
// B = A - const, B(i,j) = A(i,j) - const
//Для осуществления операции вычитания из матрицы числа необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается матрица нулевого размера.
//Результатом вычитания из матрицы числа всегда является МАТРИЦА.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& A - ссылка на комплексную матрицу, компоненты которой
//   уменьшаются на вещественное число value.
//2. const double value - вещественное число, вычитаемое из матрицы.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица A, уменьшенная на значение value
//******************************************************************************
cmatrix operator -(const cmatrix& A, const double value)
{cmatrix result;
 if (A.IsZeroSize()) return result;//Матрица нулевого размера
 result.Set(A.Rows(),A.Cols(),false);
 //Цикл уменьшения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; i < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)-value);
 return result;
}
//******************************************************************************
//СТАТУС: I.6, friend function of the TComplexMatrix class
//OVERLOADING DECREASE OPERATION (-) by Decreasing Matrix on the Complex Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cmatrix operator -(const cmatrix& A, const complex value)
//НАЗНАЧЕНИЕ: УМЕНЬШЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА КОМПЛЕКСНУЮ ВЕЛИЧИНУ value.
//Комплексное число value должно располагаться ТОЛЬКО СПРАВА от матрицы A:
// B = A - const, B(i,j) = A(i,j) - const
//Для осуществления операции вычитания из матрицы числа необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается матрица нулевого размера.
//Результатом вычитания из матрицы числа всегда является МАТРИЦА.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& A - ссылка на комплексную матрицу, компоненты которой
//   уменьшаются на вещественное число value.
//2. const complex value - комплексное число, вычитаемое из матрицы.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица A, уменьшенная на значение value
//******************************************************************************
cmatrix operator -(const cmatrix& A, const complex value)
{cmatrix result;
 if (A.IsZeroSize()) return result;//Матрица нулевого размера
 result.Set(A.Rows(),A.Cols(),false);
 //Цикл уменьшения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; i < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)-value);
 return result;
}
//******************************************************************************
//СТАТУС: I.7, friend function of the TComplexMatrix class
//OVERLOADING MULTIPLICATION OPERATION (*) by Multiply Matrix on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cmatrix operator *(const double value, const cmatrix& A)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Число умножается слева: B = const * A, B(i,j) = A(i,j) * const
//Для осуществления операции умножения матрицы на число необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается матрица нулевого размера.
//Результатом умножения матрицы на число всегда является МАТРИЦА.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const double value - вещественное число, умножаемое на матрицу.
//2. const cmatrix& A - ссылка на комплексную матрицу, компоненты которой
//   умножаются на вещественное число value.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица А, умноженная на значение value
//******************************************************************************
cmatrix operator *(const double value, const cmatrix& A)
{cmatrix result;
 if (A.IsZeroSize()) return result;//Матрица нулевого размера
 result.Set(A.Rows(),A.Cols(),false);
 //Цикл умножения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)*value);
 return result;
}
//******************************************************************************
//СТАТУС: I.8, friend function of the TComplexMatrix class
//OVERLOADING MULTIPLICATION OPERATION (*) by Multiply Matrix on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cmatrix operator *(const cmatrix& A, const double value)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Число умножается справа: B = A * const, B(i,j) = A(i,j) * const
//Для осуществления операции умножения матрицы на число необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается матрица нулевого размера.
//Результатом умножения матрицы на число всегда является МАТРИЦА.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& A - ссылка на комплексную матрицу, компоненты которой
//   умножаются на вещественное число value.
//2. const double value - вещественное число, умножаемое на матрицу.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: сmatrix result - матрица А, умноженная на значение value
//******************************************************************************
cmatrix operator *(const cmatrix& A, const double value)
{cmatrix result;
 if (A.IsZeroSize()) return result;//Матрица нулевого размера
 result.Set(A.Rows(),A.Cols(),false);
 //Цикл умножения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)*value);
 return result;
}
//******************************************************************************
//СТАТУС: I.9, friend function of the TComplexMatrix class
//OVERLOADING MULTIPLICATION OPERATION (*) by Multiply Matrix on the Complex Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cmatrix operator *(const complex value, const cmatrix& A)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА КОМПЛЕКСНУЮ ВЕЛИЧИНУ value.
//Число умножается слева:
//B = const * A, B(i,j) = A(i,j) * const
//Для осуществления операции умножения матрицы на число необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается матрица нулевого размера.
//Результатом умножения матрицы на число всегда является МАТРИЦА.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const complex value - комплексное число, умножаемое на матрицу.
//2. const cmatrix& A - ссылка на комплексную матрицу, компоненты которой
//   умножаются на комплексное число value.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица А, умноженная на значение value
//******************************************************************************
cmatrix operator *(const complex value, const cmatrix& A)
{cmatrix result;
 if (A.IsZeroSize()) return result;//Матрица нулевого размера
 result.Set(A.Rows(),A.Cols(),false);
 //Цикл умножения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)*value);
 return result;
}
//******************************************************************************
//СТАТУС: I.10, friend function of the TComplexMatrix class
//OVERLOADING MULTIPLICATION OPERATION (*) by Multiply Matrix on the Complex Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cmatrix operator *(const cmatrix& A, const complex value)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА КОМПЛЕКСНУЮ ВЕЛИЧИНУ value.
//Число умножается справа: B = A * const, B(i,j) = A(i,j) * const
//Для осуществления операции умножения матрицы на число необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОЙ ДЛИНЫ.
//Если условие не выполняется, то возвращается матрица нулевого размера.
//Результатом умножения матрицы на число всегда является МАТРИЦА.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& A - ссылка на комплексную матрицу, компоненты которой
//   умножаются на комплексное число value.
//2. const complex value - комплексное число, умножаемое на матрицу.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: сmatrix result - матрица А, умноженная на значение value
//******************************************************************************
cmatrix operator *(const cmatrix& A, const complex value)
{cmatrix result;
 if (A.IsZeroSize()) return result;//Матрица нулевого размера
 result.Set(A.Rows(),A.Cols(),false);
 //Цикл умножения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)*value);
 return result;
}
//******************************************************************************
//СТАТУС: I.11, public function of the TComplexMatrix class
//OVERLOADING DIVISION OPERATION (/) by Dividing Matrix on the Real Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix operator /(const double value) const
//НАЗНАЧЕНИЕ: ДЕЛЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ДЕЙСТВИТЕЛЬНУЮ ВЕЛИЧИНУ value.
//Операция деления некоммутативна и делитель (value) располагается только слева
//от комплексной матрицы: B = A / const, B(i,j) = A(i,j) / const
//Для осуществления операции деления матрицы на число необходимо два условия:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОЙ ДЛИНЫ.
//2. Делитель value не должен быть РАВНЫМ НУЛЮ.
//Если условия не выполняются, то возвращается матрица нулевого размера.
//Результатом умножения матрицы на число всегда является МАТРИЦА.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const double value - вещественное число-делитель
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица A, поделенная на value
//******************************************************************************
cmatrix TComplexMatrix::operator /(const double value) const
{cmatrix result;
 if (IsZeroSize()) return result;//Матрица нулевого размера
 if (fabs(value) < EPS) return result;//Деление на ноль
 result.Set(Rows(),Cols(),false);
 //Цикл деления компонент матрицы на величину value
 for (ulong i = 0L; i < result.Rows(); i++)
  for (ulong j = 0L; j < result.Cols(); j++)
   result.Put(i,j,data[i][j]/value);
 return result;
}
//******************************************************************************
//СТАТУС: I.12, public function of the TComplexMatrix class
//OVERLOADING DIVISION OPERATION (/) by Dividing Matrix on the Complex Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix operator /(const complex value) const
//НАЗНАЧЕНИЕ: ДЕЛЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА КОМПЛЕКСНУЮ ВЕЛИЧИНУ value.
//Операция деления некоммутативна и делитель (value) располагается всегда слева
//от комплексной матрицы: B = A / const, B(i,j) = A(i,j) / const
//Для осуществления операции деления матрицы на число необходимо два условия:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОЙ ДЛИНЫ.
//2. Делитель value не должен быть РАВНЫМ НУЛЮ.
//Если условия не выполняются, то возвращается матрица нулевого размера.
//Результатом умножения матрицы на число всегда является МАТРИЦА.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const complex value - комплексное число-делитель
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица A, поделенная на value
//******************************************************************************
cmatrix TComplexMatrix::operator /(const complex value) const
{cmatrix result;
 if (IsZeroSize()) return result;//Матрица нулевого размера
 if (abs(value) < EPS) return result;//Деление на ноль
 result.Set(Rows(),Cols(),false);
 //Цикл деления компонент матрицы A на величину value
 for (ulong i = 0L; i < result.Rows(); i++)
  for (ulong j = 0L; j < result.Cols(); j++)
   result.Put(i,j,data[i][j]/value);
 return result;
}
//******************************************************************************
//СТАТУС: I.13; public TComplexMatrix class overloading operator +
//OVERLOADING ADDITION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix operator +(const cmatrix& A) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СЛОЖЕНИЯ ДВУХ КОМПЛЕКСНЫХ МАТРИЦ.
//Перегрузка оператора (+) для сложения двух комплексных матриц A и B:
//C = A + B, C(i,j) = A(i,j) + B(i,j).
//При сложении двух матриц должны выполняться следующие правила:
//1. Матрицы не должны быть матрицами НУЛЕВОЙ РАЗМЕРНОСТИ;
//2. Матрицы должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ:
//   A.Rows() == B.Rows() || A.Cols() == B.Cols()
//Если данные условия не выполняются, то возвращается матрица нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TComplexMatrix& A - ссылка на складываемую матрицу
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица суммы двух матриц.
//***********************-******************************************************
cmatrix TComplexMatrix::operator +(const TComplexMatrix& A) const
{cmatrix result;
 //Матрица (матрицы) нулевого размера
 if ((IsZeroSize()) || (A.IsZeroSize())) return result;
 //Операция сложения производится с матрицами разных размерностей
 if ((Rows() != A.Rows()) || (Cols() != A.Cols())) return result;
 //Копирование исходной матрицы
 result.Set(Rows(),Cols(),false);
 //Операция сложения двух матриц
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
   result.Put(i,j,data[i][j]+A.Get(i,j));
 return result; //Матрица суммы двух матриц
}
//******************************************************************************
//СТАТУС: I.14; public TComplexMatrix class overloading operator +
//OVERLOADING ADDITION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cmatrix operator +(const rmatrix& A, const cmatrix& B)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СЛОЖЕНИЯ КОМПЛЕКСНОЙ И ВЕЩЕСТВЕННОЙ МАТРИЦ.
//Перегрузка оператора (+) для сложения комплексной и вещественной матриц A и B.
//Вещественная матрица прибавляется слева: C = A + B, C(i,j) = A(i,j) + B(i,j).
//Результатом сложения вещественной и комплексной матрицы является КОМПЛЕКСНАЯ
//МАТРИЦА. При сложении двух матриц должны выполняться следующие правила:
//1. Матрицы не должны быть матрицами НУЛЕВОЙ РАЗМЕРНОСТИ;
//2. Матрицы должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ:
//   A.Rows() == B.Rows() || A.Cols() == B.Cols()
//Если данные условия не выполняются, то возвращается матрица нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& A - ссылка на вещественную матрицу.
//2. const cmatrix& B - ссылка на комплексную матрицу.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица суммы двух матриц
//******************************************************************************
cmatrix operator +(const rmatrix& A, const cmatrix& B)
{cmatrix result;
 //Матрица (матрицы) нулевого размера
 if ((A.IsZeroSize()) || (B.IsZeroSize())) return result;
 //Операция сложения производится с матрицами разных размерностей
 if ((A.Rows() != B.Rows()) || (A.Cols() != B.Cols())) return result;
 result.Set(A.Rows(),A.Cols(),false);
 //Операция сложения двух матриц
 for (ulong i = 0; i < A.Rows(); i++)
  for (ulong j = 0; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)+B.Get(i,j));
 return result; //Матрица суммы двух матриц
}
//******************************************************************************
//СТАТУС: I.15; public; TComplexMatrix class overloading operator +
//OVERLOADING ADDITION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//   friend cmatrix operator +(const cmatrix& A, const rmatrix& B)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СЛОЖЕНИЯ КОМПЛЕКСНОЙ И ВЕЩЕСТВЕННОЙ МАТРИЦ.
//Перегрузка оператора (+) с целью сложения комплексной и вещественной матриц A
//и B. Вещественная матрица прибавляется справа: C = A + B, C(i,j) = A(i,j) + B(i,j).
//Результатом сложения вещественной и комплексной матрицы является КОМПЛЕКСНАЯ
//МАТРИЦА. При сложении двух матриц должны выполняться следующие правила:
//1. Матрицы не должны быть матрицами НУЛЕВОЙ РАЗМЕРНОСТИ;
//2. Матрицы должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ:
//   A.Rows() == B.Rows() || A.Cols() == B.Cols()
//Если данные условия не выполняются, то возвращается матрица нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& B - ссылка на комплексную матрицу.
//2. const rmatrix& A - ссылка на вещественную матрицу.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица суммы двух матриц.
//******************************************************************************
cmatrix operator +(const cmatrix& A, const rmatrix& B)
{cmatrix result;
 //Матрица (матрицы) нулевого размера
 if ((A.IsZeroSize()) || (B.IsZeroSize())) return result;
 //Операция сложения производится с матрицами разных размерностей
 if ((A.Rows() != B.Rows()) || (A.Cols() != B.Cols())) return result;
 result.Set(A.Rows(),A.Cols(),false);
 //Операция сложения двух матриц
 for (ulong i = 0; i < A.Rows(); i++)
  for (ulong j = 0; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)+B.Get(i,j));
 return result; //Матрица суммы двух матриц
}
//******************************************************************************
//СТАТУС: I.16; public TComplexMatrix class overloading operator -
//OVERLOADING SUBTRACTION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix operator -(const TComplexMatrix& A) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЧИТАНИЯ ДВУХ МАТРИЦ.
//Перегрузка оператора (-) вычитания двух комплексных матриц A и B:
//C = A - B, C(i,j) = A(i,j) - B(i,j).
//При вычитании двух матриц должны выполняться следующие правила:
//1. Матрицы не должны быть матрицами НУЛЕВОЙ РАЗМЕРНОСТИ;
//2. Матрицы должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ:
//   A.Rows() == B.Rows() || A.Cols() == B.Cols()
//Если данные условия не выполняются, то возвращается матрица нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TComplexMatrix& A - ссылка на вычитаемую матрицу
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица разности двух матриц
//******************************************************************************
cmatrix TComplexMatrix::operator -(const TComplexMatrix& A) const
{cmatrix result;
 //Матрица (матрицы) нулевого размера
 if ((IsZeroSize()) || (A.IsZeroSize())) return result;
 //Операция вычитания производится с матрицами разной размерности
 if ((Rows() != A.Rows()) || (Cols() != A.Cols())) return result;
 result.Set(Rows(),Cols(),false);
 //Операция вычитания двух матриц
 for (ulong i = 0; i < result.Rows(); i++)
  for (ulong j = 0; j < result.Cols(); j++)
   result.Put(i,j,data[i][j]-A.Get(i,j));
 return result; //Вектор разности двух векторов
}
//******************************************************************************
//СТАТУС: I.17; public; TComplexMatrix class overloading operator -
//OVERLOADING SUBTRACTION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix operator -(const TRealMatrix& A) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЧИТАНИЯ ДВУХ МАТРИЦ.
//Перегрузка оператора (-) вычитания из комплексной матрицы вещественной матрицы.
//Результат - КОМПЛЕКСНАЯ МАТРИЦА C. A и B: C = A - B, C(i,j) = A(i,j) - B(i,j).
//При вычитании двух матриц должны выполняться следующие правила:
//1. Матрицы не должны быть матрицами НУЛЕВОЙ РАЗМЕРНОСТИ;
//2. Матрицы должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ:
//   A.Rows() == B.Rows() || A.Cols() == B.Cols()
//Если данные условия не выполняются, то возвращается матрица нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// const TRealMatrix& A - ссылка на вычитаемую вещественную матрицу
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица разности двух матриц
//******************************************************************************
cmatrix TComplexMatrix::operator -(const TRealMatrix& A) const
{cmatrix result;
 //Операция вычитания производится с матрицей (матрицами) нулевого размера
 if ((IsZeroSize()) || (A.IsZeroSize())) return result;
 //Операция вычитания производится с матрицами разной размерности
 if ((Rows() != A.Rows()) || (Cols() != A.Cols())) return result;
 result.Set(Rows(),Cols(),false);
 //Операция вычитания двух матриц
 for (ulong i = 0; i < result.Rows(); i++)
  for (ulong j = 0; j < result.Cols(); j++)
   result.Put(i,j,data[i][j]-A.Get(i,j));
 return result; //Вектор разности двух векторов
}
//******************************************************************************
//СТАТУС: I.18; public; TComplexMatrix class overloading operator *
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix operator *(const TComplexMatrix& A) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ ДВУХ КОМПЛЕКСНЫХ МАТРИЦ.
//Перегрузка оператора (*) для умножения двух комплексных матриц A(m x n) и B(n x p):
//C(m x p) = A(m x n) * B(n x p), где каждый элемент матрицы С вычисляется по формуле:
//C(i,j) = SUM{A(i,k)*B(k,j) by k, 0 <= k < n}
//Правила умножения матрицы на матрицу следующие:
//1. Количество СТОЛБЦОВ матрицы слева A(m x n) должно быть РАВНО количеству
//   СТРОК матрицы справа B(n x p).
//2. Размерности матриц A & B не должны быть нулевыми.
//3. При умножении матриц согласно правил 1 и 2 всегда получается МАТРИЦА размер-
//   ности равной числу СТРОК матрицы слева и числу СТОЛБЦОВ матрицы справа:
//   C(m x p) = A(m x n) * B(n x p).
//Если условия 1, 2 не выполняются, то возвращается матрица нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const TComplexMatrix& A - ссылка на умножаемую матрицу справа
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица умножения двух матриц
//******************************************************************************
cmatrix TComplexMatrix::operator *(const TComplexMatrix& A) const
{cmatrix result;
 //Операция умножения производится с матрицей (матрицами) нулевого размера
 if ((IsZeroSize()) || (A.IsZeroSize())) return result;
 //Операция умножения производится с матрицами неподходящих для умножения
 //размерностей
 if (Cols() != A.Rows()) return result;
 result.Set(Rows(),A.Cols(),C_ZERO);
 //Операция перемножения двух матриц
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < A.Cols(); j++)
   for (ulong k = 0; k < Cols(); k++)
    result.Put(i,j,result.Get(i,j) + data[i][k]*A.Get(k,j));
 return result; //Матрица перемножения двух матриц
}
//******************************************************************************
//СТАТУС: I.19; public; TComplexMatrix class overloading operator *
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cmatrix operator *(const rmatrix& A, const cmatrix& B)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ СПРАВА ВЕЩЕСТВЕННОЙ МАТРИЦЫ НА
//            КОМПЛЕКСНУЮ МАТРИЦУ.
//Перегрузка оператора (*) для умножения справа вещественной матрицы на комплекс-
//ную матрицу A(m x n) и B(n x p): C(m x p) = A(m x n) * B(n x p), где каждый
//элемент матрицы С вычисляется по следующей формуле:
// C(i,j) = SUM{A(i,k)*B(k,j) by k, 0 <= k < n}
//Результат умножения - КОМПЛЕКСНАЯ МАТРИЦА C. Правила умножения матрицы на мат-
//рицу следующие:
//1. Количество СТОЛБЦОВ матрицы слева A(m x n) должно быть РАВНО количеству
//   СТРОК матрицы справа B(n x p).
//2. Размерности матриц A & B не должны быть нулевыми.
//3. При умножении матриц согласно правил 1 и 2 всегда получается МАТРИЦА размер-
//   ности равной числу СТРОК матрицы слева и числу СТОЛБЦОВ матрицы справа:
//   C(m x p) = A(m x n) * B(n x p).
//Если условия 1, 2 не выполняются, то возвращается матрица нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const rmatrix& A - ссылка на вещественную матрицу.
//2. const сmatrix& B - ссылка на комплексную матрицу.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица умножения двух матриц
//******************************************************************************
cmatrix operator *(const rmatrix& A, const cmatrix& B)
{cmatrix result;
 //Матрица (матрицы) нулевого размера
 if ((A.IsZeroSize()) || (B.IsZeroSize())) return result;
 //Операция умножения производится с матрицами неподходящих для умножения
 //размерностей
 if (A.Cols() != B.Rows()) return result;
 result.Set(A.Rows(),B.Cols(),C_ZERO);
 //Операция перемножения двух матриц
 for (ulong i = 0; i < A.Rows(); i++)
  for (ulong j = 0; j < B.Cols(); j++)
   for (ulong k = 0; k < A.Cols(); k++)
    result.Put(i,j,result.Get(i,j) + A.Get(i,k)*B.Get(k,j));
 return result;//Матрица перемножения двух матриц
}
//******************************************************************************
//СТАТУС: I.20; public; TComplexMatrix class overloading operator *
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cmatrix operator *(const cmatrix& A, const rmatrix& B)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ СЛЕВА ВЕЩЕСТВЕННОЙ МАТРИЦЫ НА
//            КОМПЛЕКСНУЮ МАТРИЦУ.
//Перегрузка оператора (*) с целью умножения слева вещественной матрицы на комп-
//лексную матрицу A(m x n) и B(n x p): C(m x p) = A(m x n) * B(n x p), где каждый
//элемент матрицы С вычисляется по следующей формуле:
// C(i,j) = SUM{A(i,k)*B(k,j) by k, 0 <= k < n}
//Результат умножения - КОМПЛЕКСНАЯ МАТРИЦА C.
//Правила умножения матрицы на матрицу следующие:
//1. Количество СТОЛБЦОВ матрицы слева A(m x n) должно быть РАВНО количеству
//   СТРОК матрицы справа B(n x p).
//2. Размерности матриц A & B не должны быть нулевыми.
//3. При умножении матриц согласно правил 1 и 2 всегда получается МАТРИЦА размер-
//   ности равной числу СТРОК матрицы слева и числу СТОЛБЦОВ матрицы справа:
//   C(m x p) = A(m x n) * B(n x p).
//Если условия 1, 2 не выполняются, то возвращается матрица нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const сmatrix& B - ссылка на комплексную матрицу.
//2. const rmatrix& A - ссылка на вещественную матрицу.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - матрица умножения двух матриц.
//******************************************************************************
cmatrix operator *(const cmatrix& A, const rmatrix& B)
{cmatrix result;
 //Операция умножения производится с матрицей (матрицами) нулевого размера
 if ((A.IsZeroSize()) || (B.IsZeroSize())) return result;
 //Операция умножения производится с матрицами неподходящих для умножения
 //размерностей
 if (A.Cols() != B.Rows()) return result;
 result.Set(A.Rows(),B.Cols(),C_ZERO);
 //Операция перемножения двух матриц
  for (ulong i = 0; i < A.Rows(); i++)
   for (ulong j = 0; j < B.Cols(); j++)
    for (ulong k = 0; k < A.Cols(); k++)
     result.Put(i,j,result.Get(i,j) + A.Get(i,k) * B.Get(k,j));
 return result; //Матрица перемножения двух матриц
}
//******************************************************************************
//СТАТУС: I.21, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix MultByCols(const cvector& V) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ ВСЕХ СТОЛБЦОВ МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
//            КОМПЛЕКСНОГО ВЕКТОРА
//Функция последовательно перемножает все столбцы матрицы на значения элементов
//вектора. Размерность вектора должна быть равна количеству строк матрицы.
//Результатом работы функции является комплексная матрица, совпадающая по разме-
//рам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции перемножения значений элементов матрицы на зна-
//чения элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const cvector& V - ссылка на комплексный вектор, умно-
//жаемый поэлементно на все столбцы исходной матрицы.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::MultByCols(const cvector& V) const
{cmatrix result;
 //Проверка на выполнение условий поэлементного умножения столбцов исходной мат-
 //рицы на значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows())) return result;
 //Поэлементное умножение всех столбцов исходной матрицы на вектор V
 result.Set(Rows(),Cols(),false);
 for (ulong j = 0L; j < Cols(); j++)
  for (ulong i = 0L; i < Rows(); i++)
   result.Put(i,j,data[i][j]*V.Get(i));
 return result;
}
//******************************************************************************
//СТАТУС: I.22, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix MultByCols(const cvector& V, ulong index) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ СТОЛБЦА МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
//            КОМПЛЕКСНОГО ВЕКТОРА
//Функция перемножает столбец матрицы с индексом index на значения элементов
//вектора V. Размерность вектора должна быть равна количеству строк матрицы.
//Результатом работы функции является комплексная матрица, совпадающая по раз-
//мерам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции перемножения значений элементов матрицы на зна-
//чения элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы;
//4. Значение индекса столбца index является недопустимым для данной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, умножаемый поэлементно
//   на столбец исходной матрицы с индексом index;
//2. ulong index - индекс столбца, перемножаемого поэлементно с вектором V.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::MultByCols(const cvector& V, ulong index) const
{cmatrix result;
 //Проверка на выполнение условий поэлементного умножения столбца исходной мат-
 //рицы на значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows()) || (index >= Cols()))
  return result;
 //Поэлементное умножение столбца с индексом index исходной матрицы на вектор V
 result = *this;
 for (ulong i = 0L; i < Rows(); i++) result.Put(i,index,data[i][index]*V.Get(i));
 return result;
}
//******************************************************************************
//СТАТУС: I.23, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix MultByCols(const cvector& V, ulong left, ulong right) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ СТОЛБЦОВ МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
//            КОМПЛЕКСНОГО ВЕКТОРА, РАСПОЛОЖЕННЫХ В ИНТЕРВАЛЕ [left..right]
//Функция перемножает столбцы матрицы с индексами, расположенными последователь-
//но в интервале целых чисел [left..right], на значения элементов вектора V.
//Размерность вектора должна быть равна количеству строк матрицы. Аргумент left
//определяет начальное значение интервала индексов столбцов, а аргумент right -
//конечное значение интервала индексов столбцов, элементы которых перемножаются
//на вектор V.
//Результатом работы функции является комплексная матрица, совпадающая по раз-
//мерам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции перемножения значений элементов матрицы на зна-
//чения элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы;
//4. Значения индексов left или right являются недопустимыми для данной матрицы;
//5. Значение индекса left > right.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, умножаемый поэлементно
//   на столбцы с индексами исходной матрицы, расположенными в интервале
//   [left..right];
//2. ulong left - начальное значение интервала индексов столбцов, перемножаемых
//   поэлементно с вектором V.
//3. ulong right - конечное значение интервала индексов столбцов, перемножаемых
//   поэлементно с вектором V.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::MultByCols(const cvector& V, ulong left, ulong right)
const
{cmatrix result;
 //Проверка на выполнение условий поэлементного умножения столбцов исходной мат-
 //рицы на значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows()) ||
     (left >= Cols()) || (right >= Cols()) || (left > right))
  return result;
 //Поэлементное умножение столбцов с индексами, расположенными в интервале
 //[left..right], исходной матрицы на вектор V
 result = *this;
 for (ulong j = left; j <= right ; j++)
  for (ulong i = 0L; i < Rows(); i++)
   result.Put(i,j,data[i][j]*V.Get(i));
 return result;
}
//******************************************************************************
//СТАТУС: I.24, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//cmatrix MultByCols(const cvector& V, const ivector& index, bool check = false) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ СТОЛБЦОВ МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
// КОМПЛЕКСНОГО ВЕКТОРА, ИНДЕКСЫ КОТОРЫХ СОДЕРЖАТСЯ В ВЕКТОРЕ index
//  Функция перемножает столбцы матрицы с индексами, значения которых передаются
//целочисленным вектором index, на значения элементов вектора V. Размерность
//вектора V должна быть равна количеству строк матрицы.
//  Аргумент check указывает на проведение проверки значений индексов на соот-
//ветствие допустимым значениям индексов столбцов исходной матрицы и формирова-
//нию подвектора вектора index, который содержит только корректные значения ин-
//дексов столбцов для данной матрицы. Если check = true, создается объект-преди-
//кат, который осуществляет селекцию корректных значений индексов, и формируется
//подвектор вектора index с корректными значениями индексов. Созданный подвектор
//далее используется для выбора столбцов матрицы перемножаемых поэлементно с век-
//тором V.
//При check = false фильтрация некорректных значений индексов не осуществляется.
//В этом случае ответственность за корректность всех значений индексов возлагает-
//ся на пользователя и при некорректном задании значения индекса, выходящего за
//пределы допустимого значения индекса столбца для данной матрицы, приведет к
//аварийному завершению работы всей программы. При check = false функция быстрее
//выполняет необходимые действия, так как не тратится время на фильтрацию некор-
//ректных значений индексов, передавемых вектором index.
//Результатом работы функции является комплексная матрица, совпадающая по разме-
//рам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции перемножения значений элементов матрицы на зна-
//чения элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы;
//4. Вектор index - вектор нулевого размера;
//5. При check == true, получился подвектор вектора индексов столбцов нулевого
//   размера, т.е. исходный вектор индексов столбцов index не содержал ни одного
//   допустимого значения индекса столбца для данной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, умножаемый поэлементно
//   на столбцы исходной матрицы с индексами, расположенными в векторе index;
//2. const ivector& index - ссылка на вектор с индексами столбцов, перемножаемых
//   поэлементно с вектором V.
//3. bool check (false) - индикатор отбора допустимых значений индексов столбцов
//   исходной матрицы, перемножаемых поэлементно с вектором V, из вектора index.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::MultByCols(const cvector& V, const ivector& index,
                                   bool check) const
{cmatrix result;
 //Проверка на выполнение условий поэлементного умножения столбцов исходной мат-
 //рицы на значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows()) || (index.IsZeroSize()))
  return result;
 //Выбор подвектора Index корректных индексов столбцов из вектора index
 ivector Index(index);//Копирование вектора index
 if (check == ON)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Cols()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  Index = Index.Unique();
  if (Index.IsZeroSize()) return result;
 }
 //Поэлементное умножение столбцов с индексами, значения которых расположены в
 //целочисленном векторе Index, исходной матрицы на вектор V
 result = *this;
 for (ulong j = 0; j < Index.Size(); j++)
  for (ulong i = 0L; i < Rows(); i++)
   result.Put(i,Index.Get(j),data[i][Index.Get(j)]*V.Get(i));
 return result;
}
//******************************************************************************
//СТАТУС: I.25, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix MultByRows(const cvector& V) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ ВСЕХ СТРОК МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
//            КОМПЛЕКСНОГО ВЕКТОРА
//Функция последовательно перемножает все строки матрицы на значения элементов
//вектора. Размерность вектора должна быть равна количеству столбцов матрицы.
//Результатом работы функции является комплексная матрица, совпадающая по разме-
//рам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции перемножения значений элементов матрицы на зна-
//чения элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const cvector& V - ссылка на комплексный вектор, умно-
//жаемый поэлементно на все строки исходной матрицы.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::MultByRows(const cvector& V) const
{cmatrix result;
 //Проверка на выполнение условий поэлементного умножения строк исходной матрицы
 //на значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols())) return result;
 //Поэлементное умножение всех строк исходной матрицы на вектор V
 result.Set(Rows(),Cols(),false);
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(i,j,data[i][j]*V.Get(j));
 return result;
}
//******************************************************************************
//СТАТУС: I.26, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix MultByRows(const cvector& V, ulong index) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ СТРОКИ МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
//            КОМПЛЕКСНОГО ВЕКТОРА
//Функция перемножает строку матрицы с индексом index на значения элементов
//вектора V. Размерность вектора должна быть равна количеству столбцов матрицы.
//Результатом работы функции является комплексная матрица, совпадающая по раз-
//мерам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции перемножения значений элементов матрицы на зна-
//чения элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы;
//4. Значение индекса строки index является недопустимым для данной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, умножаемый поэлементно
//   на строку исходной матрицы с индексом index;
//2. ulong index - индекс строки, перемножаемого поэлементно с вектором V.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::MultByRows(const cvector& V, ulong index) const
{cmatrix result;
 //Проверка на выполнение условий поэлементного умножения строки исходной матрицы
 //на значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols()) || (index >= Rows()))
  return result;
 //Поэлементное умножение строки с индексом index исходной матрицы на вектор V
 result = *this;
 for (ulong j = 0L; j < Cols(); j++) result.Put(index,j,data[index][j]*V.Get(j));
 return result;
}
//******************************************************************************
//СТАТУС: I.27, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix MultByRows(const cvector& V, ulong left, ulong right) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ СТРОК МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
//            КОМПЛЕКСНОГО ВЕКТОРА, РАСПОЛОЖЕННЫХ В ИНТЕРВАЛЕ [left..right]
//Функция перемножает строки матрицы с индексами, расположенными последователь-
//но в интервале целых чисел [left..right], на значения элементов вектора V.
//Размерность вектора должна быть равна количеству столбцов матрицы. Аргумент
//left определяет начальное значение интервала индексов строк, а аргумент right
//- конечное значение интервала индексов строк, элементы которых перемножаются
//на вектор V.
//Результатом работы функции является комплексная матрица, совпадающая по разме-
//рам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции перемножения значений элементов матрицы на зна-
//чения элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы;
//4. Значения индексов left или right являются недопустимыми для данной матрицы;
//5. Значение индекса left > right.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, умножаемый поэлементно
//   на строки исходной матрицы с индексами в интервале [left..right];
//2. ulong left - начальное значение интервала индексов строк, перемножаемых
//   поэлементно с вектором V.
//3. ulong right - конечное значение интервала индексов строк, перемножаемых
//   поэлементно с вектором V.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::MultByRows(const cvector& V, ulong left, ulong right) const
{cmatrix result;
 //Проверка на выполнение условий поэлементного умножения строк исходной матрицы
 //на значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols()) ||
     (left >= Rows()) || (right >= Rows()) || (left > right))
  return result;
 //Поэлементное умножение строк с индексами, расположенными в интервале
 //[left..right], исходной матрицы на вектор V
 result = *this;
 for (ulong i = left; i <= right ; i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(i,j,data[i][j]*V.Get(j));
 return result;
}
//******************************************************************************
//СТАТУС: I.28, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//cmatrix MultByRows(const cvector& V, const ivector& index, bool check = false) const
//НАЗНАЧЕНИЕ: ПОЭЛЕМЕНТНОЕ УМНОЖЕНИЕ СТРОК МАТРИЦЫ НА ЗНАЧЕНИЯ ЭЛЕМЕНТОВ
// КОМПЛЕКСНОГО ВЕКТОРА, ИНДЕКСЫ КОТОРЫХ СОДЕРЖАТСЯ В ВЕКТОРЕ index
//  Функция перемножает строки матрицы с индексами, значения которых передаются
//целочисленным вектором index, на значения элементов вектора V. Размерность
//вектора V должна быть равна количеству столбцов матрицы.
//  Аргумент check указывает на проведение проверки значений индексов на соот-
//ветствие допустимым значениям индексов строк исходной матрицы и формированию
//подвектора вектора index, который содержит только корректные значения индексов
//строк для данной матрицы. Если check = true, создается объект-предикат, кото-
//рый осуществляет селекцию корректных значений индексов, и формируется подвек-
//тор вектора index с корректными значениями индексов. Созданный подвектор далее
//используется для выбора строк матрицы перемножаемых поэлементно с вектором V.
//  При check = false фильтрация некорректных значений индексов не осуществляет-
//ся. В этом случае ответственность за корректность всех значений индексов строк
//возлагается на пользователя и при некорректном задании значения индекса, выхо-
//дящего за пределы допустимого значения индекса строки для данной матрицы, при-
//ведет к аварийному завершению работы всей программы. При check = false функция
//быстрее выполняет необходимые действия, так как не тратится время на фильтра-
//цию некорректных значений индексов, передавемых вектором index.
//Результатом работы функции является комплексная матрица, совпадающая по разме-
//рам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции перемножения значений элементов матрицы на зна-
//чения элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы;
//4. Вектор index - вектор нулевого размера;
//5. При check == true, получился подвектор вектора индексов строк нулевого
//   размера, т.е. исходный вектор индексов строк index не содержал ни одного
//   допустимого значения индекса строки для данной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, умножаемый поэлементно
//   на строки исходной матрицы с индексами, размещенными в векторе index;
//2. const ivector& index - ссылка на вектор с индексами строк, перемножаемых
//   поэлементно с вектором V.
//3. bool check (false) - индикатор отбора допустимых значений индексов строк
//   исходной матрицы, перемножаемых поэлементно с вектором V, из вектора index.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::MultByRows(const cvector& V, const ivector& index,
                                   bool check) const
{cmatrix result;
 //Проверка на выполнение условий поэлементного умножения строк исходной матрицы
 //на значения элементов вектора V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols()) ||
     (index.IsZeroSize()))
  return result;
 //Выбор подвектора Index корректных индексов строк из вектора index
 ivector Index(index);//Копирование вектора index
 if (check == ON)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Cols()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  Index = Index.Unique();
  if (Index.IsZeroSize()) return result;
 }
 //Поэлементное умножение строк с индексами, значения которых расположены в
 //целочисленном векторе Index, исходной матрицы на вектор V
 result = *this;
 for (ulong i = 0; i < Index.Size(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(Index.Get(i),j,data[Index.Get(i)][j]*V.Get(j));
 return result;
}
//******************************************************************************
//СТАТУС: I.29, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix AddByCols(const cvector& V) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ ВСЕХ СТОЛБЦОВ МАТРИЦЫ С КОМПЛЕКСНЫМ ВЕКТОРОМ
//   Функция прибавляет ко всем столбцам матрицы вектор V. Размерность вектора
//должна быть равна количеству строк матрицы.
//Результатом работы функции является комплексная матрица, совпадающая по разме-
//рам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции сложения значений элементов матрицы на значения
//элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const cvector& V - ссылка на комплексный вектор,
//прибавляемый ко всем столбцам исходной матрицы.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::AddByCols(const cvector& V) const
{cmatrix result;
 //Проверка выполнения условий сложения столбцов исходной матрицы с вектором V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows())) return result;
 //Сложение всех столбцов исходной матрицы на вектор V
 result.Set(Rows(),Cols(),false);
 for (ulong j = 0L; j < Cols(); j++)
  for (ulong i = 0L; i < Rows(); i++)
   result.Put(i,j,data[i][j]+V.Get(i));
 return result;
}
//******************************************************************************
//СТАТУС: I.30, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix MultByCols(const cvector& V, ulong index) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТОЛБЦА МАТРИЦЫ С КОМПЛЕКСНЫМ ВЕКТОРОМ
//Функция прибавляет к столбцу матрицы с индексом index вектор V. Размерность
//вектора должна быть равна количеству строк матрицы.
//Результатом работы функции является комплексная матрица, совпадающая по раз-
//мерам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции сложения значений элементов матрицы на значения
//элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы;
//4. Значение индекса столбца index является недопустимым для данной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, складываемый со столбцом
//   исходной матрицы с индексом index;
//2. ulong index - индекс столбца, складываемого с вектором V.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::AddByCols(const cvector& V, ulong index) const
{cmatrix result;
 //Проверка выполнения условий сложения столбца исходной матрицы с вектором V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows()) || (index >= Cols()))
  return result;
 //Сложение столбца с индексом index исходной матрицы на вектор V
 result = *this;
 for (ulong i = 0L; i < Rows(); i++) result.Put(i,index,data[i][index]+V.Get(i));
 return result;
}
//******************************************************************************
//СТАТУС: I.31, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix AddByCols(const cvector& V, ulong left, ulong right) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТОЛБЦОВ МАТРИЦЫ С КОМПЛЕКСНЫМ ВЕКТОРОМ, РАСПОЛОЖЕННЫХ В
//            ИНТЕРВАЛЕ [left..right]
//Функция прибавляет к столбцам матрицы с индексами, расположенными последова-
//тельно в интервале целых чисел [left..right], вектор V.
//Размерность вектора должна быть равна количеству строк матрицы. Аргумент left
//определяет начальное значение интервала индексов столбцов, а аргумент right -
//конечное значение интервала индексов столбцов, элементы которых складываются
//с элементами вектора V.
//Результатом работы функции является комплексная матрица, совпадающая по раз-
//мерам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции сложения значений элементов матрицы на значения
// элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы;
//4. Значения индексов left или right являются недопустимыми для данной матрицы;
//5. Значение индекса left > right.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, складываемый со столбцами
//   с индексами исходной матрицы, расположенными в интервале [left..right];
//2. ulong left - начальное значение интервала индексов столбцов, складываемых
//   с вектором V.
//3. ulong right - конечное значение интервала индексов столбцов, складываемых
//   с вектором V.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::AddByCols(const cvector& V, ulong left, ulong right) const
{cmatrix result;
 //Проверка выполнения условий сложения столбцов исходной матрицы с вектором V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows()) ||
     (left >= Cols()) || (right >= Cols()) || (left > right))
  return result;
 //Сложение столбцов с индексами, расположенными в интервале [left..right],
 //исходной матрицы на вектор V
 result = *this;
 for (ulong j = left; j <= right ; j++)
  for (ulong i = 0L; i < Rows(); i++)
   result.Put(i,j,data[i][j]+V.Get(i));
 return result;
}
//******************************************************************************
//СТАТУС: I.32, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//cmatrix AddByCols(const cvector& V, const ivector& index, bool check = false) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТОЛБЦОВ МАТРИЦЫ С КОМПЛЕКСНЫМ ВЕКТОРОМ, ИНДЕКСЫ КОТОРЫХ
//            СОДЕРЖАТСЯ В ВЕКТОРЕ index
//  Функция прибавляет к столбцам матрицы с индексами, значения которых передают-
//ся целочисленным вектором index, вектор V. Размерность вектора V должна быть
//равна количеству строк матрицы.
//  Аргумент check указывает на проведение проверки значений индексов на соот-
//ветствие допустимым значениям индексов столбцов исходной матрицы и формирова-
//нию подвектора вектора index, который содержит только корректные значения ин-
//дексов столбцов для данной матрицы. Если check = true, создается объект-преди-
//кат, который осуществляет селекцию корректных значений индексов, и формируется
//подвектор вектора index с корректными значениями индексов. Созданный подвектор
//далее используется для выбора столбцов матрицы складываемых поэлементно с век-
//тором V.
//При check = false фильтрация некорректных значений индексов не осуществляется.
//В этом случае ответственность за корректность всех значений индексов возлагает-
//ся на пользователя и при некорректном задании значения индекса, выходящего за
//пределы допустимого значения индекса столбца для данной матрицы, приведет к
//аварийному завершению работы всей программы. При check = false функция быстрее
//выполняет необходимые действия, так как не тратится время на фильтрацию некор-
//ректных значений индексов, передавемых вектором index.
//Результатом работы функции является комплексная матрица, совпадающая по разме-
//рам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции слножения значений элементов матрицы на значения
//элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу строк исходной матрицы;
//4. Вектор index - вектор нулевого размера;
//5. При check == true, получился подвектор вектора индексов столбцов нулевого
//   размера, т.е. исходный вектор индексов столбцов index не содержал ни одного
//   допустимого значения индекса столбца для данной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, прибавляемый к столбцам
//   исходной матрицы с индексами, расположенными в векторе index;
//2. const ivector& index - ссылка на вектор с индексами столбцов, складываемых
//   с вектором V.
//3. bool check (false) - индикатор выбора допустимых значений индексов столбцов
//   исходной матрицы, складываемых с вектором V, из вектора index.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::AddByCols(const cvector& V, const ivector& index,
                                  bool check) const
{cmatrix result;
 //Проверка выполнения условий сложения столбцов исходной матрицы с вектором V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Rows()) ||
     (index.IsZeroSize()))
  return result;
 //Выбор подвектора Index корректных индексов столбцов из вектора index
 ivector Index(index);//Копирование вектора index
 if (check == ON)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Cols()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  Index = Index.Unique();
  if (Index.IsZeroSize()) return result;
 }
 //Сложение столбцов с индексами, значения которых расположены в целочисленном
 //векторе Index, исходной матрицы на вектор V
 result = *this;
 for (ulong j = 0; j < Index.Size(); j++)
  for (ulong i = 0L; i < Rows(); i++)
   result.Put(i,Index.Get(j),data[i][Index.Get(j)]+V.Get(i));
 return result;
}
//******************************************************************************
//СТАТУС: I.33, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix AddByRows(const cvector& V) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ ВСЕХ СТРОК МАТРИЦЫ С КОМПЛЕКСНЫМ ВЕКТОРОМ
//   Функция прибавляет ко всем строкам матрицы вектора V. Размерность вектора
//должна быть равна количеству столбцов матрицы.
//Результатом работы функции является комплексная матрица, совпадающая по разме-
//рам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции сложения значений элементов матрицы на значения
//элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const cvector& V - ссылка на комплексный вектор, скла-
//дываемый со всеми строками исходной матрицы.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::AddByRows(const cvector& V) const
{cmatrix result;
 //Проверка выполнения условий сложения строк исходной матрицы с вектором V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols())) return result;
 //Сложение всех строк исходной матрицы на вектор V
 result.Set(Rows(),Cols(),false);
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(i,j,data[i][j]+V.Get(j));
 return result;
}
//******************************************************************************
//СТАТУС: I.34, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix AddByRows(const cvector& V, ulong index) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТРОКИ МАТРИЦЫ С КОМПЛЕКСНЫМ ВЕКТОРОМ
//Функция добавляет к строке матрицы с индексом index вектор V. Размерность век-
//тора должна быть равна количеству столбцов матрицы.
//  Результатом работы функции является комплексная матрица, совпадающая по раз-
//мерам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции сложения значений элементов матрицы на значения
//элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы;
//4. Значение индекса строки index является недопустимым для данной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, прибавляемый к строке ис-
//   ходной матрицы с индексом index;
//2. ulong index - индекс строки, складываемой  с вектором V.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::AddByRows(const cvector& V, ulong index) const
{cmatrix result;
 //Проверка выполнения условий сложения строки исходной матрицы с вектором V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols()) || (index >= Rows()))
  return result;
 //Сложение строки с индексом index исходной матрицы на вектор V
 result = *this;//Копирование исходной матрицы
 for (ulong j = 0L; j < Cols(); j++) result.Put(index,j,data[index][j]+V.Get(j));
 return result;
}
//******************************************************************************
//СТАТУС: I.35, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix AddByRows(const cvector& V, ulong left, ulong right) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТРОК МАТРИЦЫ С КОМПЛЕКСНЫМ ВЕКТОРОМ, РАСПОЛОЖЕННЫМ В
//            ИНТЕРВАЛЕ [left..right]
//Функция прибавляет к строкам матрицы с индексами, расположенными последователь-
//но в интервале целых чисел [left..right], вектор V.
//Размерность вектора должна быть равна количеству столбцов матрицы. Аргумент
//left определяет начальное значение интервала индексов строк, а аргумент right
//- конечное значение интервала индексов строк, элементы которых складываются
//с элементами вектора V.
//Результатом работы функции является комплексная матрица, совпадающая по разме-
//рам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции сложения значений элементов матрицы на значения
//элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы;
//4. Значения индексов left или right являются недопустимыми для данной матрицы;
//5. Значение индекса left > right.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, прибавляемый к строкам
//   исходной матрицы с индексами в интервале [left..right];
//2. ulong left - начальное значение интервала индексов строк, складываемых
//   с вектором V.
//3. ulong right - конечное значение интервала индексов строк, складываемых
//   с вектором V.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::AddByRows(const cvector& V, ulong left, ulong right) const
{cmatrix result;
 //Проверка выполнения условий сложения строк исходной матрицы с вектором V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols()) ||
     (left >= Rows()) || (right >= Rows()) || (left > right))
  return result;
 //Сложение строк с индексами, расположенными в интервале [left..right], исходной
 //матрицы с вектором V
 result = *this;//Копирование исходной матрицы
 for (ulong i = left; i <= right ; i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(i,j,data[i][j]+V.Get(j));
 return result;
}
//******************************************************************************
//СТАТУС: I.36, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//cmatrix AddByRows(const cvector& V, const ivector& index, bool check = false) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТРОК МАТРИЦЫ С КОМПЛЕКСНЫМ ВЕКТОРОМ, ИНДЕКСЫ КОТОРЫХ СО-
//            ДЕРЖАТСЯ В ВЕКТОРЕ index
//  Функция прибавляет к строкам матрицы с индексами, значения которых передают-
//ся целочисленным вектором index, вектор V. Размерность вектора V должна быть
//равна количеству столбцов матрицы.
//  Аргумент check указывает на проведение проверки значений индексов на соот-
//ветствие допустимым значениям индексов строк исходной матрицы и формированию
//подвектора вектора index, который содержит только корректные значения индексов
//строк для данной матрицы. Если check = true, создается объект-предикат, кото-
//рый осуществляет селекцию корректных значений индексов, и формируется подвек-
//тор вектора index с корректными значениями индексов. Созданный подвектор далее
//используется для выбора строк матрицы складываемых с вектором V.
//  При check = false фильтрация некорректных значений индексов не осуществляет-
//ся. В этом случае ответственность за корректность всех значений индексов строк
//возлагается на пользователя и при некорректном задании значения индекса, выхо-
//дящего за пределы допустимого значения индекса строки для данной матрицы, при-
//ведет к аварийному завершению работы всей программы. При check = false функция
//быстрее выполняет необходимые действия, так как не тратится время на фильтра-
//цию некорректных значений индексов, передавемых вектором index.
//Результатом работы функции является комплексная матрица, совпадающая по разме-
//рам с исходной матрицей. Функция не изменяет значений и структуры исходной
//матрицы, так как все операции сложения значений элементов матрицы на значения
//элементов вектора происходят с ее копией.
//Функция возвращает матрицу result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор V - вектор нулевого размера;
//3. Размерность вектора V не равна числу столбцов исходной матрицы;
//4. Вектор index - вектор нулевого размера;
//5. При check == true, получился подвектор вектора индексов строк нулевого
//   размера, т.е. исходный вектор индексов строк index не содержал ни одного
//   допустимого значения индекса строки для данной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - ссылка на комплексный вектор, прибавляемый к строкам
//   исходной матрицы с индексами, размещенными в векторе index;
//2. const ivector& index - ссылка на вектор с индексами строк, складываемых
//   с вектором V.
//3. bool check (false) - индикатор отбора допустимых значений индексов строк
//   исходной матрицы, складываемых с вектором V, из вектора index.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix result - результирующая матрица
//******************************************************************************
cmatrix TComplexMatrix::AddByRows(const cvector& V, const ivector& index,
                                  bool check) const
{cmatrix result;
 //Проверка выполнения условий сложения строк исходной матрицы с вектором V
 if ((IsZeroSize()) || (V.IsZeroSize()) || (V.Size() != Cols()) || (index.IsZeroSize()))
  return result;
 //Выбор подвектора Index корректных индексов строк из вектора index
 ivector Index(index);//Копирование вектора index
 if (check == ON)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Cols()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  Index = Index.Unique();
  if (Index.IsZeroSize()) return result;
 }
 //Сложение строк с индексами, значения которых расположены в целочисленном
 //векторе Index, исходной матрицы на вектор V
 result = *this;//Копирование исходной матрицы
 for (ulong i = 0; i < Index.Size(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(Index.Get(i),j,data[Index.Get(i)][j]+V.Get(j));
 return result;
}
//******************************************************************************
//СТАТУС: I.37, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cvector SumCols(ulong left = 0L, ulong right = MAX_SIZE) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТОЛБЦОВ МАТРИЦЫ, РАСПОЛОЖЕННЫХ В ИНТЕРВАЛЕ [left..right]
//   Функция складывает столбцы матрицы с индексами, расположенными в интервале
//целых чисел [left..right]. Аргумент left определяет начальное значение интер-
//вала индексов столбцов, а аргумент right - конечное значение интервала индек-
//сов столбцов, которые складываются друг с другом. По умолчанию складываются
//все столбцы матрицы.
//   Результатом работы функции является вектор-столбец с размерностью равной
//количеству строк исходной матрицы. Функция не изменяет значений и структуры
//исходной матрицы.
//Функция возвращает вектор result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Значения индексов left или right являются недопустимыми для столбцов данной
//   матрицы;
//3. Значение индекса left > right.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left - начальное значение интервала индексов столбцов, складываемых
//   друг с другом.
//2. ulong right - конечное значение интервала индексов столбцов, складываемых
//   друг с другом.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector result - результирующий вектор-столбец
//******************************************************************************
cvector TComplexMatrix::SumCols(ulong left, ulong right) const
{cvector result;
 //Проверка выполнения условий сложения столбцов исходной матрицы
 if (IsZeroSize()) return result;
 if (right == MAX_SIZE) right = Cols()-1;
 //Проверка выполнения условий сложения столбцов исходной матрицы
 if ((left >= Cols()) || (right >= Cols()) || (left > right)) return result;
 //Cложение столбцов с индексами, расположенными в интервале [left..right],
 //исходной матрицы между собой
 result.Set(Rows(),COL,0.0) ;//Создание результирующего вектора
 for (ulong i = 0L; i < Rows() ; i++)
  for (ulong j = left; j <= right; j++)
   result.Put(i,result.Get(i)+data[i][j]);
 return result;
}
//******************************************************************************
//СТАТУС: I.38, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector SumCols(const ivector& index) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТОЛБЦОВ МАТРИЦЫ, ИНДЕКСЫ КОТОРЫХ СОДЕРЖАТСЯ В ВЕКТОРЕ
//   Функция складывает столбцы матрицы с индексами, значения которых передаются
//целочисленным вектором index, между собой. При выполнении операции сложения
//столбцов каждый индекс столбца анализируется на допустимость для данной исход-
//ной матрицы. Если значение индекса выходит за допустимые пределы возможных
//индексов столбцов данной матрицы, то он игнорируется.
//   Результатом работы функции является вектор-столбец с размерностью равной
//количеству строк исходной матрицы. Функция не изменяет значений и структуры
//исходной матрицы.
//Функция возвращает вектор result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор index - вектор нулевого размера;
//3. При селекции корректных значений индексов столбцов получился подвектор
//   вектора индексов столбцов нулевого размера, т.е. исходный вектор индексов
//   столбцов index не содержал ни одного допустимого значения индекса столбца
//   для данной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const ivector& index - ссылка на вектор с индексами
//столбцов, складываемых между собой.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector result - результирующий вектор
//******************************************************************************
cvector TComplexMatrix::SumCols(const ivector& index) const
{cvector result;
 //Проверка выполнения условий сложения столбцов исходной матрицы
 if ((IsZeroSize()) || (index.IsZeroSize())) return result;
 //Выбор подвектора Index корректных индексов столбцов из вектора index
 ivector Index(index);//Копирование вектора index
 ivector interval(2,0L);
 interval[0] = 0; interval[1] = Cols()-1;
 TBelongClosedInterval<long, ivector> Predicate =
 TBelongClosedInterval<long,ivector>(interval);
 Index = Index.SubVector(Predicate);
 if (Index.IsZeroSize()) return result;
 //Сложение столбцов с индексами, значения которых расположены в целочисленном
 //векторе Index, исходной матрицы друг с другом
 result.Set(Rows(),COL,0.0);//Создание результирующего вектора
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Index.Size(); j++)
   result.Put(i,result.Get(i)+data[i][Index.Get(j)]);
 return result;
}
//******************************************************************************
//СТАТУС: I.39, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cvector SumRows(ulong left = 0L, ulong right = MAX_SIZE) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТРОК МАТРИЦЫ, РАСПОЛОЖЕННЫХ В ИНТЕРВАЛЕ [left..right]
//   Функция складывает строки матрицы с индексами, расположенными в интервале
//целых чисел [left..right]. Аргумент left определяет начальное значение интер-
//вала индексов строк, а аргумент right - конечное значение интервала индек-
//сов строк, которые складываются друг с другом. По умолчанию складываются
//все строки матрицы.
//   Результатом работы функции является вектор-строка с размерностью равной
//количеству столбцов исходной матрицы. Функция не изменяет значений и структуры
//исходной матрицы.
//Функция возвращает вектор result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Значения индексов left или right являются недопустимыми для строк данной
//   матрицы;
//3. Значение индекса left > right.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong left - начальное значение интервала индексов строк, складываемых
//   друг с другом.
//2. ulong right - конечное значение интервала индексов строк, складываемых
//   друг с другом.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector result - результирующий вектор-строка
//******************************************************************************
cvector TComplexMatrix::SumRows(ulong left, ulong right) const
{cvector result;
 //Проверка выполнения условий сложения строк исходной матрицы
 if (IsZeroSize()) return result;
 if (right == MAX_SIZE) right = Rows()-1;
 //Проверка выполнения условий сложения строк исходной матрицы
 if ((left >= Rows()) || (right >= Rows()) || (left > right)) return result;
 //Cложение строк с индексами, расположенными в интервале [left..right],
 //исходной матрицы между собой
 result.Set(Cols(),ROW,0.0);//Создание результирующего вектора
 for (ulong j = 0L; j < Cols(); j++)
  for (ulong i = left; i <= right; i++)
   result.Put(j,result.Get(j)+data[i][j]);
 return result;
}
//******************************************************************************
//СТАТУС: I.40, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector SumRows(const ivector& index) const
//НАЗНАЧЕНИЕ: СЛОЖЕНИЕ СТРОК МАТРИЦЫ, ИНДЕКСЫ КОТОРЫХ СОДЕРЖАТСЯ В ВЕКТОРЕ
//   Функция складывает строки матрицы с индексами, значения которых передаются
//целочисленным вектором index, между собой. При выполнении операции сложения
//строк каждый индекс строки анализируется на допустимость для данной исходной
//матрицы. Если значение индекса выходит за допустимые пределы возможных индек-
//сов строк данной матрицы, то он игнорируется.
//   Результатом работы функции является вектор-строка с размерностью равной
//количеству столбцов исходной матрицы. Функция не изменяет значений и структуры
//исходной матрицы.
//Функция возвращает вектор result нулевого размера в следующих случаях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор index - вектор нулевого размера;
//3. При селекции корректных значений индексов строк получился подвектор вектора
//   индексов строк нулевого размера, т.е. исходный вектор индексов строк index
//   не содержал ни одного допустимого значения индекса строки для данной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const ivector& index - ссылка на вектор с индексами
//строк, складываемых между собой.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cvector result - результирующий вектор сложения строк
//******************************************************************************
cvector TComplexMatrix::SumRows(const ivector& index) const
{cvector result;
 //Проверка выполнения условий сложения строк исходной матрицы
 if ((IsZeroSize()) || (index.IsZeroSize())) return result;
 //Выбор подвектора Index корректных индексов строк из вектора index
 ivector Index(index);//Копирование вектора index
 ivector interval(2,0L);
 interval[0] = 0; interval[1] = Rows()-1;
 TBelongClosedInterval<long, ivector> Predicate =
 TBelongClosedInterval<long,ivector>(interval);
 Index = Index.SubVector(Predicate);
 if (Index.IsZeroSize()) return result;
 //Сложение строк с индексами, значения которых расположены в целочисленном
 //векторе Index, исходной матрицы друг с другом
 result.Set(Cols(),ROW,0.0);//Создание результирующего вектора
 for (ulong j = 0; j < Cols(); j++)
  for (ulong i = 0L; i < Index.Size(); i++)
   result.Put(j,result.Get(j)+data[Index.Get(i)][j]);
 return result;
}
//------------------------------------------------------------------------------
//Расчет миноров исходной матрицы
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex U_Minor(ulong k, ulong g) const
//НАЗНАЧЕНИЕ: РАСЧЕТ МИНОРА МАТРИЦЫ
//Функция вычисляет минор исходной матрицы следующего вида:
//M(0 1 ... k-1 k, 0 1 ... k-1 g), где g > k
// 0 1 ... k-1 k - строки исходной матрицы рассчитываемого минора;
// 0 1 ... k-1 g - столбцы исходной матрицы рассчитываемого минора.
//Верхние границы строк k и столбцов g исходной матрицы, которые участвуют в фор-
//мировании элементов минора входят в данное допустимое множество. Нумерация
//строк и столбцов начинается с 0.
//Функция использует вызов функции U_SubMatrix(k,g), которая формирует заданный
//минор и функцию DET_UnSymmetric(...), которая вычисляет данный минор.
//При генерации исключительной ситуации функция возвращает Det = 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong k - верхняя граница строк матрицы, участвующих в формировании минора
//2. ulong g - верхняя граница столбцов матрицы, участвующих в формировании минора
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex Det  - значение заданного минора
//******************************************************************************
complex TComplexMatrix::U_Minor(ulong k, ulong g) const
{complex Det = C_ZERO;
 if (IsZeroSize()) return Det;//Матрица нулевого размера
 //Проверка на допустимость индексов k & g, 0 < g < Cols(), 0 <= k < g, k < Rows()
 if ((k >= Rows()) || (g <= k) || (g >= Cols())) return Det;
 //-----------------------------------------------------------------------------
 //Формирование подматрицы M(0 1 ... k-1 k, 0 1 ... k-1 g), где g > k
 //-----------------------------------------------------------------------------
 cmatrix M = U_SubMatrix(k,g);
 Det = M.DET_UnSymmetric();//Вычисление определителя подматрицы - минора
 return Det; //Значение минора
}
//******************************************************************************
//СТАТУС: I.2; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex L_Minor(ulong g, ulong k) const
//НАЗНАЧЕНИЕ: РАСЧЕТ МИНОРА МАТРИЦЫ
//Функция вычисляет минор исходной матрицы следующего вида:
//M(0 1 ... k-1 g, 0 1 ... k-1 k), где g > k
// 0 1 ... k-1 g - строки исходной матрицы рассчитываемого минора;
// 0 1 ... k-1 k - столбцы исходной матрицы рассчитываемого минора.
//Верхние границы строк g и столбцов k исходной матрицы, которые участвуют в фор-
//мировании элементов минора входят в данное допустимое множество. Нумерация
//строк и столбцов начинается с 0.
//Функция использует вызов функции L_SubMatrix(g,k), которая формирует заданный
//минор и функцию DET_UnSymmetric(...), которая вычисляет данный минор.
//При генерации исключительной ситуации функция возвращает Det = 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong g - верхняя граница строк матрицы, участвующих в формировании минора
//2. ulong k - верхняя граница столбцов матрицы, участвующих в формировании минора
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex Det  - значение заданного минора
//******************************************************************************
complex TComplexMatrix::L_Minor(ulong g, ulong k) const
{complex Det = C_ZERO;
 if (IsZeroSize()) return Det;//Матрица нулевого размера
 //Проверка на допустимые индексы k & g, 0 < g < Rows(), 0 <= k < g, k < Cols()
 if ((k >= Cols()) || (g <= k) || (g >= Rows())) return Det;
 //-----------------------------------------------------------------------------
 //Формирование подматрицы M(0 1 ... k-1 g, 0 1 ... k-1 k), где g > k
 //-----------------------------------------------------------------------------
 cmatrix M = L_SubMatrix(g,k);
 Det = M.DET_UnSymmetric();//Вычисление определителя подматрицы - минора
 return Det; //Значение минора
}
//******************************************************************************
//СТАТУС: I.3; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex P_Minor(ulong k) const
//НАЗНАЧЕНИЕ: РАСЧЕТ ГЛАВНОГО k-го МИНОРА МАТРИЦЫ
//Функция вычисляет минор исходной матрицы следующего вида:
//M(0 1 ... k-1 k, 0 1 ... k-1 k),
// 0 1 ... k-1 k - строки исходной матрицы рассчитываемого главного минора;
// 0 1 ... k-1 k - столбцы исходной матрицы рассчитываемого главного минора.
//Верхние границы первых k строк и столбцов исходной матрицы, которые участвуют
//в формировании элементов главного минора входят в данное допустимое множество.
//Нумерация строк и столбцов начинается с 0.
//Функция использует вызов функции P_SubMatrix(k), которая формирует заданный
//главный минор и функцию DET_UnSymmetric(...), которая вычисляет данный минор.
//Если индексы столбцов и строк из которых будет формироваться главный минор бу-
//дут некорректны, то генерируется исключительная ситуация, приводящая к выводу
//сообщения об ошибке. При генерации исключительной ситуации функция завершает
//свою работу, без завершения работы всей программы. В случае неудачи функция
//возвращает Det = 0.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong k - верхняя граница строк и столбцов матрицы,
//участвующих в формировании главного минора k-го порядка
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex Det  - значение заданного главного минора k-го порядка
//******************************************************************************
complex TComplexMatrix::P_Minor(ulong k) const
{complex Det = C_ZERO;
 if (IsZeroSize()) return Det;//Матрица нулевого размера
 //Проверка на допустимость индекса k, k < Rows(), k < Cols()
 if ((k >= Cols()) || (k >= Rows())) return Det;
 //-----------------------------------------------------------------------------
 //Формирование подматрицы M(0 1 ... k-1 k, 0 1 ... k-1 k)
 //-----------------------------------------------------------------------------
 cmatrix M = P_SubMatrix(k);
 Det = M.DET_UnSymmetric();//Вычисление главного минора k-го порядка
 return Det; //Значение минора
}
//******************************************************************************
//СТАТУС: I.4; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix U_AllMinors() const
//НАЗНАЧЕНИЕ: РАСЧЕТ ВСЕХ НАДДИАГОНАЛЬНЫХ МИНОРОВ МАТРИЦЫ
//Функция вычисляет все миноры исходной матрицы следующего вида:
//M(0 1 ... k-1 k, 0 1 ... k-1 g), где g > k
// 0 1 ... k-1 k - строки исходной матрицы рассчитываемого минора;
// 0 1 ... k-1 g - столбцы исходной матрицы рассчитываемого минора.
//Диапазон изменения g: 0 < g < min(Cols(),Rows());
//Диапазон изменения k: 0 <= k < g.
//Функция использует вызов функции U_Minor(k,g). Все вычисленные миноры заносят-
//ся в матрицу, которая будет являться верхней треугольной матрицей с нулевыми
//диагональными элементами.
//При генерации исключительной ситуации функция комплексную матрицу нулевого
//размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix U_Minors  - матрица миноров
//******************************************************************************
cmatrix TComplexMatrix::U_AllMinors() const
{cmatrix U_Minors;
 if (IsZeroSize()) return U_Minors;//Матрица нулевого размера
 //-----------------------------------------------------------------------------
 //Определение всех миноров вида M(0 1 ... k-1 k, 0 1 ... k-1 g), где g > k
 //-----------------------------------------------------------------------------
 ulong bound = (Rows() < Cols()) ? Rows() : Cols();
 //Конструирование матрицы для размещения всех наддиагональных миноров
 U_Minors.Set(bound,bound,C_ZERO);
 //Цикл вычисления всех наддиагональных миноров
 for(ulong i = 0L; i < bound; i++)
  for (ulong j = i+1; j < bound; j++)
   U_Minors.Put(i,j,U_Minor(i,j));
 return U_Minors; //Матрица всех наддиагональных миноров
}
//******************************************************************************
//СТАТУС: I.5; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix L_AllMinors() const
//НАЗНАЧЕНИЕ: РАСЧЕТ ВСЕХ ПОДДИАГОНАЛЬНЫХ МИНОРОВ МАТРИЦЫ
//Функция вычисляет все миноры исходной матрицы следующего вида:
//M(0 1 ... k-1 g, 0 1 ... k-1 k), где g > k
// 0 1 ... k-1 g - строки исходной матрицы рассчитываемого минора;
// 0 1 ... k-1 k - столбцы исходной матрицы рассчитываемого минора.
//Диапазон изменения g: 0 < g < min(Cols(),Rows());
//Диапазон изменения k: 0 <= k < g.
//Функция использует вызов функции L_Minor(g,k). Все вычисленные миноры заносят-
//ся в матрицу, которая будет являться нижней треугольной матрицей с нулевыми
//диагональными элементами.
//При генерации исключительной ситуации функция возвращает матрицу нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix L_Minors  - матрица миноров
//******************************************************************************
cmatrix TComplexMatrix::L_AllMinors() const
{cmatrix L_Minors;
 if (IsZeroSize()) return L_Minors;//Матрица нулевого размера
 //-----------------------------------------------------------------------------
 //Определение всех миноров вида M(0 1 ... k-1 g, 0 1 ... k-1 k), где g > k
 //-----------------------------------------------------------------------------
 ulong bound = (Rows() < Cols()) ? Rows() : Cols();
 //Конструирование матрицы для размещения поддиагональных миноров
 L_Minors.Set(bound,bound,C_ZERO);
 //Цикл вычисления всех поддиагональных миноров
 for(ulong i = 1L; i < bound; i++)
  for (ulong j = 0; j < i; j++)
   L_Minors.Put(i,j,L_Minor(i,j));
 return L_Minors; //Матрица всех поддиагональных миноров
}
//******************************************************************************
//СТАТУС: I.6; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix P_AllMinors() const
//НАЗНАЧЕНИЕ: РАСЧЕТ ВСЕХ ГЛАВНЫХ МИНОРОВ МАТРИЦЫ
//Функция вычисляет все главные миноры исходной матрицы следующего вида:
//M(0 1 ... k-1 k, 0 1 ... k-1 k)
// 0 1 ... k-1 k - строки исходной матрицы рассчитываемого минора;
// 0 1 ... k-1 k - столбцы исходной матрицы рассчитываемого минора.
//Диапазон изменения k: 0 <= k < min(Cols(),Rows());
//Функция использует вызов функции P_Minor(k). Все вычисленные миноры заносятся
//в матрицу, которая будет являться диагональной матрицей.
//При генерации исключительной ситуации функция возвращает матрицу нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix P_Minors  - матрица главных миноров
//******************************************************************************
cmatrix TComplexMatrix::P_AllMinors() const
{cmatrix P_Minors;
 if (IsZeroSize()) return P_Minors;//Матрица нулевого размера
 //-----------------------------------------------------------------------------
 //Определение всех миноров вида M(0 1 ... k-1 k, 0 1 ... k-1 k)
 //-----------------------------------------------------------------------------
 ulong bound = (Rows() < Cols()) ? Rows() : Cols();
 //Конструирование матрицы для размещения диагональных миноров
 P_Minors.Set(bound,bound,C_ZERO);
 //Цикл вычисления всех диагональных миноров
 for(ulong i = 0L; i < bound; i++) P_Minors.Put(i,i,P_Minor(i));
 return P_Minors; //Матрица всех главных миноров
}
//******************************************************************************
//СТАТУС: I.7; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cvector& P_AllMinors(cvector& P) const
//НАЗНАЧЕНИЕ: РАСЧЕТ ВСЕХ ГЛАВНЫХ МИНОРОВ МАТРИЦЫ
//Функция вычисляет все главные миноры исходной матрицы следующего вида:
//M(0 1 ... k-1 k, 0 1 ... k-1 k)
// 0 1 ... k-1 k - строки исходной матрицы рассчитываемого минора;
// 0 1 ... k-1 k - столбцы исходной матрицы рассчитываемого минора.
//Диапазон изменения k: 0 <= k < min(Cols(),Rows());
//Функция использует вызов функции P_Minor(k). Все вычисленные миноры заносятся
//в вектор P, передаваемый по ссылке.
//В случае неудачи функция возвращает вектор нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: cvector& P - ссылка на вектор значений главных миноров
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//cvector& P - результирующий вектор с вычисленными значениями главных миноров
//******************************************************************************
cvector& TComplexMatrix::P_AllMinors(cvector& P) const
{if (IsZeroSize()) //Mатрица нулевого размера
 {P.Set(0,ROW,false); return P;}
 //-----------------------------------------------------------------------------
 //Определение всех миноров вида M(0 1 ... k-1 k, 0 1 ... k-1 k)
 //-----------------------------------------------------------------------------
 ulong bound = (Rows() < Cols()) ? Rows() : Cols();
 //Создание вектора для размещения диагональных (главных) миноров
 P.Set(bound,ROW,false);
 //Цикл вычисления всех диагональных миноров
 for(ulong i = 0L; i < bound; i++) P.Put(i,P_Minor(i));
 return P;//Вектор со всеми главными минорами
}
//******************************************************************************
//СТАТУС: I.8; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//   cmatrix AllMinors(bool L = true, bool P = true, bool U = true) const
//НАЗНАЧЕНИЕ: РАСЧЕТ ВСЕХ МИНОРОВ МАТРИЦЫ
//Функция вычисляет все миноры исходной матрицы следующего вида. Функция исполь-
//зует вызовы функций U_AllMinors(), L_AllMinors() и P_AllMinors(), в зависимос-
//ти от выбранных опций U, L, P соответственно. Все вычисленные миноры заносятся
//в матрицу, которая будет являться квадратной матрицей.
//При генерации исключительной ситуации функция возвращает матрицу нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. bool L - признак вычисления всех поддиагональных миноров
//2. bool P - признак вычисления всех главных миноров
//3. bool U - признак вычисления всех наддиагональных миноров
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: cmatrix Minors  - матрица миноров
//******************************************************************************
cmatrix TComplexMatrix::AllMinors(bool L, bool P, bool U) const
{cmatrix Minors;
 if (IsZeroSize()) return Minors;//Матрица нулевого размера
 if ((L == OFF) && (P == OFF) && (U == OFF)) return Minors;
 //-----------------------------------------------------------------------------
 //Определение всех миноров исходной матрицы
 //-----------------------------------------------------------------------------
 ulong bound = (Rows() < Cols()) ? Rows() : Cols();
 //Конструирование матрицы для размещения всех миноров
 Minors.Set(bound,bound,C_ZERO);
 //Формирование поддиагональных миноров
 if (L == ON) Minors = L_AllMinors();
 //Формирование главных миноров
 if (P == ON)
 {if (L == OFF) Minors = P_AllMinors();
  else Minors = Minors + P_AllMinors();
 }
 //Формирование наддиагональных миноров
 if (U == ON)
 {if ((L == OFF) && (P == OFF)) Minors = U_AllMinors();
  else Minors = Minors + U_AllMinors();
 }
 return Minors; //Матрица всех миноров
}
//------------------------------------------------------------------------------
// Разложение комплексных квадратных матриц на нижнюю, верхнюю и диагональную
// матрицы: A = LDU
// В алгоритме используется вычисление всех миноров исходной матрицы для расчета
// коэффициентов нижней L, верхней U и диагональной D матриц. С вычислительной
// точки зрения этот алгоритм нельзя считать эффективным для разложения матрицы.
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LDU_Gauss(cmatrix& LDU) const
//НАЗНАЧЕНИЕ: РАЗЛОЖЕНИЕ КВАДРАТНОЙ МАТРИЦЫ НА ПРОИЗВЕДЕНИЕ ДВУХ ТРЕУГОЛЬНЫХ и
//            ДИАГОНАЛЬНОЙ МАТРИЦ ВЫЧИСЛЕНИЕМ ВСЕХ МИНОРОВ
// LDU-expansion of real square matrix by calculating all minors
//Функция предназначена для разложения квадратной комплексной матрицы на
//произведение двух треугольных матриц и диагональной матрицы вычислением всех
//миноров исходной матрицы.
//ТЕОРЕТИЧЕСКИЕ ПРЕДПОСЫЛКИ.
// Всякая квадратная матрица A = ||a(i,k)|| (1..n) ранга r, у которой
//       | 1  2 ... k |
// Dk = A|            | != 0 (k = 1, 2, ..., r),
//       | 1  2 ... k |
// представима в виде произведения нижней треугольной матрицы L, диагональной
// матрицы D и верхней треугольной матрицы U:
//
//                             |D1       |
//                             | D2/D1   |
//           |1    0  ...... 0||  .      ||1 U12 ......... U1n|
//           |L21  1  ...... 0||   .     ||0  1 U23 ...... U2n|
// A = LDU = |L31  L32  1 .. 0||    .    ||0  0  1  U34 .. U3n| ,где
//           | ............. 0||  Dr/Dr-1||0 ..............   |
//           |Ln1  Ln2 ....  1||     0   ||0  0  0 ........ 1 |
//                             |      .  |
//                             |       0 |
//
//       A(1 2 ... k-1 g, 1 2 ... k-1 k)        A(1 2 ... k-1 k, 1 2 ... k-1 g)
// Lgk = -------------------------------, Ukg = -------------------------------
//           A(1 2 ... k, 1 2 ... k)                A(1 2 ... k, 1 2 ... k)
//
// (g = k+1, ...., n; k = 1, 2, ..., r), а Lgk, Ukg произвольные при
//  g = k+1, ...., n; k = r+1, ...., n.
//РЕАЛИЗАЦИЯ. Осуществляется проверка матрицы на квадратную, если матрица тако-
//вой не является, то функция возвращает false и матрицу LDU нулевого размера.
//Для квадратной матрицы вычисляются все ее миноры - матрица миноров Minor. Далее
//вычисляются коэффициенты матриц L, U и D по формулам из теоремы и заносятся в
//матрицу LDU. Нижняя треугольная подматрица матрицы LDU будет содержать коэффи-
//циенты матрицы L (без элементов главной диагонали, равных 1); верхняя треуголь-
//ная подматрица матрицы LDU - коэффициенты матрицы U (без элементов главной
//диагонали, равных 1); на диагонали матрицы LDU - располагаются коэффициенты
//диагональной матрицы D.
//Если матрица - квадртная, то функция возвращает true и элементы матриц L,D,U
//в матрице LDU, передаваемой в функцию по ссылке.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//cmatrix& LDU - ссылка на матрицу с элементами верхней U, нижней L треугольных
//матриц и диагональной D матрицы, представляющие исходную матрицу: A = LDU
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат LDU-разложения матрицы
//******************************************************************************
bool TComplexMatrix::LDU_Gauss(cmatrix& LDU) const
{//Матрица нулевого размера или неквадратная
 if (IsZeroSize() || IsRectang()) {LDU.Set(0L,0L,false); return false;}
 //Формируем результирующую матрицу
 LDU.Set(Rows(),Rows(),C_ZERO);
 //Расчет всех миноров исходной матрицы
 cmatrix M = AllMinors();
 //-----------------------------------------------------------------------------
 //Расчет коэффициентов матрицы L(g,k)
 for (ulong i = 1L; i < Rows(); i++)
  for (ulong j = 0L; j < i; j++)
  {if (M.Get(j,j) != 0) LDU.Put(i,j,M.Get(i,j)/M(j,j));}
 //----------------------------------------------------------------------------
 //Расчет коэффициентов матрицы U(g,k)
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = i+1; j < Cols(); j++)
  {if (M.Get(i,i) != 0) LDU.Put(i,j,M.Get(i,j)/M(i,i));}
 //----------------------------------------------------------------------------
 //Расчет коэффициентов матрицы D(k,k)
 LDU.Put(0L,0L,M.Get(0L,0L));
 for (ulong i = 1L; i < Rows(); i++)
 {if (M.Get(i-1,i-1) != 0) LDU.Put(i,i,M.Get(i,i)/M(i-1,i-1));}
 return true;
}
//******************************************************************************
//СТАТУС: I.2, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool LDU_Gauss(cmatrix& L, cmatrix& D, cmatrix& U) const
//НАЗНАЧЕНИЕ: РАЗЛОЖЕНИЕ КВАДРАТНОЙ МАТРИЦЫ НА ПРОИЗВЕДЕНИЕ ДВУХ ТРЕУГОЛЬНЫХ и
//            ДИАГОНАЛЬНОЙ МАТРИЦ ВЫЧИСЛЕНИЕМ ВСЕХ МИНОРОВ
// LDU-expansion of real square matrix by calculating all minors
//Функция предназначена для разложения квадратной комплексной матрицы на
//произведение двух треугольных матриц и диагональной матрицы вычислением всех
//миноров исходной матрицы. Функция использует вызов функции LDU_Gauss(A) и
//далее при успешном завершении ее работы размещает элементы нижней треугольной
//матрицы в матрице L, верхней треугольной матрицы - в матрице U и диагональной
//матрицы в матрице D, передаваемых по ссылке.
//В случае неудачи, функция возвращает false и матрицы L, D и U нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//cmatrix& L - ссылка на матрицу с элементами нижней треугольной матрицы разложе-
//ния исходной матрицы: A = LDU;
//cmatrix& D - ссылка на матрицу с элементами диагональной D матрицы разложения
//исходной матрицы: A = LDU;
//cmatrix& U - ссылка на матрицу с элементами верхней треугольной матриц разложе-
//ния исходной матрицы: A = LDU
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат LDU-разложения матрицы
//******************************************************************************
bool TComplexMatrix::LDU_Gauss(cmatrix& L, cmatrix& D, cmatrix& U) const
{cmatrix B;
 if (LDU_Gauss(B) == false)
 {L.Set(0L,0L,false); D.Set(0L,0L,false); U.Set(0L,0L,false); return false;}
 L.Set(B.Rows(),C_ZERO); D.Set(B.Rows(),C_ZERO); U.Set(B.Rows(),C_ZERO);
 //Формирование матриц L,D и U с коэффициентами матриц разложения исходной
 for (ulong i = 0L; i < B.Rows(); i++)
  for (ulong j = 0L; j < B.Cols(); j++)
  {if (i == j) {L.Put(i,i,1); D.Put(i,i,B.Get(i,i)); U.Put(i,i,1);}
   if (i > j) L.Put(i,j,B.Get(i,j));
   if (i < j) U.Put(i,j,B.Get(i,j));
  }
 return true;
}
//------------------------------------------------------------------------------
//Расчет определителей комплексных квадратных матриц и разложение матриц
//на верхнюю и нижнюю треугольные матрицы: A = LU
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.1; TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend complex InnerProduct(ulong l, ulong s, ulong u, complex init,
//                            const cmatrix& A, bool Avar, ulong Aconst,
//                            const cmatrix& B, bool Bvar, ulong Bconst);
//НАЗНАЧЕНИЕ: НАКОПЛЕНИЕ ВНУТРЕННЕГО СКАЛЯРНОГО ПРОИЗВЕДЕНИЯ ЭЛЕМЕНТОВ МАТРИЦЫ
//           (МАТРИЦ) ВИДА Ak * Bk И СУММИРОВАНИЕ ИХ С НАЧАЛЬНЫМ ЗНАЧЕНИЕМ.
//Функция накапливает скалярное произведения элементов матрицы (матриц).
//Вычиления производятся с числами типа long double, что увеличивает точность
//вычислений, затем результирующая сумма округляется до типа double. При вычис-
//лениях один из индексов матриц A & B изменяется в диапазоне от l до u с шагом
//s, другой индекс матриц является ЗАФИКСИРОВАННЫМ. Переменные Avar и Bvar типа
//bool указывают на изменяемый тип индекса матриц - СТРОКУ или СТОЛБЕЦ. Если из-
//меняется строка, то эти переменные принимают значение ROW (true), иначе COL
//(false). Аргументы Aconst и Bconst указывают на значение зафиксированного ин-
//декса, который будет являтся противоположным значениям переменных Avar и Bvar.
//Переменная init содержит начальное значение скалярного произведения.
//Пользователь должен контролировать корректность задания параметров функции
//InnerProduct, чтобы избежать попытки доступа к несуществующим элементам матриц.
//Общая формула накопления скалярного произведения имеет вид:
// sum = init + SUM[A(k,c1)*B(c2,k), l <= k < u, с шагом s], где
//1. sum - результат накопления скалярного произведения элементов матриц(ы);
//2. init - начальное значение sum;
//3. A(k,c1), B(c2,k) - значения элементов матриц A & B, порядок индексов элемен-
//   тов k, c1, c2 может быть произвольным, т.е. допустимы следующие варианты:
//   a) A(k,c1), B(c2,k) b) A(c1,k), B(c2,k) c) A(k,c1), B(k,c2);
//4. k - значение переменного индекса для доступа к элементам матриц A & B.
//   Индекс k изменяется от l до u с шагом s;
//5. c1, c2 - значения фиксированных индексов для доступа к элементам матриц A и
//   B соответственно.
//Для реализации накопления скалярного произведения комплексных чисел текущая
//пара комплексных чисел Ak(a1,b1) & Bk(a2,b2), которые перемножаются между со-
//бой раскладываются на реальную и мнимую части повышенной точности. Операция
//умножения комплексных чисел в этом случае записывается следующим образом:
//Ak*Bk = a1*a2 - b1*b2 + i*(a1*b2 + a2*b1).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong l - нижняя граница переменного индекса элемента матрицы
//2. ulong s - шаг переменного индекса элемента матрицы
//3. ulong u - верхняя граница переменного индекса элемента матрицы
//4. complex init - начальное значение скалярного произведения элементов матриц
//5. const cmatrix& A - ссылка на матрицу A
//6. bool Avar - признак типа изменяемого индекса элементов матрицы A: строка
//   или столбец
//7. ulong Aconst - значение фиксированного индекса элементов матрицы A
//8. const cmatrix& B - ссылка на матрицу B
//9. bool Bvar - признак типа изменяемого индекса элементов матрицы B: строка
//   или столбец
//10. ulong Bconst - значение фиксированного индекса элементов матрицы B
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// complex result  - накопленное произведение элементов матриц(ы) по переменному
// индексу строки (столбца) с начальным значением init
//******************************************************************************
complex InnerProduct(ulong l, ulong s, ulong u, complex init, const cmatrix& A,
       bool Avar, ulong Aconst, const cmatrix& B, bool Bvar, ulong Bconst)
{long double sum_real = real(init);
 long double sum_imag = imag(init);
 long double a1, b1, a2, b2;
 complex result;
 complex Ak, Bk;
 ulong c1 = Aconst;
 ulong c2 = Bconst;
 //Вычисление скалярного произведения комплексных чисел с повышенной точностью
 for (ulong k = l; k < u; k += s)
 {Ak = (Avar == ROW) ? A.Get(k,c1) : A.Get(c1,k);
  Bk = (Bvar == ROW) ? B.Get(k,c2) : B.Get(c2,k);
  a1 = real(Ak); b1 = imag(Ak);
  a2 = real(Bk); b2 = imag(Bk);
  sum_real += a1*a2 - b1*b2;
  sum_imag += a1*b2 + a2*b1;
 }
 result = complex(sum_real,sum_imag);
return result;
}
//******************************************************************************
//СТАТУС: I.2, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool LU_UnSymmetric(complex& Det, cmatrix& LU, ivector& ExChange,
//      double* Real = NULL, double* Imag = NULL, long* Power = NULL) const
//НАЗНАЧЕНИЕ: РАЗЛОЖЕНИЕ КОМПЛЕКСНОЙ КВАДРАТНОЙ МАТРИЦЫ НА ПРОИЗВЕДЕНИЕ ДВУХ
//            ТРЕУГОЛЬНЫХ МАТРИЦ ПО АЛГОРИТМУ КРАУТА
//Функция предназначена для разложения квадратной несимметрической комплексной
//матрицы на произведение двух треугольных матриц и вычисление определителя мат-
//рицы A в форме, исключающей возможность переполнения разрядной сетки ЭВМ.
//ТЕОРЕТИЧЕСКИЕ ПРЕДПОСЫЛКИ. Аналогично LU-разложения действительной квадратной
//несимметрической матрице.
//ПРИМЕНЕНИЕ АЛГОРИТМА.
//В начале работы функция проверяет исходную матрицу на матрицу ненулевого раз-
//мера и на квадратную матрицу. В случае, если матрица является матрицей нулево-
//го размера или не является квадратной, то генерируется исключительная ситуация.
//При исключительной ситуации функция возвращает false, определитель матрицы счи-
//тается равным нулю, матрица разложения A исходной матрицы вида LU и вектор пе-
//рестановок строк становятся нулевого размера. Исключительная ситуация может быть
//сгенерирована в ходе работы функции, если текущий ведущий элемент матрицы на r-ом
//шаге работы алгоритма Краута станет равным или близким к нулю (lrr < eps,
//eps = 1e-15), что может быть вызвано особенностью исходной матрицы или ошибками
//округления, приводящими матрицу к вырожденному виду. Это означает, что опреде-
//литель матрицы равен 0 и треугольное разложение такой матрицы провести невозможно.
//Так как определитель комплексной матрицы число комплексное, то анализ на вырож-
//денность матрицы ведется по наибольшей по абсолютной величине мнимой или реальной
//части коэффициента lrr.
//Исходная матрица при работе функции сохраняется, все операции проводятся с ко-
//пией исходной матрицы - матрицей LU, передаваемой по ссылке. При успешном завер-
//шении работы алгоритма Краута матрица LU будет содержать элементы нижней L и
//верхней U треугольных матриц, за исключением диагональных элементов матрицы U,
//которые считаются равными единице. Информация о перестановке строк матрицы A
//будет содержатся в векторе ExChange, ExChange.Size() = A.Rows(), причем на
//i-ом шаге происходит перестановка строк с номерами i и ExChange[i]. Определи-
//тель матрицы A после вычислений представлен в двух видах: в виде значения пере-
//даваемой по ссылке переменной Det типа complex и в виде:
// (Real + i*Imag)*2^(Power). Второй способ представления определителя дает воз-
//можность сохранить очень большие значения определителя, приводящие в первом
//случае к переполнению разрядной сетки компьютера. Вектор перестановок ExChange
//используется при решении систем уравнений вида AX = B, где B - матрица правых
//частей, X - матрица решений (векторы x), соответствующие своим правым частям
//матрицы B. С помощью вектора перестановок осуществляется перестановка строк
//матрицы B, так как в ходе выполнения алгоритма Краута порядок следования строк
//в матрице A может быть изменен.
//При работе функции используется функция InnerProduct для вычисления скалярного
//произведения элементов комплексной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. complex& Det - ссылка на переменную со значением определителя матрицы;
//2. cmatrix& LU - ссылка на матрицу с элементами верхней U и нижней L треуголь-
//   ных матриц, за исключением диагональных элементов U равных 1, которые пред-
//   ставляют исходную матрицу: A = LU;
//3. ivector& ExChange - вектор перестановок строк исходной матрицы при выполне-
//   нии алгоритма Краута;
//4. double* Real (NULL) - указатель на мантиссу реальной части определителя;
//5. double* Imag (NULL) - указатель на мантиссу мнимой части определителя;
//6. long* Power (NULL) - указатель на показатель степени числа 2 определителя
//   матрицы. Параметры Real, Imag & Power дают возможность представить опреде-
//   литель в виде: Det = (Real + i*Imag) * 2^(Power), что позволяет избежать
//   переполнения разрядной сетки компьютера.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат разложения матрицы на две треугольные и
//вычисления определителя исходной матрицы
//****************************************************************************************
bool TComplexMatrix::LU_UnSymmetric(complex& Det, cmatrix& LU, ivector& ExChange,
                     double* Real, double* Imag, long* Power) const
{bool lSuccess = true;
 try
 {if (IsZeroSize()) throw M_ZERO_ERROR;//Матрица нулевого размера
  if (!IsSquare()) throw M_TYPE_ERROR; //Матрица не квадратная

  LU = *this; //Копируем исходную матрицу
  //Формируем вектор перестановок
  ExChange.Resize(LU.Rows()); ExChange.SetType(ROW);
  for (ulong i = 0L; i < ExChange.Size(); i++) ExChange.Put(i,i);

  //Объявление рабочих переменных
  const double _EPS = 1e-10;//машинный ноль
  double detr = 1.0; //мантисса реальной части определителя
  double deti = 0.0; //мантисса мнимой части определителя
  long dete = 0; //показатель степени определителя
  complex value;
  double x, y, w;
  double z; //норма скалярного произведения на r-ом шаге алгоритма
  ulong l;  //индекс ведущей строки

  //----------------------------------------------------------------------------
  //                             АЛГОРИТМ КРАУТА
  //----------------------------------------------------------------------------
  //1. Вычисление норм всех строк матрицы
  rvector Norms = LU.NormAllRows(EUCLIDEAN_NORM);
  //2. Начало цикла разложения матрицы A на две треугольные: L & U
  for (ulong k = 0L; k < LU.Rows(); k++) //k-ый шаг алгоритма Краута
  {l = k; z = 0.0;
   //Цикл вычисления коэффициентов L(i,k) - нижней треугольной матрицы
   for (ulong i = k; i < LU.Rows(); i++)
   {value = InnerProduct(0,1,k,-LU(i,k),LU,COL,i,LU,ROW,k);
    LU.Put(i,k, -value);
    //Проверка евклидовой нормы i-строки матрицы на нуль. Если евклидова норма
    //строки равна нулю, то матрица A вырождена (квадратная матрица неполного
    //ранга)
    if (Norms[i] < _EPS) throw M_DEGENERACY;
    x = norm(value)/Norms[i];
    if (x > z) {z = x; l = i;}
   }//Конец цикла по i

   //Проверка на перестановку строк l и k
   if (l != k) //Выполнить перестановку
   {//Изменение знака определителя при перестановке строк матрицы
    detr = -detr; deti = -deti;
    LU.ExchangeRows(l, k); //Перестановка строк с индексами l & k
    Norms.Put(l,Norms.Get(k));
   }
   ExChange.Put(k,l);
   //Пошаговое вычисление определителя матрицы
   x = real(LU.Get(k,k));
   y = imag(LU.Get(k,k));
   w = x*detr - y*deti;//Вычисление реальной части мантиссы определителя
   deti = x*deti + y*detr;//Вычисление мнимой части мантиссы определителя
   detr = w;
   //Проверка на вырожденность матрицы A
   if (fabs(detr) < fabs(deti)) w = deti;
   if (fabs(w) < _EPS) throw M_DEGENERACY;

   //Представление определителя матрицы в виде (detr + i*deti)*2^(dete), где
   //max(|detr|,|deti|) = 0 или  1/16 <= |max(|detr|,|deti|)| < 1
   //w = max(|detr|,|deti|)
   while (fabs(w) >= 1.0)
   {w = w * 0.0625;
    detr = detr * 0.0625;
    deti = deti * 0.0625;
    dete = dete + 4;
   }
   while (fabs(w) < 0.0625)
   {w = w * 16;
    detr = detr * 16;
    deti = deti * 16;
    dete = dete - 4;
   }
   //Цикл вычисления коэффициентов U(k,j) - верхней треугольной матрицы
   complex Lkk = -1/LU.Get(k,k);
   for (ulong j = k+1; j < LU.Cols(); j++)
   {value = InnerProduct(0,1,k,-LU(k,j),LU,COL,k,LU,ROW,j);
    LU.Put(k,j, value * Lkk);
   }//Конец цикла по j

  }//Конец цикла по k
  //---------------------- Конец алгоритма Краута -----------------------------
  if ((Real != NULL) && (Imag != NULL) && (Power != NULL))
  {*Real = detr; *Imag = deti; *Power = dete;}
  //Получение значения определителя в явном виде
  double p = pow(2.0,dete);
  Det = complex(detr*p,deti*p); //Det A = (detr + i*detri) * 2^dete
 }
 catch (int error_type) //Блок обработки исключительной ситуации
 {//Установка выходных данных в случае генерации исключительной ситуации
  lSuccess = false;
  LU.Set(0L,0L,false);
  ExChange.Set(0L,ROW);
  Det = C_ZERO;
  if (Real != NULL) *Real = 0.0;
  if (Imag != NULL) *Imag = 0.0;
  if (Power != NULL) *Power = 0;
  if (error_type == M_TYPE_ERROR) return lSuccess;
  else if (error_type == M_ZERO_ERROR) return lSuccess;
  else if (error_type == M_DEGENERACY) return lSuccess;//Вырожденная матрица
 }
 return lSuccess;
}
//****************************************************************************************
//СТАТУС: I.3, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//complex DET_UnSymmetric(double* Real = NULL, double* Imag = NULL, long* Power = NULL) const
//НАЗНАЧЕНИЕ: РАСЧЕТ ОПРЕДЕЛИТЕЛЯ КВАДРАТНОЙ КОМПЛЕКСНОЙ НЕСИММЕТРИЧЕСКОЙ МАТРИЦЫ
//Для расчета определителя функция использует алгоритм Краута (компактная схема Гаусса)
//LU-разложения несимметрической квадратной матрицы с вычислением определителя, который
//возвращается функцией. Det A = 0 - означает вырожденность комплексной матрицы.
//Параметры Real, Imag & Power дают возможность представить определитель в виде:
// Det = (Real + i*Imag) * 2^(Power), что позволяет избежать переполнения разрядной сетки
//компьютера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double* Real (NULL) - указатель на мантиссу реальной части определителя;
//2. double* Imag (NULL) - указатель на мантиссу мнимой части определителя;
//3. long* Power (NULL) - указатель на показатель степени числа 2 определителя матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex Det - значение определителя матрицы
//****************************************************************************************
complex TComplexMatrix::DET_UnSymmetric(double* Real, double* Imag, long* Power)
const
{complex Det;//Значение определителя комплексной матрицы
 try
 {if (IsZeroSize()) throw M_ZERO_ERROR;//Матрица нулевого размера
  if (!IsSquare()) throw M_TYPE_ERROR; //Матрица не квадратная
  cmatrix LU = *this; //Копируем исходную матрицу
  //Формируем вектор перестановок
  ivector ExChange(LU.Rows(),ROW);
  for (ulong i = 0L; i < ExChange.Size(); i++) ExChange.Put(i,i);
  //Объявление рабочих переменных
  double detr = 1.0; //мантисса реальной части определителя
  double deti = 0.0; //мантисса мнимой части определителя
  long dete = 0; //показатель степени определителя
  complex value;
  double x, y, w;
  double z; //норма скалярного произведения на r-ом шаге алгоритма
  ulong l;  //индекс ведущей строки
  //----------------------------------------------------------------------------
  //                             АЛГОРИТМ КРАУТА
  //----------------------------------------------------------------------------
  //1. Вычисление норм всех строк матрицы
  rvector Norms = LU.NormAllRows(EUCLIDEAN_NORM);
  //2. Начало цикла разложения матрицы A на две треугольные: L & U
  for (ulong k = 0L; k < LU.Rows(); k++) //k-ый шаг алгоритма Краута
  {l = k; z = 0.0;
   //Цикл вычисления коэффициентов L(i,k) - нижней треугольной матрицы
   for (ulong i = k; i < LU.Rows(); i++)
   {value = InnerProduct(0,1,k,-LU(i,k),LU,COL,i,LU,ROW,k);
    LU.Put(i,k, -value);
    //Проверка евклидовой нормы i-строки матрицы на нуль
    if (Norms[i] < EPS) //Норма строки равна нулю - матрица A вырождена
    {Det = C_ZERO;
     if (Real != NULL) *Real = 0.0;
     if (Imag != NULL) *Imag = 0.0;
     if (Power != NULL) *Power = 0;
     return Det;
    }
    x = norm(value)/Norms.Get(i);
    if (x > z) {z = x; l = i;}
   }//Конец цикла по i

   //Проверка на перестановку строк l и k
   if (l != k) //Выполнить перестановку
   {//Изменение знака определителя при перестановке строк матрицы
    detr = -detr; deti = -deti;
    LU.ExchangeRows(l, k); //Перестановка строк с индексами l & k
    Norms.Put(l,Norms.Get(k));
   }
   ExChange.Put(k,l);
   //Пошаговое вычисление определителя матрицы
   x = real(LU.Get(k,k));
   y = imag(LU.Get(k,k));
   w = x*detr - y*deti;//Вычисление реальной части мантиссы определителя
   deti = x*deti + y*detr;//Вычисление мнимой части мантиссы определителя
   detr = w;
   //Проверка на вырожденность матрицы A
   if (fabs(detr) < fabs(deti)) w = deti;
   if (fabs(w) < EPS) //Матрица A - вырожденная матрица
   {Det = C_ZERO;
    if (Real != NULL) *Real = 0.0;
    if (Imag != NULL) *Imag = 0.0;
    if (Power != NULL) *Power = 0;
    return Det;
   }
   //Представление определителя матрицы в виде (detr + i*deti)*2^(dete), где
   //max(|detr|,|deti|) = 0 или  1/16 <= |max(|detr|,|deti|)| < 1
   //w = max(|detr|,|deti|)
   while (fabs(w) >= 1.0)
   {w = w * 0.0625;
    detr = detr * 0.0625;
    deti = deti * 0.0625;
    dete = dete + 4;
   }
   while (fabs(w) < 0.0625)
   {w = w * 16;
    detr = detr * 16;
    deti = deti * 16;
    dete = dete - 4;
   }
   //Цикл вычисления коэффициентов U(k,j) - верхней треугольной матрицы
   complex Lkk = -1/LU.Get(k,k);
   for (ulong j = k+1; j < LU.Cols(); j++)
   {value = InnerProduct(0,1,k,-LU(k,j),LU,COL,k,LU,ROW,j);
    LU.Put(k,j, value * Lkk);
   }//Конец цикла по j

  }//Конец цикла по k
  //---------------------- Конец алгоритма Краута -----------------------------
  if ((Real != NULL) && (Imag != NULL) && (Power != NULL))
  {*Real = detr; *Imag = deti; *Power = dete;}
  //Получение значения определителя в явном виде
  double p = pow(2.0,dete);
  Det = complex(detr*p,deti*p); //Det A = (detr + i*detri) * 2^dete
 }
 catch (int error_type) //Блок обработки исключительной ситуации
 {//Установка выходных данных в случае генерации исключительной ситуации
  Det = C_ZERO;
  if (Real != NULL) *Real = 0.0;
  if (Imag != NULL) *Imag = 0.0;
  if (Power != NULL) *Power = 0;
  string s;
  if (error_type == M_TYPE_ERROR) return Det;
  else if (error_type == M_ZERO_ERROR) return Det;
 }
 return Det;
}
//------------------------------------------------------------------------------
//    Решение комплексных систем линейных алгебраических уравнений
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.4, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// cmatrix LE_UnSymSolution(const cmatrix& B, const ivector& ExChange) const
//НАЗНАЧЕНИЕ: РЕШЕНИЕ КОМПЛЕКСНОЙ СИСТЕМЫ ЛИНЕЙНЫХ УРАВНЕНИЙ ВИДА AX = B
//Данная функция позволяет решить систему линейных уравнений AX = B, где A -
//несимметрическая матрица размера n * n, B - матрица r правых частей размера
//n * r. Данной функции должнен предшествовать вызов функции LU_UnSymmetric(...),
//которая раскладывает матрицу A на произведение верхней U и нижней L треугольных
//матриц. Исходной матрицей в данной функции, служит именно такая разложенная на
//L & U матрица, а не матрица коэффициентов при неизвестных в левой части систе-
//мы линейных уравнений. Информация о перестановке строк при разложении LU-раз-
//ложении матрицы коэффициентов передаются через вектор ExChange. Решение систе-
//мы уравнений AX = B состоит из трех этапов: перестановке элементов правых час-
//тей, которые хранятся в матрице B и последовательного решения сначала системы
//уравнений LY = B, а затем системы UX = Y. Матрицы решений Y, а затем и X запи-
//сываются в матрицу X, которая возвращается по окончании работы функцией. Сле-
//дует заметить, что данная система всегда будет иметь решение, так как матрица
//коэффициентов разложена на матрицы L и U.
//При работе функции используется функция InnerProduct для вычисления скалярного
//произведения элементов комплексных матриц.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& B - ссылка на матрицу правых частей размера n x r
//2. const ivector& ExChange - вектор перестановок строк исходной матрицы при
//   выполнении алгоритма Краута;
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//cmatrix X - матрица решений системы линейных уравнений с r правыми частями
//******************************************************************************
cmatrix TComplexMatrix::LE_UnSymSolution(const cmatrix& B, const ivector& ExChange) const
{cmatrix X;
 try
 {if (B.IsZeroSize()) throw M_ZERO_ERROR;//B - матрица нулевого размера
  //Проверка на соответствие числа строк матрицы коэффициентов при неизвестных
  //A количества строк матрицы правых частей B
  if (Rows() != B.Rows()) throw M_SIZE_ERROR;

  X = B;
  ulong r = B.Cols();
  ulong n = Rows();
  complex x;
  //Шаг 1. Перестановка строк матрицы правых частей B
  if (!ExChange.IsZeroSize()) X.ExchangeRows(ExChange);
  //Решение системы уравнений по k-му столбцу матрицы правых частей B
  for (ulong k = 0; k < r; k++)
  {//Шаг 2. Решение системы LY = B
   for (ulong i = 0; i < n; i++)
   {x = InnerProduct(0,1,i,X(i,k),*this,COL,i,X,ROW,k);
    X.Put(i,k, -x/data[i][i]);
   }
   //Шаг 3. Решение системы UX = B
   for (ulong i = n-1;; i--)
   {x = InnerProduct(i+1,1,n,X(i,k),*this,COL,i,X,ROW,k);
    X.Put(i,k, -x);
    if (i == 0) break;
   }
  }//Конец решения СЛУ с r правыми частями
 }
 //Обработка исключительных ситуаций
 catch (int error_type)
 {
  if (error_type == M_SIZE_ERROR) return X;
  else if (error_type == M_ZERO_ERROR) return X;
 }//Конец блока обработки исключительных ситуаций
 return X;//Матрица решений для r правых частей СЛУ вида AX = B.
}
//******************************************************************************
//СТАТУС: I.5, TComplexMatrix class friend function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend cmatrix LE_UnSymSolution(const cmatrix& A, const cmatrix& B)
//НАЗНАЧЕНИЕ: РЕШЕНИЕ КОМПЛЕКСНОЙ СИСТЕМЫ ЛИНЕЙНЫХ УРАВНЕНИЙ ВИДА AX = B
//Данная функция позволяет решить систему линейных уравнений AX = B, где A -
//несимметрическая матрица размера n * n коэффициентов СЛУ при неизвестных,
//B - матрица r правых частей размера n * r. Функция для решения системы линей-
//ных уравнений использует разновидность компактной схемы Гаусса - алгоритм
//Краута и состоит из двух основных частей: 1) Разложения матрицы A на верхнюю
//U треугольную матрицу с единицами на главной диагонале и нижнюю L треугольную
//матрицу по алгоритму Краута 2) Собственно нахождения неизвестных (вектора реше-
//ния) для r правых частей матрицы B. Работа функции строится на вызове двух
//функций LU_UnSymmetric(...) и LE_UnSymSolution(...).
//В ходе решения системы линейных уравнений могут возникать исключительные ситуа-
//ции. Основные причины генерации таких ситуаций следующие: вырожденность матри-
//цы A (detA = 0), несоответствие числа строк матрицы B матрице A, нулевыми раз-
//мерами матриц A или B. При возникновении исключительной ситуации возвращается
//матрица решений X нулевого размера без принудительного завершения работы всей
//программы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& A - ссылка на матрицу коэффициентов при неизвестных размера
//   n x n
//2. const cmatrix& B - ссылка на матрицу правых частей размера n x r
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//cmatrix X - матрица решений системы линейных уравнений с r правыми частями
//******************************************************************************
cmatrix LE_UnSymSolution(const cmatrix& A, const cmatrix& B)
{cmatrix X;
 try
 {//Проверка матриц A & B на матрицы нулевого размера
  if (B.IsZeroSize() || A.IsZeroSize()) throw M_ZERO_ERROR;
  //Проверка матрицы А на квадратную
  if (!A.IsSquare()) throw M_SIZE_ERROR;
  //Проверка на соответствие числа строк матрицы коэффициентов при неизвестных
  //A количества строк матрицы правых частей B
  if (A.Rows() != B.Rows()) throw M_SIZE_MISMATCH;
  //----------------------------------------------------------------------------
  //1. Разложение матрицы A по алгоритму Краута вида A = LU
  //----------------------------------------------------------------------------
  complex Det;
  cmatrix LU;
  ivector ExChange;
  bool lSuccess = A.LU_UnSymmetric(Det, LU, ExChange);
  //Анализ матрицы A на вырожденность - det A = 0
  if (lSuccess == false) throw M_DEGENERACY;
  //----------------------------------------------------------------------------
  //2. Решение комплексной системы линейных уравнений с r-правыми частями
  //----------------------------------------------------------------------------
  X = LU.LE_UnSymSolution(B, ExChange);
 }
 //Блок обработки исключительных ситуаций
 catch (int error_type)
 {
  if (error_type == M_SIZE_ERROR) return X;
  else if (error_type == M_SIZE_MISMATCH) return X;
  else if (error_type == M_ZERO_ERROR) return X;
  else if (error_type == M_DEGENERACY) return X;//Вырожденная матрица
 }//Конец блока обработки исключительных ситуаций
 return X;//Матрица решений СЛУ с r правыми частями
}

//------------------------------------------------------------------------------
// Обращение комплексных матриц
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: I.6, TComplexMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: cmatrix INV_Krauth() const
//НАЗНАЧЕНИЕ: ОБРАЩЕНИЕ НЕСИММЕТРИЧЕСКОЙ КВАДРАТНОЙ МАТРИЦЫ С ИСПОЛЬЗОВАНИЕМ
//            КОМПАКТНОЙ СХЕМЫ ГАУССА (АЛГОРИТМ КРАУТА) ДЛЯ РЕШЕНИЯ СЛУ
//Данная функция позволяет обратить несимметрическую квадратную матрицу размера
//n * n. Работа функции сходна с функцией для решения системы линейных уравнений
//с использованием компактной схемы Гаусса и состоит из двух основных частей:
//1) LU разложения матрицы A по алгоритму Краута 2) Собственно нахождения обрат-
//ной матрицы, когда матрица правых частей B является единичной матрицей размера
//n x n. Работа функции строится на вызове двух функций LU_UnSymmetric(...) и
//LE_UnSymSolution(...). После выполнения последней функции элементы преобразо-
//ванной матрицы B являются элементами ОБРАТНОЙ МАТРИЦЫ.
//При обращении матрицы могут возникать исключительные ситуации. Основные причи-
//ны генерации таких ситуаций следующие: вырожденность исходной матрицы A
//(detA = 0), нулевым размером матрицы A, матрица А не является квадратной. При
//возникновении исключительной ситуации возвращается матрица Inverse нулевого
//размера без принудительного завершения работы всей программы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//cmatrix Inverse - обратная матрица
//******************************************************************************
cmatrix TComplexMatrix::INV_Krauth() const
{cmatrix Inverse;
 try
 {if (IsZeroSize()) throw M_ZERO_ERROR;//Матрица A - матрица нулевого размера
  if (!IsSquare()) throw M_SIZE_ERROR;//Проверка матрицы А на квадратную
  //----------------------------------------------------------------------------
  //1. LU разложение матрицы A по алгоритму Краута
  //----------------------------------------------------------------------------
  complex Det;
  cmatrix LU;
  ivector ExChange;
  bool lSuccess = LU_UnSymmetric(Det, LU, ExChange);
  //Анализ матрицы A на вырожденность - det A = 0
  if (lSuccess == false) throw M_DEGENERACY;
  //----------------------------------------------------------------------------
  //2. Обращение матрицы А n x n решением системы линейных уравнений AX = B, где
  //   матрица B - единичная матрица размера n x n.
  //----------------------------------------------------------------------------
  cmatrix E(Rows(),CM_UNIT);
  Inverse = LU.LE_UnSymSolution(E, ExChange);
 }
 //Блок обработки исключительных ситуаций
 catch (int error_type)
 {if (error_type == M_SIZE_ERROR) return Inverse;
  else if (error_type == M_ZERO_ERROR) return Inverse;
  else if (error_type == M_DEGENERACY) return Inverse;//Вырожденная матрица
 }//Конец блока обработки исключительных ситуаций
 return Inverse;//Обратная матрица
}

//----------------------------------------------------------------------------------------
//Расчет собственных значений и собственных векторов комплексных матриц
//----------------------------------------------------------------------------------------
//****************************************************************************************
//СТАТУС: I.7, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// uint EVV_Jacobi(rvector& D, rmatrix& V, double EPS = 1e-19)
//НАЗНАЧЕНИЕ: РАСЧЕТ СОБСТВЕННЫХ ЗНАЧЕНИЙ И СОБСТВЕННЫХ ВЕКТОРОВ МАТРИЦЫ
//Функция определяет ВСЕ собственные значения и собственные векторы эрмитовой матрицы по
//алгоритму ЯКОБИ. Для этого эрмитова матрица преобразуется в действительную матрицу, кото-
//рая является СИММЕТРИЧЕСКОЙ. Далее вызывается функция для расчета собственных чисел и
//векторов по методу Якоби для действительной симметрической матрицы. Если комплексная
//матрица не является эрмитовой, то алгоритм расчета не будет выполнен, количество вращений
//будет равно 0. Для эрмитовой матрицы будет получено удвоенное количество собственных зна-
//чений и векторов, пары таких значений и векторов будут равны между собой.
//После выполнения алгоритма Якоби расположение собственных значений не упорядочено.
//Собственный вектор Vi, записываемый в i-й столбец матрицы D, будет соответствовать i-му
//собственному числу, записываемому в вектор D с порядковым номером i.
//Преобразование эрмитовой матрицы C = A + iB в действительную симметрическую матрицу R
//происходит по следующей схеме:
//     | A  -B |
// R = |       |, A, B - матрицы действительных и мнимых частей матрицы C.
//     | B   A |  (Прим.: размерность R в два раза больше по строкам и столбцам, чем C.)
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& D - вектор, в котором будут храниться парные собственные числа матрицы;
//2. rmatrix& V - матрица, в которую будут передаваться вычисленные собственные вектора,
//   соответствующие собственным числам, расположенным в векторе D;
//3. double EPS (1e-30) - заданная точность вычислений.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint rot - количество проведенных плоских вращений при приведении
// исходной матрицы к диагональному виду.
//****************************************************************************************
uint TComplexMatrix::EVV_Jacobi(rvector& D, rmatrix& V, double EPS)
{uint rot = 0;//Счетчик числа проведенных плоских вращений
 const ulong limit = 2147483648L;
 //Предотвращение попытки преобразования комплексной матрицы большого размера
 if ((Rows() > limit) || (Cols() > limit))
 {D.Resize(0,false); V.Set(0,false); return rot;}
 double Real, Image;
 complex z;
 ulong m = Rows(), n = Cols();
 TRealMatrix A(2*m,2*n,false);//Установка свойств действительной матрицы

 //Копирование значений элементов исходной комплексной матрицы
 for (ulong i = 0L; i < m; i++)
  for (ulong j = 0L; j < n; j++)
  {z = data[i][j];
   Real = real(z); Image = imag(z);
   A.Put(i,j,Real); A.Put(i+m,j+n,Real);
   A.Put(i,j+n,-Image); A.Put(i+m,j,Image);
  }
 //Расчет собственных значений и векторов преобразованной эрмитовой матрицы в
 //эквивалентную ей действительную симметрическую матрицу
 rot = A.EVV_Jacobi(D,V,EPS);
 return rot;
}
//****************************************************************************************
//СТАТУС: I.7.1, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// int EV_Jacobi(rvector& D, double EPS = 1e-19, bool lExcludePairVals = true) const
//НАЗНАЧЕНИЕ: РАСЧЕТ СОБСТВЕННЫХ ЗНАЧЕНИЙ ЭРМИТОВОЙ МАТРИЦЫ
//Функция определяет ВСЕ собственные значения эрмитовой матрицы по алгоритму ЯКОБИ для сим-
//метрических матриц. Для этого эрмитова матрица преобразуется в действительную матрицу,
//которая будет СИММЕТРИЧЕСКОЙ. Далее вызывается функция для расчета собственных чисел по
//методу Якоби для действительной симметрической матрицы. С целью ускорения вычислений про-
//верка на эритовость исходной матрицы не осуществляется. Для эрмитовой матрицы будет полу-
//чено удвоенное количество собственных значений, пары таких значений будут равными. Опция
//lExcludePairVals позволяет исключить парные значения. После выполнения алгоритма Якоби
//расположение собственных значений будет упорядочено благодаря проведения сортировки по
//возрастанию.
//Преобразование эрмитовой матрицы C = A + iB в действительную симметрическую матрицу R
//происходит по следующей схеме:
//     | A  -B |
// R = |       |, A, B - матрицы действительных и мнимых частей матрицы C.
//     | B   A |  (Прим.: размерность R в два раза больше по строкам и столбцам, чем C.)
//Функция возвращает количество вращений rot - в случае удачи и -1 - в противном случае.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rvector& D - вектор, в котором будут храниться собственные числа матрицы;
//2. double EPS (1e-19) - заданная точность вычислений;
//3. lExcludePairVals (true) - опция исключения парных значений собственных чисел.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: int rot - количество проведенных плоских вращений при приведении
// исходной матрицы к диагональному виду.
//****************************************************************************************
int TComplexMatrix::EV_Jacobi(rvector& D, double EPS, bool lExcludePairVals) const
{uint rot = 0;//Счетчик числа проведенных плоских вращений
 const ulong limit = 2147483648L;
 ulong n = this->Rows();
 double Real, Image;
 complex z;
 rvector EVals;
 //Проверка матрицы на КВАДРАТНУЮ и НЕНУЛЕВОГО размера, предотвращение попытки преобразова-
 //ния комплексной матрицы большого размера
 if (!this->IsSquare() || this->IsZeroSize() || n > limit) {D.Resize(0,false); return -1;}
 //Установка размеров действительной матрицы
 TRealMatrix A(2*n,2*n,false);
 //Копирование значений элементов исходной комплексной матрицы
 for (ulong i = 0L; i < n; i++)
  for (ulong j = 0L; j < n; j++)
  {z = data[i][j];
   Real = real(z); Image = imag(z);
   A.Put(i,j,Real); A.Put(i+n,j+n,Real);
   A.Put(i,j+n,-Image); A.Put(i+n,j,Image);
  }
 //Расчет собственных значений действительную симметрическую матрицу эквивалентной исходной
 //эрмитовой матрицы c сортировкой собственных значений по возрастанию
 rot = A.EV_Jacobi(EVals,EPS,true);
 if (rot != -1)
 {if (lExcludePairVals) //Исключение парных собственных значений
  {D.Set(n,ROW,false);
   for (ulong i = 0; i < n; i++) D.Put(i,EVals.Get(2*i));
  }
  else D = EVals;
 }
 else D.Set(0,ROW,false);
 return rot;
}
//****************************************************************************************
//СТАТУС: I.8, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool HessenbergForm(rmatrix& Ar, rmatrix& Ai, ivector& permut) const
//НАЗНАЧЕНИЕ: Приведение к форме Хессенберга исходной комплексной матрицы. Реальные и мни-
//мые части матрицы Хессенберга H будут хранится в вещественных матрицах Ar и Ai. Исходная
//матрица должна быть КВАДРАТНОЙ.
//Данная процедура является базовой для других алгоритмов решения полной проблемы собственных
//чисел комплексных матриц общего вида.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. rmatrix& Ar - вещественная матрица-приемник реальной части матрицы Хессенберга;
//2. rmatrix& Ai - вещественная матрица-приемник мнимой части матрицы Хессенберга;
//3. ivector& permut - целочисленный вектор для обозначения строк и столбцов, которые
//   подверглись перестановкам в процессе приведения исходной матрицы к матрице Хессенберга.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат приведения исходной матрицы к матрице
//Хессенберга
//****************************************************************************************
bool TComplexMatrix::HessenbergForm(rmatrix& Ar, rmatrix& Ai, ivector& permut) const
{//------------------------------------------------------------------------------------
 //Проверка исходной матрицы на квадратную
 if ((this->IsZeroSize()) || (this->Rows() != this->Cols()))
 {Ar.Set(0,false); Ai.Set(0,false); permut.Resize(0,false);
  return false;
 }
 //Копирование реальной и мнимой частей в матрицы Ar и Ai
 if (ComplexToReal(*this,Ar,Ai) == false) {permut.Resize(0,false); return false;}
 permut.Resize(this->Rows(),false);
 for (ulong i = 0; i < permut.Size(); i++) permut.Put(i,i);
 //-------------------------------------------------------------------------------------
 //Рабочие переменные
 ulong n = this->Rows();
 ulong l = n-1;
 ulong k = 0;
 ulong la = l - 1;
 ulong i;
 double xr, xi, yr, yi;
 complex z;

 //Основной цикл функции
 for (ulong m = k+1; m <= la; m++)
 {i = m; xr = xi = 0;
  for (ulong j = m; j <= l; j++)
  {if (fabs(Ar.Get(j,m-1))+fabs(Ai.Get(j,m-1)) > fabs(xr)+fabs(xi))
   {xr = Ar.Get(j,m-1); xi = Ai.Get(j,m-1);
    i = j;
   }
  }
  permut.Put(m,i);
  //Перестановка строк и столбцов в матрицах Ar и Ai
  if (i != m)
  {for (ulong j = m-1; j < n; j++)
   {yr = Ar.Get(i,j); Ar.Put(i,j,Ar.Get(m,j)); Ar.Put(m,j,yr);
    yi = Ai.Get(i,j); Ai.Put(i,j,Ai.Get(m,j)); Ai.Put(m,j,yi);
   }
   for (ulong j = 0; j <= l; j++)
   {yr = Ar.Get(j,i); Ar.Put(j,i,Ar.Get(j,m)); Ar.Put(j,m,yr);
    yi = Ai.Get(j,i); Ai.Put(j,i,Ai.Get(j,m)); Ai.Put(j,m,yi);
   }
  }//Конец перестановок

  if ((xr != 0.0) || (xi != 0.0))
  {for (i = m+1; i <= l; i++)
   {yr = Ar.Get(i,m-1); yi = Ai.Get(i,m-1);
    if ((yr != 0.0) || (yi != 0.0))
    {//Вместо процедуры cdiv(yr,yi,xr,xi,yr,yi)
     z = complex(yr,yi)/complex(xr,xi);
     yr = real(z); yi = imag(z);
     Ar.Put(i,m-1,yr); Ai.Put(i,m-1,yi);

     for (ulong j = m; j < n; j++)
     {Ar.Put(i,j,Ar.Get(i,j) - yr*Ar.Get(m,j) + yi*Ai.Get(m,j));
      Ai.Put(i,j,Ai.Get(i,j) - yr*Ai.Get(m,j) - yi*Ar.Get(m,j));
     }//Конец цикла по j

     for (ulong j = 0; j <= l; j++)
     {Ar.Put(j,m,Ar.Get(j,m) + yr*Ar.Get(j,i) - yi*Ai.Get(j,i));
      Ai.Put(j,m,Ai.Get(j,m) + yr*Ai.Get(j,i) + yi*Ar.Get(j,i));
     }//Конец цикла по j

    }//Условие: yr != 0.0 || yi != 0.0

   }//Конец цикла по i

  }//Условие: xr != 0.0 || xi != 0.0

 }//Конец цикла по m

 return true;
}
//****************************************************************************************
//СТАТУС: I.9, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool EVV_LR_algorithm(cvector& W, cmatrix& V, double eps = 1e-19) const
//НАЗНАЧЕНИЕ: Определение собственных значений и ненормированных собственных векторов ком-
//плексной квадратной матрицы с предварительным преобразованием ее к форме Хессенберга.
//При успешном завершении работы функции вектор W будет содержать собственные значения, а
//матрица V - ненормированные собственные векторы исходной матрицы. Выход из процедуры
//происходит в том случае, если для нахождения собственных значений необходимо более 30
//итераций.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& W - вектор-приемник собственных значений комплексной матрицы;
//2. cmatrix& V - матрица-приемник собственных векторов комплексной матрицы;
//3. double eps (1e-19) - относительная точность машины.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат решения полной проблемы собственных значений
//****************************************************************************************
bool TComplexMatrix::EVV_LR_algorithm(cvector& W, cmatrix& V, double eps) const
{//Проверка матрицы на квадратную
 if ((this->IsZeroSize()) || (this->Rows() != this->Cols()))
 {W.Set(0,false); V.Set(0,false); return false;}
 //Объявление рабочих переменных
 rmatrix Hr, Hi;//Реальная и мнимая части формы Хессенберга исходной матрицы
 ivector Permut;
 //-----------------------------------------------------------------------------------
 //I. Приведение исходной матрицы к форме Хессенберга
 if (this->HessenbergForm(Hr,Hi,Permut) == false)
 {W.Set(0,false); V.Set(0,false); return false;}
 //-----------------------------------------------------------------------------------
 //II. Решение полной проблемы собственных значений
 //Объявление рабочих переменных
 long i, j, k, m, its, en;
 double sr, si, tr, ti, xr, xi, yr, yi, zr, zi, norm;
 complex z;
 long n = this->Rows();
 long low = 0;
 long upp = n-1;
 bool lBreak;
 //Векторы мнимой и реальной частей собственных значений исходной матрицы
 rvector Wr(n,COL,0.0);
 rvector Wi(n,COL,0.0);
 //Матрицы мнимых и реальных частей собственных ненормированных векторов исходной матрицы
 rmatrix Vr(n,0.0);
 rmatrix Vi(n,0.0);

 //Debug
 ofstream ftest;
 ftest.open("debug.txt");
 ftest << "Complex matrix C: " << *this << endl;
 ftest << "Hessenberg form of matrix C" << endl;
 ftest << "Real part Hr: " << Hr << endl;
 ftest << "Image part Hi: " << Hi << endl;
 ftest << "Permutation vector Permut: " << Permut << endl;
 

 tr = ti = 0.0;
 //Начальная инициализация матриц Vr и Vi как единичных диагональных матриц
 for (i = 0; i < n; i++) Vr.Put(i,i,1.0);

 ftest << "1. Init real & image parts Eigen Vectors" << endl;
 ftest << "Init EigenVecs Vr: " << Vr << endl;
 ftest << "Init EigenVecs Vi: " << Vi << endl;

 //!!! New
 //for (i = 0; i < n; i++) Permut.Put(i,i);

 for (i = upp-1; i >= low+1; i--)
 {j = Permut.Get(i);
  for (k = i+1; k <= upp; k++) {Vr.Put(k,i,Hr.Get(k,i-1)); Vi.Put(k,i,Hi.Get(k,i-1));}
  if (i != j)
  {for (k = i; k <= upp; k++)
   {Vr.Put(i,k,Vr.Get(j,k)); Vi.Put(i,k,Vi.Get(j,k));
    Vr.Put(j,k,0.0); Vi.Put(j,k,0.0);
   }//Конец цикла по k
   Vr.Put(j,i,1.0);
  }//end i != j
 }//Конец цикла по i

 ftest << "2. Real & image parts Eigen Vectors before calculate EigenVals" << endl;
 ftest << "Init EigenVecs Vr: " << Vr << endl;
 ftest << "Init EigenVecs Vi: " << Vi << endl;


 en = upp;


 do //Цикл вычисления всех собственных значений
 {its = 0;
  do //Цикл выделения единственного малого поддиагонального элемента - цикл итераций
  {lBreak = false;
   for (k = en; k >= low+1; k--)
   {if (fabs(Hr.Get(k,k-1))+fabs(Hi.Get(k,k-1)) <=
        eps*(fabs(Hr.Get(k-1,k-1)) + fabs(Hi.Get(k-1,k-1)) +
             fabs(Hr.Get(k,k)) + fabs(Hi.Get(k,k)))) {lBreak = true; break;}
   }
   if (!lBreak) k = low;
   //Проверка на выход из цикла итераций для вычисления собственного значения
   if (k == en) break;
   //Проверка на выход из функции
   if (its == 30) {W.Set(0,false); V.Set(0,false); return false;}

   //Формирование сдвига
   if ((its == 10) || (its == 20))
   {sr = fabs(Hr.Get(en,en-1)) + fabs(Hr.Get(en-1,en-2));
    si = fabs(Hi.Get(en,en-1)) + fabs(Hi.Get(en-1,en-2));
   }
   else
   {sr = Hr.Get(en,en); si = Hi.Get(en,en);
    xr = Hr.Get(en-1,en)*Hr.Get(en,en-1) - Hi.Get(en-1,en)*Hi.Get(en,en-1);
    xi = Hr.Get(en-1,en)*Hi.Get(en,en-1) + Hi.Get(en-1,en)*Hr.Get(en,en-1);

    if ((xr != 0.0) || (xi != 0.0))
    {yr = (Hr.Get(en-1,en-1) - sr)/2.0;
     yi = (Hi.Get(en-1,en-1) - si)/2.0;
     z = csqrt(yr*yr - yi*yi + xr, 2.0*yr*yi + xi);
     zr = real(z); zi = imag(z);
     if ((yr*zr + yi*zi) < 0.0) {zr = -zr; zi = -zi;}
     z = cdiv(xr,xi,yr+zr,yi+zi);
     xr = real(z); xi = imag(z);
     sr = sr - xr; si = si - xi;
    }// xr != 0 or xi != 0
   }//  its != 10 && its != 20

   for (i = low; i <= en; i++) {Hr.Put(i,i,Hr.Get(i,i)-sr); Hi.Put(i,i,Hi.Get(i,i)-si);}
   tr = tr + sr; ti = ti + si; its = its+1; j = k+1;

   //Выделение последовательных малых поддиагональных элементов
   xr = fabs(Hr.Get(en-1,en-1)) + fabs(Hi.Get(en-1,en-1));
   yr = fabs(Hr.Get(en,en-1)) + fabs(Hi.Get(en,en-1));
   zr = fabs(Hr.Get(en,en)) + fabs(Hi.Get(en,en));
   lBreak = false;
   for (m = en-1; m >= j; m--) //start m
   {yi = yr; yr = fabs(Hr.Get(m,m-1)) + fabs(Hi.Get(m,m-1));
    xi = zr; zr = xr;
    xr = fabs(Hr.Get(m-1,m-1)) + fabs(Hi.Get(m-1,m-1));
    if (yr <= (eps*zr/yi*(zr+xr+xi))) {lBreak = true; break;}
   }//end m
   if (!lBreak) m = k;

   //Треугольное разложение вида H = L*R
   for (i = m+1; i <= en; i++)
   {xr = Hr.Get(i-1,i-1); xi = Hi.Get(i-1,i-1);
    yr = Hr.Get(i,i-1); yi = Hi.Get(i,i-1);
    if ((fabs(xr)+fabs(xi)) < (fabs(yr)+fabs(yi)))
    {//Перестановка строк в массивах hr и hi
     for (j = i-1; j < n; j++)
     {zr = Hr.Get(i-1,j); Hr.Put(i-1,j,Hr.Get(i,j)); Hr.Put(i,j,zr);
      zi = Hi.Get(i-1,j); Hi.Put(i-1,j,Hi.Get(i,j)); Hi.Put(i,j,zi);
     }//end j
     z = cdiv(xr,xi,yr,yi);
     zr = real(z); zi = imag(z); Wr.Put(i,1.0);
    }
    else
    {z = cdiv(yr,yi,xr,xi);
     zr = real(z); zi = imag(z); Wr.Put(i,-1.0);
    }
    Hr.Put(i,i-1,zr); Hi.Put(i,i-1,zi);
    for (j = i; j < n; j++)
    {Hr.Put(i,j,Hr.Get(i,j) - zr*Hr.Get(i-1,j) + zi*Hi.Get(i-1,j));
     Hi.Put(i,j,Hi.Get(i,j) - zr*Hi.Get(i-1,j) - zi*Hr.Get(i-1,j));
    }//end j
   }//end i

   //Вычисление произведения R*L = H
   for (j = m+1; j <= en; j++)
   {xr = Hr.Get(j,j-1); xi = Hi.Get(j,j-1);
    Hr.Put(j,j-1,0.0); Hi.Put(j,j-1,0.0);

    //Перестановка столбцов в матрицах Hr, Hi, Vr, Vi, если требуется
    if (Wr.Get(j) > 0)
    {for (i = 0; i <= j; i++)
     {zr = Hr.Get(i,j-1); Hr.Put(i,j-1,Hr.Get(i,j)); Hr.Put(i,j,zr);
      zi = Hi.Get(i,j-1); Hi.Put(i,j-1,Hi.Get(i,j)); Hi.Put(i,j,zi);
     }
     for (i = low; i <= upp; i++)
     {zr = Vr.Get(i,j-1); Vr.Put(i,j-1,Vr.Get(i,j)); Vr.Put(i,j,zr);
      zi = Vi.Get(i,j-1); Vi.Put(i,j-1,Vi.Get(i,j)); Vi.Put(i,j,zi);
     }
    }//end перестановки столбцов

    for (i = 0; i <= j; i++)
    {Hr.Put(i,j-1,Hr.Get(i,j-1) + xr*Hr.Get(i,j) - xi*Hi.Get(i,j));
     Hi.Put(i,j-1,Hi.Get(i,j-1) + xr*Hi.Get(i,j) + xi*Hr.Get(i,j));
    }//end i
    for (i = low; i <= upp; i++)
    {Vr.Put(i,j-1,Vr.Get(i,j-1) + xr*Vr.Get(i,j) - xi*Vi.Get(i,j));
     Vi.Put(i,j-1,Vi.Get(i,j-1) + xr*Vi.Get(i,j) + xi*Vr.Get(i,j));
    }//end накопления преобразований
   }//end j
  } while (true);//Конец цикла итераций

  //Отыскание собственного значения
  Wr.Put(en,Hr.Get(en,en)+tr); Wi.Put(en,Hi.Get(en,en)+ti);
  if (en == 0) break;//Все собственные значения найдены
  else en = en - 1;
 } while (true);//Конец цикла вычисления всех собственных значений

 //----------------------------------------------------------------------------------
 //Вычисление собственных ненормированных векторов матрицы
 //---------------------------------------------------------------------------------
 norm = 0.0;
 for (i = 0; i < n; i++)
 {norm = norm + fabs(Wr.Get(i)) + fabs(Wi.Get(i));
  for (j = i+1; j < n; j++) norm = norm + fabs(Hr.Get(i,j)) + fabs(Hi.Get(i,j));
 }
 //Обратная подстановка для определения собственных векторов верхней треугольной матрицы
 for (en = n-1; en > 0; en--)
 {xr = Wr.Get(en); xi = Wi.Get(en);
  for (i = en-1; i >= 0; i--)
  {zr = Hr.Get(i,en); zi = Hi.Get(i,en);
   for (j = i+1; j <= en-1; j++)
   {zr = zr + Hr.Get(i,j)*Hr.Get(j,en) - Hi.Get(i,j)*Hi.Get(j,en);
    zi = zi + Hr.Get(i,j)*Hi.Get(j,en) + Hi.Get(i,j)*Hr.Get(j,en);
   }
   yr = xr - Wr.Get(i); yi = xi - Wi.Get(i);
   if ((yr == 0.0) && (yi == 0.0)) yr = eps*norm;
   z = cdiv(zr,zi,yr,yi);
   Hr.Put(i,en,real(z)); Hi.Put(i,en,imag(z));
  }//end i
 }//end обратной подстановки

 //Умножение на матрицу преобразования для восстановления собственных векторов исходной
 //полной матрицы
 for (j = n-1; j >= low; j--) 
  for (i = low; i <= upp; i++)
  {zr = Vr.Get(i,j); zi = Vi.Get(i,j);
   m = (upp < j) ? upp : j-1; //m = j-1;
   for (k = low; k <= m; k++)
   {zr = zr + Vr.Get(i,k)*Hr.Get(k,j) - Vi.Get(i,k)*Hi.Get(k,j);
    zi = zi + Vr.Get(i,k)*Hi.Get(k,j) + Vi.Get(i,k)*Hr.Get(k,j);
   }
   Vr.Put(i,j,zr); Vi.Put(i,j,zi);
  }//end i,j

 //Копирование реальной и мнимой частей собственных значений из векторов Wr & Wi в
 //комплексный вектор W
 W.Set(n,COL,false);
 for (i = 0; i < n; i++) W.Put(i,complex(Wr.Get(i),Wi.Get(i)));

 //Копирование реальных и мнимых частей собственных векторов из матриц Vr & Vi в
 //комплексную матрицу V
 V.Set(n,false);
 for (i = 0; i < n; i++)
  for (j = 0; j < n; j++) V.Put(i,j,complex(Vr.Get(i,j),Vi.Get(i,j)));

 return true;
}
//****************************************************************************************
//СТАТУС: I.10, TComplexMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool EVV_NormReducingJacobi(cvector& W, cmatrix& V, double eps = 1e-19) const
//НАЗНАЧЕНИЕ: Определение собственных значений и ненормированных собственных векторов для
//комплексной квадратной матрицы общего вида по методу Якоби с понижением нормы.
//При успешном завершении работы функции вектор W будет содержать собственные значения, а
//матрица V - ненормированные собственные векторы исходной матрицы. Функция определяет
//систему правых собственных векторов Inv(W)*D*W, где D - диагональная матрица собственных
//значений исходной матрицы; W - система правых собственных векторов; Inv(W) - система ле-
//вых собственных векторов. Собственные значения располагаются в порядке убывания их абсо-
//лютной величины.
//Выход из процедуры происходит в следующих случаях:
//1) Sum(i!=j)Cij < 100*eps, eps - машинная точность,
//   Sum(i!=j)Cij - сумма всех внедиагональных элементов исходной матрицы;
//2) Не было выполнено ни одного преобразования в течение полного цикла;
//3) Для нахождения собственных значений выполнено более 35 итераций.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cvector& W - вектор-приемник собственных значений комплексной матрицы;
//2. cmatrix& V - матрица-приемник собственных векторов комплексной матрицы;
//3. double eps (1e-19) - относительная точность машины.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - результат решения полной проблемы собственных значений
//****************************************************************************************
bool TComplexMatrix::EVV_NormReducingJacobi(cvector& W, cmatrix& V, double eps) const
{//Проверка матрицы на квадратную
 if ((this->IsZeroSize()) || (this->Rows() != this->Cols()))
 {W.Set(0,false); V.Set(0,false); return false;}
 //--------------------------------------------------------------------------------------
 //Объявление рабочих переменных
 double tau, tem, tep, max, hj, hr, hi, g, te, tee, br, bi, er, ei, dr, di;
 double root, root1, root2, ca, sa, cb, sb, cx, sx, sh, ch, eta, tse, nd, nc, s, c;
 double cot2x, d, de, sig, cotx, cos2a, sin2a, tanh, c1r, c2r, s1r, s2r, c1i, c2i;
 double s1i, s2i, isw, b, e, zim, zik, aik, aim, tim, tik, uim, uik, ami, aki, zki, zmi;

 long i, j, k, m, it;
 long n = this->Rows();
 bool mark = false;
 bool lBreak;
 rmatrix A, Z;//Матрицы для размещения реальной и мнимой частей исходной матрицы;
 //Матрицы для размещения реальной и мнимой частей собственных векторов
 rmatrix T(n,false);//Реальная часть собственных векторов исходной матрицы
 rmatrix U(n,false);//Мнимая часть собственных векторов исходной матрицы
 rvector en(n,COL,0.0);
 //-------------------------------------------------------------------------------------
 //Предварительная подготовка к вычислениям
 //------------------------------------------------------------------------------------
 //Представление исходной матрицы в виде C = A + iZ, С - исходная комплексная матрица
 if (ComplexToReal(*this,A,Z) == false) {W.Set(0,false); V.Set(0,false); return false;};
 //Формирование единичной матрицы T и нулевой матрицы U
 for (i = 0; i < n; i++)
 {T.Put(i,i,1.0); U.Put(i,i,0.0);
  for (j = i+1; j < n; j++)
  {T.Put(i,j,0.0); T.Put(j,i,0.0); U.Put(i,j,0.0); U.Put(j,i,0.0);}
 }
 //-------------------------------------------------------------------------------------
 //Основной цикл функции
 //-------------------------------------------------------------------------------------
 for (it = 1; it <= 35; it++)
 {if (mark) break;//Выход из цикла
  //Критерий сходимости
  tau = 0.0;
  for (k = 0; k < n; k++)
  {tem = 0.0;
   for (i = 0; i < n; i++)
   {if (i != k) tem = tem + fabs(A.Get(i,k)) + fabs(Z.Get(i,k));
   }
   tau = tau + tem;
   en.Put(k,tem + fabs(A.Get(k,k)) + fabs(Z.Get(k,k)));
  }
  //Перестановка строк и столбцов
  for (k = 0; k < n-1; k++)
  {max = en.Get(k); i = k;
   for (j = k+1; j < n; j++)
   {if (en.Get(j) > max) {max = en.Get(j); i = j;}
   }
   if (i != k)
   {en.Put(i,en.Get(k));
    for (j = 0; j < n; j++)
    {tep = A.Get(k,j); A.Put(k,j,A.Get(i,j)); A.Put(i,j,tep);
     tep = Z.Get(k,j); Z.Put(k,j,Z.Get(i,j)); Z.Put(i,j,tep);
    }//end j
    for (j = 0; j < n; j++)
    {tep = A.Get(j,k); A.Put(j,k,A.Get(j,i)); A.Put(j,i,tep);
     tep = Z.Get(j,k); Z.Put(j,k,Z.Get(j,i)); Z.Put(j,i,tep);
     tep = T.Get(j,k); T.Put(j,k,T.Get(j,i)); T.Put(j,i,tep);
     tep = U.Get(j,k); U.Put(j,k,U.Get(j,i)); U.Put(j,i,tep);
    }//end j
   }//end i != k
  }//end k
  if (tau < 100.0*eps) break;//Выход из основного цикла по итерациям
  //Перебор элементов матрицы
  mark = true;
  for (k = 0; k < n-1; k++)
   for (m = k+1; m < n; m++)
   {hj = hr = hi = g = 0.0;
    for (i = 0; i < n; i++)
    {if ((i != k) && (i != m))
     {hr = hr + A.Get(k,i)*A.Get(m,i) + Z.Get(k,i)*Z.Get(m,i)
              - A.Get(i,k)*A.Get(i,m) - Z.Get(i,k)*Z.Get(i,m);
      hi = hi + Z.Get(k,i)*A.Get(m,i) - A.Get(k,i)*Z.Get(m,i)
              - A.Get(i,k)*Z.Get(i,m) + A.Get(i,k)*Z.Get(i,m);
      te =  A.Get(i,k)*A.Get(i,k) + Z.Get(i,k)*Z.Get(i,k) +
            A.Get(m,i)*A.Get(m,i) + Z.Get(m,i)*Z.Get(m,i);
      tee = A.Get(i,m)*A.Get(i,m) + Z.Get(i,m)*Z.Get(i,m) +
            A.Get(k,i)*A.Get(k,i) + Z.Get(k,i)*Z.Get(k,i);
      g = g + te + tee; hj = hj - te + tee;
     }
    }//end i
    br  = A.Get(k,m) + A.Get(m,k); bi = Z.Get(k,m) + Z.Get(m,k);
    er  = A.Get(k,m) - A.Get(m,k); ei = Z.Get(k,m) - Z.Get(m,k);
    dr  = A.Get(k,k) - A.Get(m,m); di = Z.Get(k,k) - Z.Get(m,m);
    te  = br*br + ei*ei + dr*dr;
    tee = bi*bi + er*er + di*di;
    if (te >= tee) {isw = 1.0; c = br; s = ei; d = dr; de = di; root2 = sqrt(te);}
    else {isw = -1.0; c = bi; s = -er; d = di; de = dr; root2 = sqrt(tee);}
    root1 = sqrt(s*s + c*c);
    sig = (d >= 0.0) ? 1.0 : -1.0;
    sa = 0.0; ca = (c >= 0.0) ? 1.0 : -1.0;
    lBreak = false;
    if (root1 < eps)
    {sx = sa = 0.0; cx = ca = 1.0;
     e = (isw > 0.0) ? er : ei;
     b = (isw > 0.0) ? bi : -br;
     nd = d*d + de*de;
     lBreak = true;
    }
    if (!lBreak)
    {if (fabs(s) > eps) {ca = c/root1; sa = s/root1;}
     cot2x = d/root1;
     cotx = cot2x + (sig*sqrt(1.0 + cot2x*cot2x));
     sx = sig/sqrt(1.0 + cotx*cotx);
     cx = sx*cotx;
     //Определение параметров вращения
     eta = (er*br + bi*ei)/root1;
     tse = (br*bi - er*ei)/root1;
     te  = sig*(-root1*de + tse*d)/root2;
     tee = (d*de + root1*tse)/root2;
     nd  = root2*root2 + tee*tee;
     tee = hj*cx*sx;
     cos2a = ca*ca - sa*sa;
     sin2a = 2.0*ca*sa; tem = hr*cos2a + hi*sin2a;
     tep = hi*cos2a - hr*sin2a;
     hr = cx*cx*hr - sx*sx*tem - ca*tee;
     hi = cx*cx*hi + sx*sx*tep - sa*tee;
     b = isw*te*ca + eta*sa;
     e = ca*eta - isw*te*sa;
    }
    s = hr - sig*root2*e;
    c = hi - sig*root2*b;
    root = sqrt(c*c + s*s);
    lBreak = false;
    if (root < eps) {cb = ch = 1.0; sb = sh = 0.0; lBreak = true;}
    if (!lBreak)
    {cb = -c/root; sb = s/root;
     tee  = cb*b - e*sb; nc = tee*tee;
     tanh = root/(g+2.0*(nc + nd));
     ch = 1.0/sqrt(1.0 - tanh*tanh);
     sh = ch*tanh;
    }
    //Подготовка к преобразованию
    tem = sx*sh*(sa*cb - sb*ca);
    c1r = cx*ch - tem; c2r = cx*ch + tem;
    c1i = c2i = -sx*sh*(ca*cb + sa*sb);
    tep = sx*ch*ca; tem = cx*sh*sb;
    s1r = tep - tem; s2r = -tep - tem;
    tep = sx*ch*sa; tem = cx*sh*cb;
    s1i = tep + tem; s2i = tep - tem;
    //Проверка: выполнять преобразование или нет
    tem = sqrt(s1r*s1r + s1i*s1i);
    tep = sqrt(s2r*s2r + s2i*s2i);
    if ((tem > eps) || (tep > eps))
    {mark = false;
     //Левое преобразование
     for (i = 0; i < n; i++)
     {aki = A.Get(k,i); ami = A.Get(m,i);
      zki = Z.Get(k,i); zmi = Z.Get(m,i);
      A.Put(k,i, c1r*aki - c1i*zki + s1r*ami - s1i*zmi);
      Z.Put(k,i, c1r*zki + c1i*aki + s1r*zmi + s1i*ami);
      A.Put(m,i, s2r*aki - s2i*zki + c2r*ami - c2i*zmi);
      Z.Put(m,i, s2r*zki + s2i*aki + c2r*zmi + c2i*ami);
     }//end i
     //Правое преобразование (расчет правых собственных векторов)
     for (i = 0; i < n; i++)
     {aik = A.Get(i,k); aim = A.Get(i,m);
      zik = Z.Get(i,k); zim = Z.Get(i,m);
      A.Put(i,k, c2r*aik - c2i*zik - s2r*aim + s2i*zim);
      Z.Put(i,k, c2r*zik + c2i*aik - s2r*zim - s2i*aim);
      A.Put(i,m, -s1r*aik + s1i*zik + c1r*aim - c1i*zim);
      Z.Put(i,m, -s1r*zik - s1i*aik + c1r*zim + c1i*aim);

      tik = T.Get(i,k); tim = T.Get(i,m);
      uik = U.Get(i,k); uim = U.Get(i,m);
      T.Put(i,k, c2r*tik - c2i*uik - s2r*tim + s2i*uim);
      U.Put(i,k, c2r*uik + c2i*tik - s2r*uim - s2i*tim);
      T.Put(i,m, -s1r*tik + s1i*uik + c1r*tim - c1i*uim);
      U.Put(i,m, -s1r*uik - s1i*tik + c1r*uim + c1i*tim);
     }//end i
    }//end if (tem > eps) || (tep > eps)
   }//end m - конец цикла по m
 }//end it - конец цикла по итерациям

 //Копирование реальной и мнимой частей собственных значений из диагональных элементов
 //матриц A и Z в комплексный вектор W
 W.Set(n,COL,false);
 for (i = 0; i < n; i++) W.Put(i,complex(A.Get(i,i),Z.Get(i,i)));

 //Копирование реальных и мнимых частей собственных векторов из матриц T & U в
 //комплексную матрицу V
 V.Set(n,false);
 for (i = 0; i < n; i++)
  for (j = 0; j < n; j++) V.Put(i,j,complex(T.Get(i,j),U.Get(i,j)));

 return true;
}
//==============================================================================
// II. РЕАЛИЗАЦИЯ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TComplexMatrix
//     PRIVATE MEMBER-FUNCTION OF TComplexMatrix CLASS REALIZATION
//==============================================================================
//******************************************************************************
//СТАТУС: II.1., private, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Initial()
//НАЗНАЧЕНИЕ: Начальная  инициализация свойств комплексной матрицы при ее конст-
//руировании.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::Initial()
{//Начальная инициализация защищенных членов-данных класса при конструировании
 type = SQUARE;  //Комплексная квадратная матрица
 m = 0L; n = 0L; //Установка размерности матрицы
 data = NULL;    //Установка указателя на элементы матрицы в NULL
}
//******************************************************************************
//СТАТУС: II.2., private, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Create()
//НАЗНАЧЕНИЕ: Распределение оперативной памяти под элементы комплексной матрицы
//без их инициализации. Количество элементов матрицы определяется по формуле:
//Q = Rows()*Cols(). Если m или n равны 0, то создается матрица нулевого размера.
//В случае нехватки памяти генерируется ошибка и функция возвращает false.
//Элементы комплексной матрицы хранятся в двумерном массиве data. При создании
//вектора-столбца, получается матрица вида: data[m][1], вектора-строки-data[1][n].
//В общем случае создается матрица следующего вида: data[m][n].
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//******************************************************************************
bool TComplexMatrix::Create()
{//Матрица нулевого размера
 if ((Rows() == 0) || (Cols() == 0)) {Initial(); return false;}
 try //Распределение памяти под элементы матрицы
  {data = new complex*[Rows()];//Распределение памяти под строки матрицы - m
   //Распределение памяти под столбцы матрицы - n
   for (ulong i = 0L; i < Rows(); i++) data[i] = new complex[Cols()];
  }
  // ENTER THIS BLOCK ONLY IF xalloc IS THROWN.
  // YOU COULD REQUEST OTHER ACTIONS BEFORE TERMINATING
  catch (std::bad_alloc) {return false;} //xalloc x
 return true;
}
//******************************************************************************
//СТАТУС: II.3., private, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Delete()
//НАЗНАЧЕНИЕ: Удаление из оперативной памяти элементов комплексной матрицы.
//После завершения работы функции получается матрица нулевого размера.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::Delete()
{//Матрица нулевого размера
 if (data == NULL) {Initial(); return;}
 //Удаление элементов матрицы
 for (ulong i = 0L; i < m; i++) delete[] data[i];
 delete[] data ;
 Initial();
}

//==============================================================================
// III. РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TComplexMatrix
//      PROTECTED MEMBER-FUNCTION OF TComplexMatrix CLASS REALIZATION
//==============================================================================
//------------------------------------------------------------------------------
// РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ФУНКЦИЙ КЛАССА TComplexMatrix ИНИЦИАЛИЗАЦИИ ЭЛЕМЕНТОВ
// МАТРИЦЫ В ЗАВИСИМОСТИ ОТ ЕЕ ПОДТИПА
//------------------------------------------------------------------------------
//******************************************************************************
//СТАТУС: III.1, TComplexMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitZeroMatrix()
//НАЗНАЧЕНИЕ: Инициализация элементы комплексной матрицы с нулевыми элементами
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::InitZeroMatrix()
{for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++) data[i][j] = C_ZERO;
}
//******************************************************************************
//СТАТУС: III.2, TComplexMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitMatrix()
//НАЗНАЧЕНИЕ: Инициализация элементов матрицы (квадратной или прямоугольной)
//случайными значениями.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::InitMatrix()
{randomize();//Инициализация генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++) data[i][j] = complex(rand(),rand());
}
//******************************************************************************
//СТАТУС: III.3, TComplexMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitDiagonal()
//НАЗНАЧЕНИЕ: Инициализация элементов диагональной матрицы случайными значениями
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::InitDiagonal()
{if (IsSquare() == false) {InitMatrix(); return;}
 randomize();//Инициализация генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i == j) ? complex(rand(),rand()) : C_ZERO;
}
//******************************************************************************
//СТАТУС: III.4, TComplexMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitScalar()
//НАЗНАЧЕНИЕ: Инициализация элементов скалярной матрицы случайным значением.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::InitScalar()
{if (IsSquare() == false) {InitMatrix(); return;}
 randomize();//Инициализация генератора случайных чисел
 complex value(rand(),rand());
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i == j) ? value : C_ZERO;
}
//******************************************************************************
//СТАТУС: III.5, TComplexMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitUnit()
//НАЗНАЧЕНИЕ: Инициализация элементов единичной матрицы.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::InitUnit()
{if (IsSquare() == false) {InitMatrix(); return;}
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i == j) ? C_ONE : C_ZERO;
}
//******************************************************************************
//СТАТУС: III.6, TComplexMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitBand(ulong diags)
//НАЗНАЧЕНИЕ: Инициализация элементов ленточной матрицы случайными значениями.
//Количество диагоналей diags должно быть нечетным и быть в пределах:
// 1 < diags < 2*Rows()-1. Матрица должна быть квадратной и Rows() > 2.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong diags - число диагоналей матрицы
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::InitBand(ulong diags)
{if (IsSquare() == false) {InitMatrix(); return;}
 if (Rows() < 3) {InitMatrix(); return;}
 if ((diags < 3) || (diags%2 == 0L) || (diags >= 2*Rows()-1)) diags = 3;
 randomize();//Инициализация генератора случайных чисел
 ulong delta;
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
  {delta = (i > j) ? (i-j) : (j-i);
   if (2*delta <= diags-1) data[i][j] = complex(rand(),rand());
   else data[i][j] = C_ZERO;
  }
}
//******************************************************************************
//СТАТУС: III.7, TComplexMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitUTriang()
//НАЗНАЧЕНИЕ: Инициализация элементов верхней треугольной матрицы случайными
//значениями.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::InitUTriang()
{if (IsSquare() == false) {InitMatrix(); return;}
 randomize();//Инициализация генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i <= j) ? complex(rand(),rand()) : C_ZERO;
}
//******************************************************************************
//СТАТУС: III.8, TComplexMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitLTriang()
//НАЗНАЧЕНИЕ: Инициализация элементов нижней треугольной матрицы случайными
//значениями.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::InitLTriang()
{if (IsSquare() == false) {InitMatrix(); return;}
 randomize();//Инициализация генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i >= j) ? complex(rand(),rand()) : C_ZERO;
}
//******************************************************************************
//СТАТУС: III.9, TComplexMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitSymmetric()
//НАЗНАЧЕНИЕ: Инициализация элементов симметрической матрицы случайными значениями.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::InitSymmetric()
{if (IsSquare() == false) {InitMatrix(); return;}
 randomize();//Инициализация генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {if (i != j) data[i][j] = data[j][i] = complex(rand(),rand());
   else data[i][j] = complex(rand(),rand());
  }
}
//******************************************************************************
//СТАТУС: III.10, TComplexMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitSkewSymmetric()
//НАЗНАЧЕНИЕ: Инициализация элементов кососимметрической матрицы случайными значениями
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::InitSkewSymmetric()
{if (IsSquare() == false) {InitMatrix(); return;}
 randomize();//Инициализация генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {if (i != j) {data[i][j] = complex(rand(),rand()); data[j][i] = -data[i][j];}
   else data[i][j] = complex(rand(),rand());
  }
}
//******************************************************************************
//СТАТУС: III.11, TComplexMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitAltSign()
//НАЗНАЧЕНИЕ: Инициализация элементов знакопеременной матрицы случайными значениями
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::InitAltSign()
{if (IsSquare() == false) {InitMatrix(); return;}
 randomize();//Инициализация генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {if (i != j) {data[i][j] = complex(rand(),rand()); data[j][i] = -data[i][j];}
   else data[i][j] = C_ZERO;
  }
}
//******************************************************************************
//СТАТУС: III.12, TComplexMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitHermitian()
//НАЗНАЧЕНИЕ: Инициализация эрмитовой матрицы случайными значениями.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void TComplexMatrix::InitHermitian()
{if (IsSquare() == false) {InitMatrix(); return;}
 randomize();//Инициализация генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {if (i != j) {data[i][j]=complex(rand(),rand()); data[j][i]=conj(data[i][j]);}
   else data[i][j] = complex(rand(),0.0);
  }
}
//----------------------------------------------------------------------------------------
// РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ФУНКЦИЙ КЛАССА TRealMatrix
// КОНСОЛЬНОГО ВВОДА ЭЛЕМЕНТОВ МАТРИЦЫ
//----------------------------------------------------------------------------------------
//****************************************************************************************
//СТАТУС: III.1., protected, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutHermitianMatrix(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ ЭРМИТОВОЙ МАТРИЦЫ
//Так как внедиагональные элементы эрмитовой матрицы комплексно-сопряжены, то осуществляется
//ввод только поддиагональных элементов матрицы. Диагональные элементы эрмитовой матрицы -
//вещественные числа, поэтому осуществляется при вводе необходимая проверка. Эрмитовая
//матрица должна быть квадратной, т.е. m = n. Формат ввода элементов матрицы следующий:
//MODE: INPUT ELEMENTS of Hermitian matrix
//<name>[<i>][<j>]: <complex value>.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование эрмитовой матрицы.
//2. bool confirm - опция подтверждения ввода каждого элемента матрицы;
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TComplexMatrix::InPutHermitianMatrix(const string& name, bool confirm)
{bool lflag;
 int x, y, x1 = wherex(), y1 = wherey();
 complex z;
 const string line(78,'-');
 string s;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << " " << Properties(s);
 cout << " 1. Diagonal Elements are REAL NUMBERs" << endl;
 cout << " 2. (i,j) & (j,i) Matrix Elements are COMPLEX CONJUGATED" << endl;
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода элементов эрмитовой матрицы - только поддиагональные элементы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {do
   {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
    z = EditComplex(confirm); //Ввод комплексного элемента матрицы
    lflag = false; //Сброс флага окончания ввода одного элемента
    //Анализ введенного значения
    if (i != j) //Внедиагональный элемент
    {data[i][j] = z; data[j][i] = conj(z);}
    else //Диагональный элемент
    {if (imag(z) != 0) //Ошибка! Диагональные элементы - вещественные числа
     {lflag = true;
      cout << "\nERROR! Diagonal element Hermitian Matrix must be REAL NUMBER."
           << endl;
      cout << "Press any key & try again...\a"; getch();
     }
     else data[i][j] = z;
    }
    ClrScr(x,y);//Очистка экрана
   } while (lflag); //Цикл ввода одного элемента эрмитовой матрицы
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.2., protected, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutComplexMatrix(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ КОМПЛЕКСНОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//MODE: INPUT ELEMENTS of <matrix type>
//<name>[<i>][<j>]: <complex value>.
//Функция позволяет вводить комплексные матрицы и векторы TComplexMatrix произвольных типов.
//При ввода элементов матрицы проверяется корректность комплексных чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование комплексной матрицы (вектора);
//2. bool confirm - опция подтверждения ввода каждого элемента матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TComplexMatrix::InPutComplexMatrix(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << " " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода всех элементов комплексной матрицы или вектора
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
   data[i][j] = EditComplex(confirm); //Ввод комплексного элемента матрицы
   ClrScr(x,y);//Очистка экрана
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a\a"; getch();
 ClrScr(x1,y1);
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.3., protected, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutDiagonal(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ ДИАГОНАЛЬНОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>][<j>]: <complex value>.
//При ввода элементов матрицы проверяется корректность комплексных чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование комплексной матрицы;
//2. bool confirm - опция подтверждения ввода каждого элемента матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TComplexMatrix::InPutDiagonal(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //---------------------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << " " << Properties(s);
 cout << line << endl;
 //---------------------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода диагональных элементов комплексной матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {if (i == j)
   {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
    data[i][j] = EditComplex(confirm);//Ввод элемента матрицы
    ClrScr(x,y);//Очистка экрана
   }
   else data[i][j] = C_ZERO;
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.4., protected, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutScalar(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ СКАЛЯРНОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//Diagonal elements value: <complex value>.
//При ввода элементов матрицы проверяется корректность комплексных чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование комплексной матрицы;
//2. bool confirm - опция подтверждения ввода каждого элемента матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TComplexMatrix::InPutScalar(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 complex value;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << " " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Ввод диагонального элемента скалярной матрицы
 cout << "Diagonal elements value: ";
 value = EditComplex(confirm); //Ввод элемента матрицы
 //Цикл присваивания диагональным элементам скалярной матрицы значения value
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {data[i][j] = (i == j) ? value : C_ZERO;}
 ClrScr(x,y);//Очистка экрана
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.5., protected, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutBand(ulong diags, const string& name, bool confirm=true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ ЛЕНТОЧНОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>][<j>]: <complex value>.
//Функция позволяет вводить элементы ленточной матрицы, которые принадлежат ее диагоналям,
//остальным элементам автоматически присваиваются нулевые значения. При ввода элементов
//матрицы проверяется корректность комплексных чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong diags - количество диагоналей ленточной матрицы;
//2. const string& name - наименование комплексной матрицы;
//3. bool confirm - опция подтверждения ввода каждого элемента матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TComplexMatrix::InPutBand(ulong diags, const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << " " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода элементов ленточной матрицы
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
  {ulong delta = (i > j) ? (i-j) : (j-i);
   if (2*delta <= diags-1) //Диагональный элемент ленточной матрицы
   {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
    data[i][j] = EditComplex(confirm); //Ввод элемента матрицы
    ClrScr(x,y);//Очистка экрана
   }
   else data[i][j] = C_ZERO;
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.6., protected, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutUTriang(const string& name, bool confirm=true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ ВЕРХНЕЙ ТРЕУГОЛЬНОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>][<j>]: <complex value>.
//Функция позволяет вводить элементы верхней треугольной матрицы, которые размещаются на и
//выше ее главной диагонали, остальным элементам автоматически присваиваются нулевые значения.
//При вводе элементов матрицы проверяется корректность комплексных чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование комплексной матрицы;
//2. bool confirm - опция подтверждения ввода каждого элемента матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TComplexMatrix::InPutUTriang(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << " " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода элементов верхней треугольной матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {if (i <= j)
   {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
    data[i][j] = EditComplex(confirm); //Ввод элемента матрицы
    ClrScr(x,y);//Очистка экрана
   }
   else data[i][j] = C_ZERO;
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.7., protected, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutLTriang(const string& name, bool confirm=true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ НИЖНЕЙ ТРЕУГОЛЬНОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>][<j>]: <complex value>.
//Функция позволяет вводить элементы нижней треугольной матрицы, которые размещаются на ее
//главной диагонали и под ней, остальным элементам автоматически присваиваются нулевые
//значения. При вводе элементов матрицы проверяется корректность комплексных чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование комплексной матрицы;
//2. bool confirm - опция подтверждения ввода каждого элемента матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TComplexMatrix::InPutLTriang(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << " " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода элементов нижней треугольной матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {if (i >= j)
   {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
    data[i][j] = EditComplex(confirm); //Ввод элемента матрицы
    ClrScr(x,y);//Очистка экрана
   }
   else data[i][j] = C_ZERO;
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.8., protected, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutSymmetric(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ СИММЕТРИЧЕСКОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>][<j>]: <complex value>.
//Функция позволяет вводить элементы симметрической матрицы, которые размещаются на ее
//главной диагонали и над ней, поддиагональным элементам присваиваются значения симметрических
//им наддиагоналных элементов. При вводе элементов матрицы проверяется корректность комплексных
//чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование комплексной матрицы;
//2. bool confirm - опция подтверждения ввода каждого элемента матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TComplexMatrix::InPutSymmetric(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << " " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода элементов симметрической матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
   data[i][j] = EditComplex(confirm);//Ввод элемента матрицы
   if (i != j) data[j][i] = data[i][j];
   ClrScr(x,y);//Очистка экрана
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.9., protected, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutSkewSymmetric(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ КОСОСИММЕТРИЧЕСКОЙ МАТРИЦЫ
//Формат ввода элементов матрицы следующий:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>][<j>]: <complex value>.
//Функция позволяет вводить элементы кососимметрической матрицы, которые размещаются на ее
//главной диагонали и над ней, поддиагональным элементам присваиваются значения симметрических
//им наддиагоналных элементов с противоположным знаком.
//При вводе элементов матрицы проверяется корректность комплексных чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование действительной матрицы;
//2. bool confirm - опция подтверждения ввода данных каждого элемента матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TComplexMatrix::InPutSkewSymmetric(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << " " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода элементов кососимметрической матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
    data[i][j] = EditComplex(confirm); //Ввод элемента матрицы
    if (i != j) data[j][i] = -data[i][j];
    ClrScr(x,y);//Очистка экрана
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}
//****************************************************************************************
//СТАТУС: III.10., protected, TComplexMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutAltSign(const string& name, bool confirm = true)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ЭЛЕМЕНТОВ ЗНАКОПЕРЕМЕННОЙ МАТРИЦЫ
//Формат ввода элементов матрицы:
//----------------------------------------------------------------------------------------
//MODE: INPUT ELEMENTS of <matrix name>;
//      TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//----------------------------------------------------------------------------------------
//<name>[<i>][<j>]: <complex value>.
//Функция позволяет вводить элементы знакопеременной матрицы, которые размещают-
//ся над ее главной диагональю, поддиагональным элементам присваиваются значения
//симметрических им наддиагоналных элементов с противоположным знаком. Значения
//диагональных элементов матрицы равны нулю.
//При вводе элементов матрицы проверяется корректность комплексных чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const string& name - наименование действительной матрицы;
//2. bool confirm - опция подтверждения ввода каждого элемента матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void TComplexMatrix::InPutAltSign(const string& name, bool confirm)
{int x, y, x1 = wherex(), y1 = wherey();
 const string line(78,'-');
 string s;
 //-----------------------------------------------------------------------------
 //Вывод заголовка и характеристик редактируемой матрицы
 cout << endl << line << endl;
 cout << "MODE: INPUT ELEMENTS of <" << name << ">; " << endl;
 cout << " " << Properties(s);
 cout << line << endl;
 //-----------------------------------------------------------------------------
 x = wherex(); y = wherey();
 //Цикл ввода элементов знакопеременной матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {if (i < j)
   {cout << name << "[" << (i+1) << "][" << (j+1) << "]: ";
    data[i][j] = EditComplex(confirm); //Ввод элемента матрицы
    if (i != j) data[j][i] = -data[i][j];
    ClrScr(x,y);//Очистка экрана
   }
   else data[i][j] = C_ZERO;
  }
 cout << "Elements of " << GetSubType(s) << " <" << name << "> are entered!\n";
 cout << "Press any key...\a"; getch();
 ClrScr(x1,y1);//Очистка экрана
 cout << flush; gotoxy(x1,y1);
}

//===================================================================================
//    РЕАЛИЗАЦИЯ ДРУЖЕСТВЕННЫХ ФУНКЦИЙ КЛАССУ TComplexMatrix
//    REALIZATION of THE FRIEND FUNCTION TO TComplexMatrix CLASS
//===================================================================================
//***********************************************************************************
//СТАТУС: FRIEND FUNCTION to TComplexMatrix class # 1
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend uint* MaxStrLen(const TComplexMatrix& C, uint precision)
//НАЗНАЧЕНИЕ: Определение максимальнго символьного размера элементов комплексной мат-
//рицы C и максимальной ширины каждого столбца матрицы для рационального отображения
//элементов комплексной матрицы. При вычислении максимальной символьной длины приняты
//следующие соглашения:
//1. Если мнимая часть элемента матрицы равна 0, то ее длина не учитывается.
//2. Формат вывода комплексного числа: "a[+||-]b*i; "
//3. Точность представления a & b равна precision.
//В ходе работы функции создается массив для хранения данных по максимальной ширине
//каждого столбца матрицы и максимального символьного размера элемента данной матрицы
// - MaxLen[C.GetColCount+1]. Максимальный размер элемента матрицы хранится в послед-
//ней ячейке массива MaxLen.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TComplexMatrix& C - ссылка на комплексную матрицу;
//2. uint precision - количество выводимых цифр чисел с плавающей точкой.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//uint* MaxLen - массив с шириной каждого столбца матрицы и максимальной символьной
//длиной элемента матрицы C.
//***********************************************************************************
uint* MaxStrLen(const TComplexMatrix& C, uint precision)
{uint* MaxLen = NULL;
 if (C.IsZeroSize()) return MaxLen;//Матрица нулевого размера
 //Распределение памяти под элементы массива MaxLen и их начальная инициализация
 uint szMaxLen = C.Cols()+1;
 MaxLen = new uint[szMaxLen];
 for (uint i = 0; i < szMaxLen; i++) MaxLen[i] = 0;

 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 complex z;
 uint count;
 //Цикл считывания элементов комплексной матрицы
 for (ulong i = 0L; i < C.Rows(); i++)
  for (ulong j = 0L; j < C.Cols(); j++)
  {z = C.Get(i,j);
   //Формирование символьного представления комплексного числа
   //Анализ реальной части числа
   if (fabs(real(z)) < EPS) text << "0";
   else text << setprecision(precision) << real(z);
   //Анализ мнимой части числа
   if (fabs(imag(z)) > EPS)
   {if (imag(z) > 0) text << "+" << setprecision(precision) << imag(z);
    else text << setprecision(precision) << imag(z);
    text << "i;";
   }
   else text << ";";
   text << ends;
   //Получение максимальной символьной длины элемента комплексной матрицы и каждого
   //столбца матрицы
   count = text.pcount()-1;
   if (count > MaxLen[j])
   {MaxLen[j] = count;
    if (MaxLen[j] > MaxLen[szMaxLen-1]) MaxLen[szMaxLen-1] = MaxLen[j];
   }
   text.seekp(0);
  }
return MaxLen;
}
//----------------------------------------------------------------------------------------
//Построение корреляционной матрицы
//----------------------------------------------------------------------------------------
//****************************************************************************************
//СТАТУС: Friend Function to TComplexMatrix class # 2
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool CorrelationMatrix(const cvector& V, cmatrix& R);
//НАЗНАЧЕНИЕ: ПОСТРОЕНИЕ КОРРЕЛЯЦИОННОЙ (КОВАРИАЦИОННОЙ) МАТРИЦЫ
//Расчет корреляционной матрицы по данным из вектора V и размещение ее элементов в матрице
//R. Размерность матрицы R будет равна размерности вектора V. Функция изменяет размерность
//и элементы матрицы R и не изменяет вектор V. Каждый элемент матрицы R рассчитывается по
//формуле: R[i,j] = V[i] * conj(V[j]).
//Функция возвращает false, если вектор V - нулевого размера или невозможно выделить память
//под размещение элементов матрицы R.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cvector& V - константная ссылка на комплексный исходный вектор по элементам
//   которого строится корреляционная матрица R.
//2. cmatrix& R - ссылка на комплексную матрицу, в которой будут размещаться элементы
//   корреляционной матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции.
//****************************************************************************************
bool CorrelationMatrix(const cvector& V, cmatrix& R)
{//Проверка на вектор нулевого размера
 if (V.IsZeroSize()) {R.Set(0,false); return false;}
 //Распределение памяти под корреляционную матрицу R без начальной инициализации
 if (R.Set(V.Size(),false) == false) return false;
 //Формирование корреляционной (ковариационной) матрицы
 for (ulong i = 0L; i < R.Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {if (i == j) R.Put(i,j,norm(V.Get(i)));
   else
   {R.Put(i,j,V.Get(i)*conj(V.Get(j)));
    R.Put(j,i,conj(R.Get(i,j)));
   }
  }
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TComplexMatrix class # 3
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool CorrelationMatrix(const cmatrix& A, cmatrix& R)
//НАЗНАЧЕНИЕ: ПОСТРОЕНИЕ АДДИТИВНОЙ КОРРЕЛЯЦИОННОЙ (КОВАРИАЦИОННОЙ) МАТРИЦЫ
//Функция рассчитывает корреляционную матрицу по данным из матрицы A и размещает ее элементы
//в матрице R. Каждый столбец матрицы A должен представлять собой вектор по которому строится
//j-ая корреляционная матрица. Количество таких матриц равно количеству столбцов матрицы A.
//Все матрицы суммируются и, таким образом, получается АДДИТИВНАЯ корреляционная матрица.
//Размерность матрицы R будет равна числу строк матрицы A. Функция изменяет размерность и
//элементы матрицы R и не изменяет матрицу A. Каждый элемент матрицы R вычисляется по формуле:
// R[i,j] = SUM [A[i,k] * conj(A[j,k])], 0 <= k < A.Cols().
//Функция возвращает false, если матрица A - нулевого размера или невозможно выделить память
//под размещение элементов матрицы R.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& A - константная ссылка на комплексную исходную матрицу, по элементам
//   которой строится аддитивная корреляционная матрица R;
//2. cmatrix& R - ссылка на комплексную матрицу, в которой будут размещаться элементы
//   аддитивной корреляционной матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции.
//****************************************************************************************
bool CorrelationMatrix(const cmatrix& A, cmatrix& R)
{//Проверка на матрицу нулевого размера
 if (A.IsZeroSize()) return false;
 //Распределение памяти под корреляционную матрицу R без начальной инициализации
 if (R.Set(A.Rows(),C_ZERO) == false) return false;
 //Формирование аддитивной корреляционной матрицы R
 for (ulong k = 0L; k < A.Cols(); k++) //Цикл по столбцам матрицы A
  for (ulong i = 0L; i < R.Rows(); i++)
   for (ulong j = 0L; j <= i; j++)
   {if (i == j) R.Put(i,j, R.Get(i,j) + norm(A.Get(i,k)));
    else
    {R.Put(i,j, R.Get(i,j) + A.Get(i,k)*conj(A.Get(j,k)));
     R.Put(j,i,conj(R.Get(i,j)));
    }
   }
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TComplexMatrix class # 4
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool QuadraticForm(complex& c_val, const cmatrix& A, const cvector& W)
//НАЗНАЧЕНИЕ: Вычисление КВАДРАТИЧЕСКАЯ ФОРМЫ: c_val = trW * A * W. Результатом вычисления
//квадратической формы является, в общем случае, комплексное число. Квадратическая форма
//вычисляется в одном цикле без формирования промежуточных результатов в виде вектора.
//Правила вычисления КВАДРАТИЧЕСКОЙ МАТРИЧНОЙ ФОРМЫ:
//1. Матрица A & вектор W не должны быть нулевого размера;
//2. Матрица A должна быть КВАДРАТНОЙ;
//3. Размерности матрицы A и вектора W должны быть согласованы;
//4. Вектор W может быть вектором-строкой или вектором-столбцом;
//5. Вектор trW комплексно-сопряженный вектору W.
//При невыполнении условий 1-3 функция возвращает false. В случае успешного вычисления
//квадратичной формы результат заносится в переменную c_val, передаваемую по ссылке и
//функция возвращает true.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. complex& c_val - ссылка на результирующую комплексную переменную;
//2. const cmatrix& A - ссылка на комплексную матрицу;
//3. const cvector& W - ссылка на комплексный вектор.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат вычисления квадратической формы
//****************************************************************************************
bool QuadraticForm(complex& c_val, const cmatrix& A, const cvector& W)
{c_val = C_ZERO;
 //Проверка на допустимость вычисления квадратичной формы
 if (A.IsZeroSize() || W.IsZeroSize()) return false;
 if ((A.Rows() != A.Cols()) || (A.Rows() != W.Size())) return false;
 //Вычисление квадратической формы trW * A * W
 complex sum;
 for (ulong i = 0L; i < A.Rows(); i++)
 {sum = C_ZERO;
  for (ulong j = 0L; j < A.Cols(); j++) sum += A.Get(i,j)*W.Get(j);
  sum *= conj(W.Get(i));
  c_val += sum;
 }
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TComplexMatrix class # 5
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//friend bool Multiply(complex& c_val, const cvector& L, const cmatrix& A, const cvector& R)
//НАЗНАЧЕНИЕ: Вычисление ПРОИЗВЕДЕНИЯ вида: c_val = L * A * R. Произведение вычисляется в
//одном цикле без формирования промежуточных результатов в виде вектора. Правила вычисления:
//1. Матрица A & вектора L и R не должны быть нулевого размера;
//2. Матрица A должна быть КВАДРАТНОЙ;
//3. Размерности матрицы A и векторов L, R должны быть согласованы;
//4. Вектора L и R могут быть вектором-строкой или вектором-столбцом;
//При невыполнении условий 1-3 функция возвращает false. В случае успешного вычисления
//произведения результат заносится в переменную c_val, передаваемую по ссылке и функция
//возвращает true.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. complex& c_val - ссылка на результирующую комплексную переменную;
//2. const cvector& L - ссылка на левый комплексный вектор;
//3. const cmatrix& A - ссылка на комплексную матрицу;
//4. const cvector& R - ссылка на правый комплексный вектор.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат вычисления произведения L*A*R
//****************************************************************************************
bool Multiply(complex& c_val, const cvector& L, const cmatrix& A, const cvector& R)
{c_val = C_ZERO;
 //Проверка на допустимость вычисления квадратичной формы
 if (A.IsZeroSize() || L.IsZeroSize() || R.IsZeroSize()) return false;
 if ((A.Rows() != A.Cols()) || (A.Rows() != L.Size()) || (A.Cols() != R.Size()))
  return false;
 //Вычисление квадратической формы trW * A * W
 complex sum;
 for (ulong i = 0L; i < A.Rows(); i++)
 {sum = C_ZERO;
  for (ulong j = 0L; j < A.Cols(); j++) sum += A.Get(i,j)*R.Get(j);
  sum *= conj(L.Get(i));
  c_val += sum;
 }
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TComplexMatrix class # 6
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Transform_trCAC(cmatrix& B, const cmatrix& A, const cmatrix& C)
//НАЗНАЧЕНИЕ: Матричное преобразование вида: B(m,m) = trC(m,n)*A(n,n)*C(n,m), trC - транс-
//понированная комплексно-сопряженная матрица к матрице C, заданная не явно. В зависимости
//от размерности матрицы C она может считаться расположенной слева или справа от матрицы A.
//Правила вычисления:
//1. Матрицы A & C не должны быть нулевого размера;
//2. Матрица A должна быть КВАДРАТНОЙ;
//3. Число строк или столбцов матрицы C должны быть равны размерности A. При числе строк
//   матрицы C равных размерности A - матрица C умножается справа, при числе столбцов C
//   равных размерности A - матрица C умножается слева.
//При невыполнении условий 1-3 функция возвращает false. В случае успешного вычисления
//матричного произведения результат формируется в матрице B, передаваемую по ссылке и
//функция возвращает true.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& B - ссылка на результирующую комплексную матрицу;
//2. const cmatrix& A - ссылка на комплексную преобразуемую матрицу;
//3. const cvector& C - ссылка на правую (левую) комплексную матрицу.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат вычисления произведения trC*A*C
//****************************************************************************************
bool Transform_trCAC(cmatrix& B, const cmatrix& A, const cmatrix& C)
{ulong N, M;
 bool lRightPos;
 complex z;
 cvector V;
 //Проверка на допустимость матричного преобразования
 if (A.IsZeroSize() || (A.Rows() != A.Cols()) || C.IsZeroSize()) {B.Set(0,false); return false;}
 N = A.Rows();
 if (N == C.Rows()) {M = C.Cols(); lRightPos = true;}
 else if (N == C.Cols()) {M = C.Rows(); lRightPos = false;}
 else {B.Set(0,false); return false;}
 //Формируем матрицу B и вектор V необходимой размерности и инициализируем их нулями
 B.Set(M,C_ZERO);
 V.Set(N,COL,C_ZERO);
 //Выполняем преобразование B = trC*A*C
 for (ulong i = 0; i < M; i++)
  for (ulong j = 0; j < M; j++)
  {//Формируем элементы вектора V
   for (ulong k = 0; k < N; k++)
    for (ulong l = 0; l < N; l++)
    {z = (lRightPos) ? C.Get(l,j) : conj(C.Get(j,l));
     V.Put(k,V.Get(k)+A.Get(k,l)*z);
    }
   //Вычисляем элемент матрицы B[i,j]
   for (ulong k = 0; k < N; k++)
   {z = (lRightPos) ? conj(C.Get(k,i)) : C.Get(i,k);
    B.Put(i,j,B.Get(i,j)+V.Get(k)*z);
    V.Put(k,C_ZERO);
   }
  }
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TComplexMatrix class # 7
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Trace_trCAC(double& Trace,const cmatrix& A,const cmatrix& C)
//НАЗНАЧЕНИЕ: Вычисление следа матричного преобразования: B(m,m) = trC(m,n)*A(n,n)*C(n,m),
//trC - транспонированная комплексно-сопряженная матрица к матрице C, заданная не явно. В
//зависимости от размерности матрицы C она может считаться расположенной слева или справа
//от матрицы A. Правила вычисления:
//1. Матрицы A & C не должны быть нулевого размера;
//2. Матрица A должна быть КВАДРАТНОЙ;
//3. Число строк или столбцов матрицы C должны быть равны размерности A. При числе строк
//   матрицы C равных размерности A - матрица C умножается справа, при числе столбцов C
//   равных размерности A - матрица C умножается слева.
//При невыполнении условий 1-3 функция возвращает false. В случае успешного вычисления
//матричного произведения результат формируется в переменной Trace, передаваемой по ссылке
//и функция возвращает true.
//Функция оптимизирована для вычисления следа матричного произведения, что позволяет сокра-
//тить вычислительные затраты по сравнению с классическим методом вычисления. Так как диа-
//гональные элементы матрицы B, по которым вычисляется след представляют из себя квадратич-
//ные формы (вещественные числа), то и след комплексной матрицы B будет ВЕЩЕСТВЕННЫМ.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double& Trace - ссылка на результирующую переменную - след матрицы B;
//2. const cmatrix& A - ссылка на комплексную преобразуемую матрицу;
//3. const cvector& C - ссылка на правую (левую) комплексную матрицу.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат вычисления произведения trC*A*C
//****************************************************************************************
bool Trace_trCAC(double& Trace, const cmatrix& A, const cmatrix& C)
{ulong N, M;
 bool lRightPos;
 complex z;
 complex DiagSum;
 cvector V;
 //Проверка на допустимость матричного преобразования
 if (A.IsZeroSize() || (A.Rows() != A.Cols()) || C.IsZeroSize()) {Trace = 0; return false;}
 N = A.Rows();
 if (N == C.Rows()) {M = C.Cols(); lRightPos = true;}
 else if (N == C.Cols()) {M = C.Rows(); lRightPos = false;}
 else {Trace = 0; return false;}
 //Формируем вектор V необходимой размерности и инициализируем его нулями
 DiagSum = C_ZERO;
 V.Set(N,COL,C_ZERO);
 //Выполняем преобразование B = trC*A*C с учетом вычисления только диагональных элементов
 //матрицы B
 for (ulong i = 0; i < M; i++)
 {//Формируем элементы вектора V
  for (ulong k = 0; k < N; k++)
   for (ulong l = 0; l < N; l++)
   {z = (lRightPos) ? C.Get(l,i) : conj(C.Get(i,l));
    V.Put(k,V.Get(k)+A.Get(k,l)*z);
   }
  //Вычисляем след матрицы B
  for (ulong k = 0; k < N; k++)
  {z = (lRightPos) ? conj(C.Get(k,i)) : C.Get(i,k);
   DiagSum += V.Get(k)*z;
   V.Put(k,C_ZERO);
  }
 }
 Trace = abs(DiagSum);
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TComplexMatrix class # 8
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool ComplexToReal(const cmatrix& C, rmatrix& Ar, rmatrix& Ai)
//НАЗНАЧЕНИЕ: Представление матрицы C в виде Ar + i*Ai, размещением ее реальных и мнимых
//частей в вещественных матрицах Ar и Ai. Функция возвращает true при успешном копировании
//реальной и мнимой части матрицы C в матрицы Ar и Ai.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const cmatrix& C - ссылка на исходную комплексную матрицу;
//2. rmatrix& Ar - ссылка на матрицу-приемник реальной части матрицы C;
//3. rmatrix& Ai - ссылка на матрицу-приемник мнимой части матрицы C.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат копирования в реальной и мнимой частей
//матрицы C в матрицы Ar и Ai.
//****************************************************************************************
bool ComplexToReal(const cmatrix& C, rmatrix& Ar, rmatrix& Ai)
{//Проверка матрицы C на нулевую размерность
 if (C.IsZeroSize()) {Ar.Set(0,false); Ai.Set(0,false); return false;}
 Ar.Set(C.Rows(),C.Cols(),false);
 Ai.Set(C.Rows(),C.Cols(),false);

 if (Ar.IsZeroSize() || Ai.IsZeroSize()) {Ar.Set(0,false); Ai.Set(0,false); return false;}
 complex z;
 //Копирование реальной и мнимой частей матрицы C в матрицы Ar и Ai
 for (ulong i = 0L; i < C.Rows(); i++)
  for (ulong j = 0L; j < C.Cols(); j++)
  {z = C.Get(i,j);
   Ar.Put(i,j,real(z));
   Ai.Put(i,j,imag(z));
  }
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TComplexMatrix class # 9
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool RealToComplex(cmatrix& C, const rmatrix& Ar, const rmatrix& Ai)
//НАЗНАЧЕНИЕ: Создание комплексной матрицы C из двух вещественных матриц Ar и Ai, которые
//содержат вещественные (Ar) и мнимые (Ai) части формируемой матрицы C. Для успешной работы
//функции необходимо равенство размерностей матриц Ar и Ai.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& C - ссылка на результирующую комплексную матрицу;
//2. const rmatrix& Ar - ссылка на матрицу-источник реальной части матрицы C;
//3. const rmatrix& Ai - ссылка на матрицу-источник мнимой части матрицы C.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат создания матрицы С из матриц Ar и Ai.
//****************************************************************************************
bool RealToComplex(cmatrix& C, const rmatrix& Ar, const rmatrix& Ai)
{//Проверка равенства размерностей матриц Ar и Ai
 if ((Ar.Rows() != Ai.Rows()) || (Ar.Cols() != Ai.Cols())) {C.Set(0,false); return false;}
 C.Set(Ar.Rows(),Ar.Cols(),false);
 if (C.IsZeroSize()) return false;
 //Создание матрицы C из матриц Ar и Ai, содержащих реальную и мнимую части
 for (ulong i = 0L; i < C.Rows(); i++)
  for (ulong j = 0L; j < C.Cols(); j++)
   C.Put(i,j,complex(Ar.Get(i,j),Ai.Get(i,j)));

 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TComplexMatrix class # 10
//НАИМЕНОВАНИЕ ФУНКЦИИ: friend bool Average(cmatrix& A, const cmatrix& B, ulong n)
//НАЗНАЧЕНИЕ: Выполнение усреднения элементов матрицы B делением их на число опытов n c
//последующим суммированием с элементами матрицы A, которая будет изменяться функцией:
//A = A + B/n. Матрицы A и B должны быть ненулевого размера и одинаковой размерности. Если
//матрица A не совпадает по размеру с матрицей B, то выполняется операция: A = B/n.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& A - ссылка на результирующую матрицу;
//2. const cmatrix& B - ссылка на матрицу с усредняемыми элементами;
//3. ulong n - число усреднений в эксперименте (n > 0).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения операции
//****************************************************************************************
bool Average(cmatrix& A, const cmatrix& B, ulong n)
{if (B.IsZeroSize()) {A.Set(0L,false); return false;}
 if ((A.Rows() != B.Rows()) || (A.Cols() != B.Cols()))
 {A = B;
  if (n > 0)
  {for (ulong i = 0L; i < A.Rows(); i++)
    for (ulong j = 0L; j < A.Cols(); j++)
     A.Put(i,j,A.Get(i,j)/n);
  }
 }
 else
 {if (n == 0) n = 1;
  for (ulong i = 0L; i < A.Rows(); i++)
    for (ulong j = 0L; j < A.Cols(); j++)
     A.Put(i,j,A.Get(i,j)+B.Get(i,j)/n);
 }
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TComplexMatrix class # 11
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend bool InfiniteAverage(cmatrix& AvX, const cmatrix& Xk, ulong k)
//НАЗНАЧЕНИЕ: Выполнение операции непрерывного усреднения элементов матрицы без задания
//общего числа усреднений. Функция формирует в матрице AvX матрицу усредненных значений
//на k-ом шаге (опыте) по формуле: AvX = (k*AvX + Xk)/(k+1), k > 0. Для k == 0: AvX = Xk.
//Правила использования функции следующие:
//1. Пользователь должен следить, чтобы при каждом очередном вызове функции значения k
//   отличались на ЕДИНИЦУ в сторону увеличения k, иначе результаты усреднения будут
//   неверными. Для первого вызова функции следует задать k == 0.
//2. Матрица Xk не должна быть матрицей нулевого размера, иначе функция возвращает false и
//   матрицу AvX - нулевого размера.
//3. За исключением k == 0 размерности матриц AvX и Xk должны совпадать, иначе возвращается
//   false и матрица AvX - нулевого размера.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& AvX - ссылка на результирующую матрицу с усредненными значениями для k опытов;
//2. const cmatrix& Xk - ссылка на матрицу с элементами k-ой выборки;
//3. ulong k - номер выборки (k >= 0).
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения операции
//****************************************************************************************
bool InfiniteAverage(cmatrix& AvX, const cmatrix& Xk, ulong k)
{if (Xk.IsZeroSize()) {AvX.Set(0L,false); return false;}
 if (k == 0) {AvX = Xk; return true;}
 if (IsEqualSize(AvX,Xk) == false) {AvX.Set(0L,false); return false;}
 //Получение матрицы усредненных значений AvX на k-ом шаге: AvX = (k*AvX + Xk)/(k+1)
 for (ulong i = 0L; i < AvX.Rows(); i++)
  for (ulong j = 0L; j < AvX.Cols(); j++)
   AvX.Put(i,j,(k*AvX.Get(i,j)+Xk.Get(i,j))/(k+1));
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TComplexMatrix class # 12
//НАИМЕНОВАНИЕ ФУНКЦИИ:  friend bool Conj(cmatrix& C)
//НАЗНАЧЕНИЕ: КОМПЛЕКСНОЕ-СОПРЯЖЕНИЕ ЭЛЕМЕНТОВ МАТРИЦЫ C
//Операция производится с исходной матрицы C, передаваемой в функцию по ссылке. При сопря-
//жении матрицы нулевого размера возвращается false. Функция изменяет элементы матрицы C.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//cmatrix& C - ссылка на матрицу, чьи элементы будут комплексно-сопряжены
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения функции.
//****************************************************************************************
bool Conj(cmatrix& C)
{if (C.IsZeroSize()) return false;//Матрица нулевого размера
 //Получение матрицы C с комплексно-сопряженными ей элементами
 for (ulong i = 0; i < C.Rows(); i++)
  for (ulong j = 0; j < C.Cols(); j++)
    C.Put(i,j,conj(C.Get(i,j)));
 return true;
}
//****************************************************************************************
//СТАТУС: Friend Function to TComplexMatrix class # 13
//НАИМЕНОВАНИЕ ФУНКЦИИ:  friend bool Conj(cmatrix& A, const cmatrix& B)
//НАЗНАЧЕНИЕ: КОМПЛЕКСНОЕ-СОПРЯЖЕНИЕ ЭЛЕМЕНТОВ МАТРИЦЫ B с ПРИСВОЕНИЕМ РЕЗУЛЬТАТА МАТРИЦЕ A.
//Операция производится с элементами матрицы B с присвоением результатов матрице A. При
//сопряжении матрицы B нулевого размера возвращается false и матрица A становится матрицей
//нулевого размера. Функция изменяет элементы матрицы A.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. cmatrix& A - ссылка на результирующую матрицу;
//2. cmatrix& B - ссылка на матрицу, чьи элементы комплексно-сопрягаются.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения функции.
//****************************************************************************************
bool Conj(cmatrix& A, const cmatrix& B)
{A = B;
 if (A.IsZeroSize()) return false;//Матрица нулевого размера
 //Получение матрицы C с комплексно-сопряженными ей элементами
 for (ulong i = 0; i < A.Rows(); i++)
  for (ulong j = 0; j < A.Cols(); j++)
    A.Put(i,j,conj(A.Get(i,j)));
 return true;
}


//***********************************************************************************
//                 РЕАЛИЗАЦИЯ КЛАССА TIntMatrix
//***********************************************************************************
//===================================================================================
// I. РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TRealMatrix
//    PUBLIC MEMBER-FUNCTION OF TRealMatrix CLASS REALIZATION
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1., public, TIntMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsZero() const
//НАЗНАЧЕНИЕ: Проверка на матрицу со всеми нулевыми элементами. В случае удачи функция
//возвращает - true и false - в противном случае. Свойства матрицы со всеми нулевыми
//элементами: A[i][j] = 0 - ВСЕ элементы матрицы должны быть равны НУЛЮ.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица со всеми нулевыми элементами (false - не RM_ZERO).
//***********************************************************************************
bool TIntMatrix::IsZero() const
{for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
  {if (data[i][j] != 0L) return false;} //Все элементы д.б. нулевыми
 return true;
}
//***********************************************************************************
//СТАТУС: I.2, public, TIntMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsSymmetric() const
//НАЗНАЧЕНИЕ: Проверка матрицы на СИММЕТРИЧНОСТЬ. В случае симметричности функция
//возвращает - true и false - в противном случае. Свойства симметрической матрицы:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = A[j][i] - элементы матрицы, расположенные симметрично друг друга
//   относительно главной диагонали матрицы должны быть равными.
//3. Должен существовать внедиагональный элемент матрицы отличный от нуля.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица симметрическая (false - не симметрическая).
//***********************************************************************************
bool TIntMatrix::IsSymmetric() const
{if (!IsSquare() || (Rows() < 2)) return false; //Проверка на квадратную матрицу
 bool lNonZero = false;
 //Цикл проверки свойства 2 & 3
 for (ulong i = 1L; i < Rows(); i++)
  for (ulong j = 0L; j < i; j++)
  {if (lNonZero == false) lNonZero = (data[i][j] != 0L) ? true : false;
   if (data[i][j] != data[j][i]) return false;
  }
 return lNonZero;
}
//***********************************************************************************
//СТАТУС: I.3, public, TIntMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsSkewSymmetric() const
//НАЗНАЧЕНИЕ: Проверка матрицы на кососимметричность. В случае кососимметричности
//функция возвращает - true и false - в противном случае. Свойства кососимметрической
//матрицы:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = -A[j][i] - элементы матрицы, расположенные симметрично друг друга
//   относительно главной диагонали матрицы должны быть равными по модулю и противо-
//   положными по знаку.
//3. Должен существовать внедиагональный элемент матрицы отличный от нуля.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица кососимметрическая (false - не кососимметрическая).
//***********************************************************************************
bool TIntMatrix::IsSkewSymmetric() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 bool lNonZero = false;
 //Цикл проверки свойства 2 & 3
 for (ulong i = 1L; i < Rows(); i++)
  for (ulong j = 0L; j < i; j++)
  {if (lNonZero == false) lNonZero = (data[i][j] != 0L) ? true : false;
   if (data[i][j] != -data[j][i]) return false;
  }
 return lNonZero;
}
//***********************************************************************************
//СТАТУС: I.4, public, TIntMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsAltSign() const
//НАЗНАЧЕНИЕ: Проверка матрицы на знакопеременность. В случае знакопеременности функ-
//ция возвращает - true и false - в противном случае. Свойства знакопеременной матрицы:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = -A[j][i] - элементы матрицы, расположенные симметрично друг друга отно-
//   сительно главной диагонали матрицы должны быть равными по модулю и противополож-
//   ными по знаку.
//3. A[i][i] = 0 - элементы матрицы, расположенные на главной диагонали должны быть
//   равными нулю.
//4. Должен существовать внедиагональный элемент матрицы отличный от нуля.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица знакопеременная (false - не знакопеременная).
//***********************************************************************************
bool TIntMatrix::IsAltSign() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 bool lNonZero = false;
 //Цикл проверки свойства 2 и 3
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i ; j++)
  {if (i != j) //Элемент матрицы размещен не на главной диагонали
   {if (lNonZero == false) lNonZero = (data[i][j] != 0L) ? true : false;
    if (data[i][j] != -data[j][i]) return false;
   }
   //Элемент матрицы размещен на главной диагонали
   else if (data[i][j] != 0L) return false;
  }
return lNonZero;
}
//***********************************************************************************
//СТАТУС: I.5, public, TIntMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsUpperTriang() const
//НАЗНАЧЕНИЕ: Проверка матрицы на верхнюю треугольную. Если матрица - верхняя треуголь-
//ная, то функция возвращает - true и false - в противном случае.
//Свойства верхней треугольной матрицы:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 2;
//2. A[i][j] = 0, для всех i > j - элементы матрицы, расположенные ниже главной
//   диагонали матрицы должны быть равны нулю.
//3. Должны существовать элементы матрицы отличные от нуля, расположенные выше
//   главной диагонали.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица верхняя треугольная (false - не верхняя треугольная).
//***********************************************************************************
bool TIntMatrix::IsUpperTriang() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 bool lNonZero = false;
 //Цикл проверки свойства 2
 for (ulong i = 1L; i < Rows(); i++)
  for (ulong j = 0L; j < i; j++)
  {if (lNonZero == false) lNonZero = (data[j][i] != 0L) ? true : false;
   //Элемент матрицы, размещенные ниже главной диагонали
   if (data[i][j] != 0L) return false;
  }
 return lNonZero;
}
//***********************************************************************************
//СТАТУС: I.6., public, TIntMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsLowerTriang() const
//НАЗНАЧЕНИЕ: Проверка матрицы на нижнюю треугольную. Если матрица - нижняя треуголь-
//ная, то функция возвращает - true и false - в противном случае. Свойства нижней
//треугольной матрицы:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = 0, для всех i < j - элементы матрицы, расположенные выше главной
//   диагонали матрицы должны быть равны нулю.
//3. Должны существовать элементы матрицы отличные от нуля, расположенные ниже
//   главной диагонали.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица нижняя треугольная (false - не нижняя треугольная).
//***********************************************************************************
bool TIntMatrix::IsLowerTriang() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 bool lNonZero = false;
 //Цикл проверки свойства 2
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = i+1; j < Cols(); j++)
  {if (lNonZero == false) lNonZero = (data[j][i] != 0L) ? true : false;
   //Элементы матрицы, размещенные выше главной диагонали
   if (data[i][j] != 0L) return false;
  }
 return lNonZero;
}
//***********************************************************************************
//СТАТУС: I.7, public, TIntMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsDiagonal() const
//НАЗНАЧЕНИЕ: Проверка матрицы на диагональную. Если матрица - диагональная, то функ-
//ция возвращает - true и false - в противном случае. Свойства диагональной матрицы:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = 0, для всех i != j - элементы матрицы, расположенные не на главной
//   диагонали матрицы должны быть равны нулю.
//3. Должен существовать элемент матрицы отличный от нуля, расположенный на главной
//   диагонали.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица диагональная (false - не диагональная).
//***********************************************************************************
bool TIntMatrix::IsDiagonal() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 bool lNonZero = false;
 //Цикл проверки свойства 2
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {//Элемент матрицы размещенный не на главной диагонали
   if ((i != j) && (data[i][j] != 0L)) return false;
   //Диагональный элемент
   else if (lNonZero == false) lNonZero = (data[i][j] != 0L) ? true : false;
  }
return lNonZero;
}
//***********************************************************************************
//СТАТУС: I.8., public, TIntMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsScalar() const
//НАЗНАЧЕНИЕ: Проверка матрицы на скалярную. Если матрица - скалярная, то функция
//возвращает - true и false - в противном случае. Свойства скалярной матрицы:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = 0, для всех i != j - элементы матрицы, расположенные не на главной
//   диагонали матрицы должны быть равны нулю.
//3. A[i][i] = c, для всех i = j - элементы матрицы, расположенные на главной
//   диагонали равны между собой (c != 1 && c != 0).
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица скалярная (false - не скалярная).
//***********************************************************************************
bool TIntMatrix::IsScalar() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 long c = data[0][0];
 if (c == 0L) return false;//Проверка на c == 0
 if (c == 1L) return false;//Проверка на c == 1
 //Цикл проверки свойства 2 & 3
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {//Внедиагональный элемент матрицы
   if ((i != j) && (data[i][j] != 0L)) return false;
   //Диагональный элемент матрицы
   else if (data[i][j] != c) return false;
  }
 return true;
}
//***********************************************************************************
//СТАТУС: I.9, public, TIntMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsUnit() const
//НАЗНАЧЕНИЕ: Проверка матрицы на единичную. Если матрица - единичная, функция возвра-
//щает - true и false - в противном случае. Свойства единичной матрицы:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 1;
//2. A[i][j] = 0, для всех i != j - элементы матрицы, расположенные не на главной
//   диагонали матрицы должны быть равны нулю.
//3. A[i][i] = 1, для всех i = j - элементы матрицы, расположенные на главной
//   диагонали равны между собой.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица единичная (false - не единичная).
//***********************************************************************************
bool TIntMatrix::IsUnit() const
{if (!IsSquare() || (Rows() < 2)) return false;//Проверка на квадратную матрицу
 //Цикл проверки свойства 2 & 3
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
  {//Внедиагональный элемент матрицы
   if ((i != j) && (data[i][j] != 0L)) return false;
   //Внедиагональный элемент матрицы
   else if (data[i][j] != 1L) return false;
  }
 return true;
}
//***********************************************************************************
//СТАТУС: I.10, public, TIntMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool IsBand(ulong& diags) const
//НАЗНАЧЕНИЕ: Проверка матрицы на ленточную с автоматическим определением числа диго-
//налей. На ленточную проверяется квадратная  матрица размерностью не меньше трех,
//максимальное число диагоналей матрицы определяется формулой: maxdiag = 2*Rows()-1.
//Проверка начинается с максимально возможного числа диагоналей. Это позволяет опреде-
//лить сразу является матрица ленточной или нет. Число диагоналей у ленточной матрицы
//может быть только НЕЧЕТНЫМ. Если матрица является ленточной, то функция возвращает
//- true и false - в противном случае. В переменную diags, передаваемую по ссылке, за-
//носится число диагоналей квадратной матрицы (1<=diags<= maxdiag).
//Матрица считается ленточной:
// - при diags != 1 (диагональная матрица) и diags != maxdiag (обыкновенная квадратная
//   матрица). При diags == 0 - матрица прямоугольная.
//Свойства ленточной вещественной матрицы следующие:
//1. m == n - матрица должна быть КВАДРАТНОЙ, m > 2;
//2. A[i][j] = 0, для элементов матрицы, индексы которых должны удовлетворять
//   следующему неравенству: 2*|i-j| > diag-1.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong& diags - число диагоналей матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - true - матрица ленточная (false - не ленточная).
//***********************************************************************************
bool TIntMatrix::IsBand(ulong& diags) const
{//Проверка на квадратную матрицу
 if (!IsSquare() || (Rows() < 3)) {diags = 0L; return false;}
 diags = 2*Rows()-1;//Максимальное число диагоналей данной матрицы
 for (ulong n = Rows()-1; n > 0; n--)
 {ulong j = 0L;
  bool lZeroDiag = true;
  for (ulong i = n; i < Rows(); i++)
  {if ((data[i][j] != 0L) || (data[j][i] != 0L)) {lZeroDiag = false; break;}
   j++;
  }
  if (lZeroDiag == false) break;
  diags -= 2;//Уменьшаем число диагоналей ленточной матрицы от значения maxdiag
 }
 //Анализ результатов
 return ((diags == 1L) || (diags == 2*Rows()-1)) ? false : true;
}
//***********************************************************************************
//СТАТУС: I.11, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: uint SubType() const
//НАЗНАЧЕНИЕ: Определение подтипа матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint type - подтип матрицы
//***********************************************************************************
uint TIntMatrix::SubType() const
{if (IsZeroSize()) return RM_ZEROSIZE;//Матрица нулевого размера
 //Действительное число - матрица размером 1 x 1
 if ((Rows() == 1) && (Cols() == 1)) return RM_NUMBER;
 //Матрица со всеми нулевыми элементами
 if (IsZero()) return RM_ZERO;

 if (IsRectang()) //Прямоугольная матрица
 {if ((Rows() == 1) && (Cols() > 1)) return RV_ROW;//Вектор-строка
  if ((Cols() == 1) && (Rows() > 1)) return RV_COLUMN;//Вектор-столбец
  return RM_RECTANGULAR;
 }
 else //Квадратная матрица
 {//Проверка подклассов класса <КВАДРАТНАЯ МАТРИЦА> ...
  //---------------------------------------------------------------------------------
  //Проверка на диагональную матрицу
  if (IsDiagonal())
  {if (IsScalar()) return RM_SCALAR;//Проверка на скалярную матрицу
   if (IsUnit()) return RM_UNIT;//Проверка на единичную матрицу
   return RM_DIAGONAL;
  }
  //---------------------------------------------------------------------------------
  if (IsSymmetric()) return RM_SYMMETRICAL;//Проверка на симметричность
  if (IsSkewSymmetric()) //Проверка на кососимметричность
  {//Проверка на знакопеременность
   if (IsAltSign()) return RM_ALTERNATINGSIGN;
   return RM_SKEWSYMMETRIC;
  }
  //---------------------------------------------------------------------------------
  //Проверка на верхнюю треугольную матрицу
  if (IsUpperTriang()) return RM_UPPERTRIANG;
  //Проверка на нижнюю треугольную матрицу
  if (IsLowerTriang()) return RM_LOWERTRIANG;
  //---------------------------------------------------------------------------------
  //Проверка на ленточную матрицу с определением числа ее диагоналей
  ulong diags = 0L;
  if (IsBand(diags)) return RM_BAND;
 }
return RM_SQUARE;
}
//***********************************************************************************
//СТАТУС: I.12, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: uint SubType(ulong& n) const
//НАЗНАЧЕНИЕ: Определение подтипа матрицы. В переменную n, передаваемую по ссылке, в
//зависимости от подтипа матрицы заноситься дополнительная информация о матрице. Для
//квадратной матрицы и векторов - n будет содержать размерности, для ленточной матри-
//цы - количество диагоналей.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong& n - ссылка на переменную, в которую заносится
//дополнительная информация о матрице
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint type - подтип матрицы
//***********************************************************************************
uint TIntMatrix::SubType(ulong& n) const
{n = 0L;
 if (IsZeroSize()) return RM_ZEROSIZE;//Матрица нулевого размера
 //Действительное число - матрица размером 1 x 1
 if ((Rows() == 1) && (Cols() == 1)) {n = 1L; return RM_NUMBER;}
 //Матрица со всеми нулевыми элементами
 if (IsZero()) return RM_ZERO;

 if (IsRectang()) //Прямоугольная матрица
 {if ((Rows() == 1) && (Cols() > 1)) {n = Cols(); return RV_ROW;}//Вектор-строка
  if ((Cols() == 1) && (Rows() > 1)) {n = Rows(); return RV_COLUMN;}//Вектор-столбец
  return RM_RECTANGULAR;
 }
 else //Квадратная матрица
 {//Проверка подклассов класса <КВАДРАТНАЯ МАТРИЦА> ...
  //---------------------------------------------------------------------------------
  n = Rows();//Размерность квадратной матрицы
  //Проверка на диагональную матрицу
  if (IsDiagonal())
  {if (IsScalar()) return RM_SCALAR;//Проверка на скалярную матрицу
   if (IsUnit()) return RM_UNIT;//Проверка на единичную матрицу
   return RM_DIAGONAL;
  }
  //---------------------------------------------------------------------------------
  if (IsSymmetric()) return RM_SYMMETRICAL;//Проверка на симметричность
  if (IsSkewSymmetric()) //Проверка на кососимметричность
  {//Проверка на знакопеременность
   if (IsAltSign()) return RM_ALTERNATINGSIGN;
   return RM_SKEWSYMMETRIC;
  }
  //---------------------------------------------------------------------------------
  //Проверка на верхнюю треугольную матрицу
  if (IsUpperTriang()) return RM_UPPERTRIANG;
  //Проверка на нижнюю треугольную матрицу
  if (IsLowerTriang()) return RM_LOWERTRIANG;
  //---------------------------------------------------------------------------------
  //Проверка на ленточную матрицу с определением числа ее диагоналей
  ulong diags;
  if (IsBand(diags)) {n = diags; return RM_BAND;}
 }
return RM_SQUARE;
}
//***********************************************************************************
//СТАТУС: I.13, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// void Properties(ulong& rows, ulong& cols, bool& type, uint& subtype) const
//НАЗНАЧЕНИЕ: Определение свойств матрицы. Функция размещает характеристики матрицы в
//переменных rows, cols, type, subtype, передаваемых по ссылке. Для ленточной матрицы
//cols будет содержать количество ее диагоналей.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong& rows - ссылка на число строк матрицы;
//2. ulong& cols - ссылка на число столбцов (диагоналей) матрицы;
//3. bool& type  - ссылка на тип матрицы (SQUARE || RECTANG);
//4. uint& subtype - ссылка на подтип матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIntMatrix::Properties(ulong& rows, ulong& cols, bool& type, uint& subtype) const
{type = Type(); rows = Rows(); cols = Cols();
 ulong n; subtype = SubType(n);//Определение подтипа матрицы
 if (subtype == RM_BAND) cols = n;//Число диагоналей для ленточной матрицы
}
//***********************************************************************************
//СТАТУС: I.14, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Properties(PF_MATRIX& Info) const
//НАЗНАЧЕНИЕ: Определение свойств матрицы. Функция размещает характеристики матрицы в
//структуре Info, передаваемой по ссылке. Для ленточной матрицы поле Info.cols будет
//содержать количество ее диагоналей.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: PF_MATRIX& Info - ссылка на структуру свойств матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIntMatrix::Properties(PF_MATRIX& Info) const
{Info.type = Type(); Info.rows = Rows(); Info.cols = Cols();
 //----------------------------------------------------------------------------------
 //Определение подтипа матрицы
 //----------------------------------------------------------------------------------
 ulong n; Info.subtype = SubType(n);
 //Число диагоналей для ленточной матрицы
 if (Info.subtype == RM_BAND) Info.cols = n;
}
//***********************************************************************************
//СТАТУС: I.15, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetType(string& s, uint language = ENG) const
//НАЗНАЧЕНИЕ: Формирование наименования типа матрицы на русском или английском языке.
//Допускается многоязычный интерфейс корректировкой кода функции. Язык по умолчанию -
//английский. Формирование типа матрицы (SQUARE || RECTANG) осуществляется в строке s,
//передаваемой по ссылке. Функция возвращает ссылку на строку с наименованием типа
//матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку для формирования имени типа вектора;
//2. uint language [ENG] - язык наименования типа вектора.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// string& s - ссылка на строку с сформированным именем типа вектора
//***********************************************************************************
string& TIntMatrix::GetType(string& s, uint language) const
{if (language == RUS) //Формирование наименования типа матрицы на русском языке
  s = (IsSquare()) ? "Квадратная матрица" : "Прямоугольная матрица";
 else //Формирование наименования типа матрицы на английском языке
  s = (IsSquare()) ? "Square integer matrix" : "Rectangular integer matrix";
 return s;
}
//***********************************************************************************
//СТАТУС: I.16, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& GetSubType(string& s, uint language = ENG) const
//НАЗНАЧЕНИЕ: Получение наименования подтипа матрицы. Таблица соответствия подтипа
//матрицы с ее наименованиями представлена массивом RMatrName. В массиве хранятся
//наименования матриц на русском и английском языке. Индексом для получения имени
//матрицы служит ее подтип (subtype). Осуществляется обработка некорректного задания
//языка, на  котором  должно  быть получено имя. Допускается многоязычный интерфейс
//путем корректировки структуры MATRIX_NAME и внесения изменений в массив RMatrName.
//Язык по умолчанию - английский.  При формировании наименования матрицы в строке s,
//прежнее содержимое строки уничтожается.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку;
//2. uint language (ENG) - язык, на котором формируется наименование матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с именем подтипа матрицы
//***********************************************************************************
string& TIntMatrix::GetSubType(string& s, uint language) const
{uint index = SubType();//Определяем подтип матрицы
 switch (language)
 { case RUS: //указать наименование типа матрицы на русском языке
    s = RMatrName[index].rus_name; break;
   case ENG: //указать наименование типа матрицы на английском языке
    s = RMatrName[index].eng_name; break;
   //Наименование типа матрицы на заданном языке отсутствует
   default: //указать наименование типа матрицы на английском языке
    s = RMatrName[index].eng_name; break;
 }
 return s;
}
//****************************************************************************************
//СТАТУС: I.17; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// string& GetData(string& s, string delim) const;
//НАЗНАЧЕНИЕ: Функция размещает в строке s, передаваемой по ссылке, значения элементов
//матрицы в отформатированном виде. Формат вывода значений элементов матрицы:
// < X11<delim>X12<delim>X13...X1n\n >
// < X21<delim>X22<delim>X23...X1n\n >
// < .............................\n >
// < Xm1<delim>Xm2<delim>Xm3...Xmn\n >, где Xij - значениe элемента матрицы.
//При выводе элементов целочисленной матрицы приняты следующие соглашения:
//1. Все элементы матрицы имеют ширину вывода равную наибольшей символьной длине
//   элемента в данном столбце матрицы, который определяется функцией WidthCols(...)
//2. Выводятся только отрицательные знаки чисел.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которую заносятся элементы матрицы;
//2. string& delim - строка символов-разделителей между двумя соседними числами.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - ссылка на строку с элементами матрицы.
//****************************************************************************************
string& TIntMatrix::GetData(string& s, string& delim) const
{s.resize(0);
 if (IsZeroSize()) return s.append("Zero-size integer matrix.");
 if (delim.empty()) delim.assign(1,' ');
 //Определение максимальной символьной длины элемента матрицы
 ivector WCols;
 WidthCols(WCols);

 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 text.setf(ios::right);//Выравнивание по правому краю.
 //Вывод значений элементов вещественной матрицы в строку
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {//Формирование символьного представления вещественного числа
   text << setw(WCols.Get(j)) << data[i][j];
   if ((Cols()-j) > 1) text << delim << ends;
   else text << endl << ends;//Каждая строка матрицы выводится с новой строки
   s.append(text.str()); text.seekp(0);
  }
return s;
}
//***********************************************************************************
//СТАТУС: I.18; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: uint WidthCols(ivector& Width) const
//НАЗНАЧЕНИЕ: Определение максимального символьного размера элементов целочисленной
//матрицы и максимальной ширины каждого столбца матрицы. Функция применяется для
//форматированного вывода элементов матрицы.
//В ходе работы функции создается вектор V, передаваемый по ссылке, для хранения мак-
//симальной ширины каждого столбца матрицы и максимального символьного размера элемента
//матрицы - Width[Cols()+1]. Максимальный размер элемента матрицы хранится в последнем
//элементе вектора Width.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//ivector& Width - вектор, в который записывается ширина каждого столбца матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: uint MaxLen - максимальная символьная длина элемента матрицы
//***********************************************************************************
uint TIntMatrix::WidthCols(ivector& Width) const
{uint MaxLen = 0;
 //Проверка матрицы на нулевой размер
 if (IsZeroSize()) {Width.Resize(0); return MaxLen;}
 //Установка нового размера вектора Width и его начальная инициализация
 Width.Set(Cols()+1,0L);

 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 uint count;
 //Цикл считывания элементов вещественной матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {//Формирование символьного представления вещественного числа
   text << data[i][j] << ends;
   //Определение максимальной символьной длины элемента матрицы и каждого ее столбца
   count = text.pcount()-1;
   if (count > (ulong) Width.Get(j))
   {Width.Put(j,count);
    if (MaxLen < count) MaxLen = count;
   }
   text.seekp(0);
  }
 Width.Put(Cols(),MaxLen);
return MaxLen;
}
//***********************************************************************************
//СТАТУС: I.19; public member-function of class TIntMatrix
//НАИМЕНОВАНИЕ ФУНКЦИИ: string& Properties(string& s) const
//НАЗНАЧЕНИЕ: Формирование свойств TIntMatrix в виде строки.
//ПРИМЕР: TYPE: <matrix type>; DIMENSION: <Rows X Cols>.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: string& s - ссылка на строковый объект
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: string& s - строка со свойствами матрицы
//***********************************************************************************
string& TIntMatrix::Properties(string& s) const
{char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 s.resize(0);
 PF_MATRIX Info;
 Properties(Info);//Определение свойств матрицы
 //----------------------------------------------------------------------------------
 //1. Формирование наименования типа матрицы
 s.append("TYPE: ");
 text << RMatrName[Info.subtype].eng_name << "; " << ends;
 s.append(text.str()); text.seekp(0);
 //2. Формирование размерности матрицы
 s.append("DIMENSION: ");
 text << Rows() << " x " << Cols() << ends;
 s.append(text.str()); text.seekp(0);
 //Для ленточной матрицы формируем количество ее диагоналей
 if (Info.subtype == RM_BAND)
 {text << "; " << Info.cols << "-diags" << ends;
  s.append(text.str()); text.seekp(0);
 }
 s.append("\n");//'\n'
return s;
}
//-----------------------------------------------------------------------------------
//  РЕАЛИЗАЦИЯ ОБЩЕДОСТУПНЫХ ЧЛЕНОВ-ФУНКЦИЙ TIntMatrix по УСТАНОВКЕ СВОЙСТВ МАТРИЦЫ
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: I.1, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(ulong rows, ulong cols, long value)
//НАЗНАЧЕНИЕ: Установка новых размеров матрицы и их инициализация значением value.
//При невозможности создания матрицы новых размеров функция возвращает false, матрица
//становится нулевой размерности.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong rows - количество строк матрицы;
//2. ulong cols - количество столбцов матрицы;
//3. long value - инициализирующая величина
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак создания матрицы новых размеров
//***********************************************************************************
bool TIntMatrix::Set(ulong rows, ulong cols, long value)
{//Анализ на соответствие размеров старой и новой матрицы
 if ((rows != Rows()) || (cols != Cols()))
 {Delete();//1. Удаление элементов матрицы со старыми размерами
  //2. Установка новых размеров и типа матрицы
  m = rows; n = cols; type = (m == n) ? SQUARE : RECTANG;
  //3. Распределение памяти под хранение элементов матрицы с новыми размерами
  if (Create() == false) return false;
 }
 //Инициализация элементов матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = value;
 return true;
}
//***********************************************************************************
//СТАТУС: I.2, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(ulong rows, ulong cols, bool init)
//НАЗНАЧЕНИЕ: Установка новых размеров матрицы и ее инициализация cлучайными значениями
//при init = true. По умолчанию матрица не инициализируется. При невозможности созда-
//ния матрицы новых размеров возвращается false, матрица становится нулевой размерности.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong rows - количество строк матрицы;
//2. ulong cols - количество столбцов матрицы;
//3. bool init - опция инициализации случайными значениями элементов матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак создания матрицы новых размеров
//***********************************************************************************
bool TIntMatrix::Set(ulong rows, ulong cols, bool init)
{//Анализ на соответствие размеров старой и новой матрицы
 if ((rows != Rows()) || (cols != Cols()))
 {Delete();//1. Удаление элементов матрицы со старыми размерами
  //2. Установка новых размеров и типа матрицы
  m = rows; n = cols; type = (m == n) ? SQUARE : RECTANG;
  //3. Распределение памяти под хранение элементов матрицы с новыми размерами
  if (Create() == false) return false;
 }
 if (init) InitMatrix();//Инициализация элементов матрицы случайными значениями
 return true;
}
//***********************************************************************************
//СТАТУС: I.3, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(ulong size, uint sq_type, ulong diags = 3L)
//НАЗНАЧЕНИЕ: Установка новых свойств квадратной матрицы и ее инициализация. При
//невозможности создания квадратной матрицы новых размеров функция возвращает false,
//матрица становится нулевой размерности.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong size - размерность квадратной матрицы;
//2. uint sq_type - подтип квадратной матрицы;
//3. ulong diags (3) - количество диагоналей для ленточной матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак создания матрицы новых размеров
//***********************************************************************************
bool TIntMatrix::Set(ulong size, uint sq_type, ulong diags)
{//Анализ на соответствие размеров старой и новой матрицы
 if ((size != Rows()) || (size != Cols()))
 {Delete();//1. Удаление элементов матрицы со старыми размерами
  //2. Установка новых размеров и типа матрицы
  m = n = size; type = SQUARE;
  //3. Распределение памяти под хранение элементов матрицы с новыми размерами
  if (Create() == false) return false;
 }
 switch (sq_type) //Инициализация элементов квадратной матрицы
 { case RM_DIAGONAL:
    InitDiagonal(); break;
   case RM_SCALAR:
    InitScalar(); break;
   case RM_UNIT:
    InitUnit(); break;
   case RM_BAND:
    InitBand(diags); break;
   case RM_UPPERTRIANG:
    InitUTriang(); break;
   case RM_LOWERTRIANG:
    InitLTriang(); break;
   case RM_SYMMETRICAL:
    InitSymmetric(); break;
   case RM_SKEWSYMMETRIC:
    InitSkewSymmetric(); break;
   case RM_ALTSIGN:
    InitAltSign(); break;
   case RM_ZERO:
    InitZeroMatrix(); break;
   default: //По умолчанию - квадратная матрица
    InitMatrix(); break;
 }
 return true;
}
//***********************************************************************************
//СТАТУС: I.4, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Set(const PF_MATRIX& Info)
//НАЗНАЧЕНИЕ: Установка новых свойств матрицы по данным из структуры Info типа
//PF_MATRIX, передаваемой по ссылке. При невозможности создания матрицы с новыми
//свойствами функция возвращает false и матрица становится нулевой размерности. При
//создании квадратной матрицы (Info.type == SQUARE), размерность матрицы определяется
//полем Info.rows.
//При создании ленточной матрицы (Info.type == SQUARE && Info.subtype == RM_BAND) раз-
//мерность матрицы определяется полем Info.rows, количество диагоналей - полем Info.cols.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const PF_MATRIX& Info - ссылка на структуру со свойствами создаваемой матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак создания матрицы с новыми свойствами
//***********************************************************************************
bool TIntMatrix::Set(const PF_MATRIX& Info)
{if (Info.type == RECTANG) //Создание прямоугольной матрицы
  return Set(Info.rows,Info.cols,true);
 else //Создание квадратной матрицы
  return Set(Info.rows, Info.subtype, Info.cols);
}

//-----------------------------------------------------------------------------------
// ИНИЦИАЛИЗАЦИЯ ЭЛЕМЕНТОВ МАТРИЦЫ TIntMatrix СЛУЧАЙНЫМИ ЗНАЧЕНИЯМИ
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: I.1, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Rand()
//НАЗНАЧЕНИЕ: Инициализация элементов матрицы случайными величинами, распределенными
//по равновероятному закону в интервале [0..2^24]. Функция возвращает false для
//матрицы нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//***********************************************************************************
bool TIntMatrix::Rand()
{if (IsZeroSize()) return false;//Матрица нулевого размера не инициализируется
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 //Инициализация элементов вектора СВ
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = RNG.Rand();
 return true;
}
//***********************************************************************************
//СТАТУС: I.1, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Rand(long A, long B);
//НАЗНАЧЕНИЕ: Инициализация элементов матрицы целыми случайными величинами, распреде-
//ленными по равновероятному закону в интервале [left..right], где left = Min(A,B) и
//right = Max(A,B). Функция возвращает false для  матрицы нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. long A - нижняя граница интервала изменения равномерной СВ;
//2. long B - верхняя граница интервала изменения равномерной СВ.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - признак выполнения функции
//***********************************************************************************
bool TIntMatrix::Rand(long A, long B)
{if (IsZeroSize()) return false;//Матрица нулевого размера не инициализируется
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 long left = A;
 long right = B;
 if (A > B) {left = B; right = A;}
 //Инициализация элементов вектора СВ
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = RNG.Rand(left,right);
 return true;
}
//-----------------------------------------------------------------------------------
// РЕАЛИЗАЦИЯ ФУНКЦИЙ ПО РАБОТЕ СО СТРОКАМИ и СТОЛБЦАМИ TIntMatrix
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: I.1; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ivector Row(ulong index) const
//НАЗНАЧЕНИЕ: Получение строки матрицы с заданным индексом от 0 до Rows()-1.
//Если индекс строки матрицы некорректен, то функция возвращает вектор нулевого разме-
//ра. Функция возвращает вектор с параметрами: size = Cols(); type = ROW.
//Корректные значения индекса строки: 0 <= index < Rows().
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong index - индекс копируемой строки матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ivector Row - строка матрицы с номером index
//***********************************************************************************
ivector TIntMatrix::Row(ulong index) const
{ivector Row(0L,ROW);
 if ((IsZeroSize()) || (index >= Rows())) return Row;
 //Формируем вектор Row с элементами строки матрицы с номером index
 Row.Resize(Cols());
 //Копирование значений элементов строки матрицы в вектор Row
 for (ulong j = 0; j < Cols(); j++) Row.Put(j,data[index][j]);
 return Row;
}
//***********************************************************************************
//СТАТУС: I.2; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Row(ivector& V, ulong index) const
//НАЗНАЧЕНИЕ: Получение строки матрицы с заданным индексом от 0 до Rows()-1.
//Строка матрицы с индексом index формируется в векторе V, передаваемом по ссылке.
//Если индекс строки матрицы некорректен или матрица нулевого размера, то функция воз-
//вращает false и вектор V становится вектором нулевого размера. Вектор V будет иметь
//следующие свойства: size = Cols(); type = ROW.
//Корректные значения индекса строки: 0 <= index < Rows().
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong index - индекс копируемой строки матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TIntMatrix::Row(ivector& V, ulong index) const
{V.Resize(Cols()); V.SetType(ROW);
 if ((IsZeroSize()) || (index >= Rows())) return false;
 //Копирование значений элементов строки матрицы в вектор V
 for (ulong j = 0L; j < Cols(); j++) V.Put(j,data[index][j]);
 return true;
}
//***********************************************************************************
//СТАТУС: I.3; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: ivector Col(ulong index) const
//НАЗНАЧЕНИЕ: Получение столбца матрицы с заданным индексом от 0 до Cols()-1.
//Если индекс столбца матрицы некорректен, то возвращается вектор-столбец нулевого
//размера. Функция возвращает вектор с параметрами: size = Rows(); type = COL.
//Корректные значения индекса столбца: 0 <= index < Cols().
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong index - индекс копируемого столбца матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ivector Col - столбец матрицы с номером index
//***********************************************************************************
ivector TIntMatrix::Col(ulong index) const
{ivector Col(0L,COL);
 if ((IsZeroSize()) || (index >= Cols())) return Col;
  //Формируем вектор Col с элементами столбца матрицы с номером index
  Col.Resize(Rows());
  //Копирование значений элементов столбца матрицы в вектор Col
  for (ulong i = 0L; i < Rows(); i++) Col.Put(i,data[i][index]);
 return Col;
}
//***********************************************************************************
//СТАТУС: I.4; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Col(ivector& V, ulong index) const
//НАЗНАЧЕНИЕ: Получение столбца матрицы с заданным индексом от 0 до Cols()-1.
//Столбец матрицы с индексом index формируется в векторе V, передаваемом по ссылке.
//Если индекс столбца матрицы некорректен или матрица нулевого размера, то функция
//возвращает false и вектор V становится вектором нулевого размера.
//Вектор V будет иметь следующие свойства: size = Rows(); type = COL.
//Корректные значения индекса строки: 0 <= index < Cols().
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong index - индекс копируемого столбца матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TIntMatrix::Col(ivector& V, ulong index) const
{V.Resize(Rows()); V.SetType(COL);
 if ((IsZeroSize()) || (index >= Cols())) return false;
 //Копирование значений элементов столбца матрицы в вектор V
 for (ulong i = 0L; i < Rows(); i++) V.Put(i,data[i][index]);
 return true;
}
//***********************************************************************************
//СТАТУС: I.5; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ExchangeRows(ulong i, ulong j)
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ДВУХ СТРОК МАТРИЦЫ
//Функция переставляет две строки матрицы с индексами от 0 до Rows()-1. Функция возв-
//ращает признак успешно или нет произошла перестановка двух строк. Функция изменяет
//элементы исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong i - индекс первой строки матрицы, которую необходимо переставить;
//2. ulong j - индекс второй строки матрицы, который переставляется с первой строкой.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool Success - признак выполнения операции перестановки
//***********************************************************************************
bool TIntMatrix::ExchangeRows(ulong i, ulong j)
{if ((IsZeroSize()) || (i >= Rows()) || (j >= Rows())) return false;
 //Проверка на совпадение индексов переставляемых строк
 if (i == j) return true;//Перестановка не требуется
 //Операция перестановки двух строк матрицы
 long x;
 for (ulong k = 0L; k < Cols(); k++)
 {x = data[i][k]; data[i][k] = data[j][k]; data[j][k] = x;}
 return true; //Перестановка двух строк выполнена
}
//***********************************************************************************
//СТАТУС: I.6; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ExchangeRows(const ivector& permutation)
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА СТРОК МАТРИЦЫ
//Функция переставляет строки матрицы согласно вектору перестановок permutation.
//Функция возвращает признак успешно или нет произошла перестановка строк. Функция
//изменяет элементы исходной матрицы. Вектор перестановок может быть больше или меньше
//числа строк матрицы. i-ый элемент вектора хранит индекс строки матрицы с которой
//совершается перестановка. Перестановка двух строк выполняется функцией
//ExchangeRows(i,permutation[i]), где i - индекс первой переставляемой строки,
//permutation[i] - индекс второй строки матрицы переставляемой с первой строкой.
//Если индексы переставляемых строк матрицы некорректны, то возвращается false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const ivector& permutation - ссылка на вектор перестановок строк матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool Success - признак выполнения операции перестановки
//***********************************************************************************
bool TIntMatrix::ExchangeRows(const ivector& permutation)
{if ((IsZeroSize()) || (permutation.IsZeroSize())) return false;
 //Операция перестановки строк матрицы по вектору перестановок
 bool lSuccess;
 ulong Count = (Rows() < permutation.Size()) ? Rows() : permutation.Size();
 for (ulong k = 0L; k < Count; k++)
 {lSuccess = ExchangeRows(k, permutation[k]);
  if (lSuccess == false) return lSuccess;
 }
 return lSuccess;//Перестановка строк выполнена успешно
}
//***********************************************************************************
//СТАТУС: I.7; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ExchangeCols(ulong i, ulong j)
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ДВУХ СТОЛБЦОВ МАТРИЦЫ
//Функция переставляет два столбца матрицы с индексами от 0 до Cols()-1. Возвращается
//признак успешно или нет произошла перестановка двух столбцов. Функция изменяет эле-
//менты исходной матрицы. Если индексы переставляемых столбцов матрицы некорректны,
//то возвращается false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ulong i - индекс первого столбца матрицы, который необходимо переставить;
//2. ulong j - индекс второго столбца матрицы, переставляемый с первым столбцом.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool Success - признак выполнения операции перестановки
//***********************************************************************************
bool TIntMatrix::ExchangeCols(ulong i, ulong j)
{if ((IsZeroSize()) || (i >= Cols()) || (j >= Cols())) return false;
 //Проверка на совпадение индексов переставляемых столбцов
 if (i == j) return true;//Перестановка не требуется
 //Операция перестановки двух столбцов матрицы
 long x;
 for (ulong k = 0L; k < Rows(); k++)
 {x = data[k][i]; data[k][i] = data[k][j]; data[k][j] = x;}
 return true; //Перестановка двух столбцов выполнена
}
//***********************************************************************************
//СТАТУС: I.8; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ExchangeCols(const ivector& permutation)
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА СТОЛБЦОВ МАТРИЦЫ
//Функция переставляет столбцы матрицы согласно вектору перестановок permutation.
//Возвращается признак успешно или нет произошла перестановка столбцов. Функция изме-
//няет элементы исходной матрицы. Вектор перестановок может быть больше или меньше
//числа столбцов матрицы. i-ый элемент вектора хранит индекс столбца матрицы с кото-
//рым необходимо совершить перестановку. Перестановка пары столбцов выполняется функ-
//цией ExchangeCols(i,permutation[i]), где i - индекс первой переставляемого столбца,
//permutation[i] - индекс второго столбца матрицы переставляемой с первым столбцом.
//Если индексы переставляемых столбцов матрицы некорректны, то возвращается false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//const ivector& permutation - ссылка на вектор перестановок столбцов матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool Success - признак выполнения операции перестановки
//***********************************************************************************
bool TIntMatrix::ExchangeCols(const ivector& permutation)
{if ((IsZeroSize()) || (permutation.IsZeroSize())) return false;
 bool lSuccess;
 //Операция перестановки столбцов матрицы по вектору перестановок
 ulong Count = (Cols() < permutation.Size()) ? Cols() : permutation.Size();
 for (ulong k = 0L; k < Count; k++)
 {lSuccess = ExchangeCols(k, permutation[k]);
  if (lSuccess == false) return lSuccess;
 }
 return lSuccess; //Перестановка столбцов выполнена
}
//***********************************************************************************
//СТАТУС: I.9; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: imatrix& U_SubMatrix(imatrix& SubMatrix, ulong k, ulong g) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ КВАДРАТНОЙ ПОДМАТРИЦЫ
//Функция формирует квадратную подматрицу из исходной матрицы следующего вида:
//SubMatrix(0 1 ... k-1 k, 0 1 ... k-1 g), где
// 0 1 ... k-1 k - строки исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы;
// 0 1 ... k-1 g - столбцы исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы, g > k.
//Подматрица формируется из элементов, стоящих на пересечении строк и столбцов, кото-
//рые принадлежат вышеуказанному множеству столбцов и строк, исходной матрицы. Функ-
//ция возвращает сформированную подматрицу.
//Верхние границы строк k и столбцов g исходной матрицы, которые участвуют в формиро-
//вании элементов подматрицы входят в данное допустимое множество. Нумерация строк и
//столбцов начинается с 0.
//Если индексы столбцов и строк из которых будет формироваться подматрица будут некор-
//ректны, то возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& SubMatrix - ссылка на матрицу в которой формируется подматрица;
//2. ulong k - верхняя граница строк матрицы, участвующих в формировании подматрицы;
//3. ulong g - верхняя граница столбцов матрицы, участвующих в формировании подматрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix& SubMatrix - ссылка на квадратную подматрицу
//***********************************************************************************
imatrix& TIntMatrix::U_SubMatrix(imatrix& SubMatrix, ulong k, ulong g) const
{//Проверка исходной матрицы на матрицу нулевого размера
 if (IsZeroSize()) {SubMatrix.Set(0L,false); return SubMatrix;}
 //Проверка на допустимые индексы k & g, 0 <= k < Rows(), k < g < Cols()
 if ((k >= Rows()) || (g <= k) || (g >= Cols()))
 {SubMatrix.Set(0L,false); return SubMatrix;}
 //----------------------------------------------------------------------------------
 //Формирование подматрицы
 //----------------------------------------------------------------------------------
 SubMatrix.Set(k+1,false);
 //Цикл формирования элементов подматрицы
 //Rows: 0 1 ... k-1 k; Cols: 0 1 ... k-1 g
 for (ulong i = 0L; i < Rows(); i++)
 {if (i > k) break; //Выход из цикла - подматрица сформирована
  for (ulong j = 0L; j < Cols(); j++)
  {if (j < k) SubMatrix.Put(i,j,data[i][j]);
   //Формирование последнего столбца подматрицы
   else {SubMatrix.Put(i,k,data[i][g]); break;}
  }
 }
 return SubMatrix;//Квадратная подматрица
}
//***********************************************************************************
//СТАТУС: I.10; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: imatrix& L_SubMatrix(imatrix& SubMatrix, ulong g, ulong k) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ КВАДРАТНОЙ ПОДМАТРИЦЫ
//Функция формирует квадратную подматрицу из исходной матрицы следующего вида:
//SubMatrix(0 1 ... k-1 g, 0 1 ... k-1 k), где
// 0 1 ... k-1 g - строки исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы;
// 0 1 ... k-1 k - столбцы исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы, g > k.
//Подматрица формируется из элементов, стоящих на пересечении строк и столбцов, кото-
//рые принадлежат вышеуказанному множеству столбцов и строк, исходной матрицы. Функ-
//ция возвращает сформированную подматрицу.
//Верхние границы строк g и столбцов k исходной матрицы, которые участвуют в формиро-
//вании элементов подматрицы входят в данное допустимое множество. Нумерация строк и
//столбцов начинается с 0.
//Если индексы столбцов и строк из которых будет формироваться подматрица некорректны,
//то возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& SubMatrix - ссылка на матрицу, в которой формируется подматрица
//1. ulong g - верхняя граница строк матрицы, участвующих в формировании подматрицы;
//2. ulong k - верхняя граница столбцов матрицы, участвующих в формировании подматрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix& SubMatrix - квадратная подматрица
//***********************************************************************************
imatrix& TIntMatrix::L_SubMatrix(imatrix& SubMatrix, ulong g, ulong k) const
{//Проверка исходной матрицы на матрицу нулевого размера
 if (IsZeroSize()) {SubMatrix.Set(0L,false); return SubMatrix;}
 //Проверка на допустимые индексы k & g, 0 < g < Rows(), 0 <= k < g, k < Cols()
 if ((k >= Cols()) || (g <= k) || (g >= Rows()))
 {SubMatrix.Set(0L,false); return SubMatrix;}
 //----------------------------------------------------------------------------------
 //Формирование подматрицы
 //----------------------------------------------------------------------------------
 SubMatrix.Set(k+1,false);
 //Цикл формирования элементов подматрицы
 //Rows: 0 1 ... k-1 g; Cols: 0 1 ... k-1 k
 for (ulong i = 0L; i < Rows(); i++)
 {if (i == k) i = g;//Формирование последней строки матрицы
  for (ulong j = 0L; j <= k ; j++)
  {if (i != g) SubMatrix.Put(i,j,data[i][j]);
   else SubMatrix.Put(k,j,data[i][j]);
  }
  if (i == g) break;//Выход из цикла - подматрица сформирована
 }
 return SubMatrix;//Квадратная подматрица
}
//***********************************************************************************
//СТАТУС: I.11; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: imatrix& P_SubMatrix(imatrix& SubMatrix, ulong k) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ КВАДРАТНОЙ ПОДМАТРИЦЫ
//Функция формирует квадратную подматрицу из исходной матрицы следующего вида:
//SubMatrix(0 1 ... k-1 k, 0 1 ... k-1 k), где
// 0 1 ... k-1 k - строки исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы;
// 0 1 ... k-1 k - столбцы исходной матрицы из которых будут выбираться элементы
// формируемой подматрицы.
//Подматрица формируется из элементов, стоящих на пересечении первых k строк и первых
//k столбцов - ГЛАВНЫЕ ПОДМАТРИЦЫ. Функция возвращает сформированную подматрицу.
//Верхние границы строк k и столбцов k исходной матрицы, которые участвуют в формиро-
//вании элементов подматрицы входят в данное допустимое множество. Нумерация строк и
//столбцов начинается с 0.
//Если индексы столбцов и строк из которых будет формироваться подматрица некорректны,
//то возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& SubMatrix - ссылка на результирующую матрицу;
//2. ulong k - верхняя граница строк и столбцов матрицы, формирующих подматрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix& SubMatrix - главная подматрица k-го порядка
//***********************************************************************************
imatrix& TIntMatrix::P_SubMatrix(imatrix& SubMatrix, ulong k) const
{//Проверка исходной матрицы на матрицу нулевого размера
 if (IsZeroSize()) {SubMatrix.Set(0L,false); return SubMatrix;}
 //Проверка на допустимость индекса k, 0 <= k < Rows(), 0 <= k < Cols()
 if ((k >= Cols()) || (k >= Rows()))
 {SubMatrix.Set(0L,false); return SubMatrix;}
 //----------------------------------------------------------------------------------
 //Формирование главной подматрицы
 //----------------------------------------------------------------------------------
 SubMatrix.Set(k+1,false);
 //Цикл формирования элементов подматрицы
 //Rows: 0 1 ... k-1 k; Cols: 0 1 ... k-1 k
 for (ulong i = 0L; i <= k; i++)
  for (ulong j = 0L; j <= k ; j++)
   SubMatrix.Put(i,j,data[i][j]);
 return SubMatrix;//Квадратная подматрица
}
//***********************************************************************************
//СТАТУС: I.12; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//imatrix& SubMatrixByCols(imatrix& SubMatrix, const ivector& IndexCols,
//                         bool Check=false) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДМАТРИЦЫ ПО ИНДЕКСАМ СТОЛБЦОВ ИСХОДНОЙ МАТРИЦЫ
//Количество  строк подматрицы определяется количеством строк исходной матрицы.
//Переменная Check - это опция проверки на принадлежность номеров индексов в векторе
//IndexCols допустимым значениям индексов столбцов исходной матрицы. При проверке фор-
//мируется объект-предикат типа TBelongClosedInterval, проверяющий каждое значение
//индекса столбца на допустимость и на основе его работы формируется подвектор вектора
//IndexCols с корректными значениями индексов столбцов. Если Check == false, то про-
//верка не проводится, что ускоряет работу функции, но ответственность за корректные
//значения индексов столбцов возлагается на пользователя.
//Функция может вернуть подматрицу нулевого размера в следующих случаях:
//1. Исходная матрица является матрицей нулевого размера;
//2. Вектор индексов столбцов является вектором нулевого размера;
//3. При Check == true, подвектор вектора IndexCols оказался вектором нулевого размера
//   - все индексы столбцов находятся вне границ размерности матрицы по столбцам.
//Возможно аварийное завершение работы программы при Check == false, если индекс
//столбца в векторе IndexCols является некорректным.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& SubMatrix - ссылка на результирующую матрицу;
//2. const ivector& IndexCols - ссылка на вектор с индексами столбцов исходной матрицы;
//3. bool Check (false) - индикатор проверки значений индексов столбцов в векторе
//   IndexCols на корректность
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//imatrix& SubMatrix - подматрица, формируемая из столбцов исходной матрицы, индексы
//которых размещены в векторе IndexCols.
//***********************************************************************************
imatrix& TIntMatrix::SubMatrixByCols(imatrix& SubMatrix, const ivector& IndexCols,
 bool Check) const
{//Проверка исходной матрицы и вектора с индексами столбцов на нулевой размер
 if (IsZeroSize() || IndexCols.IsZeroSize())
 {SubMatrix.Set(0L,false); return SubMatrix;}
 //Формирование вектора корректных индексов столбцов для исходной матрицы
 ivector Index = IndexCols;
 if (Check)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Cols()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  if (Index.IsZeroSize()) {SubMatrix.Set(0L,false); return SubMatrix;}
 }
 //----------------------------------------------------------------------------------
 //Формирование подматрицы с индексами столбцов исходной матрицы, размещенных
 //в векторе Index, и количеством строк равным их числу исходной матрицы
 SubMatrix.Set(Rows(),Index.Size(),false);
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Index.Size(); j++)
   SubMatrix.Put(i,j,data[i][Index.Get(j)]);
 return SubMatrix; //Подматрица, составленная из столбцов исходной матрицы
}
//***********************************************************************************
//СТАТУС: I.13; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//imatrix& SubMatrixByRows(imatrix& SubMatrix, const ivector& IndexRows,
//                         bool Check = false) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДМАТРИЦЫ ПО ИНДЕКСАМ СТРОК ИСХОДНОЙ МАТРИЦЫ
//Количество столбцов подматрицы определяется количеством столбцов исходной матрицы.
//Check - опция проверки на принадлежность номеров индексов в векторе IndexCols допу-
//стимым значениям индексов строк исходной матрицы. При проверке формируется объект-
//предикат типа TBelongClosedInterval<long,ivector>, проверяющий все значения индек-
//сов строки на допустимость и на основе его работы формируется подвектор вектора
//IndexRows с корректными значениями индексов строк. Если Check == false, то проверка
//не проводится, что ускоряет работу, но ответственность за корректные значения индек-
//сов строк возлагается на пользователя.
//Функция может вернуть подматрицу нулевого размера в следующих случаях:
//1. Исходная матрица является матрицей нулевого размера;
//2. Вектор индексов строк является вектором нулевого размера;
//3. При Check == true, подвектор вектора IndexRows оказался вектором нулевого размера
//  - все индексы строк находятся вне границ размерности матрицы по строкам.
//Возможно аварийное завершение работы программы при Check == false, если индекс строки
//в векторе IndexRows является некорректным.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& SubMatrix - ссылка на результирующую матрицу;
//2. const ivector& IndexRows - ссылка на вектор с индексами строк исходной матрицы;
//3. bool Check (false) - индикатор проверки значений индексов строк в векторе
//  IndexRows на корректность
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//imatrix& SubMatrix - подматрица, формируемая из строк исходной матрицы, индексы ко-
//торых размещены в векторе IndexRows.
//***********************************************************************************
imatrix& TIntMatrix::SubMatrixByRows(imatrix& SubMatrix, const ivector& IndexRows,
 bool Check) const
{//Проверка исходной матрицы и вектора с индексами строк на нулевой размер
 if (IsZeroSize() || IndexRows.IsZeroSize())
 {SubMatrix.Set(0L,false); return SubMatrix;}
 //Формирование вектора корректных индексов строк для исходной матрицы
 ivector Index = IndexRows;
 if (Check)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Rows()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Index = Index.SubVector(Predicate);
  if (Index.IsZeroSize()) {SubMatrix.Set(0L,false); return SubMatrix;}
 }
 //----------------------------------------------------------------------------------
 //Формирование подматрицы с индексами строк исходной матрицы, размещенных в векторе
 //Index, и количеством столбцов равным числу столбцов исходной матрицы
 SubMatrix.Set(Index.Size(),Cols(),false);
 for (ulong i = 0L; i < Index.Size(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   SubMatrix.Put(i,j,data[Index.Get(i)][j]);
 return SubMatrix; //Подматрица, составленная из строк исходной матрицы
}
//***********************************************************************************
//СТАТУС: I.14; TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//imatrix& SubMatrix(imatrix& SubMatrix, const ivector& IndexRows,
//                   const ivector& IndexRows, bool Check=false) const
//НАЗНАЧЕНИЕ: ФОРМИРОВАНИЕ ПОДМАТРИЦЫ ПО ИНДЕКСАМ СТРОК И СТОЛБЦОВ ИСХОДНОЙ
//МАТРИЦЫ, передавемым через векторы IndexRows и IndexCols. Размерность подматрицы
//определяется по строкам - размерностью вектора IndexRows, по столбцам - размерностью
//вектора IndexCols. Переменная Check - опция проверки на принадлежность номеров индек-
//сов в векторах IndexRows и IndexCols допустимым значениям индексов строк и столбцов
//исходной матрицы. При проверке формируются объекты-предикаты типа TBelongClosedInter-
//val, проверяющие каждое значение индекса строки и столбца на допустимость и на основе
//их работы формируется подвекторы векторов IndexRows и IndexCols с корректными зна-
//чениями индексов строк и столбцов. При Check == false то проверка не проводится, что
//ускоряет работу, но ответственность за корректные значения индексов строк и столбцов
//возлагается на пользователя. Фильтрация некорректных значений индексов столбцов и
//строк может привести к уменьшению размеров исходных векторов IndexRows и IndexCols
//либо привести их к вектору нулевого размера, при отсутствии в них корректных значе-
//ний индексов. Функция может вернуть подматрицу нулевого размера в следующих случаях:
//1. Исходная матрица является матрицей нулевого размера;
//2. Вектор индексов строк или столбцов является вектором нулевого размера;
//3. При Check == true, подвектор вектора IndexRows или IndexCols оказались векторами
//   нулевого размера - все индексы строк или столбцов находятся вне границ размерности
//   матрицы по строкам или по столбцам.
//Возможно аварийное завершение работы программы при Check == false, если индекс строки
//или столбца в векторе IndexRows или IndexCols является некорректным.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& SubMatrix - ссылка на результирующую матрицу;
//2. const ivector& IndexRows - ссылка на вектор с индексами строк исходной матрицы;
//3. const ivector& IndexCols - ссылка на вектор с индексами столбцов исходной матрицы;
//4. bool Check (false) - индикатор проверки значений индексов строк и столбцов в век-
//   торах IndexRows и IndexCols на корректность
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//imatrix& SubMatrix - подматрица, формируемая из строк и столбцов исходной матрицы,
//индексы которых размещены в векторах IndexRows и IndexCols.
//***********************************************************************************
imatrix& TIntMatrix::SubMatrix(imatrix& SubMatrix, const ivector& IndexRows,
 const ivector& IndexCols, bool Check) const
{//Проверка исходной матрицы и векторов с индексами строк и столбцов на нулевой размер
 if (IsZeroSize() || IndexRows.IsZeroSize() || IndexCols.IsZeroSize())
 {SubMatrix.Set(0L,false); return SubMatrix;}
 //Формирование вектора корректных индексов строк для исходной матрицы
 ivector Row = IndexRows;
 if (Check)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Rows()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Row = Row.SubVector(Predicate);
  if (Row.IsZeroSize()) {SubMatrix.Set(0L,false); return SubMatrix;}
 }
 //Формирование вектора корректных индексов столбцов для исходной матрицы
 ivector Col = IndexCols;
 if (Check)
 {ivector interval(2,0L);
  interval[0] = 0; interval[1] = Cols()-1;
  TBelongClosedInterval<long, ivector> Predicate =
  TBelongClosedInterval<long,ivector>(interval);
  Col = Col.SubVector(Predicate);
  if (Col.IsZeroSize()) {SubMatrix.Set(0L,false); return SubMatrix;}
 }
 //----------------------------------------------------------------------------------
 //Формирование подматрицы с индексами строк и столбцов исходной матрицы, размещенных
 //в векторах Row и Col
 SubMatrix.Set(Row.Size(),Col.Size(),false);
 //Цикл формирования значений элементов подматрицы SubMatrix
 for (ulong i = 0L; i < Row.Size(); i++)
  for (ulong j = 0L; j < Col.Size(); j++)
   SubMatrix.Put(i,j,data[Row.Get(i)][Col.Get(j)]);
 return SubMatrix;//Подматрица, составленная из строк и столбцов исходной матрицы
}
//***********************************************************************************
//СТАТУС: I.15, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//imatrix& ReverseByCol(imatrix& SubMatrix, ulong left = 0L, ulong right = MAX_SIZE) const
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ЭЛЕМЕНТОВ МАТРИЦЫ В ЗАДАННОМ ИНТЕРВАЛЕ СТОЛБЦОВ В ОБРАТНОМ
//ПОРЯДКЕ ПО СТОЛБЦАМ
//Функция изменяет порядок следования элементов матрицы по столбцам в интервале от ин-
//декса столбца со значением left до индекса столбца со значением right (включая его)
//на обратный.
//Значения верхней и нижней границ интервала столбцов, в которой должна осуществляться
//обратная перестановка должны удовлетворять следующим условиям:
// left <= right && right < Cols(), в противном случае функция не выполняется.
//По умолчанию, осуществляется перестановка всех элементов матрицы по всем столбцам.
//Функция не изменяет внутренную структуру исходной матрицы, так как функция работает
//с ее копией. Результат работы функции - матрица, совпадающая по размерам с исходной,
//но с переставленными в обратном порядке элементами по столбцам.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& A - ссылка на результирующую матрицу;
//2. ulong left (0) - нижний индекс столбца, с которого будет происходить перестановка
//   элементов матрицы в обратном порядке;
//3. ulong right (MAX_SIZE ~ Size()-1) - верхний индекс столбца матрицы, до которого
//   будет происходить перестановка элементов вектора в обратном порядке, включая
//   значение индекса right.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//imatrix& A - матрица с переставленными в обратном порядке столбцами относительно
//исходной матрицы элементами.
//***********************************************************************************
imatrix& TIntMatrix::ReverseByCol(imatrix& A, ulong left, ulong right) const
{right = (right == MAX_SIZE) ? Cols()-1 : right;
 //Проверка на возможность или необходимость осуществления перестановки
 if ((Cols() < 2) || (left >= right) || (right >= Cols()))
 {A.Set(0L,false); return A;}
 //Выполнение перестановки элементов матрицы по столбцам в обратном порядке
 A = *this;//Копирование исходной матрицы
 ulong r = right;
 ulong l = left;
 long temp;
 for (ulong i = 0; i < A.Rows(); i++)
 {while (l < r)
  {temp = A.Get(i,l); A.Put(i,l,A.Get(i,r)); A.Put(i,r,temp);
   l++; r--; //Переход к другим индексам переставляемых элементов
  }
  r = right; l = left;
 }
 return A;//Матрица с переставленными в обратном порядке элементами
}
//***********************************************************************************
//СТАТУС: I.16, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//imatrix& ReverseByRow(imatrix& A, ulong left = 0L, ulong right = MAX_SIZE) const;
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ЭЛЕМЕНТОВ МАТРИЦЫ В ЗАДАННОМ ИНТЕРВАЛЕ СТРОК В ОБРАТНОМ
//ПОРЯДКЕ ПО СТРОКАМ
//Функция изменяет порядок следования элементов матрицы по строкам в интервале от ин-
//декса строки со значением left до индекса строки со значением right (включая его)
//на обратный.
//Значения верхней и нижней границ интервала строк, в которой должна выполняться обрат-
//ная перестановка должны удовлетворять следующим условиям:
// left <= right && right < Cols(), в противном случае функция не выполняется.
//По умолчанию, осуществляется перестановка всех элементов матрицы по всем строкам.
//Функция не изменяет внутренней структуры исходной матрицы, так как функция работает
//с ее копией. Результат работы функции - матрица, совпадающая по размерам с исходной,
//но с переставленными в обратном порядке элементами по строкам.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& A - ссылка на результирующую матрицу;
//2. ulong left (0) - нижний индекс строки, с которого будет происходить перестановка
//   элементов матрицы в обратном порядке;
//3. ulong right (MAX_SIZE ~ Size()-1) - верхний индекс строки матрицы, до которого
//   будет происходить перестановка элементов вектора в обратном порядке, включая
//   значение индекса right.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//imatrix& A - матрица с переставленными в обратном порядке по строкам относительно
//исходной матрицы элементами.
//***********************************************************************************
imatrix& TIntMatrix::ReverseByRow(imatrix& A, ulong left, ulong right) const
{right = (right == MAX_SIZE) ? Rows()-1 : right;
 //Проверка на возможность или необходимость осуществления перестановки
 if ((Rows() < 2) || (left >= right) || (right >= Rows()))
 {A.Set(0L,false); return A;}
 //Выполнение перестановки элементов матрицы по строкам в обратном порядке
 A = *this;//Копирование исходной матрицы
 ulong r = right;
 ulong l = left;
 long temp;
 for (ulong i = 0; i < A.Cols(); i++)
 {while (l < r)
  {temp = A.Get(l,i); A.Put(l,i,A.Get(r,i)); A.Put(r,i,temp);
   l++; r--; //Переход к другим индексам переставляемых элементов
  }
  r = right; l = left;
 }
 return A;//Матрица с переставленными в обратном порядке элементами
}
//***********************************************************************************
//СТАТУС: I.17, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ReverseCols()
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ВСЕХ СТОЛБЦОВ МАТРИЦЫ В ОБРАТНОМ ПОРЯДКЕ
//Функция изменяет внутренную структуры исходной матрицы. Если матрица нулевого раз-
//мера, то функция возвращает false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения функции
//***********************************************************************************
bool TIntMatrix::ReverseCols()
{if (IsZeroSize()) return false;
 ulong r = Cols()-1;
 ulong l = 0L;
 long temp;
 for (ulong i = 0; i < Rows(); i++)
 {while (l < r)
  {temp = data[i][l]; data[i][l] = data[i][r]; data[i][r] = temp;
   l++; r--; //Переход к другим индексам переставляемых элементов
  }
  r = Cols()-1; l = 0L;
 }
 return true;//Обратная перестановка элементов матрицы по столбцам завершена
}
//***********************************************************************************
//СТАТУС: I.18, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool ReverseRows()
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ВСЕХ СТРОК МАТРИЦЫ В ОБРАТНОМ ПОРЯДКЕ
//Функция изменяет внутренную структуры исходной матрицы. Если матрица нулевого раз-
//мера, то функция возвращает false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения функции
//***********************************************************************************
bool TIntMatrix::ReverseRows()
{if (IsZeroSize()) return false;
 ulong up = 0L;
 ulong down = Rows()-1;
 long temp;
 for (ulong j = 0L; j < Cols(); j++)
 {while (up < down)
  {temp = data[up][j]; data[up][j] = data[down][j]; data[down][j] = temp;
   up++; down--; //Переход к другим индексам переставляемых элементов
  }
  up = 0L; down = Rows()-1;
 }
 return true;//Обратная перестановка элементов матрицы по строкам завершена
}
//***********************************************************************************
//СТАТУС: I.19, TIntMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// imatrix& AssignRow(imatrix& A, const ivector& V, ulong row, ulong pos = 0L) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТРОКЕ МАТРИЦЫ ЦЕЛОЧИСЛЕННОГО ВЕКТОРА
//Присваивание строке исходной матрицы с индексом row, начиная со столбца с индексом
//pos, элементов вектора V, передавемого по ссылке. По умолчанию индекс первого столб-
//ца, с которого начинается присваивание, равен 0. Вектор V может иметь любую размер-
//ность. Функция присваивает значения элементов вектора V копии исходной матрицы, на-
//чиная с первого элемента вектора V, до последнего элемента вектора V или последнего
//столбца матрицы, в зависимости от соотношения начального индекса столбца pos матри-
//цы, с которого начинается присваивание, размеров матрицы и вектора V.
//Исходная матрица не изменяется функцией, все операции осуществляются с копией исход-
//ной матрицы, которая является результатом работы функции.
//Функция возвращает матрицу A нулевого размера в следующих исключительных ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Номер строки row превышает количество строк для данной матрицы;
//4. Начальный  индекс столбца pos в исходной матрице, начиная с которого выполняется
//   присваивание, превышает количество столбцов исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& A - результирующая матрица
//1. const ivector& V - ссылка  на вектор-источник, значения  элементов которого
//   будут присваиваться строке исходной матрицы;
//2. ulong row - номер строки матрицы, которой будут присваиваться элементы вектора V;
//3. ulong pos - начальный индекс столбца матрицы, с которого начнется  присваи-
//   вание значений элементов вектора V строке c номером row матрицы;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix& A - ссылка на результирующая матрица
//***********************************************************************************
imatrix& TIntMatrix::AssignRow(imatrix& A, const ivector& V, ulong row, ulong pos) const
{//Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (row >= Rows()) || (pos >= Cols()))
 {A.Set(0L,false); return A;}
 A = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора строке матрицы
 ulong col;
 for (ulong i = 0L; i < V.Size(); i++)
 {col = i+pos;
  if (col < A.Cols()) A.Put(row,col,V.Get(i));
  else break; //Выход из цикла
 }
 return A;
}
//***********************************************************************************
//СТАТУС: I.20, TIntMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//imatrix& AssignRow(imatrix& A, const ivector& V, ulong left, ulong right, ulong pos) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТРОКАМ МАТРИЦЫ ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА,
//            ИНДЕКСЫ КОТОРЫХ ПРИНАДЛЕЖАТ ИНТЕРВАЛУ [left..right]
//Присваивание строкам матрицы с индексами в интервале [left..right], начиная со столб-
//ца с индексом pos, элементов вектора V, передавемого по ссылке. Вектор V может иметь
//любую размерность. Функция присваивает значения элементов вектора V копии исходной
//матрицы, начиная с первого и до последнего элемента вектора V или последнего столбца
//матрицы, в зависимости от соотношения начального индекса столбца pos матрицы, с ко-
//торого начинается присваивание, размеров матрицы и вектора V.
//Исходная матрица не изменяются функцией, все операции происходят с копией исходной
//матрицы A, передаваемой по ссылке, являющаяся результатом работы функции.
//Функция возвращает матрицу A нулевого размера в следующих исключительных ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Граничные индексы left или right строк превышают количество строк исходной
//   матрицы или left > right;
//4. Начальный  индекс столбца pos в исходной матрице, начиная с которого выполняется
//   присваивание, превышает количество столбцов исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& A - ссылка на результирующую матрицу;
//1. const ivector& V - ссылка на вектор-источник, элементы которого присваиваются
//   строкам исходной матрицы;
//2. ulong left - нижняя граница интервала индексов строк матрицы, которым присваивают-
//   ся элементы вектора V;
//3. ulong right - верхняя граница интервала индексов строк матрицы, которым присваи-
//   ваются элементы вектора V;
//4. ulong pos - начальный индекс столбца матрицы, с которого начнется присваивание
//   элементов вектора V строкам матрицы, принадлежащим интервалу [left..right];
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix& A - ссылка на результирующую матрицу
//***********************************************************************************
imatrix& TIntMatrix::AssignRow(imatrix& A, const ivector& V, ulong left, ulong right,
                               ulong pos) const
{//Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (pos >= Cols()))
 {A.Set(0L,false); return A;}
 right = (right == MAX_SIZE) ? Rows()-1 : right;
 if ((right >= Rows()) || (left > right)) {A.Set(0L,false); return A;}
 A = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора строкам матрицы
 ulong col;
 for (ulong row = left; row <= right; row++)
 {for (ulong i = 0L; i < V.Size(); i++)
  {col = i+pos;
   if (col < A.Cols()) A.Put(row,col,V.Get(i));
   else break; //Выход из цикла по столбцам матрицы
  }
 }
return A;
}
//***********************************************************************************
//СТАТУС: I.21, TIntMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//imatrix& AssignRow(imatrix& A, const ivector& V, const ivector& rows, ulong pos=0) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТРОКАМ МАТРИЦЫ ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА, ИНДЕКСЫ
//КОТОРЫХ ПЕРЕДАЮТСЯ ВЕКТОРОМ rows
//Присваивание строкам матрицы с индексами, расположенными в векторе rows, начиная со
//столбца с индексом pos, элементов вектора V, передавемого по ссылке. По умолчанию
//индекс столбца pos, с которого начинается присваивание, равен 0. Вектор V может иметь
//любую размерность. Функция присваивает значения элементов вектора V копии исходной
//матрицы A, начиная с первого до последнего элемента вектора V или последнего столбца
//матрицы, в зависимости от соотношения начального индекса столбца pos матрицы, с ко-
//торого начинается присваивание, размеров матрицы и вектора V.
//Вектор rows, передаваемый по ссылке, содержит индексы строк, которым присваиваются
//значения элементов вектора V. Перед выполнением операции присваивания индексы строк,
//хранимые в векторе rows, фильтруются. Из элементов вектора rows формируется его под-
//вектор Index, который не содержит повторяющихся индексов строк и индексов, значения
//которых превышают количество строк исходной матрицы.
//Исходная матрицы не изменяется функцией, все операции присваивания происходят с ко-
//пией исходной матрицы A, которая является результатом работы функции.
//Функция возвращает матрицу A нулевого размера в следующих исключительных ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Вектор-индексов строк rows - вектор нулевого размера;
//4. Подвектор Index - нулевого размера - корректные значения индексов строк для
//   данной исходной матрицы в векторе-индексов строк rows не найдены;
//5. Начальный  индекс столбца pos в исходной матрице, начиная с которого выполняется
//   присваивание, превышает количество столбцов исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& A - ссылка на результирующую матрицу;
//2. const ivector& V - ссылка  на вектор-источник, элементы которого присваиваются
//   строкам исходной матрицы;
//3. const ivector& rows - ссылка на вектор с индексами строк, которым присваиваются
//   значения элементов вектора V;
//4. ulong pos - начальный индекс столбца матрицы, с которого начинется присваивание
//   значений элементов вектора V строкам матрицы, индексы которых расположены в век-
//   торе rows;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix& A - ссылка на результирующую матрицу
//***********************************************************************************
imatrix& TIntMatrix::AssignRow(imatrix& A, const ivector& V, const ivector& rows,
 ulong pos) const
{//Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (rows.IsZeroSize()) || (pos >= Cols()))
 {A.Set(0L,false); return A;}
 //Формирование вектора корректных индексов строк для исходной матрицы
 ivector Index = rows;
 ivector interval(2,0L);
 interval[0] = 0; interval[1] = Rows()-1;
 TBelongClosedInterval<long, ivector> Predicate =
 TBelongClosedInterval<long,ivector>(interval);
 Index = Index.SubVector(Predicate);
 Index = Index.Unique();//Фильтрация повторяющихся индексов строк
 //Корректные индексы строк не найдены
 if (Index.IsZeroSize()) {A.Set(0L,false); return A;}

 A = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора строкам матрицы
 ulong col;
 for (ulong i = 0L; i < Index.Size(); i++)
 {for (ulong j = 0L; j < V.Size(); j++)
  {col = j+pos;
   if (col < A.Cols()) A.Put(Index.Get(i),col,V.Get(j));
   else break; //Выход из цикла по столбцам матрицы
  }
 }
return A;
}
//***********************************************************************************
//СТАТУС: I.22, TIntMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// imatrix& AssignCol(imatrix& A, const ivector& V, ulong col, ulong pos = 0L) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТОЛБЦУ МАТРИЦЫ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА
//Присваивание столбцу матрицы с индексом col, начиная со строки с индексом pos, эле-
//ментов вектора V, передавемого по ссылке. По умолчанию, индекс первой строки, с ко-
//торой начинается присваивание, равен 0. Вектор V может иметь любую размерность.
//Функция присваивает значения элементов вектора V копии исходной матрицы, начиная с
//первого элемента вектора V, вплоть до последнего элемента вектора V или последней
//строки матрицы, в зависимости от соотношения начального индекса строки pos матрицы,
//с которой начинается присваивание, размеров матрицы и вектора V.
//Исходная матрица не изменяется функцией, все операции происходят с копией исходной
//матрицы A, передаваемой по ссылке, которая является результатом ее работы.
//Функция возвращает матрицу A нулевого размера в следующих ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Номер столбца col превышает количество столбцов для данной матрицы;
//4. Начальный  индекс строки pos в исходной матрице, начиная с которого выполняется
//   присваивание, превышает количество строк исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& A - ссылка на результирующую матрицу;
//2. const ivector& V - ссылка  на вектор-источник, значения которого присваиваются
//   столбцу исходной матрицы;
//3. ulong col - номер столбца матрицы, которому присваиваются элементы вектора V;
//4. ulong pos - начальный индекс строки матрицы, с которой начнется присваивание
//   значений элементов вектора V столбцу c номером col матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix& A - ссылка на результирующую матрицу
//***********************************************************************************
imatrix& TIntMatrix::AssignCol(imatrix& A, const ivector& V, ulong col, ulong pos) const
{//Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (col >= Cols()) || (pos >= Rows()))
 {A.Set(0L,false); return A;}
 A = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора столбцу матрицы
 ulong row;
 for (ulong i = 0L; i < V.Size(); i++)
 {row = i+pos;
  if (row < A.Rows()) A.Put(row,col,V.Get(i));
  else break; //Выход из цикла
 }
 return A;
}
//***********************************************************************************
//СТАТУС: I.23, TIntMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//imatrix& AssignCol(imatrix& A, const ivector& V, ulong left = 0L,
//                   ulong right = MAX_SIZE, ulong pos = 0L) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТОЛБЦАМ МАТРИЦЫ ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА, ИНДЕКСЫ
//КОТОРЫХ ПРИНАДЛЕЖАТ ИНТЕРВАЛУ [left..right]
//Функция присваивает столбцам матрицы с индексами в интервале [left..right], начиная
//со строки с индексом pos, элементов вектора V, передавемого по ссылке. По умолчанию
//индекс строки pos, с которого начинается присваивание, равен 0. По умолчанию, эле-
//менты вектора V присваиваются всем столбцам матрицы. Вектор V может иметь любую раз-
//мерность. Функция присваивает значения элементов вектора V копии исходной матрицы,
//начиная с первого элемента вектора V, вплоть до последнего элемента вектора V или
//последней строки матрицы, в зависимости от соотношения начального индекса строки pos
//матрицы, с которой начинается присваивание, размеров матрицы и вектора V.
//Исходная матрица не изменяются функцией, все операции происходят с копией исходной
//матрицы А, передаваемой по ссылке, которая является результатом ее работы.
//Функция возвращает матрицу А нулевого размера в следующих ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Граничные индексы left или right столбцов превышают количество столбцов исходной
//   матрицы или left > right;
//4. Начальный  индекс  строки  pos в исходной матрице, начиная с которой выполняется
//   присваивание, превышает количество строк исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& A - ссылка на результирующую матрицу;
//2. const ivector& V - ссылка на вектор-источник, значения которого присваиваются
//   строкам исходной матрицы;
//3. ulong left -  нижняя граница интервала индексов столбцов матрицы, которым прис-
//   ваиваются элементы вектора V;
//4. ulong right - верхняя граница интервала индексов столбцов матрицы, которым прис-
//   ваиваются элементы вектора V;
//5. ulong pos - начальный индекс строки матрицы, с которой начнется присваивание
//   значений вектора V столбцам матрицы, принадлежащим интервалу [left..right];
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix& A - ссылка на результирующую матрицу
//***********************************************************************************
imatrix& TIntMatrix::AssignCol(imatrix& A, const ivector& V, ulong left, ulong right,
 ulong pos) const
{//Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (pos >= Rows()))
 {A.Set(0L,false); return A;}
 right = (right == MAX_SIZE) ? Cols()-1 : right;
 if ((right >= Cols()) || (left > right)) {A.Set(0L,false); return A;}
 A = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора столбцам матрицы
 ulong row;
 for (ulong col = left; col <= right; col++)
 {for (ulong i = 0L; i < V.Size(); i++)
  {row = i+pos;
   if (row < A.Rows()) A.Put(row,col,V.Get(i));
   else break; //Выход из цикла по строкам матрицы
  }
 }
 return A;
}
//***********************************************************************************
//СТАТУС: I.24, TIntMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//imatrix& AssignCol(imatrix& A, const ivector& V, const ivector& cols, ulong pos=0L) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ СТОЛБЦАМ МАТРИЦЫ ЭЛЕМЕНТОВ ДЕЙСТВИТЕЛЬНОГО ВЕКТОРА,
//            ИНДЕКСЫ КОТОРЫХ ПЕРЕДАЮТСЯ ВЕКТОРОМ cols
//Функция присваивает столбцам матрицы с индексами, расположенными в векторе cols, на-
//чиная со строки с индексом pos, элементов вектора V, передавемого по ссылке. По
//умолчанию, индекс строки pos, с которого начинается присваивание, равен 0. Вектор V
//может иметь любую размерность. Функция присваивает значения элементов вектора V ко-
//пии исходной матрицы, начиная с первого элемента вектора V до последнего элемента
//вектора V или последней строки матрицы, в зависимости от соотношения начального ин-
//декса строки pos матрицы, с которого начинается присваивание, размеров матрицы и
//вектора V.
//Вектор cols, передаваемый по ссылке, содержит индексы столбцов, которым присваивают-
//ся значения элементов вектора V. Перед выполнением операции присваивания индексы
//столбцов, хранимые в векторе cols, фильтруются.
//Из элементов вектора cols формируется его подвектор Index, не содержащий повторяющих-
//ся индексов столбцов и индексов, значения которых превышают количество столбцов ис-
//ходной матрицы.
//Исходная матрицы не изменяется функцией, все операции происходят с копией исходной
//матрицы A, передаваемой по ссылке, которая является результатом ее работы.
//Функция возвращает матрицу А нулевого размера в следующих ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Вектор-источник V - вектор нулевого размера;
//3. Вектор-индексов столбцов cols - вектор нулевого размера;
//4. Подвектор Index - нулевого размера - корректные значения  индексов столбцов для
//   данной исходной матрицы в векторе-индексов столбцов cols не найдены;
//5. Начальный индекс строки pos в исходной матрице, начиная с которого выполняется
//   присваивание, превышает количество строк исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& A - ссылка на результирующую матрицу;
//2. const ivector& V - ссылка на вектор-источник, значения которого присваиваются
//   столбцам исходной матрицы;
//3. const ivector& cols - ссылка на вектор с индексами столбцов, которым присваиваются
//   значения элементов вектора V;
//4. ulong pos - начальный индекс строки матрицы, с которого начнется присваивание
//   значений вектора V столбцам матрицы, индексы которых расположены в векторе cols;
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix& A - ссылка на результирующую матрицу
//***********************************************************************************
imatrix& TIntMatrix::AssignCol(imatrix& A, const ivector& V, const ivector& cols,
 ulong pos) const
{//Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (V.IsZeroSize()) || (cols.IsZeroSize()) || (pos >= Rows()))
 {A.Set(0L,false); return A;}
 //Формирование вектора корректных индексов столбцов для исходной матрицы
 ivector Index = cols;
 ivector interval(2,0L);
 interval[0] = 0; interval[1] = Cols()-1;
 TBelongClosedInterval<long, ivector> Predicate =
 TBelongClosedInterval<long,ivector>(interval);
 Index = Index.SubVector(Predicate);
 Index = Index.Unique();//Фильтрация повторяющихся индексов столбцов
 //Корректные индексы столбцов не найдены
 if (Index.IsZeroSize()) {A.Set(0L,false); return A;}

 A = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора столбцам матрицы
 ulong row;
 for (ulong j = 0L; j < Index.Size(); j++)
 {for (ulong i = 0L; i < V.Size(); i++)
  {row = i+pos;
   if (row < A.Rows()) A.Put(row,Index.Get(j),V.Get(i));
   else break; //Выход из цикла по строкам матрицы
  }
 }
 return A;
}
//***********************************************************************************
//СТАТУС: I.25, TIntMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//imatrix& Assign(imatrix& A, const imatrix& B, ulong row = 0L, ulong col = 0L) const
//НАЗНАЧЕНИЕ: ПРИСВАИВАНИЕ ОДНОЙ МАТРИЦЕ ЭЛЕМЕНТОВ ДРУГОЙ МАТРИЦЫ
//Функция выполняет присваивание элементам матрицы значений элементов матрицы B, пере-
//даваемой по ссылке. Присваивание начинается с элемента исходной матрицы, который раз-
//мещается на пересечении строки с индексом row и столбца с индексом col. По умолчанию
//присваивание начинается с первого элементы исходной матрицы с координатами (0,0).
//Далее присваивание осуществляется элементам исходной матрицы, индексы которых распо-
//лагаются правее (по столбцам) и ниже (по строкам) индексов начального элемента исход-
//ной матрицы. Матрица B может иметь любую размерность. Присваивание значений матрицы
//B начинается с первого элемента данной матрицы - B(0,0) и осуществляется либо до
//последнего значения данной матрицы по координатам строки или столбца, либо до послед-
//них значений исходной матрицы по ее координатам строк и столбцов в зависимости от
//соотношения размерностей исходной матрицы, матрицы-источника B по строкам и столбцам
//и координаты начального элемента исходной матрицы, с которого начинается присваива-
//ние. При осуществлении операции присваивания размеры исходной матрицы не изменяются,
//так как присваивание осуществляется в крайнем случае до граничных значений индексов
//исходной матрицы по строкам и столбцам.
//Исходная матрица не изменяется функцией, все операции осуществляются с копией исход-
//ной матрицы A, передаваемой по ссылке, которая является результатом ее работы.
//Функция возвращает матрицу A нулевого размера в следующих ситуациях:
//1. Исходная матрица - матрица нулевого размера;
//2. Матрица-источник B - матрица нулевого размера;
//3. Координаты начального элемента, с которого начинается присваивание выходят за
//   пределы граничных значений по строкам или столбцам для исходной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. imatrix& A - ссылка на результирующую матрицу;
//2. const imatrix& B - ссылка  на матрицу-источник, значения  элементов которой
//   будут присваиваться элементам исходной матрицы;
//3. ulong row - индекс строки начального элемента исходной матрицы;
//4. ulong col - индекс столбца начального элемента исходной матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix& A - ссылка на результирующую матрицу
//***********************************************************************************
imatrix& TIntMatrix::Assign(imatrix& A, const imatrix& B, ulong row, ulong col) const
{//Проверка на возможность осуществления операции присваивания
 if ((IsZeroSize()) || (B.IsZeroSize()) || (row >= Rows()) || (col >= Cols()))
 {A.Set(0L,false); return A;}
 A = *this;//Копирование исходной матрицы
 //Выполнение операции присваивания значений вектора столбцам матрицы
 ulong Row, Col;
 for (ulong i = 0L; i < B.Rows(); i++)
 {Row = i+row;
  if (Row >= A.Rows()) break;//Выход из цикла по строкам
  for (ulong j = 0L; j < B.Cols(); j++)
  {Col = j+col;
   if (Col < A.Cols()) A.Put(Row,Col,B.Get(i,j));
   else break; //Выход из цикла по столбцам матрицы
  }
 }
return A;
}
//-----------------------------------------------------------------------------------
//              РЕАЛИЗАЦИЯ ПЕРЕГРУЖЕННЫХ ОПЕРАТОРОВ TIntMatrix
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: I.1; public; TIntMatrix class overloading operator()
//OVERLOADING OPERATOR OF FUNCTION CALL
//НАИМЕНОВАНИЕ ФУНКЦИИ: long& operator() (ulong i, ulong j)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЗОВА ФУНКЦИИ класса TIntMatrix
//Функция предназначена для доступа к элементу матрицы. Осуществляется проверка кор-
//ректности индексов строки и столбца, по которым располагается требуемый элемент мат-
//рицы. Функция вызывается во всех пользовательских функциях, кроме вызова в операторе
//присваивания и конструкторе копирования, т.к. в качестве аргументов последних пере-
//дается константный объект.
//Доступ к членам-данным константных объектов можно осуществлять только с использова-
//нием константных функций.
//ПРИМЕР ВЫЗОВА: A(3,2), где i=3 - индекс строки, j=2 - индекс столбца матрицы. Нуме-
//рация строк и столбцов начинается с 0.
//Если индекс элемента матрицы некорректен, то возвращается 0L.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint i - индекс строки матрицы, в котором располагается компонент
//2. uint j - индекс столбца матрицы, в котором располагается компонент
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: long& value - ссылка на a[i][j] компонент матрицы
//***********************************************************************************
long& TIntMatrix::operator() (ulong i, ulong j)
{if (IsZeroSize()) return data[0][0];
 //Проверка корректности индексов доступа к элементу матрицы
 if ((i >= Rows()) || (j >= Cols())) return data[0][0];
 return data[i][j];
}
//***********************************************************************************
//СТАТУС: I.2; public; TIntMatrix class overloading operator()
//OVERLOADING OPERATOR OF FUNCTION CALL
//НАИМЕНОВАНИЕ ФУНКЦИИ: const long& operator() (ulong i, ulong j) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЗОВА ФУНКЦИИ класса TIntMatrix
//Функция предназначена для доступа к одному элементу матрицы или вектора. Осуществ-
//ляется проверка корректности индексов строки и столбца, по которым располагается
//требуемый элемент матрицы. Функция вызывается в операторе присваивания и конструк-
//торе копирования, т.к. в качестве их аргументов передается константный объект. Дос-
//туп к членам-данным константных объектов можно осуществлять только с использованием
//константных функций.
//ПРИМЕР ВЫЗОВА: A(3,2), где i=3 - индекс строки, j=2 - индекс столбца матрицы. Нуме-
//рация строк и столбцов начинается с 0.
//Если индекс элемента матрицы некорректен, то возвращается data[0][0] или 0L.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint i - индекс строки матрицы, в котором располагается компонент
//2. uint j - индекс столбца матрицы, в котором располагается компонент
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// const long& value - ссылка на a[i][j] компонент матрицы
//***********************************************************************************
const long& TIntMatrix::operator() (ulong i, ulong j) const
{if (IsZeroSize()) return data[0][0];//Матрица нулевого размера
 //Проверка корректности индексов доступа к элементу матрицы
 if ((i >= Rows()) || (j >= Cols())) return data[0][0];
 return data[i][j];
}
//***********************************************************************************
//СТАТУС: I.3; public; TIntMatrix class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator =(const TIntMatrix& A)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ класса TIntMatrix.
//Копирование характеристик и значений элементов из одной целочисленной матрицы в дру-
//гую. Осуществляется корректное копирование членов-указателей на данные копируемого
//класса в создаваемый класс с целью недопущения ссылок указателей разных объектов
//класса на одно и то же место памяти. При невозможности работы выполнения оператора
//присваивания возвращается false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TIntMatrix& A - ссылка на копируемую матрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат работы функции
//***********************************************************************************
bool TIntMatrix::operator =(const TIntMatrix& A)
{//Предотвращение попытки присваивания объекта самому себе
 if (this == &A) return false;
 //Установка свойств копирующей матрицы
 if (Set(A.Rows(),A.Cols(),false) == false) return false;
 //Копирование значений элементов матрицы A
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = A.Get(i,j);
 return true;
}
//***********************************************************************************
//СТАТУС: I.4; public; TIntMatrix class overloading operator =
//OVERLOADING ASSIGNMENT OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator =(const long value)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПРИСВАИВАНИЯ КОМПОНЕНТАМ МАТРИЦЫ ЦЕЛОГО ЧИСЛА.
//ВСЕМ элементам матрицы присваивается значение value. При присваивании матрице нуле-
//вой размерности числа value возвращается false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const long value - присваиваемое матрице значение
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения операции
//***********************************************************************************
bool TIntMatrix::operator =(const long value)
{if (IsZeroSize()) return false;//Матрица нулевого размера
 //Цикл присваивания компонентам вектора значения value
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
    data[i][j] = value;
 return true;
}
//***********************************************************************************
//СТАТУС: I.5; public TIntMatrix class overloading operator ==
//OVERLOADING COMPARISON OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool operator ==(const TIntMatrix& A) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СРАВНЕНИЯ ДВУХ МАТРИЦ.
//Две матрицы считаются РАВНЫМИ, если:
//1) Размерности матриц равны Rows()==A.Rows() && Cols()==A.Cols()
//2) data[i][j] == A.data[i][j], для всех i,j (0<=i<Rows(), 0<=j<Cols()).
//В случае равентства матриц функция возвращает true, в противном случае - false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TIntMatrix& A - ссылка на сравниваемую матрицу
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool compare - результат сравнения
//***********************************************************************************
bool TIntMatrix::operator ==(const TIntMatrix& A) const
{//Матрица сравнивается сама с собой
 if (this == &A) return true;
 //Размерности матриц не совпадают
 if ((Rows() != A.Rows()) || (Cols() != A.Cols())) return false;
 //Поэлементное сравнение матриц
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {if (data[i][j] != A.Get(i,j)) return false;}
 return true;//Результат сравнения двух матриц
}
//***********************************************************************************
//СТАТУС: I.8;  TIntMatrix class friend overloading operator <<
//OVERLOADING OPERATOR OF THE STREAM INSERTION
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend ostream& operator <<(ostream& out, const TIntMatrix& A)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ПОТОКОВОГО ВЫВОДА класса TIntMatrix.
//Функция предназначена для вывода в поток характеристик матрицы и ее элементов. Функ-
//ция возвращает ссылку на поток, что позволяет записывать в программе операторы вы-
//вода в поток каскадно. Формат вывода значений элементов матрицы:
// <x11  x12  x13  ... x1n\n>
// <x21  x22  x23  ... x2n\n>
// <......................\n>
// <xm1  xm2  xm3  ... xmn\n>, где Xij - значениe ij-го элемента матрицы.
//При выводе элементов матрицы приняты следующие соглашения:
//1. Все элементы матрицы имеют ширину вывода равную наибольшей символьной длине
//   элемента в данном столбце матрицы.
//2. Выводятся только отрицательные знаки чисел.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. ostream& out - ссылка на объект потока вывода
//2. сonst TIntMatrix& A - ссылка на матрицу, выводимую в поток.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ostream& out - ссылка на объект потока вывода.
//***********************-***********************************************************
ostream& operator <<(ostream& out, const TIntMatrix& A)
{string s;
 long flags = out.flags();
 A.Properties(s); //Получение свойств матрицы A в виде строки
 //Вывод характеристик матрицы
 out << s;
 if (A.IsZeroSize()) return out;
 //Формирование символьного представления элементов вещественной матрицы
 string StrMatrElem;
 out.setf(ios::right);//Выравнивание по правому краю.
 out << A.GetData(StrMatrElem, string(" ")) << endl;
 out.flags(flags);
return out;
}
//===================================================================================
//    РЕАЛИЗАЦИЯ ОПЕРАЦИЙ ЛИНЕЙНОЙ АЛГЕБРЫ над ЦЕЛОЧИСЛЕННЫМИ МАТРИЦАМИ
// Все операции линейной алгебры не изменяют значений компонент исходных матриц,
// над которыми выполняются операции линейной алгебры.
//===================================================================================
//***********************************************************************************
//СТАТУС: I.1, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Reverse()
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ЭЛЕМЕНТОВ КВАДРАТНОЙ МАТРИЦЫ ОТНОСИТЕЛЬНО ДОПОЛНИТЕЛЬНОЙ
//ДИАГОНАЛИ
//Операция проводится с исходной квадратной матрицей. Алгоритм перестановки элементов
//квадратной матрицы относительно дополнительной диагонали:
// A[i,j] -> A'[ |j-n|, |i-n| ], где n = Rows()-1.
//Если матрица - не квадратная или нулевого размера, то возвращается false и исходная
//матрица не изменяется.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат перестановки
//***********************************************************************************
bool TIntMatrix::Reverse()
{if (IsZeroSize() || IsRectang()) return false;
 //----------------------------------------------------------------------------------
 //Перестановка элементов матрицы относительно дополнительной диагонали
 //----------------------------------------------------------------------------------
 ulong new_i, new_j, n = Rows()-1;
 long temp;
 for (ulong i = 0L; i < n; i++)
  for (ulong j = 0L; j < (n-i); j++)
  {temp = data[i][j]; new_i = n-j; new_j = n-i;
   data[i][j] = data[new_i][new_j];
   data[new_i][new_j] = temp;
  }
 return true;
}
//***********************************************************************************
//СТАТУС: I.2, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: imatrix& Reverse(imatrix& A) const
//НАЗНАЧЕНИЕ: ПЕРЕСТАНОВКА ЭЛЕМЕНТОВ КВАДРАТНОЙ МАТРИЦЫ ОТНОСИТЕЛЬНО ДОПОЛНИТЕЛЬНОЙ
//ДИАГОНАЛИ. Операция проводится с копией исходной квадратной матрицей - матрицей A,
//передаваемой по ссылке. Алгоритм перестановки элементов квадратной матрицы относи-
//тельно дополнительной диагонали: A[i,j] -> A'[ |j-n|, |i-n| ], где n = Rows()-1.
//Если матрица - не квадратная или нулевого размера, то возвращается ссылка на матри-
//цу A, нулевого размера. Исходная матрица не изменяется.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: imatrix& A - ссылка на результирующую матрицу
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//imatrix& A - ccылка на матрицу с переставленными элементами относительно
//дополнительной диагонали
//***********************************************************************************
imatrix& TIntMatrix::Reverse(imatrix& A) const
{if (IsZeroSize() || IsRectang()) {A.Set(0L,false); return A;}
 if (A.Set(Rows(),false) == false) return A;
 //----------------------------------------------------------------------------------
 //Перестановка элементов матрицы относительно дополнительной диагонали
 //----------------------------------------------------------------------------------
 ulong new_i, new_j, n = Rows()-1;
 for (ulong i = 0L; i < n; i++)
  for (ulong j = 0L; j < (n-i); j++)
  {new_i = n-j; new_j = n-i;
   A.Put(i,j,data[new_i][new_j]);
   A.Put(new_i,new_j,data[i][j]);
  }
 return A;
}
//***********************************************************************************
//СТАТУС: I.3, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Transpose()
//НАЗНАЧЕНИЕ: ТРАНСПОНИРОВАНИЕ МАТРИЦЫ. Транспонирование проводится с исходной матри-
//цей, ссылка на которую возвращается в качестве результата функцией. Результатом
//транспонирования матрицы A(m x n) есть матрица B(n x m). Столбцы матрицы B совпадают
//со строками матрицы A. При транспонировании матрицы нулевого размера возвращается
//false.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения транспонирования
//***********************************************************************************
bool TIntMatrix::Transpose()
{if (IsZeroSize()) return false;//Матрица нулевого размера
 //Создание транспонированной матрицы
 imatrix A(*this);
 Set(Cols(),Rows(),false);
 if (A.IsZeroSize() || IsZeroSize()) return false;
 //Транспонирование элементов матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = A.Get(j,i);
 return true;
}
//***********************************************************************************
//СТАТУС: I.3, TIntMatrix class public member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: imatrix& Transpose(imatrix& A) const
//НАЗНАЧЕНИЕ: ТРАНСПОНИРОВАНИЕ МАТРИЦЫ. Транспонирование проводится с копией исходной
//матрицы - матрицей A, передаваемой по ссылке, которая возвращается в качестве резуль-
//тата функцией. Результатом транспонирования матрицы A(m x n) есть матрица B(n x m).
//Столбцы матрицы B совпадают со строками матрицы A. При транспонировании матрицы ну-
//левого размера возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: imatrix& A - ссылка на результирующую матрицу
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix& A - ссылка на транспонированную матрицу
//***********************************************************************************
imatrix& TIntMatrix::Transpose(imatrix& A) const
{if (IsZeroSize()) {A.Set(0L,false); return A;}//Матрица нулевого размера
 //Создание транспонированной матрицы
 if (A.Set(Cols(),Rows(),false) == false) return A;
 //Транспонирование элементов матрицы
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   A.Put(j,i,data[i][j]);
 return A;
}
//***********************************************************************************
//СТАТУС: I.4, TIntMatrix class overloading operator !
//OVERLOADING UNARY OPERATOR < ! >
//НАИМЕНОВАНИЕ ФУНКЦИИ: imatrix& operator !() const
//Функция осуществляет транспонирование матрицы. Операция транспонирования производится
//с копией исходной матрицы, которая возвращается данной функцией. Результатом транс-
//понирования матрицы A(m x n) является матрица B(n x m). Столбцы матрицы B совпадают
//со строками матрицы A. При транспонировании матрицы нулевого размера возвращается
//матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix& A - ссылка на транспонированную матрицу
//***********************************************************************************
imatrix& TIntMatrix::operator !() const
{imatrix A;
 return Transpose(A);
}
//***********************************************************************************
//СТАТУС: I.5, TIntMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double Trace() const
//НАЗНАЧЕНИЕ: ВЫЧИСЛЕНИЕ СЛЕДА КВАДРАТНОЙ МАТРИЦЫ
//След квадратной матрицы вычисляется СУММИРОВАНИЕМ ЕЕ ДИАГОНАЛЬНЫХ ЭЛЕМЕНТОВ.
//При попытке определения следа матрицы нулевого размера или прямоугольной матрицы
//возвращается 0.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double Spur - след квадратной матрицы
//***********************************************************************************
double TIntMatrix::Trace() const
{double Spur = 0.0;
 //Матрица нулевого размера или прямоугольная матрица
 if ((IsZeroSize()) || (IsRectang())) return Spur;
 //Вычисление следа квадратной матрицы
 for (ulong i = 0L; i < Rows(); i++) Spur += data[i][i];
 return Spur;
}
//-----------------------------------------------------------------------------------
// Вычисление норм матрицы и ее нормирование
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: I.1, TIntMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double FirstNorm() const
//НАЗНАЧЕНИЕ: ПЕРВАЯ (КУБИЧЕСКАЯ) НОРМА КВАДРАТНОЙ МАТРИЦЫ
//Определение первой (кубической) нормы матрицы. Для квадратной матрицы A(n x n) пер-
//вая норма вычисляется по формуле: ||A|| = max|Aij| by i & j, максимальное абсолютное
//значение элемента матрицы A размера n. Функция возвращает 0 для прямоугольной или
//нулевого размера матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - первая норма матрицы
//***********************************************************************************
double TIntMatrix::FirstNorm() const
{//Матрица нулевого размера или прямоугольная матрица
 if ((IsZeroSize()) || (IsRectang())) return 0.0;
 //Поиск максимального по абсолютной величины элемента квадратной матрицы
 double norm = 0.0, value;
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
  {value = labs(data[i][j]);
   if (norm < value) norm = value;
  }
 return norm;
}
//***********************************************************************************
//СТАТУС: I.2, TIntMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double NFirstNorm() const
//НАЗНАЧЕНИЕ: МАТРИЧНАЯ НОРМА КВАДРАТНОЙ МАТРИЦЫ вида N*max|Aij|
//Норма определена для квадратной матрицы A(n x n) и вычисляется по формуле:
// ||A|| = n*max|Aij| by i & j, максимальное абсолютное значение элемента матрицы A
//размера n. Функция возвращает 0 для прямоугольной и нулевого размера матриц.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - норма матрицы
//***********************************************************************************
double TIntMatrix::NFirstNorm() const {return Rows()*FirstNorm();}
//***********************************************************************************
//СТАТУС: I.3, TIntMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double SecondNorm() const
//НАЗНАЧЕНИЕ: ВТОРАЯ (ОКТАЭДРИЧЕСКАЯ) НОРМА КВАДРАТНОЙ МАТРИЦЫ
//Вторая (октаэдрическая) норма квадратной матрицы вычисляется по формуле:
// ||A|| = SUM|Aij| by i & j, сумма абсолютных значений элементов матрицы A.
//Функция возвращает norm == 0 для прямоугольной и нулевого размера матриц.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - вторая норма матрицы
//***********************************************************************************
double TIntMatrix::SecondNorm() const
{double norm = 0.0;
 //Матрица нулевого размера или прямоугольная матрица
 if ((IsZeroSize()) || (IsRectang())) return norm;
 //Суммирование абсолютных величин компонент квадратной матрицы
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++) norm += labs(data[i][j]);
 return norm;
}
//***********************************************************************************
//СТАТУС: I.4, TIntMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double ThirdNorm() const
//НАЗНАЧЕНИЕ: ТРЕТЬЯ (СФЕРИЧЕСКАЯ, ЕВКЛИДОВА) НОРМА КВАДРАТНОЙ МАТРИЦЫ
//Для матрицы A(n x n) евклидова норма вычисляется по формуле:
// ||A|| = sqrt(SUM|Aij|^2 by i & j).
//Функция возвращает norm == 0 для прямоугольной и нулевого размера матриц.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - евклидова норма матрицы
//***********************************************************************************
double TIntMatrix::ThirdNorm() const
{double norm = 0.0;
 //Матрица нулевого размера или прямоугольная матрица
 if ((IsZeroSize()) || (IsRectang())) return norm;
 //Суммирование квадратов абсолютных величин элементов квадратной матрицы
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++) norm += data[i][j]*data[i][j];
 norm = sqrt(norm);//Вычисление нормы квадратной матрицы
 return norm;
}
//***********************************************************************************
//СТАТУС: I.5, TIntMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double PNorm(uint p = 2) const
//НАЗНАЧЕНИЕ: P-НОРМА (НОРМЫ ГЕЛЬДЕРА) КВАДРАТНОЙ МАТРИЦЫ
//Для матрицы A(n x n) p-норма вычисляется по формуле:
// ||A|| = {SUM|Aij|^p by i,j}^(1/p).
//Функция возвращает norm == 0 для прямоугольной и нулевого размера матриц.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: uint p - p-норма матрицы, default p=2 - Евклидова норма.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - p-норма квадратной матрицы
//***********************************************************************************
double TIntMatrix::PNorm(uint p) const
{double norm = 0.0;
 //Матрица нулевого размера или прямоугольная матрица
 if ((IsZeroSize()) || (IsRectang())) return norm;
 if (p == 0) norm = FirstNorm();
 else if (p == 1) norm = SecondNorm();//Вторая норма
 else if (p == 2) norm = ThirdNorm();//Третья норма
 else //Вычисление p-нормы квадратной иатрицы
 {for (ulong i = 0L; i < Rows(); i++)
   for (ulong j = 0L; j < Cols(); j++)
    norm += pow(labs(data[i][j]),p);
  norm = pow(norm,1/p);
 }
 return norm;
}
//***********************************************************************************
//СТАТУС: I.6, TIntMatrix class public member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: double Norm(uint type, uint p = 2) const
//НАЗНАЧЕНИЕ: НОРМА КВАДРАТНОЙ МАТРИЦЫ
//Определение нормы квадратной матрицы в зависимости от значения переменной type.
//Аргумент p необходим для определения p-нормы матрицы. По умолчанию функция опреде-
//ляет ЕВКЛИДОВУ НОРМУ матрицы A. Функция возвращает norm == 0 для прямоугольной или
//нулевого размера матриц, а также для нормы несуществующего типа.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint type - тип определяемой нормы квадратной матрицы;
//2. uint p - параметр для p-нормы матрицы, (by default p=2 - Евклидова норма)
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double norm - норма матрицы заданного типа
//***********************************************************************************
double TIntMatrix::Norm(uint type, uint p) const
{double norm;
  switch (type)
  {//Определение первой (кубической) нормы
   case FIRST_NORM:
    norm = FirstNorm(); break;
   //Определение второй (октаэдрической) нормы
   case SECOND_NORM:
    norm = SecondNorm(); break;
   //Определение третьей (сферической, евклидовой) нормы
   case THIRD_NORM:
    norm = ThirdNorm(); break;
   //Определение p-нормы или нормы Гельдера
   case P_NORM:
    norm = PNorm(p); break;
   //Несуществующий тип нормы
   default:
    norm = 0.0;
  }
return norm;
}
//-----------------------------------------------------------------------------------
//Реализация операций линейной алгебры перегрузкой операторов (+-*/) для TIntMatrix
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: I.1, friend function of the TIntMatrix class
//OVERLOADING ADDITION OPERATION (+) by Increasing Matrix on the Long Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend imatrix operator +(const long value, const imatrix& A)
//НАЗНАЧЕНИЕ: УВЕЛИЧЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ЦЕЛОЕ ЧИСЛО value.
//Операция сложения матрицы с целым числом. Число прибавляется слева.
//B = const + A, B(i,j) = A(i,j) + const
//Для осуществления операции сложения матрицы с числом необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОГО РАЗМЕРА.
//Если условие не выполняется, то возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const long value - целое число, прибавляемое к матрице;
//2. const imatrix& A - ссылка на матрицу, к элементам которой прибавляется value.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix result - матрица A, увеличенная на значение value
//***********************************************************************************
imatrix operator +(const long value, const imatrix& A)
{if (A.IsZeroSize()) return A;//Матрица нулевого размера
 //Конструирование результирующей матрицы
 imatrix result(A.Rows(),A.Cols(),false);
 //Цикл увеличения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)+value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.2, friend function of the TIntMatrix class
//OVERLOADING ADDITION OPERATION (+) by Increasing Matrix on the Long Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend imatrix operator +(const imatrix& A, const long value)
//НАЗНАЧЕНИЕ: УВЕЛИЧЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ЦЕЛОЕ ЧИСЛО value.
//Операция сложения матрицы с целым числом. Число прибавляется справа.
//B = A + const, B(i,j) = A(i,j) + const
//Для осуществления операции сложения матрицы с числом необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОГО РАЗМЕРА.
//Если условие не выполняется, то возвращается матрица нулевого размера.
//Результатом сложения матрицы с числом всегда является МАТРИЦА.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const imatrix& A - ссылка на матрицу, к элементам которой прибавляется value;
//2. const long value - целое число, прибавляемое к матрице.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix result - матрица A, увеличенная на значение value
//***********************************************************************************
imatrix operator +(const imatrix& A, const long value)
{if (A.IsZeroSize()) return A;//Матрица нулевого размера
 //Конструирование результирующей матрицы
 imatrix result(A.Rows(),A.Cols(),false);
 //Цикл увеличения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)+value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.3, friend function of the TIntMatrix class
//OVERLOADING DECREASE OPERATION (-) by Decreasing Matrix on the Long Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend imatrix operator -(const imatrix& A, const long value)
//НАЗНАЧЕНИЕ: УМЕНЬШЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ЦЕЛОЕ ЧИСЛО value.
//Операция уменьшения элементов матрицы на целое число value. value должно распола-
//гаться ТОЛЬКО СПРАВА от матрицы A.
// B = A - const, B(i,j) = A(i,j) - const
//Для осуществления операции вычитания из матрицы числа необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОГО РАЗМЕРА.
//Если условие не выполняется, то возвращается матрица нулевого размера. Результатом
//вычитания из матрицы числа всегда является МАТРИЦА.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const imatrix& A - ссылка на матрицу, компоненты которой уменьшаются на value;
//2. const long value - целое число, вычитаемое из матрицы.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix result - матрица A, уменьшенная на значение value
//***********************************************************************************
imatrix operator -(const imatrix& A, const long value)
{if (A.IsZeroSize()) return A;//Матрица нулевого размера
 //Конструирование результирующей матрицы
 imatrix result(A.Rows(),A.Cols(),false);
 //Цикл уменьшения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; i < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)-value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.4, friend function of the TIntMatrix class
//OVERLOADING MULTIPLICATION OPERATION (*) by Multiply Matrix to the Long Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend imatrix operator *(const long value, const imatrix& A)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ЦЕЛОЕ ЧИСЛО value. Число умножается слева:
// B = const * A, B(i,j) = A(i,j) * const
//Для осуществления операции умножения матрицы на число необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОГО РАЗМЕРА.
//Если условие не выполняется, то возвращается матрица нулевого размера. Результатом
//умножения матрицы на число всегда является МАТРИЦА.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const long value - целое число, умножаемое на матрицу;
//2. const imatrix& A - ссылка на матрицу, компоненты которой умножаются на value.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix result - матрица А, умноженная на значение value
//***********************************************************************************
imatrix operator *(const long value, const imatrix& A)
{if (A.IsZeroSize()) return A;//Матрица нулевого размера
 //Конструирование результирующей матрицы
 imatrix result(A.Rows(),A.Cols(),false);
 //Цикл умножения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)*value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.5, friend function of the TIntMatrix class
//OVERLOADING MULTIPLICATION OPERATION (*) by Multiply Matrix to the Long Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend imatrix operator *(const imatrix& A, const long value)
//НАЗНАЧЕНИЕ: УМНОЖЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ЦЕЛОЕ ЧИСЛО value. Число умножается
//справа: B = A * const, B(i,j) = A(i,j) * const
//Для осуществления операции умножения матрицы на число необходимо одно условие:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕВОГО РАЗМЕРА.
//Если условие не выполняется, то возвращается матрица нулевого размера. Результатом
//умножения матрицы на число всегда является МАТРИЦА.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const imatrix& A - ссылка на матрицу, компоненты которой умножаются на value;
//2. const long value - целое число, умножаемое на матрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix result - матрица А, умноженная на значение value
//***********************************************************************************
imatrix operator *(const imatrix& A, const long value)
{if (A.IsZeroSize()) return A;//Матрица нулевого размера
 //Конструирование результирующей матрицы
 imatrix result(A.Rows(),A.Cols(),false);
 //Цикл умножения компонент матрицы A на величину value
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
   result.Put(i,j,A.Get(i,j)*value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.6, public function of the TIntMatrix class
//OVERLOADING DIVISION OPERATION (/) by Dividing Matrix on the Long Value.
//НАИМЕНОВАНИЕ ФУНКЦИИ: rmatrix operator /(const long value) const
//НАЗНАЧЕНИЕ: ДЕЛЕНИЕ КОМПОНЕНТ МАТРИЦЫ НА ЦЕЛОЕ ЧИСЛО value. Операция деления неком-
//мутативна и делитель (value) должен быть расположен слева от матрицы.
//B = A / const, B(i,j) = A(i,j) / const
//Для осуществления операции деления матрицы на число необходимо два условия:
//1. Матрица A не должна быть МАТРИЦЕЙ НУЛЕГО РАЗМЕРА.
//2. Делитель value не должен быть РАВНЫМ НУЛЮ.
//Если условия не выполняются, то возвращается матрица нулевого размера. Результатом
//умножения матрицы на число всегда является МАТРИЦА.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const long value - число, делимое на матрицу
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: rmatrix result - матрица A, поделенная на value
//***********************************************************************************
rmatrix TIntMatrix::operator /(const long value) const
{rmatrix result;
 if (IsZeroSize()) return result;//Матрица нулевого размера
 //Попытка деления на ноль
 if (value == 0L) return result;
 result.Set(Rows(),Cols(),false);//Создание результирующей матрицы
 //Цикл деления компонент матрицы A на величину value
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   result.Put(i,j,data[i][j]/value);
 return result;
}
//***********************************************************************************
//СТАТУС: I.7; public; TIntMatrix class overloading operator +
//OVERLOADING ADDITION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: imatrix operator +(const TIntMatrix& A) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР СЛОЖЕНИЯ ДВУХ МАТРИЦ.
//Перегрузка оператора (+) с целью сложения двух целочисленных матриц A и B:
// C = A + B, C(i,j) = A(i,j) + B(i,j).
//При сложении двух матриц должны выполняться следующие правила:
//1. Матрицы не должны быть матрицами НУЛЕВОГО РАЗМЕРА;
//2. Матрицы должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ:
//   A.Rows() == B.Rows() || A.Cols() == B.Cols()
//Если данные условия не выполняются, то возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TIntMatrix& A - ссылка на складываемую матрицу
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix result - матрица суммы двух матриц.
//***********************************************************************************
imatrix TIntMatrix::operator +(const TIntMatrix& A) const
{imatrix result;
 //Матрица (матрицы) нулевого размера
 if ((IsZeroSize()) || (A.IsZeroSize())) return result;
 //Матрицы разных размерностей
 if ((Rows() != A.Rows()) || (Cols() != A.Cols())) return result;
 result.Set(Rows(),Cols(),false);//Создание результирующей матрицы
 //Операция сложения двух матриц
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
    result.Put(i,j,data[i][j]+A.Get(i,j));
 return result; //Матрица суммы двух матриц
}
//***********************************************************************************
//СТАТУС: I.8; public; TIntMatrix class overloading operator -
//OVERLOADING SUBTRACTION OPERATOR
//НАИМЕНОВАНИЕ ФУНКЦИИ: imatrix operator -(const TIntMatrix& A) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР ВЫЧИТАНИЯ ДВУХ МАТРИЦ
//Перегрузка оператора (-) с целью вычитания двух целочисленных матриц A и B:
// C = A - B, C(i,j) = A(i,j) - B(i,j).
//При вычитании двух матриц должны выполняться следующие правила:
//1. Матрицы не должны быть матрицами НУЛЕВОГО РАЗМЕРА;
//2. Матрицы должны быть ОДИНАКОВОЙ РАЗМЕРНОСТИ:
//   A.Rows() == B.Rows() || A.Cols() == B.Cols()
//Если данные условия не выполняются, то возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TRealMatrix& A - ссылка на вычитаемую матрицу
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix result - матрица разности двух матриц.
//***********************************************************************************
imatrix TIntMatrix::operator -(const TIntMatrix& A) const
{imatrix result;
 //Матрица (матрицы) нулевого размера
 if ((IsZeroSize()) || (A.IsZeroSize())) return result;
 //Матрицы разной размерности
 if ((Rows() != A.Rows()) || (Cols() != A.Cols())) return result;
 result.Set(Rows(),Cols(),false);//Создание результирующей матрицы
 //Операция вычитания двух матриц
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
    result.Put(i,j,data[i][j]-A.Get(i,j));
 return result; //Матрица разности двух матриц
}
//***********************************************************************************
//СТАТУС: I.9; public; TIntMatrix class overloading operator *
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ: imatrix operator *(const TIntMatrix& A) const
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ ДВУХ ЦЕЛОЧИСЛЕННЫХ МАТРИЦ.
//Перегрузка оператора (*) с целью умножения двух целочисленных матриц A(m x n) и
//B(n x p): C(m x p) = A(m x n) * B(n x p), где каждый элемент матрицы С вычисляется
//по формуле: C(i,j) = SUM{A(i,k)*B(k,j) by k, 0 <= k < n}
//Правила умножения матрицы на матрицу следующие:
//1. Количество СТОЛБЦОВ матрицы слева A(m x n) должно быть РАВНО количеству
//   СТРОК матрицы справа B(n x p).
//2. Размерности матриц A & B не должны быть нулевыми.
//3. При умножении матриц согласно правил 1 и 2 всегда получается МАТРИЦА размерности
//   равной числу СТРОК матрицы слева и числу СТОЛБЦОВ матрицы справа:
//   C(m x p) = A(m x n) * B(n x p).
//Если условия 1, 2 не выполняются, то возвращается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: const TIntMatrix& A - ссылка на умножаемую матрицу справа.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: imatrix result - матрица умножения двух матриц
//***********************************************************************************
imatrix TIntMatrix::operator *(const TIntMatrix& A) const
{imatrix result;
 //Матрица (матрицы) нулевого размера
 if ((IsZeroSize()) || (A.IsZeroSize())) return result;
 //Операция умножения производится с матрицами неподходящих для умножения
 //размерностей
 if (Cols() != A.Rows()) return result;
 result.Set(Rows(),A.Cols(),0L);
 //Операция перемножения двух матриц
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < A.Cols(); j++)
   for (ulong k = 0; k < Cols(); k++)
    result.Put(i,j,result.Get(i,j) + data[i][k]*A.Get(k,j));
 return result; //Результат перемножения двух матриц
}
//***********************************************************************************
//СТАТУС: I.10; friend function of the TIntMatrix class overloading operator *
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//   friend ivector operator *(const ivector& V, const imatrix& A)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ СЛЕВА ЦЕЛОЧИСЛЕННОГО ВЕКТОРА НА
//            ЦЕЛОЧИСЛЕННУЮ МАТРИЦУ
//Функция реализует перегрузку оператора (*) с целью умножения слева целочисленного
//вектора X(1 x n) на целочиленную матрицу A(n x p). Правила умножения слева вектора
//на матрицу следующие:
//1. Вектор должен быть ВЕКТОРОМ-СТРОКОЙ;
//2. Умножаются ВЕКТОР-СТРОКА на МАТРИЦУ, у которой количество строк n должно быть
//   равно размерности вектора-строки.
//3. Размерности вектора и матрицы не должны быть нулевыми.
//Если данные условия не выполняются, то возвращается вектор нулевого размера.
//Результатом умножения слева вектора-строки на матрицу является ВЕКТОР-СТРОКА:
// X(1 x n) * A(n x p) = Y(1 x p)
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TIntVector& V - ссылка на умножаемый вектор;
//2. const TIntMatrix& A - ссылка на умножаемую матрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// ivector result - вектор-строка как результат умножения вектора-строки на матрицу.
//***********************************************************************************
ivector operator *(const ivector& V, const imatrix& A)
{ivector result;
 //Операция умножения производится с вектором нулевого размера
 if (V.Size() == 0L) return result;
 //Операция умножения производится на матрицу нулевого размера
 if ((A.Cols() == 0L) || (A.Rows() == 0L)) return result;
 //Операция умножения слева производится с вектором-столбцом
 if (V.IsColumn()) return result;
 //Операция умножения слева вектора-строки на матрицу производится с разными
 //размером вектора и количеством строк матрицы.
 if (V.Size() != A.Rows()) return result;
 //Установка свойств результирующего вектора-строки. Размерность результирующего век-
 //тора равна количеству столбцов матрицы.
 result.Set(A.Cols(),ROW,0L);
 //Операция умножения слева вектора-строки на матрицу
 for (ulong i = 0; i < A.Cols(); i++)
  for (ulong j = 0; j < A.Rows(); j++)
   result.Put(i,result.Get(i)+ V.Get(j) * A.Get(j,i));
 return result; //Результирующий вектор умножения вектора на матрицу слева
}
//***********************************************************************************
//СТАТУС: I.11; friend function of the TIntMatrix class overloading operator *
//OVERLOADING MULTIPLICATION OPERATOR (*)
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//   friend ivector operator *(const imatrix& A, const ivector& V)
//НАЗНАЧЕНИЕ: ПЕРЕГРУЖЕННЫЙ ОПЕРАТОР УМНОЖЕНИЯ СПРАВА ЦЕЛОЧИСЛЕННОГО ВЕКТОРА НА
//            ЦЕЛОЧИСЛЕННУЮ МАТРИЦУ
//Функция реализует перегрузку оператора (*) с целью умножения справа целочисленного
//вектора X(n x 1) на целочисленную матрицу A(m x n). Правила умножения справа вектора
//на матрицу следующие:
//1. Вектор должен быть ВЕКТОРОМ-СТОЛБЦОМ;
//2. Умножаются МАТРИЦА на ВЕКТОР-СТОЛБЕЦ, у которой количество столбцов n должно быть
//   равно размерности вектора-столбца.
//3. Размерности вектора и матрицы не должны быть нулевыми.
//Если данные условия не выполняются, то возвращается вектор нулевого размера.
//Результатом умножения справа вектора-стролбца на матрицу является
//ВЕКТОР-СТОЛБЕЦ: A(m x n) * X(n x 1) = Y(m x 1).
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TIntVector& V - ссылка на умножаемый вектор;
//2. const TIntMatrix& A - ссылка на умножаемую матрицу.
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// ivector result - вектор-столбец как результат умножения вектора-столбца на матрицу
// справа.
//***********************************************************************************
ivector operator *(const imatrix& A, const ivector& V)
{ivector result;
 //Операция умножения производится с вектором нулевого размера
 if (V.Size() == 0L) return result;
 //Операция умножения производится на матрицу нулевого размера
 if ((A.Cols() == 0L) || (A.Rows() == 0L)) return result;
 //Операция умножения справа производится с вектором-строкой
 if (V.IsRow()) return result;
 //Операция умножения справа вектора-стролбца на матрицу производится с разными
 //размером вектора и количеством столбцов матрицы.
 if (V.Size() != A.Cols()) return result;
 //Установка свойств результирующего вектора-столбца. Размерность результирующего
 //вектора равна количеству строк матрицы.
 result.Set(A.Rows(),COL,0L);
 //Операция умножения справа вектора-столбца на матрицу
 for (ulong i = 0; i < A.Rows(); i++)
  for (ulong j = 0; j < A.Cols(); j++)
   result.Put(i, result.Get(i) + V.Get(j) * A.Get(i,j));
 return result; //Результирующий вектор умножения справа вектора на матрицу
}
//****************************************************************************************
//СТАТУС: I.12; Friend function of the TIntMatrix class
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// friend string& MakeTable(string& sTbl, const UStringMap& HeadColl, const imatrix& A,
//                          string& delim = string(1,' '));
//НАЗНАЧЕНИЕ: Табличное форматирование данных матрицы A с формированием заголовка таблицы
//по столбцам из контейнера заголовков HeadColl в строке sTbl типа string. Функция возвра-
//щает ссылку на строку sTbl.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& sTbl - ссылка на результирующую строку с табличным представлением матрицы A;
//2. const UStringMap& HeadColl - контейнер с заголовками столбцов матрицы A;
//3. const imatrix& A - ссылка на матрицу с форматируемыми данными;
//4. string& delim - строка-разделитель столбцов матрицы A в строке sTbl.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: bool lSuccess - результат выполнения операции
//****************************************************************************************
string& MakeTable(string& sTbl, const UStringMap& HeadColl, const imatrix& A, string& delim)
{//Объявление переменных
 ivector WCols;
 string sHead;
 std::map<ulong,string>::const_iterator pos;
 string sCurHead;//Строка с текущим заголовком
 long LenHead;//Длина строки с текущим заголовком
 char buffer[80];
 ostrstream text(buffer, sizeof(buffer));
 text.setf(ios::right);//Выравнивание по правому краю.
 //Определение максимальной символьной длины элемента матрицы
 if (A.WidthCols(WCols) == 0)
 {sTbl.assign("Zero-size Integer Matrix"); return sTbl;}
 //Построение заголовка таблицы
 for (ulong i = 0; i < A.Cols(); i++)
 {pos = HeadColl.find(i);//Поиск заголовка столбца с номером i
  if (pos != HeadColl.end())
  {LenHead = pos->second.length(); sCurHead.assign(pos->second);}
  else //Формируем заголовок автоматически
  {text << "Col_" << i << ends;
   sCurHead.assign(text.str()); text.seekp(0); LenHead = sCurHead.length();
  }
  if (WCols.Get(i) < LenHead) WCols.Put(i,LenHead);

  text << setw(WCols.Get(i)) << sCurHead;
  if ((A.Cols()-i) > 1) text << delim << ends;
  else text << endl << ends;
  sHead.append(text.str()); text.seekp(0);
 }
 sTbl.assign(sHead);
 //Табличное представление данных, хранящихся в матрице A
 //Вывод значений элементов вещественной матрицы в строку
 for (ulong i = 0L; i < A.Rows(); i++)
  for (ulong j = 0L; j < A.Cols(); j++)
  {//Формирование символьного представления вещественного числа
   text << setw(WCols.Get(j)) << A.Get(i,j);
   if ((A.Cols()-j) > 1) text << delim << ends;
   else text << endl << ends;//Каждая строка матрицы выводится с новой строки
   sTbl.append(text.str()); text.seekp(0);
  }
 return sTbl;
}

//===================================================================================
// II. РЕАЛИЗАЦИЯ ЗАКРЫТЫХ ЧЛЕНОВ-ФУНКЦИЙ КЛАССА TIntMatrix
//     PRIVATE MEMBER-FUNCTION OF TIntMatrix CLASS REALIZATION
//===================================================================================
//***********************************************************************************
//СТАТУС: II.1., private, TIntMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Initial()
//НАЗНАЧЕНИЕ: Начальная инициализация свойств целочисленной матрицы при ее создании.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIntMatrix::Initial()
{//Начальная инициализация защищенных членов-данных класса
 type = SQUARE; //Вещественная матрица нулевого размера
 m = 0L; n = 0L; //Установка размерности матрицы
 data = NULL;    //Установка указателя на элементы матрицы в NULL
}
//***********************************************************************************
//СТАТУС: II.2., private, TIntMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool Create()
//НАЗНАЧЕНИЕ: Распределение оперативной памяти под элементы целочисленной матрицы без
//их инициализации. Количество элементов матрицы определяется по формуле:
//Q = Rows()*Cols(). Если Rows() или Cols() равны 0, то создается матрица нулевого
//размера. В случае нехватки памяти генерируется ошибка и функция возвращает false.
//Элементы матрицы хранятся в двумерном массиве data. При создании вектора-столбца,
//получается матрица вида: data[m][1], при создании вектора-строки - data[1][n].
//В общем случае создается матрица следующего вида: data[m][n].
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
bool TIntMatrix::Create()
{//Проверка на матрицу нулевого размера
 if ((Rows() == 0) || (Cols() == 0)) {Initial(); return true;}
 //Распределение памяти под элементы матрицы и первоначальная их инициализация
 try
  {//Распределение памяти под строки матрицы - m
   data = new long*[Rows()];
   //Распределение памяти под столбцы матрицы - n
   for (ulong i = 0L; i < Rows(); i++) data[i] = new long[Cols()];
  }
  // ENTER THIS BLOCK ONLY IF xalloc IS THROWN.
  // YOU COULD REQUEST OTHER ACTIONS BEFORE TERMINATING
  catch (std::bad_alloc) {Initial(); return false;} //xalloc x
 return true;
}
//***********************************************************************************
//СТАТУС: II.3., private, TIntMatrix class member-function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void Delete()
//НАЗНАЧЕНИЕ: Удаление из оперативной памяти элементов целочисленной матрицы. После
//завершения работы функции получается матрица нулевого размера.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIntMatrix::Delete()
{if (data == NULL) {Initial(); return;}//Проверка на матрицу нулевого размера
 //Удаление элементов матрицы
 for (ulong i = 0L; i < Rows(); i++) delete[] data[i];//Удаление строк
 delete[] data ;
 Initial();
}
//-----------------------------------------------------------------------------------
// РЕАЛИЗАЦИЯ ЗАЩИЩЕННЫХ ФУНКЦИЙ КЛАССА TIntMatrix ИНИЦИАЛИЗАЦИИ ЭЛЕМЕНТОВ
// МАТРИЦЫ В ЗАВИСИМОСТИ ОТ ЕЕ ПОДТИПА
//-----------------------------------------------------------------------------------
//***********************************************************************************
//СТАТУС: III.1, TIntMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitZeroMatrix()
//НАЗНАЧЕНИЕ: Инициализация элементы матрицы с нулевыми элементами
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIntMatrix::InitZeroMatrix()
{for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++) data[i][j] = 0L;
}
//***********************************************************************************
//СТАТУС: III.2, TIntMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitMatrix()
//НАЗНАЧЕНИЕ: Инициализация элементов матрицы любого типа случайными значениями.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIntMatrix::InitMatrix()
{TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 long Max = (Rows() > Cols()) ? Rows() : Cols();
 long Min = -Max;
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++) data[i][j] = RNG.Rand(Min,Max);
}
//***********************************************************************************
//СТАТУС: III.3, TIntMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitDiagonal()
//НАЗНАЧЕНИЕ: Инициализация элементов диагональной матрицы случайными значениями
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIntMatrix::InitDiagonal()
{if (IsSquare() == false) {InitMatrix(); return;}
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i == j) ? RNG.Rand(-1*Rows(),Rows()) : 0L;
}
//***********************************************************************************
//СТАТУС: III.4, TIntMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitScalar()
//НАЗНАЧЕНИЕ: Инициализация элементов скалярной матрицы случайным значением.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIntMatrix::InitScalar()
{if (IsSquare() == false) {InitMatrix(); return;}
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 long value = RNG.Rand(-1*Rows(),Rows());
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i == j) ? value : 0L;
}
//***********************************************************************************
//СТАТУС: III.5, TIntMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitUnit()
//НАЗНАЧЕНИЕ: Инициализация элементов единичной матрицы.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIntMatrix::InitUnit()
{if (IsSquare() == false) {InitMatrix(); return;}
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i == j) ? 1L : 0L;
}
//***********************************************************************************
//СТАТУС: III.6, TIntMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitBand(ulong diags)
//НАЗНАЧЕНИЕ: Инициализация элементов ленточной матрицы случайными значениями.
//Количество диагоналей diags должно быть нечетным и быть в пределах:
// 1 < diags < 2*Rows()-1. Матрица должна быть квадратной и Rows() > 2.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: ulong diags - число диагоналей матрицы
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIntMatrix::InitBand(ulong diags)
{if (IsSquare() == false) {InitMatrix(); return;}
 if (Rows() < 3) {InitMatrix(); return;}
 if ((diags < 3) || (diags%2 == 0L) || (diags >= 2*Rows()-1)) diags = 3;
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 ulong delta;
 for (ulong i = 0; i < Rows(); i++)
  for (ulong j = 0; j < Cols(); j++)
  {delta = (i > j) ? (i-j) : (j-i);
   if (2*delta <= diags-1) data[i][j] = RNG.Rand(-1*Rows(),Rows());
   else data[i][j] = 0.0;
  }
}
//***********************************************************************************
//СТАТУС: III.7, TIntMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitUTriang()
//НАЗНАЧЕНИЕ: Инициализация элементов верхней треугольной матрицы случайными числами.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIntMatrix::InitUTriang()
{if (IsSquare() == false) {InitMatrix(); return;}
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i <= j) ? RNG.Rand(-1*Rows(),Rows()) : 0L;
}
//***********************************************************************************
//СТАТУС: III.8, TIntMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitLTriang()
//НАЗНАЧЕНИЕ: Инициализация элементов нижней треугольной матрицы случайными числами.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIntMatrix::InitLTriang()
{if (IsSquare() == false) {InitMatrix(); return;}
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j < Cols(); j++)
   data[i][j] = (i >= j) ? RNG.Rand(-1*Rows(),Rows()) : 0L;
}
//***********************************************************************************
//СТАТУС: III.9, TIntMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitSymmetric()
//НАЗНАЧЕНИЕ: Инициализация элементов симметрической матрицы случайными значениями.
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIntMatrix::InitSymmetric()
{if (IsSquare() == false) {InitMatrix(); return;}
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {if (i != j) data[i][j] = data[j][i] = RNG.Rand(-1*Rows(),Rows());
   else data[i][j] = RNG.Rand(-1*Rows(),Rows());
  }
}
//***********************************************************************************
//СТАТУС: III.10, TIntMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitSkewSymmetric()
//НАЗНАЧЕНИЕ: Инициализация элементов кососимметрической матрицы случайными значениями
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIntMatrix::InitSkewSymmetric()
{if (IsSquare() == false) {InitMatrix(); return;}
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {if (i != j) {data[i][j] = RNG.Rand(-1*Rows(),Rows()); data[j][i] = -data[i][j];}
   else data[i][j] = RNG.Rand(-1*Rows(),Rows());
  }
}
//***********************************************************************************
//СТАТУС: III.11, TIntMatrix class protected member function
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InitAltSign()
//НАЗНАЧЕНИЕ: Инициализация элементов знакопеременной матрицы случайными значениями
//-----------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: нет
//-----------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//***********************************************************************************
void TIntMatrix::InitAltSign()
{if (IsSquare() == false) {InitMatrix(); return;}
 TRandomGenerator RNG(T_16);//Создание генератора случайных чисел
 for (ulong i = 0L; i < Rows(); i++)
  for (ulong j = 0L; j <= i; j++)
  {if (i != j) {data[i][j] = RNG.Rand(-1*Rows(),Rows()); data[j][i] = -data[i][j];}
   else data[i][j] = 0L;
  }
}



//===================================================================================
//    РЕАЛИЗАЦИЯ СЕРВИСНЫХ ФУНКЦИЙ -- REALIZATION of THE SERVICE FUNCTION
//===================================================================================
//***********************************************************************************
//СТАТУС: Service function # 1
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//  ulong ReplaceCharSet(string& s, const string& charset= string(" \t"),
//                       const string& str = string())
//НАЗНАЧЕНИЕ: Замена символов в строке s из множества символов, определяемых в
//charset, на строку str. Вместо каждого найденного в s символа из набора charset
//подставляется строка str.
//Если строка str - пустая (NULL), то найденные в строке s символы из множества
//charset просто извлекаются из  строки. По умолчанию происходит извлечение про-
//бельных символов и символов табуляции. В ходе работы функции строка s изменяется,
//если в ней встречаются символы из charset.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. string& s - ссылка на строку, в которой производится замена символов;
//2. const string& charset - множество символов, подлежащих замене в строке s;
//3. const string& str - строка, замещающая символы из множества charset в строке s.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: ulong ReplCount - количество произведенных замен символов.
//******************************************************************************
ulong ReplaceCharSet(string& s, const string& charset, const string& str)
{ulong ReplCount = 0L;
 if (s.length() == 0) return ReplCount;
 string t;
 long pos;
 bool replace = true;
 if (str.empty()) replace = false;
 //Начало цикла поиска символов из множества charset и их замены на str в s.
 do
 {pos = s.find_first_of(charset);
  if (pos != string::npos) //Символ из множества charset найден  - NPOS
  {t.append(s,0,pos);
   if (replace) t.append(str);
   s = s.substr(pos+1);
   ReplCount++;
  }
 } while (pos != string::npos); //NPOS = -1
 if (ReplCount > 0) {t += s; s.assign(t);}
return ReplCount;
}
//******************************************************************************
//СТАТУС: Service function # 2
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// bool StrToComplex(complex& z, const string& s, string& ends)
//НАЗНАЧЕНИЕ: Преобразование содержащегося в строке s символьного представления
//комплексного числа (z = a + bi, где i - мнимая единица) в его двоичное представ-
//ление типа complex, с записью результата в переменную z. В случае успеха функция
//возвращает логическое значение lSuccess = true, в случае ошибки - false. При
//возникновении ошибки, реальная  и мнимая  части числа  могут принимать нулевые
//значения (синтаксическая ошибка)  либо  +-HUGE_VAL  в  случае, если символьное
//представление числа превышает двоичное представление числа типа double, так как
//реальная и мнимая части комплексного числа представлены данными числами.
//Символьное представление комплексного числа может включать мнимую и реальную
//части, либо только мнимую или только реальную части числа. Порядок следования
//мнимой и реальной частей числа произвольный. После успешного считывания реаль-
//ной (мнимой) части числа функция ожидает считывание мнимой (реальной) части
//числа. Индикатором мнимой части числа является символ 'i', который должен при-
//писываться СПРАВА к символьному представлению вещественного числа без каких-
//либо символов разделителей. Если после успешного считывания мнимой (реальной)
//части комплексного числа, функция считает еще одну точно такую часть, то она
//посчитает, что данная часть относится к другому числу, сформирует строку ends
//с начала символьного представления данного числа и посчитает, что символьное
//преобразование комплексного числа z успешно завершено. В таком случае, комп-
//лексное число z будет содержать только реальную или только мнимую часть, дру-
//гая часть z будет считаться равной 0.
//Если комплексное число z содержит обе части - мнимую и реальную, то ends будет
//содержать символы, расположенные непосредственно после последнего символа в
//строке s, который участвовал в преобразовании. Подстрока ends строки s оказы-
//вается полезной при разборе строк, содержащих несколько комплексных значений,
//разделяемых символами-разделителями (exmpl. пробелы, запятые и т.д.).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. complex& z - ссылка на комплексное число, в которое будет помещен результат
//   преобразования символьного в двоичное представление комплексного числа.
//2. string& s - ссылка на строку, в которой содержится символьное представление
//   комплексного числа либо в десятичной нотации (exmpl.'123.45-0.89i'), либо
//   в научной нотации (exmpl. '4.5e-3 + 3.1415e+20i').
//3. string& ends - строка символов, расположенных непосредственно после послед-
//   него символа в строке s, который участвовал в преобразовании.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - индикатор удачного или неудачного символьного преобразования
//                строки s в двоичное представление комплексного числа.
//******************************************************************************
bool StrToComplex(complex& z, const string& s, string& ends)
{bool lSuccess = true;
 double Image = 0.0, Real = 0.0;
 bool lImage = false; //Индикатор считывания мнимой или реальной части числа
 char* endptr = NULL;
 string t;
 //-----------------------------------------------------------------------------
 //I. Начальная инициализация переменных
 z = complex(Real,Image); ends = s;
 //Проверка на нулевую строку
 if (s.length() == 0) {lSuccess = false; return lSuccess;}
 //-----------------------------------------------------------------------------
 //II. Получаем ПЕРВУЮ часть комплексного числа
 double d = strtod(s.c_str(), &endptr);
 ends = endptr;
 //1. Анализируем полученный результат
 if (ends == s) //Варианты: Ошибка || i || +i || -i
 {if (ends.length() == 1)
  {if (ends[0] == 'i')
   {ends.resize(0); z = complex(0,1); return lSuccess;} //Мнимая единица
   else {lSuccess = false; return lSuccess;} //Синтаксическая ошибка
  }
  else if (ends.length() > 1)
  {if (ends[0] == 'i') {z = complex(0,1); t = ends.substr(1); lImage = true;}
   else if ((ends[0] == '+') && (ends[1] == 'i'))
   {z = complex(0,1);
    if (ends.length() > 2) {t = ends.substr(2); lImage = true;}
    else {ends.resize(0); return lSuccess;} //Комплексное число мнимое
   }
   else if ((ends[0] == '-') && (ends[1] == 'i'))
   {z = complex(0,-1);
    if (ends.length() > 2) {t = ends.substr(2); lImage = true;}
    else {ends.resize(0); return lSuccess;} //Комплексное число мнимое
   }
   else {lSuccess = false; return lSuccess;} //Синтаксическая ошибка
  }
 }//Конец анализа на первую [+-] мнимую единицу или синтаксическую ошибку
 else
 {//1.1. Получили реальную часть z, мнимая часть равна 0
  if (ends.length() == 0)
  {Real = d; z = complex(Real,Image);
   //Очень большое или очень маленькое число
   if ((d == +HUGE_VAL) || (d == -HUGE_VAL)) {ends = s; lSuccess = false;}
   return lSuccess;
  }
  //1.2. Длина ends >= 1
  //Получили реальную часть числа и символы
  if (ends[0] != 'i')
  {Real = d; z = complex(Real,Image);
   //Очень большое или очень маленькое число
   if ((d == +HUGE_VAL) || (d == -HUGE_VAL))
   {ends = s; lSuccess = false; return lSuccess;}
   if (ends.length() == 1) {ends.resize(0); return lSuccess;}
   else {t = ends; lImage = false;}
  }
  //1.3 Получили мнимую часть числа z, реальная часть равна 0
  else
  {Image = d; z = complex(Real,Image);
   //Очень большое или очень маленькое число
   if ((d == +HUGE_VAL) || (d == -HUGE_VAL))
   {ends = s; lSuccess = false; return lSuccess;}
   if (ends.length() == 1) {ends.resize(0); return lSuccess;}
   else {t = ends.substr(1); lImage = true;}
  }
 }
 //-----------------------------------------------------------------------------
 //III. Получаем ВТОРУЮ часть комплексного числа
 //Проверка на повторение символа 'i'
 if ((lImage == true) && (t[0] == 'i'))
 {z = complex(0,0); ends = t; lSuccess = false; return lSuccess;}
 //Проверка на обязательное наличие знака '+' или '-' перед считыванием
 //второй части комплексного числа.
 if ((t[0] != '+') && (t[0] != '-')) {ends = t; return lSuccess;}
 d = strtod(t.c_str(), &endptr);
 ends = endptr;
 //1. Анализируем полученный результат
 //Варианты: Синтаксическая ошибка || +i || -i
 if (ends == t)
 {if (lImage == false) //Мнимая часть числа еще не получена
  {if (ends.length() > 1)
   {if ((ends[0] == '+') && (ends[1] == 'i')) //Мнимая часть равна 1
    {z = complex(Real,1);
     if (ends.length() > 2) ends = ends.substr(2);
     else ends.resize(0);
    }
    else if ((ends[0] == '-') && (ends[1] == 'i')) //Мнимая часть равна -1
    {z = complex(Real,-1);
     if (ends.length() > 2) ends = ends.substr(2);
     else ends.resize(0);
    }
   }
   return lSuccess; //Комплексное число состоит только из реальной части
  }
  //Получено комплексное число с мнимой частью и нулевой реальной частью
  else return lSuccess;
 }
 else //Вторая часть числа считана успешно
 {//2. Определяем принадлежность считанного значения к мнимой или реальной
  //   части комплексного числа.
  if ((ends.length() != 0) && (ends[0] == 'i')) //Мнимая часть числа
  {if (lImage == true) //Мнимая часть числа уже считана
   {ends = t; return lSuccess;}
   else //Мнимая часть числа еще не получена
   {Image = d; z = complex(Real,Image);
    //Очень большое или очень маленькое число
    if ((d == +HUGE_VAL) || (d == -HUGE_VAL))
    {ends = t; lSuccess = false; return lSuccess;}
    if (ends.length() == 1) ends.resize(0);
    else ends = ends.substr(1);
    return lSuccess;
   }
  }
  else //Реальная часть комплексного числа
  {if (lImage == false) //Реальная часть числа уже считана
   {ends = t; return lSuccess;}
   else //Реальная часть числа еще не получена
   {Real = d; z = complex(Real,Image);
    //Очень большое или очень маленькое число
    if ((d == +HUGE_VAL) || (d == -HUGE_VAL))
    {ends = t; lSuccess = false; return lSuccess;}
    if (ends.length() == 0) ends.resize(0);
    return lSuccess;
   }
  }
 }//Обработка второй части комплексного числа завершена
}
//******************************************************************************
//СТАТУС: Service function # 3
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex EditComplex(bool confirm = true)
//НАЗНАЧЕНИЕ: Консольный ввод (редактирования) комплексного числа. Результат ра-
//боты - значение комплексной величины. Предусматривается  режим  подтверждения
//введенной величины. Данный режим действует по умолчанию. В случае ошибочного
//или некорректного ввода появляется сообщение об ошибке и предлагается ввести
//число еще раз.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: bool confirm - опция подтверждения ввода комплексного числа
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex z - введенное значение комплексной величины
//******************************************************************************
complex EditComplex(bool confirm)
{complex z = complex(0,0);
 int x = wherex(), y = wherey();
 string s, ends;
 char c;
 bool lflag = false;
 //Начало цикла ввода комплексного числа
 do
 {//Получаем символьное представление комплексного числа из стандартного потоко-
  //вого ввода - cin и заносим его в строку s
  cin >> s;//s.read_line(cin)
  //Удаляем возможные пробелы и табуляции в строке
  ReplaceCharSet(s," \t",string());
  //Преобразуем символьную строку в двоичное представление комплексного числа
  bool lSuccess = StrToComplex(z,s,ends);
  //Анализируем результаты преобразования
  if (lSuccess == false) //Ошибка - некорректные данные
  {gotoxy(1,wherey()); lflag = true;
   cout << "Value: " << setprecision(19) << z << ";" << endl;
   cout << "Input stopped on: <" << ends << ">;" << endl;
   cout << "<Error data input! Press any key & try again...>\a"; getch();
   ClrScr(x,y);//Очистка экрана
  }
  else //Введенные данные корректные
  {ClrScr(x,y);//Очистка экрана
   cout << setprecision(19) << z << ";";//Вывод введенной комплексной величины
   if (confirm) //Подтверждение ввода
   {cout << "\nPlease, confirm input [y/n]: \a"; cin >> c;
    ClrScr(x,y);//Очистка экрана
    if ((c == 'y') || (c == 'Y')) //Ввод данных подтвержден
    {//Вывод введенной комплексной величины
     cout << setprecision(19) << z << ";"; lflag = false;
    }
    else lflag = true;
   }
  }
 } while (lflag);//Цикл ввода данных
return z;
}
//****************************************************************************************
//СТАТУС: Service function # 4
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool StrToDouble(double& z, const string& s, string& ends)
//НАЗНАЧЕНИЕ: Преобразование содержащегося в строке s символьного представления действитель-
//ного числа z в его двоичное представление типа double, с записью результата в переменную
//z. В случае успеха функция возвращает логическое значение lSuccess = true, в случае ошибки
//- false. При возникновении ошибки, число может принять нулевое значение (синтаксическая
//ошибка) либо +-HUGE_VAL в случае, если символьное представление числа превышает двоичное
//представление числа типа double.
//Строка ends будет содержать символы, расположенные непосредственно после последнего сим-
//вола в строке s, который участвовал в преобразовании. Подстрока ends строки s оказывается
//полезной при разборе строк, содержащих несколько вещественных чисел, разделяемых символа-
//ми-разделителями (exmpl. пробелы, запятые и т.д.).
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double& z - ссылка на вещественное число, в которое будет помещен результат
//   преобразования символьного в двоичное представление числа типа double.
//2. string& s - ссылка на строку, в которой содержится символьное представление
//   вещественного числа либо в десятичной нотации (exmpl.'123.45'), либо в научной нотации
//   (exmpl. '4.5e-3').
//3. string& ends - строка символов, расположенных непосредственно после последнего символа
//   в строке s, который участвовал в преобразовании.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - индикатор удачного или неудачного символьного преобразования
//                строки s в двоичное представление вещественного числа.
//****************************************************************************************
bool StrToDouble(double& z, const string& s, string& ends)
{bool lSuccess = true;
 char* endptr = NULL;
 //---------------------------------------------------------------------------------------
 //I. Начальная инициализация переменных
 z = 0; ends = s;
 //Проверка на нулевую строку
 if (s.length() == 0) {lSuccess = false; return lSuccess;}
 //---------------------------------------------------------------------------------------
 //II. Получаем вещественное число
 double d = strtod(s.c_str(), &endptr);
 ends = endptr;
 //1. Анализируем полученный результат
 if (ends == s) //Синтаксическая ошибка
 {lSuccess = false; return lSuccess;}
 else //Получили вещественное число
 {z = d;
  //Очень большое или очень маленькое число
  if ((z == +HUGE_VAL) || (z == -HUGE_VAL)) {ends = s; lSuccess = false;}
 }
return lSuccess;
}
//****************************************************************************************
//СТАТУС: Service function # 5
//НАИМЕНОВАНИЕ ФУНКЦИИ: double EditDouble(bool confirm = true)
//НАЗНАЧЕНИЕ: Консольный ввод (редактирование) вещественного числа. Результат
//работы - значение величины типа double. Предусматривается режим подтверждения
//введенной величины. Данный режим действует по умолчанию. В случае ошибочного
//или некорректного ввода появляется сообщение об ошибке и предлагается ввести
//число еще раз.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ: bool confirm - опция подтверждения ввода вещественного числа
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double z - введенное значение действительного числа
//******************************************************************************
double EditDouble(bool confirm)
{double z = 0.0;
 int x = wherex(), y = wherey();
 string s, ends;
 char c;
 bool lflag = false;
 //Начало цикла ввода вещественного числа
 do
 {//Получаем символьное представление вещественного числа из стандартного потоко-
  //вого ввода - cin и заносим его в строку s
  cin >> s; //s.read_line(cin)
  //Удаляем возможные пробелы и табуляции в строке
  ReplaceCharSet(s," \t",string());
  //Преобразуем символьную строку в двоичное представление вещественного числа
  bool lSuccess = StrToDouble(z,s,ends);
  //Анализируем результаты преобразования
  if (lSuccess == false) //Ошибка - некорректные данные
  {gotoxy(1,wherey()); lflag = true;
   cout << "Value: " << setprecision(19) << z << ";" << endl;
   cout << "Input stopped on: <" << ends << ">;" << endl;
   cout << "<Error data input! Press any key & try again...>\a"; getch();
   ClrScr(x,y);//Очистка экрана
  }
  else //Введенные данные корректные
  {ClrScr(x,y);//Очистка экрана
   cout << setprecision(19) << z << ";";//Вывод введенного вещественного числа
   if (confirm) //Подтверждение ввода
   {cout << "\nPlease, confirm input [y/n]: \a"; cin >> c;
    ClrScr(x,y);//Очистка экрана
    if ((c == 'y') || (c == 'Y')) //Ввод данных подтвержден
    {//Вывод введенного вещественного значения
     cout << setprecision(19) << z << ";"; lflag = false;
    }
    else lflag = true;
   }
  }
 } while (lflag);//Цикл ввода данных
return z;
}
//******************************************************************************
//СТАТУС: Service function # 6
//НАИМЕНОВАНИЕ ФУНКЦИИ: bool StrToLong(long& z, const string& s, string& ends)
//НАЗНАЧЕНИЕ: Преобразование содержащегося в строке s символьного представления
//длинного  целого числа z в его двоичное представление типа long, с записью ре-
//зультата в переменную z. В случае успеха функция возвращает логическое значение
//lSuccess = true, в случае ошибки - false. В случае возникновения ошибки, число
//может принять нулевое значение (синтаксическая ошибка) и ends = s.
//Строка ends будет содержать символы, расположенные непосредственно после пос-
//леднего символа в строке s, который участвовал в преобразовании. Подстрока
//ends строки s оказывается полезной при разборе строк, содержащих несколько
//целых чисел, разделяемых символами-разделителями (exmpl. пробелы, запятые и
//т.д.).
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. long& z - ссылка на длинное целое, в которое будет помещен результат
//   преобразования символьного в двоичное представление числа типа long.
//2. string& s - ссылка на строку, в которой содержится символьное представление
//   целого числа (exmpl.'12345').
//3. string& ends - строка символов, расположенных непосредственно после послед-
//   него символа в строке s, который участвовал в преобразовании.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
//bool lSuccess - индикатор удачного или неудачного символьного преобразования
//                строки s в двоичное представление длинного целого числа.
//******************************************************************************
bool StrToLong(long& z, const string& s, string& ends)
{bool lSuccess = true;
 char* endptr = NULL;
 //-----------------------------------------------------------------------------
 //I. Начальная инициализация переменных
 z = 0L; ends = s;
 //Проверка на нулевую строку
 if (s.length() == 0) {lSuccess = false; return lSuccess;}
 //-----------------------------------------------------------------------------
 //II. Получаем длинное целое число
 long d = strtol(s.c_str(), &endptr, 10);
 ends = endptr;
 //1. Анализируем полученный результат
 if (ends == s) //Синтаксическая ошибка
 {lSuccess = false; return lSuccess;}
 //Получили длинное целое число
 else z = d;
return lSuccess;
}
//******************************************************************************
//СТАТУС: Service function # 7
//НАИМЕНОВАНИЕ ФУНКЦИИ: long EditLong(bool confirm = true)
//НАЗНАЧЕНИЕ: Консольный ввод (редактирование) длинного целого числа. Результат
//работы - значение величины типа long. Предусмотрен режим подтверждения введенной
//величины. Данный  режим действует по умолчанию. В случае ошибочного или некор-
//ректного ввода появляется сообщение об ошибке и предлагается ввести число еще раз.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
// bool confirm - опция подтверждения ввода длинного целого числа
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: long z - введенное значение длинного целого числа
//******************************************************************************
long EditLong(bool confirm)
{long z = 0L;
 int x = wherex(), y = wherey();
 string s, ends;
 char c;
 bool lflag = false;
 //Начало цикла ввода длинного целого числа
 do
 {//Получаем символьное представление целого числа из стандартного потокового
  //ввода - cin и заносим его в строку s
  cin >> s;//s.read_line(cin)
  //Удаляем возможные пробелы и табуляции в строке
  ReplaceCharSet(s,string(" \t"),string());
  //Преобразуем символьную строку в двоичное представление длинного целого
  bool lSuccess = StrToLong(z,s,ends);
  //Анализируем результаты преобразования
  if (lSuccess == false) //Ошибка - некорректные данные
  {gotoxy(1,wherey()); lflag = true;
   cout << "Value: " << z << ";" << endl;
   cout << "Input stopped on: <" << ends << ">;" << endl;
   cout << "<Error data input! Press any key & try again...>\a"; getch();
   ClrScr(x,y);//Очистка экрана
  }
  else //Введенные данные корректные
  {ClrScr(x,y);//Очистка экрана
   cout << z << ";";//Вывод введенного длинного целого
   if (confirm) //Подтверждение ввода
   {cout << "\nPlease, confirm input [y/n]: \a"; cin >> c;
    ClrScr(x,y);//Очистка экрана
    if ((c == 'y') || (c == 'Y')) //Ввод данных подтвержден
    {//Вывод введенного длинного целого числа
     cout << z << ";"; lflag = false;
    }
    else lflag = true;
   }
  }
 } while (lflag);//Цикл ввода данных
return z;
}
//****************************************************************************************
//СТАТУС: SERVICE FUNCTION # 8
//НАИМЕНОВАНИЕ ФУНКЦИИ: void InPutPF_RMATRIX(PF_MATRIX& Info, const char* Name = NULL)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ПОЛЕЙ СТРУКТУРЫ PF_MATRIX.
//Ввод характеристик формируемой действительной матрицы. После ввода свойств введенные
//параметры контролируются и при необходимости можно повторно ввести данные. Свойства
//матрицы заносятся в структуру Info. Формат ввода:
//----------------------------------------------------------------------------------------
// MODE: DATA ENTRY for BUILDING REAL MATRIX - <Name>.
//----------------------------------------------------------------------------------------
// I. MATRIX TYPE:
//  1. Type: <string>;
// II. MATRIX DIMENSION:
//  1. Rows:  <ulong value>;
//  2. Cols:  <ulong value>;
//----------------------------------------------------------------------------------------
// Структурная схема выбора типа матрицы:
// 1. Select matrix type [1-5]:
//    1. Zero size matrix;
//    2. Vector-row;
//    3. Vector-column;
//    4. Square matrix;
//    5. Rectangular matrix;
// Структурная схема выбора типа квадратной матрицы:
// 1. Select square matrix type [1-10]:
//    1. Ordinary square matrix;
//    2. Diagonal matrix;
//    3. Scalar matrix;
//    4. Unit matrix;
//    5. Band matrix;
//    6. Upper Triangular matrix;
//    7. Lower Triangular matrix;
//    8. Symmetrical matrix;
//    9. Skew Symmetrical matrix;
//   10. Alternating Sign matrix;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. PF_MATRIX& Info - ссылка на структуру с характеристиками формируемой действительной
//   матрицы;
//2. const char* Name (NULL) - наименование действительной матрицы.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void InPutPF_RMATRIX(PF_MATRIX& Info, const char* Name)
{bool flag;
 char c;
 const string line(78,'-');

 STR_UINT ListRMatrix[5] = {
  {RM_ZEROSIZE,"Zero size matrix"  },
  {RV_ROW,     "Vector_row"        },
  {RV_COLUMN,  "Vector_column"     },
  {RM_RECTANG, "Rectangular matrix"},
  {RM_SQUARE,  "Square matrix"     } };
 TB_STR_UINT TbRMatrix = {5, ListRMatrix};

 STR_UINT ListSqRMatrix[10] = {
  {RM_SQUARE,      "Ordinary square matrix" },
  {RM_DIAGONAL,    "Diagonal matrix"        },
  {RM_SCALAR,      "Scalar matrix"          },
  {RM_UNIT,        "Unit matrix"            },
  {RM_BAND,        "Band matrix"            },
  {RM_UTRIANG,     "Upper Triangular matrix"},
  {RM_LTRIANG,     "Lower Triangular matrix"},
  {RM_SYMMETR,     "Symmetrical matrix"     },
  {RM_SKEWSYMMETR, "Skew Symmetrical matrix"},
  {RM_ALTSIGN,     "Alternating Sign matrix"} };
 TB_STR_UINT TbSqRMatrix = {10, ListSqRMatrix};

 string head;
 uint exttype, x, y;
 clrscr(); //Очистка экрана
 if (Name == NULL) Name = "A";
 do //Начало цикла ввода данных
 {//----------------------------------------------------------------------------
  //Вывод заголовка
  cout << line << endl;
  cout << "MODE: Real Matrix Properties Editing - <" << Name << ">" << endl;
  cout << line << endl;
  //----------------------------------------------------------------------------
  //Выбор типа матрицы
  cout << "I. MATRIX TYPE:" << endl;
   head = " Choice matrix type: ";
   exttype = ConsoleChoice(TbRMatrix, RM_SQUARE, head.c_str(), 2);
   Info.type = (exttype == RM_SQUARE) ? SQUARE : RECTANG;
   if (exttype == RM_SQUARE)
   {head = " Choice square matrix subtype: ";
    exttype = ConsoleChoice(TbSqRMatrix, RM_SQUARE, head.c_str(), 2);
    Info.subtype = exttype;
    cout << " 1. Type: <" << GetName(TbSqRMatrix, exttype) << ">;" << endl;
   }
   else
   {Info.subtype = exttype;
    cout << " 1. Type: <" << GetName(TbRMatrix, exttype) << ">;" << endl;
   }
  //----------------------------------------------------------------------------
  //Ввод размерности матрицы
  cout << "II. MATRIX DIMENSION:" << endl;
   if (Info.subtype == RM_ZEROSIZE) //Матрица нулевого размера
   {Info.type = SQUARE; Info.rows = Info.cols = 0L;
    cout << " 1. Rows: " << Info.rows << ";" << endl;
    cout << " 2. Columns: " << Info.cols << ";" << endl;
   }
   else if (Info.subtype == RM_RECTANG) //Ввод размерности прямоугольной матрицы
   {x = wherex(); y = wherey();
    cout << " Enter rows number: "; cin >> Info.rows; ClrScr(x,y);
    if (Info.rows < 2) Info.rows = 10;
    cout << " 1. Rows: " << Info.rows << ";" << endl;
    x = wherex(); y = wherey();
    cout << " Enter columns number: "; cin >> Info.cols; ClrScr(x,y);
    if (Info.cols < 2) Info.cols = 10;
    cout << " 2. Columns: " << Info.cols << ";" << endl;
   }
   //Ввод размерности векторов
   else if ((Info.subtype == RV_ROW) || (Info.subtype == RV_COLUMN))
   {ulong size;
    x = wherex(); y = wherey();
    Info.rows = Info.cols = 1;
    cout << " Enter vector size: "; cin >> size; ClrScr(x,y);
    if (size < 1) size = 10;
    if (Info.subtype == RV_ROW) Info.cols = size;
    else Info.rows = size;
    cout << " 1. Rows: " << Info.rows << ";" << endl;
    cout << " 2. Columns: " << Info.cols << ";" << endl;
   }
   else if (Info.subtype == RM_BAND) //Ввод параметров ленточной матрицы
   {ulong maxdiagonal;
    x = wherex(); y = wherey();
    cout << " Enter matrix size: "; cin >> Info.rows; ClrScr(x,y);
    if (Info.rows < 3) Info.rows = 3;
    cout << " 1. Rows: " << Info.rows << ";" << endl;
    cout << " 2. Columns: " << Info.rows << ";" << endl;
    maxdiagonal = 2*Info.rows - 3;
    x = wherex(); y = wherey();
    cout << " Enter diagonal amount [3-" << maxdiagonal << ",odd]: ";
    cin >> Info.cols;  ClrScr(x,y);
    if ((Info.cols < 3) || (Info.cols > maxdiagonal) || (Info.cols%2 == 0))
     Info.cols = 3;
    cout << " 3. Diagonals: " << Info.cols << endl;
   }
   else //Ввод размерности квадратных матриц, кроме ленточной
   {x = wherex(); y = wherey();
    cout << " Enter matrix size: "; cin >> Info.rows; ClrScr(x,y);
    if (Info.rows < 1) Info.rows = 10;
    Info.cols = Info.rows;
    cout << " 1. Rows: " << Info.rows << ";" << endl;
    cout << " 2. Columns: " << Info.cols << ";" << endl;
   }
  cout << line << endl;
  //--------------------------------------------------------------------------------------
  //Подтверждение введенных данных
  x = wherex(); y = wherey();
  cout << "Confirm data entry, please [y/n]: "; cin >> c; ClrScr(x,y);
  if (c == 'Y' || c == 'y')
  {flag = true;
   cout << "Matrix properties are entered! Press any key...\a"; getch();
  }
  else flag = false;
  clrscr();
 } while (!flag); //Конец цикла ввода данных
}
//****************************************************************************************
//СТАТУС: SERVICE FUNCTION # 9
//НАИМЕНОВАНИЕ ФУНКЦИИ:
//void InPutPF_CMATRIX(PF_MATRIX& Info, const char* Name = NULL)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВВОД ПОЛЕЙ СТРУКТУРЫ PF_MATRIX.
//Ввод свойств для формирования комплексной матрицы. После ввода параметры контролируются
//и при необходимости можно повторно ввести данные. Введенные свойства заносятся в структуру
//Info. Формат ввода:
//----------------------------------------------------------------------------------------
// MODE: DATA ENTRY for BUILDING COMPLEX MATRIX - <Name>.
//----------------------------------------------------------------------------------------
// I. MATRIX TYPE:
//  1. Type: <string>;
// II. MATRIX DIMENSION:
//  1. Rows:  <ulong value>;
//  2. Cols:  <ulong value>;
//----------------------------------------------------------------------------------------
// Структурная схема выбора типа матрицы:
// 1. Select matrix type [1-5]:
//    1. Zero size matrix;
//    2. Vector-row;
//    3. Vector-column;
//    4. Square matrix;
//    5. Rectangular matrix;
// Структурная схема выбора типа квадратной матрицы:
// 1. Select square matrix type [1-11]:
//    1. Ordinary square matrix;
//    2. Hermitian matrix;
//    3. Diagonal matrix;
//    4. Scalar matrix;
//    5. Unit matrix;
//    6. Band matrix;
//    7. Upper Triangular matrix;
//    8. Lower Triangular matrix;
//    9. Symmetrical matrix;
//   10. Skew Symmetrical matrix;
//   11. Alternating Sign matrix;
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. PF_MATRIX& Info - ссылка на структуру с характеристиками формируемой
//   комплексной матрицы;
//2. const char* Name (NULL) - наименование комплексной матрицы
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//****************************************************************************************
void InPutPF_CMATRIX(PF_MATRIX& Info, const char* Name)
{bool flag;
 char c;
 const string line(78,'-');

 STR_UINT ListCMatrix[5] = {
  {CM_ZEROSIZE,"Zero size matrix"  },
  {CV_ROW,     "Vector_row"        },
  {CV_COLUMN,  "Vector_column"     },
  {CM_SQUARE,  "Square matrix"     },
  {CM_RECTANG, "Rectangular matrix"} };
 TB_STR_UINT TbCMatrix = {5, ListCMatrix};

 STR_UINT ListSqCMatrix[11] = {
  {CM_SQUARE,      "Ordinary square matrix" },
  {CM_HERMITIAN,   "Hermitian matrix"       },
  {CM_DIAGONAL,    "Diagonal matrix"        },
  {CM_SCALAR,      "Scalar matrix"          },
  {CM_UNIT,        "Unit matrix"            },
  {CM_BAND,        "Band matrix"            },
  {CM_UTRIANG,     "Upper Triangular matrix"},
  {CM_LTRIANG,     "Lower Triangular matrix"},
  {CM_SYMMETR,     "Symmetrical matrix"     },
  {CM_SKEWSYMMETR, "Skew Symmetrical matrix"},
  {CM_ALTSIGN,     "Alternating Sign matrix"} };
 TB_STR_UINT TbSqCMatrix = {11, ListSqCMatrix};

 string head;
 uint exttype, x, y;
 clrscr(); //Очистка экрана
 if (Name == NULL) Name = "A";
 do //Начало цикла ввода данных
 {//----------------------------------------------------------------------------
  //Вывод заголовка
  cout << line << endl;
  cout << "MODE: Complex Matrix Properties Editing - <" << Name << ">" << endl;
  cout << line << endl;
  //----------------------------------------------------------------------------
  //Выбор типа матрицы
  cout << "I. MATRIX TYPE:" << endl;
   head =  " Choice matrix type: ";
   exttype = ConsoleChoice(TbCMatrix, CM_SQUARE, head.c_str(), 2);
   Info.type = (exttype == CM_SQUARE) ? SQUARE : RECTANG;
   if (exttype == CM_SQUARE)
   {head = " Choice square matrix type: ";
    exttype = ConsoleChoice(TbSqCMatrix, CM_SQUARE, head.c_str(), 2);
    Info.subtype = exttype;
    cout << " 1. Type: <" << GetName(TbSqCMatrix, exttype) << ">;" << endl;
   }
   else
   {cout << " 1. Type: <" << GetName(TbCMatrix, exttype) << ">;" << endl;
    Info.subtype = exttype;
   }
  //---------------------------------------------------------------------------
  //Ввод размерности матрицы
  cout << "II. MATRIX DIMENSION:" << endl;
   if (Info.subtype == CM_ZEROSIZE) //Матрица нулевого размера
   {Info.type = SQUARE; Info.rows = Info.cols = 0L;
    cout << " 1. Rows: " << Info.rows << ";" << endl;
    cout << " 2. Columns: " << Info.cols << ";" << endl;
   }
   //Ввод размерности для прямоугольной матрицы
   else if (Info.subtype == CM_RECTANG)
   {x = wherex(); y = wherey();
    cout << " Enter rows number: "; cin >> Info.rows; ClrScr(x,y);
    if (Info.rows < 1) Info.rows = 10;
    cout << " 1. Rows: " << Info.rows << ";" << endl;
    x = wherex(); y = wherey();
    cout << " Enter columns number: "; cin >> Info.cols; ClrScr(x,y);
    if (Info.cols < 1) Info.cols = 10;
    cout << " 2. Columns: " << Info.cols << ";" << endl;
   }
   //Ввод размерности векторов
   else if ((Info.subtype == CV_ROW) || (Info.subtype == CV_COLUMN))
   {ulong size;
    Info.rows = Info.cols = 1;
    x = wherex(); y = wherey();
    cout << " Enter vector size: "; cin >> size; ClrScr(x,y);
    if (size < 1) size = 10;
    if (Info.subtype == CV_ROW) Info.cols = size;
    else Info.rows = size;
    cout << " 1. Rows: " << Info.rows << ";" << endl;
    cout << " 2. Columns: " << Info.cols << ";" << endl;
   }
   //Ввод параметров ленточной матрицы
   else if (Info.subtype == CM_BAND)
   {ulong maxdiagonal;
    x = wherex(); y = wherey();
    cout << " Enter matrix size: "; cin >> Info.rows; ClrScr(x,y);
    if (Info.rows < 3) Info.rows = 3;
    cout << " 1. Rows: " << Info.rows << ";" << endl;
    cout << " 2. Columns: " << Info.rows << ";" << endl;
    maxdiagonal = 2*Info.rows - 3;
    x = wherex(); y = wherey();
    cout << " Enter diagonal amount [3-" << maxdiagonal << ",odd]: ";
    cin >> Info.cols; ClrScr(x,y);
    if ((Info.cols < 3) || (Info.cols > maxdiagonal) || (Info.cols%2 == 0))
     Info.cols = 3;
    cout << " 3. Diagonals: " << Info.cols << endl;
   }
   else //Ввод размерности квадратных матриц, кроме ленточной
   {x = wherex(); y = wherey();
    cout << " Enter matrix size: "; cin >> Info.rows; ClrScr(x,y);
    if (Info.rows < 1) Info.rows = 10;
    Info.cols = Info.rows;
    cout << " 1. Rows: " << Info.rows << ";" << endl;
    cout << " 2. Columns: " << Info.cols << ";" << endl;
   }
  cout << line << endl;
  //----------------------------------------------------------------------------
  //Подтверждение введенных данных
  x = wherex(); y = wherey();
  cout << "Please, confirm data entry [y/n]: "; cin >> c; ClrScr(x,y);
  if (c == 'Y' || c == 'y')
  {flag = true;
   cout << "Matrix properties are entered! Press any key...\a"; getch();
  }
  else flag = false;
  clrscr();
 } while (!flag); //Конец цикла ввода данных
}
//****************************************************************************************
//СТАТУС: SERVICE FUNCTION # 10
//НАИМЕНОВАНИЕ ФУНКЦИИ:
// uint ConsoleChoice(const TB_STR_UINT& Table, uint Default, const char* Header = NULL,
//      uint Offset = 0)
//НАЗНАЧЕНИЕ: КОНСОЛЬНЫЙ ВЫБОР ЗАПИСИ ИЗ ТАБЛИЦЫ ТИПА TB_STR_UINT.
//Функция осуществляет выбор записи из таблицы типа TB_STR_UINT по содержимому символьных
//строк, которые отображаются на дисплее. При выборе определенной записи функция возвращает
//значение поля value типа uint, которое соответствует выбранной символьной строке. В случае
//неправильного ввода номера записи, функция возвращает значение по умолчанию - Default.
//Формат ввода следующий:
//----------------------------------------------------------------------------------------
// <Header>
//  [1] - string_1;
//  [2] - string_2;
//  ......
//  [N] - string_N;
// <Enter number [1-N]:__>
//----------------------------------------------------------------------------------------
// string_1,..,string_N - символьные поля записей таблицы типа TB_STR_UINT
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TB_STR_UINT& Table - ссылка на таблицу записей типа STR_UINT;
//2. uint Default - значение по умолчанию возвращаемое функцией, в случае некорректного
//   ввода пользователем номера выбираемой записи;
//3. const char* Header - строка-заголовок
//4. uint Offset - смещение справа, отображаемых на экране символьных строк.
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// uint value - положительное значение поля записи типа STR_UINT, которое было выбрано
// пользователем из таблицы Table.
//****************************************************************************************
uint ConsoleChoice(const TB_STR_UINT& Table, uint Default, const char* Header, uint Offset)
{uint value;
 uint width = 1;
 //Установка ширины вывода номеров записей
 if (Table.size > 9) width = 2;
 int x = wherex(), y = wherey();
 const string s(Offset,' ');
 cout << Header << endl;//Отображение заголовка меню
 //Цикл отображения строковых полей таблицы Table
 for (uint i = 0; i < Table.size; i++)
  cout << s << "[" << setw(width) << (i+1) << "] - " << Table.rec[i].str << ";" << endl;
 //Отображение поля ввода номера записи и его ввод
 cout << s << "Enter number [1-" << Table.size << "]: "; cin >> value;
 if ((value < 1) || (value > Table.size)) value = Default;
 else value = Table.rec[value-1].value;
 ClrScr(x,y);//Очистка экрана
 return value;
}
//******************************************************************************
//СТАТУС: SERVICE FUNCTION # 11
//НАИМЕНОВАНИЕ ФУНКЦИИ: const char* GetName(const TB_STR_UINT& Table, uint Value)
//НАЗНАЧЕНИЕ: Получение символьной строки из таблицы типа TB_STR_UINT по полю
//value записи типа STR_UINT.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. const TB_STR_UINT& Table - ссылка на таблицу с записями типа STR_UINT;
//2. uint Value - значение поля записи, по которому производится поиск символь-
//   ной строки.
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
// const char *s - указатель на символьную строку в таблице Table
//******************************************************************************
const char* GetName(const TB_STR_UINT& Table, uint Value)
{uint index = 0;
 char* s; //Указатель на строку
 //Поиск наименования заданного типа матрицы в таблице CMatrName
 for (uint i = 0; i < Table.size; i++)
  if (Value == Table.rec[i].value) {index = i; break;}
 //Определяем символьную строку, соответствующую поля со значением Value
 s = Table.rec[index].str;
return s;
}
//******************************************************************************
//СТАТУС: SERVICE FUNCTION # 12
//НАИМЕНОВАНИЕ ФУНКЦИИ: void ClrScr(uint x, uint y)
//НАЗНАЧЕНИЕ: Очистка области экрана методом "снизу вверх" от текущей строки  до
//строки с индексом y. После очистки экрана курсор размещается в позиции (x, y).
//Данные, расположенные правее положения курсора, также стираются.
//------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. uint x - положение курсора в столбце экрана после его очистки
//2. uint y - индекс верхней строки экрана до которой осуществляется его очистка
//------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: нет
//******************************************************************************
void ClrScr(uint x, uint y)
{while (true) //Очистка экрана методом "снизу вверх"
 {if (y < (uint) wherey()) {gotoxy(1,wherey()); clreol(); gotoxy(1,wherey()-1);}
  else {gotoxy(x,y); clreol(); break;}
 }
}
//****************************************************************************************
//СТАТУС: SERVICE FUNCTION # 13
//НАИМЕНОВАНИЕ ФУНКЦИИ: double cabs(double Xr, double Xi)
//НАЗНАЧЕНИЕ: Вычисление модуля комплексного числа Xr + i*Xi по формуле:
//            cabs(X) = sqrt(Xr*Xr + Xi*Xi)
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double Xr - реальная часть комплексного числа X;
//2. double Xi - мнимая часть комплексного числа X
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: double r_val - модуль комплексного числа X
//****************************************************************************************
double cabs(double Xr, double Xi)
{double h;
 Xr = fabs(Xr); Xi = fabs(Xi);
 if (Xr > Xi) {h = Xr; Xr = Xi; Xi = h;}
 if (Xi == 0.0) return Xr;
 h = Xi/Xr;
 return Xr*sqrt(1.0 + h*h);
}
//****************************************************************************************
//СТАТУС: SERVICE FUNCTION # 14
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex cdiv(double Xr, double Xi, double Yr, double Yi)
//НАЗНАЧЕНИЕ: Деление двух комплексных чисел Z = X/Y: Zr + i*Zi = (Xr + i*Xi)/(Yr + i*Yi)
//К процедуре нельзя обращаться, если Yr = Yi = 0.
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double Xr - реальная часть комплексного числа X;
//2. double Xi - мнимая часть комплексного числа X;
//3. double Yr - реальная часть комплексного числа Y;
//4. double Yi - мнимая часть комплексного числа Y
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex c_val - результат деления X/Y
//****************************************************************************************
complex cdiv(double Xr, double Xi, double Yr, double Yi)
{double Zr, Zi;
 double h;
 if ((Yr == 0.0) && (Yi == 0.0)) return complex(0,0);//Проверка Y на ноль
 if (fabs(Yr) > fabs(Yi))
 {h = Yi/Yr; Yr = h*Yi + Yr;
  Zr = (Xr + h*Xi)/Yr;
  Zi = (Xi - h*Xr)/Yr;
 }
 else
 {h = Yr/Yi; Yi = h*Yr + Yi;
  Zr = (h*Xr + Xi)/Yi;
  Zi = (h*Xi - Xr)/Yi;
 }
 return complex(Zr,Zi);
}
//****************************************************************************************
//СТАТУС: SERVICE FUNCTION # 15
//НАИМЕНОВАНИЕ ФУНКЦИИ: complex csqrt(double Xr, double Xi)
//НАЗНАЧЕНИЕ: Извлечение квадратного корня из комплексного числа Y = sqrt(X):
//            Yr + i*Yi = sqrt(Xr + i*Xi)
//----------------------------------------------------------------------------------------
//ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ:
//1. double Xr - реальная часть комплексного числа X;
//2. double Xi - мнимая часть комплексного числа X
//----------------------------------------------------------------------------------------
//ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ: complex c_val -  квадратный корень комплексного числа X
//****************************************************************************************
complex csqrt(double Xr, double Xi)
{double Yr, Yi;
 double h;
 h = sqrt((fabs(Xr) + cabs(Xr,Xi))/2.0);
 if (Xi != 0.0) Xi = Xi/(2.0*h);
 if (Xr >= 0.0) Xr = h;
 else
 {if (Xi >= 0.0) {Xr = Xi; Xi = h;}
  else {Xr = -Xi; Xi = -h;}
 }
 Yr = Xr; Yi = Xi;
 return complex(Yr,Yi);
}
